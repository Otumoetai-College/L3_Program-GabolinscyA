#Importing outside modules/frameworks to support my program
#Module that detects the users pc username
import os
#Module that enables randomisation of variables inside a list
import random
#Module that enables me to round my caluclated numbers to the close whole number through math.ceil()
import math
#Enables the tkinter addon which I'll use for my GUI
try:
    import tkinter as tk  #python 3
    from tkinter import font as tkfont, ttk  #python 3
except ImportError:
    import Tkinter as tk  #python 2
    import tkFont as tkfont  #python 2
#Importing Pillow which lets me display images in my GUI
from PIL import ImageTk, Image
#Imports the 3rd party framework Flask
from flask import Flask
#Imports the bcrypt that allows me to salt and hash my passwords but also encode my username for easier detection
from flask_bcrypt import Bcrypt
app = Flask(__name__)
bcrypt = Bcrypt(app)
#
class Champions:
    def __init__(self, hp, rp, ap, name, title, code, rp_name, attack_list, specials_list, passive):
        #Health Point
        self.hp = hp
        #Resource Point
        self.rp = rp
        #Attack Power
        self.ap = ap
        #Set Name
        self.name = name
        #Set Title
        self.title = title
        #Set Code
        self.code = code
        #Resource Power Name
        self.rp_name = rp_name
        #Attacks List
        self.attack_list = attack_list
        #Special Abilities List
        self.specials_list = specials_list 
        #Passive Name
        self.passive = passive
#Tanks:
#MNK
MONK = Champions(2000, 100, 150, 'Feramon, the Monk', "Monk", "MNK", "Focus", ["Palm Strike", "Leg Sweep"], ["Harmonize", "Pressure Points"], "Inner-body Connection")
#BBR
BARBARIAN = Champions(2250, 100, 150, 'Baralor, the Barbarian', "Barbarian", "BBR", "Rage", ["Bloodthirst", "Pulverize"], ["Challenging Shout", "Impactful Boast"], "All Eyes on Me")
#KGG
KINGS_GUARD = Champions(2000, 0, 150, 'Hecutis, the Kings-Guard', "Kings-Guard", "KGG", "null", ["Shield Bash", "Trainwreck"], ["Fortification", "Block"], "Self-Sacrificing")
#MTF
MASTER_FENCER = Champions(2000, 0, 150, 'Lorelai, the Master Fencer', "Fencer", "MTF", "null", ["Flanking Strikes", "Riposte"], ["Magic Reflection", "Evasive Manoeuvres"], "Keen Reflexes")

#DPS:

#Melee
#BKR
BERSERKER = Champions(1000, 100, 400, 'Kelzarg, the Berserker', "Berserker", "BKR", "Rage", ["Angering Strike", "Unbridled Rampage"], ["Pure Rage", "Reckless Flurry"], "Ever-Burning Rage")
#RGE
ROGUE = Champions(1000, 0, 400, 'Ryker, the Rogue', "Rogue", "RGE", "null", ["Serrated Slash", "Eviscerate"], ["Garrote", "Exploit Weakness"], "Incisions within Incisions")
#SRV
SURVIVALIST = Champions(1000, 0, 400, 'Mally, the Survivalist', "Survivalist", "SRV", "null", ["Spear Thrust", "Scrap Bomb"], ["Play Dead", "Survival Kit"], "Preparation")
#BST
BRAWLIST = Champions(1250, 0, 400, 'George, the Brawlist', "Brawlist", "BST", "null", ["Hard Hitter", "Wide Swing", "Uppercut", "Knock Out"], [], "Combo King")

#Magic
#ADM
ACADEMIC_MAGE = Champions(1000, 200, 400, 'Tulip, the Academic Mage', "Academics Mage", "ADM", "Mana", ["Frost Bolt", "Fireball"], ["Arcane Brilliance", "Magical Barrier"], "Interwoven with Magic")
#DRD
DRUID = Champions(1000, 200, 400, 'Fuds, the Druid', "Druid", "DRD", "Mana", ["Vine-Swipe", "Invigorate Thorns"], ["Barbed Bush Armour", "Burst N Bloom"], "Natural Selection")
#WRK
WARLOCK = Champions(1000, 200, 400, "Sol'ghar, the Warlock", "Warlock", "WRK", "Mana", ["Black Bolt", "Void Infusion"], ["Wound Fissure", "Soul Tap"], "Touch of Corruption")
#BDM
BLOODMANCER = Champions(1000, 0, 400, 'Flynn, the Bloodmancer', "Bloodmancer", "BDM", "null", ["Drain Life", "Blood Spike"], ["Blood Boil", "Enharden Nerves"], "Blood-strength Channeling")

#Mixed
#PLD
PALADIN = Champions(1000, 0, 400, 'Olig, the Paladin', "Paladin", "PLD", "null", ["Holy Wrath", "Righteous Blow", "Crusade"], ["Damnation"], "Holy Auras")
#LGR
LEGION_RANGER = Champions(1000, 0, 400, 'Brad, the Legion Ranger', "Ranger", "LGR", "null", ["Steady Aim", "Power Shot", "Multi-shot", "Ricochet Shot"], [], "Arrow Tips")
#MGM
MAGNETIMANCER = Champions(1000, 0, 400, "Kel'ther, the Magnetimancer ", "Magnetimancer", "MGM", "null", ["Chain Bolts", "Electrical Expulsion"], ["Energise", "Superconductor"], "Polarisation")
#PWC
POWER_CONDUIT = Champions(1000, 3, 0, 'Power Conduit', "Power Conduit", "PWC", "Charges", [], ["Muscle Enlarger", "Mistic Bloom", "Power Surge", "Full Potential"], "Fissile Core")

#Healers:
#ESP
EARTH_SPEAKER = Champions(1000, 200, 150, "Delmanar, the Earth's Speaker", "Earth Speaker", "ESP", "Mana", ["Rock Barrage"], ["Spring Waters", "Ocean Tides", "Boulder Cocoon"], "Toughening Mud")
#PRS
PRIEST = Champions(1000, 200, 150, 'Sethuk, Priest of the Devoted', "Priest", "PRS", "Mana", ["Shimmering Bolt", "Divine Smite"], ["Healing Light", "Diffracting Nova"], "Mark of the Divine")
#TWK
TIME_WALKER = Champions(1000, 200, 150, 'Zaqner, the Time Walker', "Time Walker", "TWK", "Mana", ["Cybernetic Blast"], ["Overclock Nanobots", "Reverse Wounds", "Alter Time"], "Nanobots")
#FDM
FIELD_MEDIC = Champions(1000, 0, 150, 'Curie, Field Medic', "Field Medic", "FDM", "null", ["Snip Snip"], ["Bandages", "Tight Tourniquet", "Secret Remedy"], "Experienced Healing")

class Monsters:
    def __init__(self, rp, rp_name, name, nickname, enter_word, attack_list, ai_spawned, size_class):
        #Resource Point
        self.rp = rp
        #Resource Power Name
        self.rp_name = rp_name
        #Set name
        self.name = name
        #Set Nickname
        self.nickname = nickname
        #Set Combat Entry Word
        self.enter_word = enter_word
        #Set Code
        self.attack_list = attack_list
        #Set the amount of AI enemies there will be
        self.ai_spawned = ai_spawned
        #Size Class of the monster
        self.size_class = size_class
GROTHAK_THE_DESTROYER = Monsters(0, "null", "Grothak the Destroyer", "Grothak", "", ["Club Slam"], 1, 'Huge')

WORMPULP_BROTHERS = Monsters(0, "null", "Wormpulp Brothers", "Wormpulp Brother", "the", ["Violent Thrash"], 2, 'Large')

SIREN_TRIPLETS = Monsters(200, "Mana", "Siren Triplets", "Triplet", "the", ["Twilight Beam"], 3, 'Medium')

VENOMSKIN_AMPHIBOIDS = Monsters(0, "null", "Venomskin Amphiboids", "Venomskin Amphiboid", "a gang of", ["Spear Thrust"], 4, 'Small')

GIANT_LOCUST_SWARM = Monsters(0, "null", "Giant Locust Swarm", "Giant Locust", "a", ["Bite"], 5, 'Tiny')

#This class loads all Frames into one parent (container) and lets me call those Frames through the use of classes. I can call these class frames through the show.frame function
class ParentClass(tk.Tk):
    #Sets container parent, frame fonts, and laods all possible frames through F
    def __init__(self, *args, **kwargs):
        global COMPUTER_USERNAME
        tk.Tk.__init__(self, *args, **kwargs)
        self.title_font = tkfont.Font(family='Times New Roman Baltic', size=120, weight="bold")
        self.small_title_font = tkfont.Font(family='Times New Roman Baltic', size=80, weight="bold")
        self.medium_text_font_bold = tkfont.Font(family='Times New Roman Baltic', size=50, weight="bold")
        self.menu_button_font = tkfont.Font(family='Helvetica', size=18, weight="bold")
        self.geometry('1280x720')
        container = tk.Frame(self)
        container.grid(sticky="nsew")
        container.grid_rowconfigure(0, weight=1)
        container.grid_columnconfigure(0, weight=1)
        COMPUTER_USERNAME = os.getlogin()
        self.frames = {}
        #Loads all frames on top of each other. The frame that is visible is the one called to go on top.
        for F in (
                OpeningPage, MainMenu, DungeonDelve, CreateTeamPage, CreditPage, How2PlayPage, LeaderboardPage,
                LoginMenu, RegisterMenu, DungeonExpeditions, TeamSelectionPage, GameFrame):
            page_name = F.__name__
            frame = F(parent=container, controller=self)
            self.frames[page_name] = frame
            frame.grid(row=0, column=0)
        self.show_frame("OpeningPage")
#Function called upon to change frames
#the frame used in the parameter is the frame changed to
    def show_frame(self, page_name):
        '''Show a frame for the given page name'''
        for frame in self.frames.values():
            frame.grid_remove()
        frame = self.frames[page_name]
        frame.tkraise()
        frame.grid()
#Function that gets one of the pieces of data thats linked to the users account and returns it
#Data can be username (string), encoded user name (string), champion list in code form (string), number of emblems (float), or  rank (string)
    def get_account_data(self, requested_data):
        current_user = open(
            "C:/Users/{}/Documents/L2_ASSIGNMENT_RPG/Game_Data (DO NOT EDIT)/game_data_current_username.txt".format(COMPUTER_USERNAME), "r")
        current_user_read = current_user.readline()
        user = str(current_user_read)
        encoded_user = user.encode("utf-8")
        encoded_user = str(encoded_user)
        current_user.close()
        accounts_file = open(
            "C:/Users/{}/Documents/L2_ASSIGNMENT_RPG/Game_Data (DO NOT EDIT)/account_data_users.txt".format(COMPUTER_USERNAME), "r")
        for line in accounts_file:
            if encoded_user in line:
                user_data_list = list(line.split(", "))
                accounts_file.close()
                if requested_data == "username":
                    return user
                elif requested_data == "encoded_username":
                    return encoded_user
                elif requested_data == "champion_list":
                    return str(user_data_list[1])
                elif requested_data == "emblems":
                    return float(user_data_list[2])
                elif requested_data == "rank":
                    rank = str(user_data_list[3]).replace("\n","")
                    return rank
#Function that gets the games current dungeon name and returns it
    def get_dungeon_difficulty_data(self, requested_data):
        difficulty_file_read = open(
            "C:/Users/{}/Documents/L2_ASSIGNMENT_RPG/Game_Data (DO NOT EDIT)/game_data_dungeon_difficulty.txt".format(COMPUTER_USERNAME),
            "r")
        dungeon_settings = difficulty_file_read.readline()
        if dungeon_settings == "Bronze":
            dungeon_name = "The City Sewers"
        elif dungeon_settings == "Silver":
            dungeon_name = "The Royal Catacombs"
        elif dungeon_settings == "Gold":
            dungeon_name = "The Forgotten Mines"
        elif dungeon_settings == "Steel":
            dungeon_name = "The Hissing Caverns"
        elif dungeon_settings == "Diamond":
            dungeon_name = "The Deep Dark"
        elif dungeon_settings == "Ruby":
            dungeon_name = "The Void Zone"
        elif dungeon_settings == "Obsidian":
            dungeon_name = "The Abyss"
        difficulty_file_read.close()
        if requested_data == "difficulty":
            return dungeon_settings
        if requested_data == "name":
            return dungeon_name
#Basic opening frame
class OpeningPage(tk.Frame):
    def __init__(self, parent, controller):
        tk.Frame.__init__(self, parent)
        self.controller = controller
        title_label = tk.Label(self, text="Dungeons of Strife", font=controller.small_title_font)
        title_label.grid(row=1, column=2, pady=10, sticky="new")
        invis_label1 = tk.Label(self)
        invis_label2 = tk.Label(self)
        invis_label3 = tk.Label(self)
        start_button = tk.Button(self, text="Start Game", padx=100, pady=80, font=controller.menu_button_font,
                           command=lambda: controller.show_frame("LoginMenu"))
        invis_label1.grid(row=2, column=2, pady=50)
        invis_label2.grid(row=1, column=1, padx=80)
        invis_label3.grid(row=2, column=1, padx=80)
        start_button.grid(row=3, column=2)
        GameFrame.set_champion_abilities_default(self)
#Frame that takes the input of the user and checks the text files database to see whether or not their account exists
class LoginMenu(tk.Frame):
    def __init__(self, parent, controller):
        tk.Frame.__init__(self, parent)
        self.controller = controller
        title_label = tk.Label(self, text="Dungeons of Strife", font=controller.small_title_font)
        title_label.grid(row=1, column=2, pady=10, sticky="new")
        invis_label1 = tk.Label(self)
        invis_label2 = tk.Label(self)
        invis_label3 = tk.Label(self)
        invis_label4 = tk.Label(self)
        username_label = tk.Label(self, text="Username:")
        username_entry = tk.Entry(self)
        password_label = tk.Label(self, text="Password:")
        password_entry = tk.Entry(self, show="*")
        login_button = tk.Button(self, text="Login", font=controller.menu_button_font,
                                command=lambda: self.login_check_password(username_entry, password_entry, problem_label))
        register_button = tk.Button(self, text="Register", font=controller.menu_button_font,
                               command=lambda: self.login_to_register(username_entry, password_entry, problem_label))
        problem_label = tk.Label(self, text="")
        back_button = tk.Button(self, text="Back", font=controller.menu_button_font,
                                 command=lambda: self.login_to_start(username_entry, password_entry, problem_label))
        invis_label1.grid(column=2, row=2, pady=50)
        invis_label2.grid(column=1, row=1, padx=80)
        invis_label3.grid(column=1, row=2, padx=80)
        invis_label4.grid(column=2, row=7, pady=50)
        login_button.grid(row=8, column=2)
        register_button.grid(row=9, column=2)
        problem_label.grid(row=10, column=2, padx=10, pady=10)
        back_button.grid(row=11, column=2)
        username_label.grid(row=3, column=2)
        username_entry.grid(row=4, column=2, padx=10, pady=10)
        password_label.grid(row=5, column=2)
        password_entry.grid(row=6, column=2, padx=10, pady=10)
#Checks username_entry and password_entry through the account_data_username/password text files to see whether or not
#the inputted account exists and displays a message through problem_label accordingly on if an input was empty or wrong.
    def login_check_password(self, username_entry, password_entry, problem_label):
        inputted_username = username_entry.get()
        inputted_username.strip()
        inputted_password = password_entry.get()
        inputted_password.strip()
        username_file = open(
            "C:/Users/{}/Documents/L2_ASSIGNMENT_RPG/Game_Data (DO NOT EDIT)/account_data_users.txt".format(COMPUTER_USERNAME), "r")
        password_file = open(
            "C:/Users/{}/Documents/L2_ASSIGNMENT_RPG/Game_Data (DO NOT EDIT)/account_data_password.txt".format(COMPUTER_USERNAME), "r")
        no_us_and_pw_warning =  ":---:Username and Password missing:---:"
        no_pw_warning =         ":----------:Password missing;---------:"
        no_us_warning =         ":----------:Username missing:---------:"
        invalid_details =       ":Username and/or Password is incorrect:"
        username_file_r = username_file.read()
        username_file.close()
        password_encoder = "{}{}".format(inputted_username, inputted_password)
        username_encoder = inputted_username
        encoded_username = username_encoder.encode("utf-8")
        if inputted_password == "":
            if inputted_username == "":
                problem_label.destroy()
                problem_label = tk.Label(self, text=no_us_and_pw_warning)
                problem_label.grid(row=10, column=2, padx=10, pady=10)
            else:
                problem_label.destroy()
                problem_label = tk.Label(self, text=no_pw_warning)
                problem_label.grid(row=10, column=2, padx=10, pady=10)
        elif inputted_username == "":
            problem_label.destroy()
            problem_label = tk.Label(self, text=no_us_warning)
            problem_label.grid(row=10, column=2, padx=10, pady=10)
        else:
            if str(encoded_username) in username_file_r:
                problem_label.destroy()
                while True:
                    password_file_r = password_file.readline()
                    if not password_file_r:
                        break
                    password_file_r = password_file_r.replace("\n", "")
                    try:
                        if bcrypt.check_password_hash(password_file_r, password_encoder):
                            problem_label.destroy()
                            self.set_current_user(inputted_username)
                            ParentClass.show_frame(app, "MainMenu")
                    except:
                        problem_label.destroy()
                        problem_label = tk.Label(self, text=invalid_details)
                        problem_label.grid(row=10, column=2, padx=10, pady=10)
            else:
                problem_label.destroy()
                problem_label = tk.Label(self, text=invalid_details)
                problem_label.grid(row=10, column=2, padx=10, pady=10)
#Writes the inputted_username into a text file for later use when finding what account is logged in
    def set_current_user(self, inputted_username):
        current_user = open(
            "C:/Users/{}/Documents/L2_ASSIGNMENT_RPG/Game_Data (DO NOT EDIT)/game_data_current_username.txt".format(COMPUTER_USERNAME), "w")
        current_user.write("{}".format(inputted_username))
        current_user.close()
#Deletes the inputted data in the text boxes so they'll be empty next time the user enters the frame
#Also deletes any problem frames to minimise confused when they next enter the frame
    def login_to_register(self, username_entry, password_entry, problem_label):
        problem_label.destroy()
        username_entry.delete(0, "end")
        password_entry.delete(0, "end")
        ParentClass.show_frame(app, "RegisterMenu")
#Deletes the inputted data in the text boxes so they'll be empty next time the user enters the frame
#Also deletes any problem frames to minimise confused when they next enter the frame
    def login_to_start(self, username_entry, password_entry, problem_label):
        problem_label.destroy()
        username_entry.delete(0, "end")
        password_entry.delete(0, "end")
        ParentClass.show_frame(app, "OpeningPage")
#Frame that takes the inputted username of the user and checks the account_data_user text file to see if that name already exists
#If it does, they are denied to make their account and told to pick another name. Multiple accounts with the same password is allowed, just not the same username
#This is because when the password is encrpyted, its encrypted form is the password and username together meaning that it'll be different from every other account with the same password
class RegisterMenu(tk.Frame):
    def __init__(self, parent, controller):
        tk.Frame.__init__(self, parent)
        self.controller = controller
        label = tk.Label(self, text="Register your account", font=controller.small_title_font)
        label.grid(row=1, column=1, pady=10)
        invis_label1 = tk.Label(self)
        invis_label2 = tk.Label(self)
        invis_label3 = tk.Label(self)
        username_label = ttk.Label(self, text="Username:")
        username_entry = tk.Entry(self)
        password_label = ttk.Label(self, text="Password:")
        password_entry = tk.Entry(self, show="*")
        problem_label = tk.Label(self, text="")
        confirm_password_label = ttk.Label(self, text="Confirm Password:")
        confirm_password_entry = tk.Entry(self, show="*")
        confirm_registerbutton = tk.Button(self, text="Register Details",
                                           command=lambda: self.register_check_password(username_entry, password_entry, confirm_password_entry, problem_label))
        back_to_login = tk.Button(self, text="Back to Login",
                                  command=lambda: self.register_to_login(username_entry, password_entry, confirm_password_entry))
        back_to_login.grid(row=8, column=1, padx=10, pady=10)
        confirm_registerbutton.grid(row=7, column=1)
        username_label.grid(row=3, column=1, ipadx=100, padx=10, pady=10)
        username_entry.grid(row=3, column=1, padx=10, pady=10)
        problem_label.grid(row=6, column=1, padx=10, pady=10)
        password_label.grid(row=4, column=1, ipadx=100, padx=10, pady=10)
        password_entry.grid(row=4, column=1, padx=10, pady=10)
        confirm_password_label.grid(row=5, column=1, ipadx=120, padx=10, pady=10)
        confirm_password_entry.grid(row=5, column=1, padx=10, pady=10)
        invis_label1.grid(row=0, pady=15)
        invis_label2.grid(row=1, padx=25)
        invis_label3.grid(row=2, column=1, pady=35)
#Checks username_entry through the account_data_users file to see whether or not the inputted username exists already
#and displays a message through problem_label accordingly on if an input was empty or if the username is already in use.
    def register_check_password(self, username_entry, password_entry, confirm_password_entry, problem_label):
        inputted_username = username_entry.get()
        inputted_username.strip()
        inputted_password = password_entry.get()
        inputted_password.strip()
        inputted_confirm_password = confirm_password_entry.get()
        inputted_confirm_password.strip()
        username_file = open(
            "C:/Users/{}/Documents/L2_ASSIGNMENT_RPG/Game_Data (DO NOT EDIT)/account_data_users.txt".format(COMPUTER_USERNAME), "r")
        password_file = open(
            "C:/Users/{}/Documents/L2_ASSIGNMENT_RPG/Game_Data (DO NOT EDIT)/account_data_password.txt".format(COMPUTER_USERNAME), "r")
        no_us_and_pw_warning = "Username and Password cannot be empty"
        no_pw_warning =        ":--------:Password cannot be empty:--------:"
        no_us_warning =        ":--------:Username cannot be empty:--------:"
        un_unavailable =       ":Sorry, this username is already being used:"
        not_equal_pw_warning = ":-------:Passwords aren't the same:--------:"
        username_file_r = username_file.read()
        username_file.close()
        password_file.close()
        if inputted_password == "":
            if inputted_username == "":
                problem_label.destroy()
                problem_label = tk.Label(self, text=no_us_and_pw_warning)
                problem_label.grid(row=6, column=1, padx=10, pady=10)
            else:
                problem_label.destroy()
                problem_label = tk.Label(self, text=no_pw_warning)
                problem_label.grid(row=6, column=1, padx=10, pady=10)
        elif inputted_confirm_password == inputted_password:
            password_encoder = "{}{}".format(inputted_username, inputted_password)
            username_encoder = inputted_username
            encoded_username = username_encoder.encode("utf-8")
            encoded_password = bcrypt.generate_password_hash(password_encoder).decode("utf-8")
            if inputted_username == "":
                problem_label.destroy()
                problem_label = tk.Label(self, text="")
                problem_label.configure(text=no_us_warning)
                problem_label.grid(row=6, column=1, padx=10, pady=10)
            else:
                if str(encoded_username) in username_file_r:
                    problem_label.destroy()
                    problem_label = tk.Label(self, text=un_unavailable)
                    problem_label.grid(row=6, column=1, padx=10, pady=10)
                else:
                    problem_label.destroy()
                    username_file.close()
                    password_file.close()
                    self.final_register_check(encoded_username, encoded_password)
        else:
            problem_label.destroy()
            problem_label = tk.Label(self, text=not_equal_pw_warning)
            problem_label.grid(row=6, column=1, padx=10, pady=10)
#Gives the user a window to make sure they are sure they want to add this account to the data base
    def final_register_check(self, encoded_username, encoded_password):
        register_window = tk.Tk()
        register_window.title("Confirmation")
        register_window_label = tk.Label(register_window, text="Are you sure you want to register with these details?")
        register_window_button_yes = tk.Button(register_window, text="Yes",
                                                command=lambda: self.user_account_set(register_window, encoded_username, encoded_password))
        register_window_button_no = tk.Button(register_window, text="No",
                                               command=register_window.destroy)
        register_window_label.grid(column=1, row=1)
        register_window_button_yes.grid(column=1, row=2)
        register_window_button_no.grid(column=1, row=3)
#Writes the newly created account information into their respective text files
    def user_account_set(self, register_window,  encoded_username, encoded_password):
        file = open("C:/Users/{}/Documents/L2_ASSIGNMENT_RPG/Game_Data (DO NOT EDIT)/account_data_users.txt".format(COMPUTER_USERNAME), "a")
        file.write("\n")
        file.write("{}, Empty:Empty:Empty:Empty:Empty, 0, Bronze".format(str(encoded_username)))
        file.close()
        file = open("C:/Users/{}/Documents/L2_ASSIGNMENT_RPG/Game_Data (DO NOT EDIT)/account_data_password.txt".format(COMPUTER_USERNAME), "a")
        file.write("\n")
        file.write(str(encoded_password))
        file.close()
        register_window.destroy()
#Deletes the inputted data in the text boxes so they'll be empty next time the user enters the frame
    def register_to_login(self, username_entry, password_entry, confirm_password_entry):
        username_entry.delete(0, "end")
        password_entry.delete(0, "end")
        confirm_password_entry.delete(0, "end")
        ParentClass.show_frame(app, "LoginMenu")

#Main menu for all the games functions
class MainMenu(tk.Frame):
    def __init__(self, parent, controller):
        tk.Frame.__init__(self, parent)
        self.controller = controller
        label = tk.Label(self, text="Surface Menu", font=controller.title_font)
        label.grid(column=2)
        invis_label1 = tk.Label(self)
        invis_label2 = tk.Label(self)
        invis_label3 = tk.Label(self)
        invis_label4 = tk.Label(self)
        invis_label5 = tk.Label(self)
        invis_label6 = tk.Label(self)
        invis_label7 = tk.Label(self)
        buttonDungeon = tk.Button(self, text="Delve into the Dungeon", padx=10, pady=10,
                                  font=controller.menu_button_font,
                                  command=lambda: controller.show_frame("DungeonDelve"))
        buttonTeam = tk.Button(self, text="Champion Camp", padx=10, pady=10, font=controller.menu_button_font,
                               command=lambda: controller.show_frame("CreateTeamPage"))
        buttonCredit = tk.Button(self, text="Credits (NYI)", padx=10, pady=10, font=controller.menu_button_font,
                                 command=lambda: controller.show_frame("CreditPage"))
        buttonH2P = tk.Button(self, text="How to Play (NYI)", padx=10, pady=10, font=controller.menu_button_font,
                              command=lambda: controller.show_frame("How2PlayPage"))
        buttonLeaderboard = tk.Button(self, text="Leaderboard (NYI)", padx=10, pady=10, font=controller.menu_button_font,
                                      command=lambda: controller.show_frame("LeaderboardPage"))
        buttonQuit = tk.Button(self, text="Exit game", padx=10, pady=10, font=controller.menu_button_font,
                               command=self.destroy)
        buttonDungeon.grid(row=1, column=2, pady=2, sticky="w")
        buttonTeam.grid(row=2, column=2, pady=2, sticky="w")
        buttonCredit.grid(row=5, column=2, pady=2, sticky="w")
        buttonH2P.grid(row=4, column=2, pady=2, sticky="w")
        buttonLeaderboard.grid(row=3, column=2, pady=2, sticky="w")
        buttonQuit.grid(row=6, column=2, pady=2, sticky="w")
        invis_label1.grid(column=1, row=1, padx=50)
        invis_label2.grid(column=1, row=2, padx=50)
        invis_label3.grid(column=1, row=3, padx=50)
        invis_label4.grid(column=1, row=4, padx=50)
        invis_label5.grid(column=1, row=5, padx=50)
        invis_label6.grid(column=1, row=6, padx=50)
        invis_label7.grid(column=1, row=7, padx=50)

#Currently a menu for a single entry point of editting your party
#In future will be where you can edit mutliple savable teams compositions (futureproofed)
class CreateTeamPage(tk.Frame):
    def __init__(self, parent, controller):
        global update_page_button
        tk.Frame.__init__(self, parent)
        self.controller = controller
        self.title_font = tkfont.Font(family='Times New Roman Baltic', size=120, weight="bold")
        for widget in self.winfo_children():
            widget.destroy()
        self.update_variables()
#Function that layouts out the menu, has a button (update_page_button) that refreshes the entire UI so that
#the display label (team_label) is refreshed to display the users newly created team
    def update_variables(self):
        global decoded_dungeoneer_team, team_button_text
        for widget in self.winfo_children():
            widget.destroy()
        team_str = ParentClass.get_account_data(self, "champion_list")
        team_list_data = team_str.split(":")
        decoded_dungeoneer_team = self.team_decode(team_list_data)
        team_text = self.display_team_vertical(decoded_dungeoneer_team)
        team_button_text = self.team_button_message(decoded_dungeoneer_team)
        title_label = tk.Label(self, text="Champion Camp", font=self.title_font)
        team_label = tk.Label(self, text=team_text)
        team_button = tk.Button(self, text=team_button_text,
                                  command=lambda: ParentClass.show_frame(app, "TeamSelectionPage"))
        update_page_button = tk.Button(self, text="Refresh Team Page", command=self.update_variables)
        return_button = tk.Button(self, text="Return to Menu",
                                 command=lambda: ParentClass.show_frame(app, "MainMenu"))
        title_label.grid(row=1, column=2, sticky="nsew", pady=10)
        team_label.grid(row=2, column=2)
        team_button.grid(row=3, column=2)
        update_page_button.grid(row=4, column=2)
        return_button.grid(row=5, column=2)
#Makes a single str that has a champion on one new line, making a visual vertical string
    def display_team_vertical(self, decoded_dungeoneer_team):
        team_text = ""
        for character in decoded_dungeoneer_team:
            team_text += "\n"
            team_text += character
        return team_text
#Simply checks if the first champion in the team is empty (will be on a fresh account)
#If it is, the button text will be more representative in telling the user to create their first team
#Otherwise it'll just say to 'edit' their current team
    def team_button_message(self, decoded_dungeoneer_team):
        text = ""
        if "Empty" in decoded_dungeoneer_team[0]:
            text = "Team 1: Create"
        else:
            text = "Team 1: Edit"
        return text
#Takes the list made after extracting the users current team from the text_file and 
#decodes specific champion code and appends the champions title to a new list that gets returned
#if there is an empty space, it instead appends 'Empty'
    def team_decode(self, team_list):
        decoded_dungeoneer_team = []
        if "Empty" in team_list[0]:
            decoded_dungeoneer_team.append("Empty")
            return decoded_dungeoneer_team
        else:
            for character in team_list:
                if character == MONK.code:
                    decoded_dungeoneer_team.append(MONK.title)
                if character == BARBARIAN.code:
                    decoded_dungeoneer_team.append(BARBARIAN.title)
                if character == KINGS_GUARD.code:
                    decoded_dungeoneer_team.append(KINGS_GUARD.title)
                if character == MASTER_FENCER.code:
                    decoded_dungeoneer_team.append(MASTER_FENCER.title)
                if character == BERSERKER.code:
                    decoded_dungeoneer_team.append(BERSERKER.title)
                if character == ROGUE.code:
                    decoded_dungeoneer_team.append(ROGUE.title)
                if character == SURVIVALIST.code:
                    decoded_dungeoneer_team.append(SURVIVALIST.title)
                if character == BRAWLIST.code:
                    decoded_dungeoneer_team.append(BRAWLIST.title)
                if character == ACADEMIC_MAGE.code:
                    decoded_dungeoneer_team.append(ACADEMIC_MAGE.title)
                if character == DRUID.code:
                    decoded_dungeoneer_team.append(DRUID.title)
                if character == WARLOCK.code:
                    decoded_dungeoneer_team.append(WARLOCK.title)
                if character == BLOODMANCER.code:
                    decoded_dungeoneer_team.append(BLOODMANCER.title)
                if character == PALADIN.code:
                    decoded_dungeoneer_team.append(PALADIN.title)
                if character == LEGION_RANGER.code:
                    decoded_dungeoneer_team.append(LEGION_RANGER.title)
                if character == MAGNETIMANCER.code:
                    decoded_dungeoneer_team.append(MAGNETIMANCER.title)
                if character == POWER_CONDUIT.code:
                    decoded_dungeoneer_team.append(POWER_CONDUIT.title)
                if character == EARTH_SPEAKER.code:
                    decoded_dungeoneer_team.append(EARTH_SPEAKER.title)
                if character == PRIEST.code:
                    decoded_dungeoneer_team.append(PRIEST.title)
                if character == TIME_WALKER.code:
                    decoded_dungeoneer_team.append(TIME_WALKER.title)
                if character == FIELD_MEDIC.code:
                    decoded_dungeoneer_team.append(FIELD_MEDIC.title)
                if character == "Empty":
                    decoded_dungeoneer_team.append("Empty")
            return decoded_dungeoneer_team

#This class is where users can make their team of champions
#Champions are designed around types and there are 3 types: Tanks, Damage Dealers, and Healers. There are 4 Tank, 12 Damage Dealers, and 4 Healer champions out of the total 20 to chose from
#Tanks are focused on taking damage away from their other allies and focusing it on themselves and reducing it
#Damage Dealers are focused on unique ways of dealing high damage to enemies or applying a lot of debuff effects to enemies or buffing allies
#Healers are focused on healing back and or reducing damage their team has taken as well as buffing allies
#A team can consist of any combonation of 5 unqiue champions. There is no limit to what team can have what, just that you can't have more than 1 of the same champion.
class TeamSelectionPage(tk.Frame):
    def __init__(self, parent, controller):
        tk.Frame.__init__(self, parent)
        self.controller = controller
        self.menu_button_font = tkfont.Font(family='Helvetica', size=18, weight="bold")
        self.title_label_font = tkfont.Font(family='Helvetica', size=30, weight="bold")
        self.small_label_font = tkfont.Font(family='Helvetica', size=12, weight="bold")
        title = tk.Label(self, text="Champion Camp", font=self.title_label_font)
        begin_recruiting_button = tk.Button(self, text="Begin Recruiting", command=lambda: self.team_creation("None"),
                                   font=controller.menu_button_font)
        cancel_button = tk.Button(self, text="Cancel", command=lambda: ParentClass.show_frame(app, "CreateTeamPage"))
        invis_label1 = tk.Label(self)
        invis_label2 = tk.Label(self)
        title.grid(row=1, column=2)
        begin_recruiting_button.grid(row=2, column=2, pady=50)
        cancel_button.grid(row=3, column=2)
        invis_label1.grid(row=1, column=1, rowspan=4, pady=50, ipadx=240, ipady=100)
        invis_label2.grid(row=1, column=2, pady=100)
#This frame is the menu where the user can look at all the different available champions and build their custom team
#Pressing one of the buttons that are named with one of the 3 types, you are shown champions that are assosiated with that type
#Users are able to gain information about champions they're interested about by clicking the 'View Details' button
#These let the user look at all their abilities, what they do, how much they cost, their cooldowns, etc. They can also look at their passives
#Clicking add to team will add them to one of the 5 slots that are shown at the bottom of the screen
#if their team is currently full, they get a pop-up window that asks if they want to replace a current champion to add the new one, letting them pick which champion they want to replace
    def team_creation(self, section_selected):
        global visual_team_label
        for widget in self.winfo_children():
            widget.destroy()
        invis_label1 = tk.Label(self)
        invis_label2 = tk.Label(self)
        team_str = ParentClass.get_account_data(self, "champion_list")
        team_list_data = team_str.split(":")
        temp_party = CreateTeamPage.team_decode(self, team_list_data)
        tank_section_button = tk.Button(self, text="Tanks", font=self.menu_button_font, width=26,
                                        command=lambda: self.team_creation("Tanks"))
        dps_section_button = tk.Button(self, text="Damage Dealers", font=self.menu_button_font, width=26,
                                        command=lambda: self.team_creation("Damage Dealers"))
        healer_section_button = tk.Button(self, text="Healers", font=self.menu_button_font, width=26,
                                        command=lambda: self.team_creation("Healers"))
        your_team_label = tk.Label(self, text=":Your Team:", font=self.small_label_font)
        visual_team_label = tk.Label(self, text=self.display_team(temp_party))
        confirm_changes_button = tk.Button(self, text="Confirm Changes", command=lambda: self.confirm_new_team(temp_party))
        cancel_button = tk.Button(self, text="Cancel", command=lambda: ParentClass.show_frame(app, "CreateTeamPage"))
        tank_section_button.grid(row=2, column=1)
        dps_section_button.grid(row=2, column=2, padx=25)
        healer_section_button.grid(row=2, column=3)
        invis_label1.grid(row=2, column=0, padx=6)
        invis_label2.grid(row=9, column=2, pady=45)
        your_team_label.grid(row=10, column=2)
        visual_team_label.grid(row=11, column=2)
        confirm_changes_button.grid(row=12, column=2)
        cancel_button.grid(row=13, column=2)
        if section_selected == "Tanks":
            tank_section_button["state"] = "disabled"
            dps_section_button["state"] = "normal"
            healer_section_button["state"] = "normal"
            invis_label3 = tk.Label(self)
            invis_label4 = tk.Label(self)
            MONK_label = tk.Label(self, text=MONK.name, font=self.menu_button_font)
            MONK_button_add = tk.Button(self, text="Add to Team",
                                        command=lambda: self.check_temp_party(MONK.title, "tank", temp_party))
            MONK_button_details = tk.Button(self, text="View Details", command=lambda: self.champion_view_details(MONK.title))
            BARBARIAN_label = tk.Label(self, text=BARBARIAN.name, font=self.menu_button_font)
            BARBARIAN_button_add = tk.Button(self, text="Add to Team",
                                                command=lambda: self.check_temp_party(BARBARIAN.title, "tank", temp_party))
            BARBARIAN_button_details = tk.Button(self, text="View Details", command=lambda: self.champion_view_details(BARBARIAN.title))
            bodyguard_label = tk.Label(self, text=KINGS_GUARD.name, font=self.menu_button_font)
            bodyguard_button_add = tk.Button(self, text="Add to Team",
                                                command=lambda: self.check_temp_party(KINGS_GUARD.title, "tank", temp_party))
            bodyguard_button_details = tk.Button(self, text="View Details", command=lambda: self.champion_view_details(KINGS_GUARD.title))
            fencer_label = tk.Label(self, text=MASTER_FENCER.name, font=self.menu_button_font)
            fencer_button_add = tk.Button(self, text="Add to Team",
                                            command=lambda: self.check_temp_party(MASTER_FENCER.title, "tank", temp_party))
            fencer_button_details = tk.Button(self, text="View Details", command=lambda: self.champion_view_details(MASTER_FENCER.title))
            MONK_label.grid(row=4, column=1, sticky="e")
            MONK_button_add.grid(row=5, column=1, sticky="e", padx=105)
            MONK_button_details.grid(row=5, column=1, sticky="e")
            BARBARIAN_label.grid(row=4, column=3, sticky="w")
            BARBARIAN_button_add.grid(row=5, column=3, sticky="w")
            BARBARIAN_button_details.grid(row=5, column=3, sticky="w", padx=80)
            bodyguard_label.grid(row=7, column=1, sticky="e")
            bodyguard_button_add.grid(row=8, column=1, sticky="e", padx=105)
            bodyguard_button_details.grid(row=8, column=1, sticky="e")
            fencer_label.grid(row=7, column=3, sticky="w")
            fencer_button_add.grid(row=8, column=3, sticky="w")
            fencer_button_details.grid(row=8, column=3, sticky="w", padx=80)
            invis_label3.grid(row=3, column=1, columnspan=3, pady=50)
            invis_label4.grid(row=6, column=1, columnspan=3, pady=50)
        elif section_selected == "Damage Dealers":
            tank_section_button["state"] = "normal"
            dps_section_button["state"] = "disabled"
            healer_section_button["state"] = "normal"
            dps_catagory1_label = tk.Label(self, text=":Melee:", font=self.menu_button_font)
            dps_catagory2_label = tk.Label(self, text=":Magic:", font=self.menu_button_font)
            dps_catagory3_label = tk.Label(self, text=":Other:", font=self.menu_button_font)
            BERSERKER_label = tk.Label(self, text=BERSERKER.name)
            BERSERKER_button_add = tk.Button(self, text="Add to Team",
                                                command=lambda: self.check_temp_party(BERSERKER.title, "melee", temp_party))
            BERSERKER_button_details = tk.Button(self, text="View Details", command=lambda: self.champion_view_details(BERSERKER.title))
            ROGUE_label = tk.Label(self, text=ROGUE.name)
            ROGUE_button_add = tk.Button(self, text="Add to Team",
                                            command=lambda: self.check_temp_party(ROGUE.title, "melee", temp_party))
            ROGUE_button_details = tk.Button(self, text="View Details", command=lambda: self.champion_view_details(ROGUE.title))
            SURVIVALIST_label = tk.Label(self, text=SURVIVALIST.name)
            SURVIVALIST_button_add = tk.Button(self, text="Add to Team",
                                                command=lambda: self.check_temp_party(SURVIVALIST.title, "melee", temp_party))
            SURVIVALIST_button_details = tk.Button(self, text="View Details", command=lambda: self.champion_view_details(SURVIVALIST.title))
            BRAWLIST_label = tk.Label(self, text=BRAWLIST.name)
            BRAWLIST_button_add = tk.Button(self, text="Add to Team",
                                            command=lambda: self.check_temp_party(BRAWLIST.title, "melee", temp_party))
            BRAWLIST_button_details = tk.Button(self, text="View Details", command=lambda: self.champion_view_details(BRAWLIST.title))
            ACADEMIC_MAGE_label = tk.Label(self, text=ACADEMIC_MAGE.name)
            ACADEMIC_MAGE_button_add = tk.Button(self, text="Add to Team",
                                                    command=lambda: self.check_temp_party(ACADEMIC_MAGE.title, "magic", temp_party))
            ACADEMIC_MAGE_button_details = tk.Button(self, text="View Details", command=lambda: self.champion_view_details(ACADEMIC_MAGE.title))
            jungle_DRUID_label = tk.Label(self, text=DRUID.name)
            jungle_DRUID_button_add = tk.Button(self, text="Add to Team",
                                                command=lambda: self.check_temp_party(DRUID.title, "magic", temp_party))
            jungle_DRUID_button_details = tk.Button(self, text="View Details", command=lambda: self.champion_view_details(DRUID.title))
            WARLOCK_label = tk.Label(self, text=WARLOCK.name)
            WARLOCK_button_add = tk.Button(self, text="Add to Team",
                                            command=lambda: self.check_temp_party(WARLOCK.title, "magic", temp_party))
            WARLOCK_button_details = tk.Button(self, text="View Details", command=lambda: self.champion_view_details(WARLOCK.title))
            BLOODMANCER_label = tk.Label(self, text=BLOODMANCER.name)
            BLOODMANCER_button_add = tk.Button(self, text="Add to Team",
                                                command=lambda: self.check_temp_party(BLOODMANCER.title, "magic", temp_party))
            BLOODMANCER_button_details = tk.Button(self, text="View Details", command=lambda: self.champion_view_details(BLOODMANCER.title))
            PALADIN_label = tk.Label(self, text=PALADIN.name)
            PALADIN_button_add = tk.Button(self, text="Add to Team",
                                            command=lambda: self.check_temp_party(PALADIN.title, "mixed", temp_party))
            PALADIN_button_details = tk.Button(self, text="View Details", command=lambda: self.champion_view_details(PALADIN.title))
            LEGION_RANGER_label = tk.Label(self, text=LEGION_RANGER.name)
            LEGION_RANGER_button_add = tk.Button(self, text="Add to Team",
                                                    command=lambda: self.check_temp_party(LEGION_RANGER.title, "mixed", temp_party))
            LEGION_RANGER_button_details = tk.Button(self, text="View Details", command=lambda: self.champion_view_details(LEGION_RANGER.title))
            MAGNETIMANCER_label = tk.Label(self, text=MAGNETIMANCER.name)
            MAGNETIMANCER_button_add = tk.Button(self, text="Add to Team",
                                                        command=lambda: self.check_temp_party(MAGNETIMANCER.title, "mixed", temp_party))
            MAGNETIMANCER_button_details = tk.Button(self, text="View Details", command=lambda: self.champion_view_details(MAGNETIMANCER.title))
            POWER_CONDUIT_label = tk.Label(self, text=POWER_CONDUIT.name)
            POWER_CONDUIT_button_add = tk.Button(self, text="Add to Team",
                                                    command=lambda: self.check_temp_party(POWER_CONDUIT.title, "mixed", temp_party))
            POWER_CONDUIT_button_details = tk.Button(self, text="View Details", command=lambda: self.champion_view_details(POWER_CONDUIT.title))
            dps_catagory1_label.grid(row=3, column=1)
            dps_catagory2_label.grid(row=3, column=2)
            dps_catagory3_label.grid(row=3, column=3)
            BERSERKER_label.grid(row=5, column=1, sticky="w")
            BERSERKER_button_add.grid(row=6, column=1, sticky="w")
            BERSERKER_button_details.grid(row=6, column=1, sticky="w", padx=80)
            ROGUE_label.grid(row=8, column=1, sticky="w")
            ROGUE_button_add.grid(row=9, column=1, sticky="w")
            ROGUE_button_details.grid(row=9, column=1, sticky="w", padx=80)
            SURVIVALIST_label.grid(row=5, column=1, sticky="e", padx=10)
            SURVIVALIST_button_add.grid(row=6, column=1, sticky="e", padx=115)
            SURVIVALIST_button_details.grid(row=6, column=1, sticky="e", padx=10)
            BRAWLIST_label.grid(row=8, column=1, sticky="e", padx=10)
            BRAWLIST_button_add.grid(row=9, column=1, sticky="e", padx=115)
            BRAWLIST_button_details.grid(row=9, column=1, sticky="e", padx=10)
            ACADEMIC_MAGE_label.grid(row=5, column=2, sticky="w", padx=10)
            ACADEMIC_MAGE_button_add.grid(row=6, column=2, sticky="w", padx=10)
            ACADEMIC_MAGE_button_details.grid(row=6, column=2, sticky="w", padx=90)
            jungle_DRUID_label.grid(row=8, column=2, sticky="w", padx=10)
            jungle_DRUID_button_add.grid(row=9, column=2, sticky="w", padx=10)
            jungle_DRUID_button_details.grid(row=9, column=2, sticky="w", padx=90)
            WARLOCK_label.grid(row=5, column=2, sticky="e", padx=10)
            WARLOCK_button_add.grid(row=6, column=2, sticky="e", padx=115)
            WARLOCK_button_details.grid(row=6, column=2, sticky="e", padx=10)
            BLOODMANCER_label.grid(row=8, column=2, sticky="e", padx=10)
            BLOODMANCER_button_add.grid(row=9, column=2, sticky="e", padx=115)
            BLOODMANCER_button_details.grid(row=9, column=2, sticky="e", padx=10)
            PALADIN_label.grid(row=5, column=3, sticky="w", padx=10)
            PALADIN_button_add.grid(row=6, column=3, sticky="w", padx=10)
            PALADIN_button_details.grid(row=6, column=3, sticky="w", padx=90)
            LEGION_RANGER_label.grid(row=8, column=3, sticky="w", padx=10)
            LEGION_RANGER_button_add.grid(row=9, column=3, sticky="w", padx=10)
            LEGION_RANGER_button_details.grid(row=9, column=3, sticky="w", padx=90)
            MAGNETIMANCER_label.grid(row=5, column=3, sticky="e")
            MAGNETIMANCER_button_add.grid(row=6, column=3, sticky="e", padx=105)
            MAGNETIMANCER_button_details.grid(row=6, column=3, sticky="e")
            POWER_CONDUIT_label.grid(row=8, column=3, sticky="e")
            POWER_CONDUIT_button_add.grid(row=9, column=3, sticky="e", padx=105)
            POWER_CONDUIT_button_details.grid(row=9, column=3, sticky="e")
        elif section_selected == "Healers":
            tank_section_button["state"] = "normal"
            dps_section_button["state"] = "normal"
            healer_section_button["state"] = "disabled"
            invis_label3 = tk.Label(self)
            invis_label4 = tk.Label(self)
            EARTH_SPEAKER_label = tk.Label(self, text=EARTH_SPEAKER.name, font=self.menu_button_font)
            EARTH_SPEAKER_button_add = tk.Button(self, text="Add to Team",
                                                    command=lambda: self.check_temp_party(EARTH_SPEAKER.title, "healer", temp_party))
            EARTH_SPEAKER_button_details = tk.Button(self, text="View Details", command=lambda: self.champion_view_details(EARTH_SPEAKER.title))
            PRIEST_label = tk.Label(self, text=PRIEST.name, font=self.menu_button_font)
            PRIEST_button_add = tk.Button(self, text="Add to Team",
                                                            command=lambda: self.check_temp_party(PRIEST.title, "healer", temp_party))
            PRIEST_button_details = tk.Button(self, text="View Details", command=lambda: self.champion_view_details(PRIEST.title))
            TIME_WALKER_label = tk.Label(self, text=TIME_WALKER.name, font=self.menu_button_font)
            TIME_WALKER_button_add = tk.Button(self, text="Add to Team",
                                                command=lambda: self.check_temp_party(TIME_WALKER.title, "healer", temp_party))
            TIME_WALKER_button_details = tk.Button(self, text="View Details", command=lambda: self.champion_view_details(TIME_WALKER.title))
            FIELD_MEDIC_label = tk.Label(self, text=FIELD_MEDIC.name, font=self.menu_button_font)
            FIELD_MEDIC_button_add = tk.Button(self, text="Add to Team",
                                                        command=lambda: self.check_temp_party(FIELD_MEDIC.title,
                                                                                            "healer", temp_party))
            FIELD_MEDIC_button_details = tk.Button(self, text="View Details", command=lambda: self.champion_view_details(FIELD_MEDIC.title))
            EARTH_SPEAKER_label.grid(row=4, column=1, sticky="e")
            EARTH_SPEAKER_button_add.grid(row=5, column=1, sticky="e", padx=105)
            EARTH_SPEAKER_button_details.grid(row=5, column=1, sticky="e")
            PRIEST_label.grid(row=4, column=3, sticky="w")
            PRIEST_button_add.grid(row=5, column=3, sticky="w")
            PRIEST_button_details.grid(row=5, column=3, sticky="w", padx=80)
            TIME_WALKER_label.grid(row=7, column=1, sticky="e")
            TIME_WALKER_button_add.grid(row=8, column=1, sticky="e", padx=105)
            TIME_WALKER_button_details.grid(row=8, column=1, sticky="e")
            FIELD_MEDIC_label.grid(row=7, column=3, sticky="w")
            FIELD_MEDIC_button_add.grid(row=8, column=3, sticky="w")
            FIELD_MEDIC_button_details.grid(row=8, column=3, sticky="w", padx=80)
            invis_label3.grid(row=3, column=1, columnspan=3, pady=50)
            invis_label4.grid(row=6, column=1, columnspan=3, pady=50)
#Simply makes and returns a string that lists out each champion in the team, any missing spaces are taken up with 'Empty'
    def display_team(self, team):
        team_text = ""
        i = 0
        for character in team:
            team_text += "["
            team_text += character
            team_text += "]"
            i += 1
        if i != 5:
            while i < 5:
                team_text += "["
                team_text += "Empty"
                team_text += "]"
                i += 1
        return team_text
#Pop-up window that shows up after the user clicks 'View Deatils' under a champions name. Tells a little detail on what they do fundementally, what their passive and attacks/specials are, and what resource they use if they do.
    def champion_view_details(self, champion_name):
        root = tk.Tk()
        champion_resource = ''
        if champion_name == "Monk": 
            champion_details = "Feramon the Monk is a master of the battlefield, using his well placed attacks to control his enemies\nwhile utilising his magical baubles to prevent imminent danger towards himself"
            attacks_list = MONK.attack_list
            specials_list = MONK.specials_list
            passive_ability = MONK.passive
            champion_code = MONK.code
            champion_resource = 'Focus'
        if champion_name == "Barbarian": 
            champion_details = "Baralor the Barbarian is in all words, an egomaniac\nHe wants all the attention for himself and can keep himself alive while he has it\nHe taunting enemies into attacking him with his words alone and gets stronger while everyones watching"
            attacks_list = BARBARIAN.attack_list
            specials_list = BARBARIAN.specials_list
            passive_ability = BARBARIAN.passive
            champion_code = BARBARIAN.code
            champion_resource = 'Rage'
        if champion_name == "Kings-Guard": 
            champion_details = "Hecutis the Kings-Guard is like a building for his allies to rally behind\nStanding inbetween his friends and the enemy is what he does best\nHis fearless attitude towards his enemies is well put as he is almost as impenetrable as his Kings fortress"
            attacks_list = KINGS_GUARD.attack_list
            specials_list = KINGS_GUARD.specials_list
            passive_ability = KINGS_GUARD.passive
            champion_code = KINGS_GUARD.code
        if champion_name == "Fencer": 
            champion_details = "Lorelai the Master Fencer is likely the fastest person alive being able to dodge and weave her away out of harms way\nwhile protecting her allies by redirect the enemies own hits right back at them"
            attacks_list = MASTER_FENCER.attack_list
            specials_list = MASTER_FENCER.specials_list
            passive_ability = MASTER_FENCER.passive
            champion_code = MASTER_FENCER.code
        if champion_name == "Berserker": 
            champion_details = "Kelzarg the Berserker only gets angrier with each attack\nBeing able to enrage himself to dish out high amounts of damage at the cost of taking more himself"
            attacks_list = BERSERKER.attack_list
            specials_list = BERSERKER.specials_list
            passive_ability = BERSERKER.passive
            champion_code = BERSERKER.code
            champion_resource = 'Rage'
        if champion_name == "Rogue": 
            champion_details = "Ryker the Rogue knows exactly where to strike to get the most of his cuts\nWhat makes him especially scary on the battlefield, is that the damage is usually done after the strikes been made"
            attacks_list = ROGUE.attack_list
            specials_list = ROGUE.specials_list
            passive_ability = ROGUE.passive
            champion_code = ROGUE.code
        if champion_name == "Survivalist": 
            champion_details = "Mally the Survivalist's time in the wild has taught her all the tricks to keep herself alive\nWhile she strikes strong, her true power comes from standing longer than any of her counterparts"
            attacks_list = SURVIVALIST.attack_list
            specials_list = SURVIVALIST.specials_list
            passive_ability = SURVIVALIST.passive
            champion_code = SURVIVALIST.code
        if champion_name == "Brawlist": 
            champion_details = "George the Brawlist knows the human body almost as well as a surgeon\nKnowing where to strike and in what order helps him keep miles ahead of his competitors"
            attacks_list = BRAWLIST.attack_list
            specials_list = BRAWLIST.specials_list
            passive_ability = BRAWLIST.passive
            champion_code = BRAWLIST.code
        if champion_name == "Academics Mage": 
            champion_details = "Tulip the Academics Mage puts her knowledge to use\nBeing able to cast a variety of high power and high utility spells to overwhelm her enemies"
            attacks_list = ACADEMIC_MAGE.attack_list
            specials_list = ACADEMIC_MAGE.specials_list
            passive_ability = ACADEMIC_MAGE.passive
            champion_code = ACADEMIC_MAGE.code
            champion_resource = 'Mana'
        if champion_name == "Druid": 
            champion_details = "Fuds the Druid loves roses, especially the thorny kinds\nShe's extremely adapt at manipulating her surrounding to support the deadly uses of her thorns"
            attacks_list = DRUID.attack_list
            specials_list = DRUID.specials_list
            passive_ability = DRUID.passive
            champion_code = DRUID.code
            champion_resource = 'Mana'
        if champion_name == "Warlock": 
            champion_details = "Sol'ghar the Warlock has fallen deep into corruption\nBy giving in to voids power, he can cast devastating spells that obliterate his enemies if given only a little time"
            attacks_list = WARLOCK.attack_list
            specials_list = WARLOCK.specials_list
            passive_ability = WARLOCK.passive
            champion_code = WARLOCK.code
            champion_resource = 'Mana'
        if champion_name == "Bloodmancer": 
            champion_details = "Flynn the Bloodmancer doesn't need the typical magic other spellcasters utilise\nUsing the power of whats on the inside, he can deliver huge blows while empowering his spells for extra effects"
            attacks_list = BLOODMANCER.attack_list
            specials_list = BLOODMANCER.specials_list
            passive_ability = BLOODMANCER.passive
            champion_code = BLOODMANCER.code
            champion_resource = 'Health'
        if champion_name == "Paladin": 
            champion_details = "Olig the Paladin is a paragon of his gods wrath\nHe promises that heavy retribution will be carried out no matter how long it takes"
            attacks_list = PALADIN.attack_list
            specials_list = PALADIN.specials_list
            passive_ability = PALADIN.passive
            champion_code = PALADIN.code
        if champion_name == "Ranger": 
            champion_details = "Brad the Legion Ranger is a standout archer that always has something for the right occasion\nHe has a myriad of techniques and skills to fit whatevers thrown his way"
            attacks_list = LEGION_RANGER.attack_list
            specials_list = LEGION_RANGER.specials_list
            passive_ability = LEGION_RANGER.passive
            champion_code = LEGION_RANGER.code
        if champion_name == "Magnetimancer": 
            champion_details = "Kel'ther the Magnetimancer loves watching things zap\nUsing his electrical prowess he polarises his enemies and watches them fry when unbalanced charges violent stabilise"
            attacks_list = MAGNETIMANCER.attack_list
            specials_list = MAGNETIMANCER.specials_list
            passive_ability = MAGNETIMANCER.passive
            champion_code = MAGNETIMANCER.code
        if champion_name == "Power Conduit": 
            champion_details = "Power Conduit is a large seemingly sentient floating pillar\nNo one knows why but it loves to support its companions with wildly powerful unknown support magic"
            attacks_list = POWER_CONDUIT.attack_list
            specials_list = POWER_CONDUIT.specials_list
            passive_ability = POWER_CONDUIT.passive
            champion_code = POWER_CONDUIT.code
            champion_resource = 'Charges'
        if champion_name == "Earth Speaker": 
            champion_details = "Delamanar the Earth Speaker takes pride in drenching allies with healing waters\nManipulating the earth for protection and waters for healing is what he does best"
            attacks_list = EARTH_SPEAKER.attack_list
            specials_list = EARTH_SPEAKER.specials_list
            passive_ability = EARTH_SPEAKER.passive
            champion_code = EARTH_SPEAKER.code
            champion_resource = 'Mana'
        if champion_name == "Priest": 
            champion_details = "Sethuk the High Priest takes from the healthly and gives to the sick\nHe granting his allies blessings that allows the damage he does to transfer into healing for them"
            attacks_list = PRIEST.attack_list
            specials_list = PRIEST.specials_list
            passive_ability = PRIEST.passive
            champion_code = PRIEST.code
            champion_resource = 'Mana'
        if champion_name == "Time Walker": 
            champion_details = "Zaqner the Time Walker takes the technology from the future to warp reality in his favour\nReversing wounds entirely using technology that also keeps his allies in the fight without him needing to lift a finger"
            attacks_list = TIME_WALKER.attack_list
            specials_list = TIME_WALKER.specials_list
            passive_ability = TIME_WALKER.passive
            champion_code = TIME_WALKER.code
            champion_resource = 'Mana'
        if champion_name == "Field Medic": 
            champion_details = "Curie the Field Medic has more than enough expierience on the field to warrent her resourcefulness\nGranting her allies fight winning buffs that linger, she can be happy to have her friends win her fights for her"
            attacks_list = FIELD_MEDIC.attack_list
            specials_list = FIELD_MEDIC.specials_list
            passive_ability = FIELD_MEDIC.passive
            champion_code = FIELD_MEDIC.code
        champion_title_label = tk.Label(root, text="{} ({})".format(champion_name, champion_code))
        champion_title_label.grid(row=0, column=1)
        champion_details_label = tk.Label(root, text=champion_details)
        champion_details_label.grid(row=1, column=1)
        champion_passive_details_button = tk.Button(root, text=passive_ability, command=lambda: GameFrame.passive_details_window(self, champion_name))
        champion_passive_details_button.grid(row=2, column=1)
        if champion_resource != '':
            champion_resource_label = tk.Label(root, text="This champion uses {} as a resource".format(champion_resource))
            champion_resource_label.grid(row=3, column=1)
            champion_attacks_label = tk.Label(root, text=":Attacks:")
            champion_attacks_label.grid(row=4, column=1)
            if len(attacks_list) != 0:
                if len(attacks_list) == 1:
                    champion_attack1_button = tk.Button(root, text="{}".format(attacks_list[0]), command=lambda: GameFrame.attack_details_window(self, attacks_list[0]))
                    champion_attack1_button.grid(row=5, column=1)
                elif len(attacks_list) == 2:
                    champion_attack1_button = tk.Button(root, text="{}".format(attacks_list[0]), command=lambda: GameFrame.attack_details_window(self, attacks_list[0]))
                    champion_attack2_button = tk.Button(root, text="{}".format(attacks_list[1]), command=lambda: GameFrame.attack_details_window(self, attacks_list[1]))
                    champion_attack1_button.grid(row=5, column=1, sticky="w")
                    champion_attack2_button.grid(row=5, column=1, sticky="e")
                elif len(attacks_list) == 3:
                    champion_attack1_button = tk.Button(root, text="{}".format(attacks_list[0]), command=lambda: GameFrame.attack_details_window(self, attacks_list[0]))
                    champion_attack2_button = tk.Button(root, text="{}".format(attacks_list[1]), command=lambda: GameFrame.attack_details_window(self, attacks_list[1]))
                    champion_attack3_button = tk.Button(root, text="{}".format(attacks_list[2]), command=lambda: GameFrame.attack_details_window(self, attacks_list[2]))
                    champion_attack1_button.grid(row=5, column=1, sticky="w")
                    champion_attack2_button.grid(row=5, column=1, sticky="e")
                    champion_attack3_button.grid(row=6, column=1)
                elif len(attacks_list) == 4:
                    champion_attack1_button = tk.Button(root, text="{}".format(attacks_list[0]), command=lambda: GameFrame.attack_details_window(self, attacks_list[0]))
                    champion_attack2_button = tk.Button(root, text="{}".format(attacks_list[1]), command=lambda: GameFrame.attack_details_window(self, attacks_list[1]))
                    champion_attack3_button = tk.Button(root, text="{}".format(attacks_list[3]), command=lambda: GameFrame.attack_details_window(self, attacks_list[2]))
                    champion_attack4_button = tk.Button(root, text="{}".format(attacks_list[3]), command=lambda: GameFrame.attack_details_window(self, attacks_list[3]))
                    champion_attack1_button.grid(row=5, column=1, sticky="w")
                    champion_attack2_button.grid(row=5, column=1, sticky="e")
                    champion_attack3_button.grid(row=6, column=1, sticky="w")
                    champion_attack4_button.grid(row=6, column=1, sticky="e")
            else:
                champion_attackless_label = tk.Label(root, text="This champion has no attacks")
                champion_attackless_label.grid(row=5, column=1)
            champion_specials_label = tk.Label(root, text=":Specials:")
            champion_specials_label.grid(row=7, column=1)
            if len(specials_list) != 0:
                if len(specials_list) == 1:
                    champion_special1_button = tk.Button(root, text="{}".format(specials_list[0]), command=lambda: GameFrame.special_details_window(self, specials_list[0]))
                    champion_special1_button.grid(row=8, column=1)
                elif len(specials_list) == 2:
                    champion_special1_button = tk.Button(root, text="{}".format(specials_list[0]), command=lambda: GameFrame.special_details_window(self, specials_list[0]))
                    champion_special2_button = tk.Button(root, text="{}".format(specials_list[1]), command=lambda: GameFrame.special_details_window(self, specials_list[1]))
                    champion_special1_button.grid(row=8, column=1, sticky="w")
                    champion_special2_button.grid(row=8, column=1, sticky="e")
                elif len(specials_list) == 3:
                    champion_special1_button = tk.Button(root, text="{}".format(specials_list[0]), command=lambda: GameFrame.special_details_window(self, specials_list[0]))
                    champion_special2_button = tk.Button(root, text="{}".format(specials_list[1]), command=lambda: GameFrame.special_details_window(self, specials_list[1]))
                    champion_special3_button = tk.Button(root, text="{}".format(specials_list[2]), command=lambda: GameFrame.special_details_window(self, specials_list[2]))
                    champion_special1_button.grid(row=8, column=1, sticky="w")
                    champion_special2_button.grid(row=8, column=1, sticky="e")
                    champion_special3_button.grid(row=9, column=1)
                elif len(specials_list) == 4:
                    champion_special1_button = tk.Button(root, text="{}".format(specials_list[0]), command=lambda: GameFrame.special_details_window(self, specials_list[0]))
                    champion_special2_button = tk.Button(root, text="{}".format(specials_list[1]), command=lambda: GameFrame.special_details_window(self, specials_list[1]))
                    champion_special3_button = tk.Button(root, text="{}".format(specials_list[2]), command=lambda: GameFrame.special_details_window(self, specials_list[2]))
                    champion_special4_button = tk.Button(root, text="{}".format(specials_list[3]), command=lambda: GameFrame.special_details_window(self, specials_list[3]))
                    champion_special1_button.grid(row=8, column=1, sticky="w")
                    champion_special2_button.grid(row=8, column=1, sticky="e")
                    champion_special3_button.grid(row=9, column=1, sticky="w")
                    champion_special4_button.grid(row=9, column=1, sticky="e")
            else:
                champion_specialless_label = tk.Label(root, text="This champion has no specials")
                champion_specialless_label.grid(row=8, column=1)
            close_button = tk.Button(root, text="Close Window", command=root.destroy)
            close_button.grid(row=10, column=1)
        else:
            champion_attacks_label = tk.Label(root, text=":Attacks:")
            champion_attacks_label.grid(row=3, column=1)
            if len(attacks_list) != 0:
                if len(attacks_list) == 1:
                    champion_attack1_button = tk.Button(root, text="{}".format(attacks_list[0]), command=lambda: GameFrame.attack_details_window(self, attacks_list[0]))
                    champion_attack1_button.grid(row=4, column=1)
                elif len(attacks_list) == 2:
                    champion_attack1_button = tk.Button(root, text="{}".format(attacks_list[0]), command=lambda: GameFrame.attack_details_window(self, attacks_list[0]))
                    champion_attack2_button = tk.Button(root, text="{}".format(attacks_list[1]), command=lambda: GameFrame.attack_details_window(self, attacks_list[1]))
                    champion_attack1_button.grid(row=4, column=1, sticky="w")
                    champion_attack2_button.grid(row=4, column=1, sticky="e")
                elif len(attacks_list) == 3:
                    champion_attack1_button = tk.Button(root, text="{}".format(attacks_list[0]), command=lambda: GameFrame.attack_details_window(self, attacks_list[0]))
                    champion_attack2_button = tk.Button(root, text="{}".format(attacks_list[1]), command=lambda: GameFrame.attack_details_window(self, attacks_list[1]))
                    champion_attack3_button = tk.Button(root, text="{}".format(attacks_list[2]), command=lambda: GameFrame.attack_details_window(self, attacks_list[2]))
                    champion_attack1_button.grid(row=4, column=1, sticky="w")
                    champion_attack2_button.grid(row=4, column=1, sticky="e")
                    champion_attack3_button.grid(row=5, column=1)
                elif len(attacks_list) == 4:
                    champion_attack1_button = tk.Button(root, text="{}".format(attacks_list[0]), command=lambda: GameFrame.attack_details_window(self, attacks_list[0]))
                    champion_attack2_button = tk.Button(root, text="{}".format(attacks_list[1]), command=lambda: GameFrame.attack_details_window(self, attacks_list[1]))
                    champion_attack3_button = tk.Button(root, text="{}".format(attacks_list[3]), command=lambda: GameFrame.attack_details_window(self, attacks_list[2]))
                    champion_attack4_button = tk.Button(root, text="{}".format(attacks_list[3]), command=lambda: GameFrame.attack_details_window(self, attacks_list[3]))
                    champion_attack1_button.grid(row=4, column=1, sticky="w")
                    champion_attack2_button.grid(row=4, column=1, sticky="e")
                    champion_attack3_button.grid(row=5, column=1, sticky="w")
                    champion_attack4_button.grid(row=5, column=1, sticky="e")
            else:
                champion_attackless_label = tk.Label(root, text="This champion has no attacks")
                champion_attackless_label.grid(row=4, column=1)
            champion_specials_label = tk.Label(root, text=":Specials:")
            champion_specials_label.grid(row=6, column=1)
            if len(specials_list) != 0:
                if len(specials_list) == 1:
                    champion_special1_button = tk.Button(root, text="{}".format(specials_list[0]), command=lambda: GameFrame.special_details_window(self, specials_list[0]))
                    champion_special1_button.grid(row=7, column=1)
                elif len(specials_list) == 2:
                    champion_special1_button = tk.Button(root, text="{}".format(specials_list[0]), command=lambda: GameFrame.special_details_window(self, specials_list[0]))
                    champion_special2_button = tk.Button(root, text="{}".format(specials_list[1]), command=lambda: GameFrame.special_details_window(self, specials_list[1]))
                    champion_special1_button.grid(row=7, column=1, sticky="w")
                    champion_special2_button.grid(row=7, column=1, sticky="e")
                elif len(specials_list) == 3:
                    champion_special1_button = tk.Button(root, text="{}".format(specials_list[0]), command=lambda: GameFrame.special_details_window(self, specials_list[0]))
                    champion_special2_button = tk.Button(root, text="{}".format(specials_list[1]), command=lambda: GameFrame.special_details_window(self, specials_list[1]))
                    champion_special3_button = tk.Button(root, text="{}".format(specials_list[2]), command=lambda: GameFrame.special_details_window(self, specials_list[2]))
                    champion_special1_button.grid(row=7, column=1, sticky="w")
                    champion_special2_button.grid(row=7, column=1, sticky="e")
                    champion_special3_button.grid(row=8, column=1)
                elif len(specials_list) == 4:
                    champion_special1_button = tk.Button(root, text="{}".format(specials_list[0]), command=lambda: GameFrame.special_details_window(self, specials_list[0]))
                    champion_special2_button = tk.Button(root, text="{}".format(specials_list[1]), command=lambda: GameFrame.special_details_window(self, specials_list[1]))
                    champion_special3_button = tk.Button(root, text="{}".format(specials_list[2]), command=lambda: GameFrame.special_details_window(self, specials_list[2]))
                    champion_special4_button = tk.Button(root, text="{}".format(specials_list[3]), command=lambda: GameFrame.special_details_window(self, specials_list[3]))
                    champion_special1_button.grid(row=7, column=1, sticky="w")
                    champion_special2_button.grid(row=7, column=1, sticky="e")
                    champion_special3_button.grid(row=8, column=1, sticky="w")
                    champion_special4_button.grid(row=8, column=1, sticky="e")
            else:
                champion_specialless_label = tk.Label(root, text="This champion has no specials")
                champion_specialless_label.grid(row=7, column=1)
            close_button = tk.Button(root, text="Close Window", command=root.destroy)
            close_button.grid(row=9, column=1)
#Function runs when the user adds a champion to the team. 
#If the champion is already in the party, they'll be told this and nothing happens
#If there is room in the party for the champion, they'll be added
#If there isn't room available, the user will be asked if they want to replace one of the champions in the party with the new champion
    def check_temp_party(self, champion, type, temp_party):
        global yes_buttonCTP, no_buttonCTP, warning_label1CTP, warning_label2CTP, visual_team_label
        tank_temp_party = []
        melee_temp_party = []
        magic_temp_party = []
        mixed_temp_party = []
        healer_temp_party = []
        if "Empty" in temp_party:
            temp_party.remove("Empty")
        if champion in temp_party:
            root = tk.Tk()
            warning_label = tk.Label(root, text="Sorry, but this character is already assigned in the party")
            ok_button = tk.Button(root, text="Ok", command=root.destroy)
            ok_button.grid(row=2, column=1)
            warning_label.grid(row=1, column=1)
            visual_team_label.destroy()
            visual_team_label = tk.Label(self, text=self.display_team(temp_party))
            visual_team_label.grid(row=11, column=2)
        else:
            if len(temp_party) < 5:
                for character in temp_party:
                    if character == MONK.title:
                        tank_temp_party.append(character)
                    if character == BARBARIAN.title:
                        tank_temp_party.append(character)
                    if character == KINGS_GUARD.title:
                        tank_temp_party.append(character)
                    if character == MASTER_FENCER.title:
                        tank_temp_party.append(character)
                    if character == BERSERKER.title:
                        melee_temp_party.append(character)
                    if character == ROGUE.title:
                        melee_temp_party.append(character)
                    if character == SURVIVALIST.title:
                        melee_temp_party.append(character)
                    if character == BRAWLIST.title:
                        melee_temp_party.append(character)
                    if character == ACADEMIC_MAGE.title:
                        magic_temp_party.append(character)
                    if character == DRUID.title:
                        magic_temp_party.append(character)
                    if character == WARLOCK.title:
                        magic_temp_party.append(character)
                    if character == BLOODMANCER.title:
                        magic_temp_party.append(character)
                    if character == PALADIN.title:
                        mixed_temp_party.append(character)
                    if character == LEGION_RANGER.title:
                        mixed_temp_party.append(character)
                    if character == MAGNETIMANCER.title:
                        mixed_temp_party.append(character)
                    if character == POWER_CONDUIT.title:
                        mixed_temp_party.append(character)
                    if character == EARTH_SPEAKER.title:
                        healer_temp_party.append(character)
                    if character == PRIEST.title:
                        healer_temp_party.append(character)
                    if character == TIME_WALKER.title:
                        healer_temp_party.append(character)
                    if character == FIELD_MEDIC.title:
                        healer_temp_party.append(character)
                    if character == "Empty":
                        p = 0
                if type == "tank":
                    tank_temp_party.append(champion)
                    tank_temp_party = sorted(tank_temp_party)
                elif type == "melee":
                    melee_temp_party.append(champion)
                    melee_temp_party = sorted(melee_temp_party)
                elif type == "magic":
                    magic_temp_party.append(champion)
                    magic_temp_party = sorted(magic_temp_party)
                elif type == "mixed":
                    mixed_temp_party.append(champion)
                    mixed_temp_party = sorted(mixed_temp_party)
                elif type == "healer":
                    healer_temp_party.append(champion)
                    healer_temp_party = sorted(healer_temp_party)
                temp_party = []
                if tank_temp_party != []:
                    for character in tank_temp_party:
                        temp_party.append(character)
                if melee_temp_party != []:
                    for character in melee_temp_party:
                        temp_party.append(character)
                if magic_temp_party != []:
                    for character in magic_temp_party:
                        temp_party.append(character)
                if mixed_temp_party != []:
                    for character in mixed_temp_party:
                        temp_party.append(character)
                if healer_temp_party != []:
                    for character in healer_temp_party:
                        temp_party.append(character)
                visual_team_label.destroy()
                visual_team_label = tk.Label(self, text=self.display_team(temp_party))
                visual_team_label.grid(row=11, column=2)
            elif len(temp_party) == 5:
                root = tk.Tk()
                warning_label1CTP = tk.Label(root, text="The party is currently full!")
                warning_label2CTP = tk.Label(root, text="Would you like to remove a current party member to make room?")
                yes_buttonCTP = tk.Button(root, text="Yes",
                                          command=lambda: self.adding_champions_tempParty(root, champion, temp_party))
                no_buttonCTP = tk.Button(root, text="No", command=lambda: root.destroy())
                warning_label1CTP.grid(row=1, column=1)
                warning_label2CTP.grid(row=2, column=1)
                yes_buttonCTP.grid(row=3, column=1, sticky="w", padx=140)
                no_buttonCTP.grid(row=3, column=1, sticky="e", padx=140)
#Gives the user a list of each champion currently in the party and asks them to choose one to remove so the new champion can take their place
    def adding_champions_tempParty(self, root, champion, temp_party):
        global champion1CTP, champion2CTP, champion3CTP, champion4CTP, champion5CTP, cancel_buttonCTP, window_labelCTP
        yes_buttonCTP.destroy()
        no_buttonCTP.destroy()
        warning_label1CTP.destroy()
        warning_label2CTP.destroy()
        window_labelCTP = tk.Label(root, text="Please choose which champion will be replaced for '{}'".format(champion))
        champion1CTP = tk.Button(root, text=temp_party[0],
                                 command=lambda: self.replace_champion(root, champion, temp_party, temp_party[0]))
        champion2CTP = tk.Button(root, text=temp_party[1],
                                 command=lambda: self.replace_champion(root, champion, temp_party, temp_party[1]))
        champion3CTP = tk.Button(root, text=temp_party[2],
                                 command=lambda: self.replace_champion(root, champion, temp_party, temp_party[2]))
        champion4CTP = tk.Button(root, text=temp_party[3],
                                 command=lambda: self.replace_champion(root, champion, temp_party, temp_party[3]))
        champion5CTP = tk.Button(root, text=temp_party[4],
                                 command=lambda: self.replace_champion(root, champion, temp_party, temp_party[4]))
        cancel_buttonCTP = tk.Button(root, text="Cancel", command=root.destroy)
        window_labelCTP.grid(row=1, column=3)
        champion1CTP.grid(row=2, column=3)
        champion2CTP.grid(row=3, column=3)
        champion3CTP.grid(row=4, column=3)
        champion4CTP.grid(row=5, column=3)
        champion5CTP.grid(row=6, column=3)
        cancel_buttonCTP.grid(row=7, column=3)
#Removes the selected champion and adds the new one, then sorts the list to match the types (Tanks > MeleeDPS > MagicDPS > MixedDPS > Healers)
    def replace_champion(self, root, champion, temp_party, selected):
        global visual_team_label
        pos = temp_party.index(selected)
        temp_pos = temp_party[pos]
        temp_party[pos] = champion
        champion1CTP.destroy()
        champion2CTP.destroy()
        champion3CTP.destroy()
        champion4CTP.destroy()
        champion5CTP.destroy()
        cancel_buttonCTP.destroy()
        window_labelCTP.destroy()
        window_labelCTP2 = tk.Label(root, text="'{}' has been replaced by '{}'!".format(temp_pos, champion))
        ok_button = tk.Button(root, text="Ok", command=root.destroy)
        window_labelCTP2.grid(row=1, column=1)
        ok_button.grid(row=2, column=1)
        tank_temp_party = []
        melee_temp_party = []
        magic_temp_party = []
        mixed_temp_party = []
        healer_temp_party = []
        for character in temp_party:
            if character == MONK.title:
                tank_temp_party.append(character)
            if character == BARBARIAN.title:
                tank_temp_party.append(character)
            if character == KINGS_GUARD.title:
                tank_temp_party.append(character)
            if character == MASTER_FENCER.title:
                tank_temp_party.append(character)
            if character == BERSERKER.title:
                melee_temp_party.append(character)
            if character == ROGUE.title:
                melee_temp_party.append(character)
            if character == SURVIVALIST.title:
                melee_temp_party.append(character)
            if character == BRAWLIST.title:
                melee_temp_party.append(character)
            if character == ACADEMIC_MAGE.title:
                magic_temp_party.append(character)
            if character == DRUID.title:
                magic_temp_party.append(character)
            if character == WARLOCK.title:
                magic_temp_party.append(character)
            if character == BLOODMANCER.title:
                magic_temp_party.append(character)
            if character == PALADIN.title:
                mixed_temp_party.append(character)
            if character == LEGION_RANGER.title:
                mixed_temp_party.append(character)
            if character == MAGNETIMANCER.title:
                mixed_temp_party.append(character)
            if character == POWER_CONDUIT.title:
                mixed_temp_party.append(character)
            if character == EARTH_SPEAKER.title:
                healer_temp_party.append(character)
            if character == PRIEST.title:
                healer_temp_party.append(character)
            if character == TIME_WALKER.title:
                healer_temp_party.append(character)
            if character == FIELD_MEDIC.title:
                healer_temp_party.append(character)
        temp_party = []
        if tank_temp_party != []:
            tank_temp_party = sorted(tank_temp_party)
            for character in tank_temp_party:
                temp_party.append(character)
        if melee_temp_party != []:
            melee_temp_party = sorted(melee_temp_party)
            for character in melee_temp_party:
                temp_party.append(character)
        if magic_temp_party != []:
            magic_temp_party = sorted(magic_temp_party)
            for character in magic_temp_party:
                temp_party.append(character)
        if mixed_temp_party != []:
            mixed_temp_party = sorted(mixed_temp_party)
            for character in mixed_temp_party:
                temp_party.append(character)
        if healer_temp_party != []:
            healer_temp_party = sorted(healer_temp_party)
            for character in healer_temp_party:
                temp_party.append(character)
        visual_team_label.destroy()
        visual_team_label = tk.Label(self, text=self.display_team(temp_party))
        visual_team_label.grid(row=11, column=2)
#Asks the user if they want save the team they have made
    def confirm_new_team(self, temp_party):
        root = tk.Tk()
        confirmation_label = tk.Label(root, text="Are you sure you want save this group?")
        yes_buttonCNT = tk.Button(root, text="Yes", command=lambda: self.save_new_team(root, temp_party))
        no_buttonCNT = tk.Button(root, text="No", command=lambda: root.destroy())
        confirmation_label.grid(row=2, column=1)
        yes_buttonCNT.grid(row=3, column=1, sticky="w", padx=70)
        no_buttonCNT.grid(row=3, column=1, sticky="e", padx=70)
#Replaces the old team data tied with the users account inside the account_data_users with the new team data
    def save_new_team(self, root, temp_party):
        user = ParentClass.get_account_data(self, "encoded_username")
        user = str(user)
        emblems = ParentClass.get_account_data(self, "emblems")
        rank = ParentClass.get_account_data(self, "rank")
        i = -1
        file = open("C:/Users/{}/Documents/L2_ASSIGNMENT_RPG/Game_Data (DO NOT EDIT)/account_data_users.txt".format(COMPUTER_USERNAME),
                    "r")
        file_allLines = file.readlines()
        for line in file_allLines:
            i += 1
            if user in line:
                new_champion_list = self.code_party(temp_party)
                new_line = "{}, {}, {}, {}".format(user, new_champion_list, emblems, rank)
                file_allLines[i] = new_line
                file_write = open(
                    "C:/Users/{}/Documents/L2_ASSIGNMENT_RPG/Game_Data (DO NOT EDIT)/account_data_users.txt".format(COMPUTER_USERNAME),
                    "w")
                file_write.writelines(file_allLines)
                file.close()
                file_write.close()
                root.destroy()
                break
        ParentClass.show_frame(app, "CreateTeamPage")
#Takes the team list and changes the champions name to their code version. 
#Reason for this is so that the text_file data isn't huge due to the long names some champions have 
    def code_party(self, temp_party):
        coded_temp_party = ""
        i = 0
        for character in temp_party:
            if character == MONK.title:
                coded_temp_party += MONK.code
            if character == BARBARIAN.title:
                coded_temp_party += BARBARIAN.code
            if character == KINGS_GUARD.title:
                coded_temp_party += KINGS_GUARD.code
            if character == MASTER_FENCER.title:
                coded_temp_party += MASTER_FENCER.code
            if character == BERSERKER.title:
                coded_temp_party += BERSERKER.code
            if character == ROGUE.title:
                coded_temp_party += ROGUE.code
            if character == SURVIVALIST.title:
                coded_temp_party += SURVIVALIST.code
            if character == BRAWLIST.title:
                coded_temp_party += BRAWLIST.code
            if character == ACADEMIC_MAGE.title:
                coded_temp_party += ACADEMIC_MAGE.code
            if character == DRUID.title:
                coded_temp_party += DRUID.code
            if character == WARLOCK.title:
                coded_temp_party += WARLOCK.code
            if character == BLOODMANCER.title:
                coded_temp_party += BLOODMANCER.code
            if character == PALADIN.title:
                coded_temp_party += PALADIN.code
            if character == LEGION_RANGER.title:
                coded_temp_party += LEGION_RANGER.code
            if character == MAGNETIMANCER.title:
                coded_temp_party += MAGNETIMANCER.code
            if character == POWER_CONDUIT.title:
                coded_temp_party += POWER_CONDUIT.code
            if character == EARTH_SPEAKER.title:
                coded_temp_party += EARTH_SPEAKER.code
            if character == PRIEST.title:
                coded_temp_party += PRIEST.code
            if character == TIME_WALKER.title:
                coded_temp_party += TIME_WALKER.code
            if character == FIELD_MEDIC.title:
                coded_temp_party += FIELD_MEDIC.code
            i += 1
            if i <= 4:
                coded_temp_party += ":"
        if len(temp_party) < 5:
            while i < 5:
                coded_temp_party += "Empty"
                i += 1
                if i <= 4:
                    coded_temp_party += ":"
        return coded_temp_party

# 
class LeaderboardPage(tk.Frame):
    def __init__(self, parent, controller):
        tk.Frame.__init__(self, parent)
        self.controller = controller
        invis_label1 = tk.Label(self)
        invis_label2 = tk.Label(self)
        opener_label = tk.Label(self, text="Guildhall Leaderboards", font=controller.small_title_font)
        opener_button = tk.Button(self, text="Enter the Guildhall",
                           command=self.leaderboard_frame, font=controller.menu_button_font)
        invis_label1.grid(row=0, column=1, pady=25)
        opener_label.grid(row=1, column=1, sticky="nsew", pady=10)
        invis_label2.grid(row=2, column=1, pady=75)
        opener_button.grid(row=3 ,column=1)
    def leaderboard_frame():
        for widget in self.winfo_children():
            widget.destroy()
#Frame that is the last screen before the player begins the game.
#It's purpose is to let the player pick the difficulty they wish to play with the 'Select Dungeon Exedition' option and to confirm whether or not they're ready to start playing
class DungeonDelve(tk.Frame):
    def __init__(self, parent, controller):
        tk.Frame.__init__(self, parent)
        self.controller = controller
        label = tk.Label(self, text="Dungeon", font=controller.title_font)
        play_button = tk.Button(self, text="Enter the Dungeon", font=controller.menu_button_font,
                                command=self.team_check)
        dungeon_settings_button = tk.Button(self, text="Select Dungeon Exedition", font=controller.menu_button_font,
                                            command=lambda: controller.show_frame("DungeonExpeditions"))
        buttonReturn = tk.Button(self, text="Return to Menu", font=controller.menu_button_font,
                                 command=lambda: controller.show_frame("MainMenu"))
        invis_label1 = tk.Label(self)
        invis_label2 = tk.Label(self)
        label.grid(row=1, column=2, pady=20)
        play_button.grid(row=3, column=2, pady=2)
        dungeon_settings_button.grid(row=4, column=2, pady=2)
        buttonReturn.grid(row=6, column=2, pady=2)
        invis_label1.grid(row=1, column=1, padx=140)
        invis_label2.grid(row=2, column=2, pady=50)
#Checks to see if the current team list is full. If not, the user is denied entry to the dungeon
    def team_check(self):
        team_str = ParentClass.get_account_data(self, "champion_list")
        team_list_data = team_str.split(":")
        decoded_dungeoneer_team = CreateTeamPage.team_decode(self, team_list_data)
        if "Empty" in decoded_dungeoneer_team:
            root = tk.Tk()
            warning_label = tk.Label(root, text="You must have a full team before \nentering the dungeon")
            okButton = tk.Button(root, text="Ok", command=root.destroy)
            warning_label.grid(row=1, column=1)
            okButton.grid(row=3, column=1)
        else:
            self.enter_dungeon_confirmation()
#Pop-up window that asks the user if they are sure they want to begin playing the game with the current team on the current difficulty
    def enter_dungeon_confirmation(self):
        root = tk.Tk()
        team_str = ParentClass.get_account_data(self, "champion_list")
        team_list_data = team_str.split(":")
        decoded_dungeoneer_team = CreateTeamPage.team_decode(self, team_list_data)
        team_visual_str = self.display_team(decoded_dungeoneer_team)
        dungeon_name_text = ParentClass.get_dungeon_difficulty_data(self, "name")
        message_label = tk.Label(root, text=":Are you sure you want to delve into {} with:\n{}".format(dungeon_name_text, team_visual_str))
        yesButton = tk.Button(root, text="Yes",
                              command=lambda: self.set_dungeon_team(decoded_dungeoneer_team, root))
        noButton = tk.Button(root, text="No", command=root.destroy)
        message_label.grid(row=1, column=1)
        yesButton.grid(row=2, column=1, sticky="w", padx=100)
        noButton.grid(row=2, column=1, sticky="e", padx=100)
#Simply makes a string of the current team
    def display_team(self, decoded_dungeoneer_team):
        team_text = ""
        for character in decoded_dungeoneer_team:
            team_text += "["
            team_text += character
            team_text += "]"
            team_text += " "
        return team_text
#Writes the users current team into a file for later east use
    def set_dungeon_team(self, decoded_dungeoneer_team, root):
        current_team = open(
            "C:/Users/{}/Documents/L2_ASSIGNMENT_RPG/Game_Data (DO NOT EDIT)/game_data_dungeon_team.txt".format(COMPUTER_USERNAME), "w")
        current_team.write(str(decoded_dungeoneer_team))
        current_team.close()
        root.destroy()
        ParentClass.show_frame(app, "GameFrame")

#Frame where the player picks the difficulty of the dungeon they want to play
#Higher difficulties are locked behind the rank system so if they want to play the harder dungeons then they'll need to rise the ranks and gain emblems
class DungeonExpeditions(tk.Frame):
    def __init__(self, parent, controller):
        tk.Frame.__init__(self, parent)
        self.controller = controller
        self.smallish_text_font = tkfont.Font(size=12)
        self.smallish_text_font_bold = tkfont.Font(size=12, weight="bold")
        self.menu_button_font_bold = tkfont.Font(family='Helvetica', size=18, weight="bold")
        self.small_title_font_bold = tkfont.Font(family='Times New Roman Baltic', size=80, weight="bold")
        self.medium_text_font_bold = tkfont.Font(family='Times New Roman Baltic', size=50, weight="bold")
        self.lesser_text_font = tkfont.Font(family='Times New Roman Baltic', size=35)
        self.entering_expedition_board()
#Buffer screen so that when the player visits later on, information is updated correctly
    def entering_expedition_board(self):
        for widget in self.winfo_children():
            widget.destroy()
        dungeon_name_text = ParentClass.get_dungeon_difficulty_data(self, "name")
        title_label = tk.Label(self, text="Expedition Selection Hall", font=self.medium_text_font_bold)
        current_expedition_label = tk.Label(self, text="Current Dungeon Selected: {}".format(dungeon_name_text), font=self.lesser_text_font)
        enter_expedition_board_button = tk.Button(self, text="View Expeditions", command=self.expedition_board, font=self.lesser_text_font)
        invis_label1 = tk.Label(self)
        invis_label2 = tk.Label(self)
        invis_label3 = tk.Label(self)
        back_button = tk.Button(self, text="Back to Dungeon Entrance", command=lambda: ParentClass.show_frame(app, "DungeonDelve"), font=self.lesser_text_font)
        invis_label1.grid(row=0, column=0, padx=60, pady=15)
        title_label.grid(row=1, column=1)
        invis_label2.grid(row=2, column=1, pady=80)
        current_expedition_label.grid(row=3, column=1)
        enter_expedition_board_button.grid(row=4, column=1)
        invis_label3.grid(row=5, column=1, pady=60)
        back_button.grid(row=6, column=1)
#There are 7 difficulties are linked with the 7 ranks. If the player has the required emblems to access the difficulty, the button will enabled and say 'Available' next to the name
#If the player does not meet the required emblems, the button to enable the difficulty will be disabled and 
#instead of saying 'Available' it will tell the player how many more emblems they'll need to collect. Each difficulty has the base hp and attack that enemies will start off with when first entering
#the dungeon. Below the base stats, each difficulty also has the number that is connected with how the game gets harder.
    def expedition_board(self):
        for widget in self.winfo_children():
            widget.destroy()
        player_emblems = ParentClass.get_account_data(self, "emblems")
        if player_emblems < 20:
            silver_dungeon_text = "+{} needed".format(20 - player_emblems)
        else:
            silver_dungeon_text = "Available"
        if player_emblems < 40:
            gold_dungeon_text = "+{} needed".format(40 - player_emblems)
        else:
            gold_dungeon_text = "Available"
        if player_emblems < 60:
            steel_dungeon_text = "+{} needed".format(60 - player_emblems)
        else:
            steel_dungeon_text = "Available"
        if player_emblems < 800:
            diamond_dungeon_text = "+{} needed".format(80 - player_emblems)
        else:
            diamond_dungeon_text = "Available"
        if player_emblems < 100:
            ruby_dungeon_text = "+{} needed".format(100 - player_emblems)
        else:
            ruby_dungeon_text = "Available"
        if player_emblems < 120:
            obsidian_dungeon_text = "+{} needed".format(120 - player_emblems)
        else:
            obsidian_dungeon_text = "Available"
        title_label = tk.Label(self, text="Expeditions Board", font=self.small_title_font_bold)
        invis_label1 = tk.Label(self)
        invis_label2 = tk.Label(self)
        invis_label3 = tk.Label(self)
        bronze_dungeon_label = tk.Label(self, text="Bronze Guild (Available)", font=self.smallish_text_font_bold)
        bronze_dungeon_button = tk.Button(self, text=":The City Sewers:\n"
                                             "Base HP (1500) : Base ATK (250)\nHP Increase (50 per Room)\n"
                                             "ATK Increase (50 per Room)", font=self.smallish_text_font_bold,
                                    command=lambda: self.set_new_dungeon_difficulty("Bronze"))
        silver_dungeon_label = tk.Label(self, text="Silver Guild ({})".format(silver_dungeon_text), font=self.smallish_text_font_bold)
        silver_dungeon_button = tk.Button(self, text=":The Royal Catacombs:\n"
                                             "Base HP (1750) : Base ATK (275)\nHP Increase (75 per Room)\n"
                                             "ATK Increase (55 per Room)", font=self.smallish_text_font_bold,
                                    command=lambda: self.set_new_dungeon_difficulty("Silver"))
        gold_dungeon_label = tk.Label(self, text="Gold Guild ({})".format(gold_dungeon_text), font=self.smallish_text_font_bold)
        gold_dungeon_button = tk.Button(self, text=":The Forgotten Mines:\n"
                                             "Base HP (2000) : Base ATK (300)\nHP Increase (100 per Room)\n"
                                             "ATK Increase (60 per Room)", font=self.smallish_text_font_bold,
                                    command=lambda: self.set_new_dungeon_difficulty("Gold"))
        steel_dungeon_label = tk.Label(self, text="Steel Guild ({})".format(steel_dungeon_text), font=self.smallish_text_font_bold)
        steel_dungeon_button = tk.Button(self, text=":The Hissing Caverns:\n"
                                             "Base HP (2250) : Base ATK (325)\nHP Increase (125 per Room)\n"
                                             "ATK Increase (65 per Room)", font=self.smallish_text_font_bold,
                                    command=lambda: self.set_new_dungeon_difficulty("Steel"))
        diamond_dungeon_label = tk.Label(self, text="Diamond Guild ({})".format(diamond_dungeon_text), font=self.smallish_text_font_bold)
        diamond_dungeon_button = tk.Button(self, text=":The Deep Dark:\n"
                                             "Base HP (2500) : Base ATK (350)\nHP Increase (150 per Room)\n"
                                             "ATK Increase (70 per Room", font=self.smallish_text_font_bold,
                                    command=lambda: self.set_new_dungeon_difficulty("Diamond"))
        ruby_dungeon_label = tk.Label(self, text="Ruby Guild ({})".format(ruby_dungeon_text), font=self.smallish_text_font_bold)
        ruby_dungeon_button = tk.Button(self, text=":The Void Zone:\n"
                                             "Base HP (2750) : Base ATK (375)\nHP Increase (175 per Room)\n"
                                             "ATK Increase (75 per Room)", font=self.smallish_text_font_bold,
                                    command=lambda: self.set_new_dungeon_difficulty("Ruby"))
        obsidian_dungeon_label = tk.Label(self, text="Obsidian Guild ({})".format(obsidian_dungeon_text), font=self.smallish_text_font_bold)
        obsidian_dungeon_button = tk.Button(self, text=":The Abyss:\n"
                                             "Base HP (3000) : Base ATK (400)\nHP Increase (175 per Room)\n"
                                             "ATK Increase (80 per Room)", font=self.smallish_text_font_bold,
                                    command=lambda: self.set_new_dungeon_difficulty("Obsidian"))
        
        buttonReturn = tk.Button(self, text="Back", font=self.menu_button_font_bold,
                                 command=self.entering_expedition_board)
        title_label.grid(row=1, column=1)
        invis_label1.grid(row=0, column=0, padx=75)
        invis_label2.grid(row=2, column=1, pady=20)
        bronze_dungeon_label.grid(row=3, column=1, sticky="w", padx=33)
        bronze_dungeon_button.grid(row=4, column=1, sticky="w")
        silver_dungeon_label.grid(row=3, column=1)
        silver_dungeon_button.grid(row=4, column=1)
        gold_dungeon_label.grid(row=3, column=1, sticky="e", padx=33)
        gold_dungeon_button.grid(row=4, column=1, sticky="e")
        steel_dungeon_label.grid(row=5, column=1, sticky="w", padx=33)
        steel_dungeon_button.grid(row=6, column=1, sticky="w")
        diamond_dungeon_label.grid(row=5, column=1)
        diamond_dungeon_button.grid(row=6, column=1)
        ruby_dungeon_label.grid(row=5, column=1, sticky="e", padx=33)
        ruby_dungeon_button.grid(row=6, column=1, sticky="e")
        obsidian_dungeon_label.grid(row=7, column=1)
        obsidian_dungeon_button.grid(row=8, column=1)
        invis_label3.grid(row=9, column=1, pady=25)
        buttonReturn.grid(row=10, column=1)
        if player_emblems < float(120):
            obsidian_dungeon_button["state"] = "disabled"
        if player_emblems < float(100):
            ruby_dungeon_button["state"] = "disabled"
        if player_emblems < float(80):
            diamond_dungeon_button["state"] = "disabled"
        if player_emblems < float(60):
            steel_dungeon_button["state"] = "disabled"
        if player_emblems < float(40):
            gold_dungeon_button["state"] = "disabled"
        if player_emblems < float(20):
            silver_dungeon_button["state"] = "disabled"
#When the player pushes a difficulty button to enable it, a textfile is updated with the current difficulty.
#This is so that all the text and data that requires to know what difficulty it is, can easily look into this file.
#This method reduces the amount of parameters needed or the use of global statements to run the program
    def set_new_dungeon_difficulty(self, difficulty):
        if difficulty == "Bronze":
            dungeon_difficulty_file = open(
                "C:/Users/{}/Documents/L2_ASSIGNMENT_RPG/Game_Data (DO NOT EDIT)/game_data_dungeon_difficulty.txt".format(COMPUTER_USERNAME),
                "w")
            dungeon_difficulty_file.write("Bronze")
            dungeon_difficulty_file.close()
        elif difficulty == "Silver":
            dungeon_difficulty_file = open(
                "C:/Users/{}/Documents/L2_ASSIGNMENT_RPG/Game_Data (DO NOT EDIT)/game_data_dungeon_difficulty.txt".format(COMPUTER_USERNAME),
                "w")
            dungeon_difficulty_file.write("Silver")
            dungeon_difficulty_file.close()
        elif difficulty == "Gold":
            dungeon_difficulty_file = open(
                "C:/Users/{}/Documents/L2_ASSIGNMENT_RPG/Game_Data (DO NOT EDIT)/game_data_dungeon_difficulty.txt".format(COMPUTER_USERNAME),
                "w")
            dungeon_difficulty_file.write("Gold")
            dungeon_difficulty_file.close()
        elif difficulty == "Steel":
            dungeon_difficulty_file = open(
                "C:/Users/{}/Documents/L2_ASSIGNMENT_RPG/Game_Data (DO NOT EDIT)/game_data_dungeon_difficulty.txt".format(COMPUTER_USERNAME),
                "w")
            dungeon_difficulty_file.write("Steel")
            dungeon_difficulty_file.close()
        elif difficulty == "Diamond":
            dungeon_difficulty_file = open(
                "C:/Users/{}/Documents/L2_ASSIGNMENT_RPG/Game_Data (DO NOT EDIT)/game_data_dungeon_difficulty.txt".format(COMPUTER_USERNAME),
                "w")
            dungeon_difficulty_file.write("Diamond")
            dungeon_difficulty_file.close()
        elif difficulty == "Ruby":
            dungeon_difficulty_file = open(
                "C:/Users/{}/Documents/L2_ASSIGNMENT_RPG/Game_Data (DO NOT EDIT)/game_data_dungeon_difficulty.txt".format(COMPUTER_USERNAME),
                "w")
            dungeon_difficulty_file.write("Ruby")
            dungeon_difficulty_file.close()
        elif difficulty == "Obsidian":
            dungeon_difficulty_file = open(
                "C:/Users/{}/Documents/L2_ASSIGNMENT_RPG/Game_Data (DO NOT EDIT)/game_data_dungeon_difficulty.txt".format(COMPUTER_USERNAME),
                "w")
            dungeon_difficulty_file.write("Obsidian")
            dungeon_difficulty_file.close()
#Each difficulties modifiers and numbers tied to it is stored in their respective function. 
#When the game finds what difficulty it is, it can easily call the function that returns all of that difficulties respective values.
    def get_bronze_dungeon_modifiers(self):
        HEALTH_BASE = 1500
        ATTACKPOWER_BASE = 250
        HEALTH_MODIFIER = 50
        ATTACKPOWER_MODIFIER = 50
        BRONZE_DUNGEON_MODIFIERS = []
        BRONZE_DUNGEON_MODIFIERS.append(HEALTH_BASE)
        BRONZE_DUNGEON_MODIFIERS.append(ATTACKPOWER_BASE)
        BRONZE_DUNGEON_MODIFIERS.append(HEALTH_MODIFIER)
        BRONZE_DUNGEON_MODIFIERS.append(ATTACKPOWER_MODIFIER)
        return BRONZE_DUNGEON_MODIFIERS
    def get_silver_dungeon_modifiers(self):
        HEALTH_BASE = 1750
        ATTACKPOWER_BASE = 275
        HEALTH_MODIFIER = 75
        ATTACKPOWER_MODIFIER = 55
        SILVER_DUNGEON_MODIFIERS = []
        SILVER_DUNGEON_MODIFIERS.append(HEALTH_BASE)
        SILVER_DUNGEON_MODIFIERS.append(ATTACKPOWER_BASE)
        SILVER_DUNGEON_MODIFIERS.append(HEALTH_MODIFIER)
        SILVER_DUNGEON_MODIFIERS.append(ATTACKPOWER_MODIFIER)
        return SILVER_DUNGEON_MODIFIERS
    def get_gold_dungeon_modifiers(self):
        HEALTH_BASE = 2000
        ATTACKPOWER_BASE = 300
        HEALTH_MODIFIER = 100
        ATTACKPOWER_MODIFIER = 60
        GOLD_DUNGEON_MODIFIERS = []
        GOLD_DUNGEON_MODIFIERS.append(HEALTH_BASE)
        GOLD_DUNGEON_MODIFIERS.append(ATTACKPOWER_BASE)
        GOLD_DUNGEON_MODIFIERS.append(HEALTH_MODIFIER)
        GOLD_DUNGEON_MODIFIERS.append(ATTACKPOWER_MODIFIER)
        return GOLD_DUNGEON_MODIFIERS
    def get_steel_dungeon_modifiers(self):
        HEALTH_BASE = 2250
        ATTACKPOWER_BASE = 325
        HEALTH_MODIFIER = 125
        ATTACKPOWER_MODIFIER = 65
        STEEL_DUNGEON_MODIFIERS = []
        STEEL_DUNGEON_MODIFIERS.append(HEALTH_BASE)
        STEEL_DUNGEON_MODIFIERS.append(ATTACKPOWER_BASE)
        STEEL_DUNGEON_MODIFIERS.append(HEALTH_MODIFIER)
        STEEL_DUNGEON_MODIFIERS.append(ATTACKPOWER_MODIFIER)
        return STEEL_DUNGEON_MODIFIERS
    def get_diamond_dungeon_modifiers(self):
        HEALTH_BASE = 2500
        ATTACKPOWER_BASE = 350
        HEALTH_MODIFIER = 150
        ATTACKPOWER_MODIFIER = 70
        DIAMOND_DUNGEON_MODIFIERS = []
        DIAMOND_DUNGEON_MODIFIERS.append(HEALTH_BASE)
        DIAMOND_DUNGEON_MODIFIERS.append(ATTACKPOWER_BASE)
        DIAMOND_DUNGEON_MODIFIERS.append(HEALTH_MODIFIER)
        DIAMOND_DUNGEON_MODIFIERS.append(ATTACKPOWER_MODIFIER)
        return DIAMOND_DUNGEON_MODIFIERS
    def get_ruby_dungeon_modifiers(self):
        HEALTH_BASE = 2750
        ATTACKPOWER_BASE = 375
        HEALTH_MODIFIER = 175
        ATTACKPOWER_MODIFIER = 75
        RUBY_DUNGEON_MODIFIERS = []
        RUBY_DUNGEON_MODIFIERS.append(HEALTH_BASE)
        RUBY_DUNGEON_MODIFIERS.append(ATTACKPOWER_BASE)
        RUBY_DUNGEON_MODIFIERS.append(HEALTH_MODIFIER)
        RUBY_DUNGEON_MODIFIERS.append(ATTACKPOWER_MODIFIER)
        return RUBY_DUNGEON_MODIFIERS
    def get_obsidian_dungeon_modifiers(self):
        HEALTH_BASE = 3000
        ATTACKPOWER_BASE = 400
        HEALTH_MODIFIER = 200
        ATTACKPOWER_MODIFIER = 80
        OBSIDIAN_DUNGEON_MODIFIERS = []
        OBSIDIAN_DUNGEON_MODIFIERS.append(HEALTH_BASE)
        OBSIDIAN_DUNGEON_MODIFIERS.append(ATTACKPOWER_BASE)
        OBSIDIAN_DUNGEON_MODIFIERS.append(HEALTH_MODIFIER)
        OBSIDIAN_DUNGEON_MODIFIERS.append(ATTACKPOWER_MODIFIER)
        return OBSIDIAN_DUNGEON_MODIFIERS

#Main Frame for the game. All gameplay is contained within this class
class GameFrame(tk.Frame):
    def __init__(self, parent, controller):
        tk.Frame.__init__(self, parent)
        for widget in self.winfo_children():
            widget.destroy()
        self.controller = controller
        self.title_font = tkfont.Font(family='Times New Roman Baltic', size=120, weight="bold")
        self.small_title_font = tkfont.Font(family='Times New Roman Baltic', size=80, weight="bold")
        self.medium_text_font_bold = tkfont.Font(family='Times New Roman Baltic', size=50, weight="bold")
        self.lesser_text_font_bold = tkfont.Font(family='Times New Roman Baltic', size=35, weight="bold")
        self.menu_button_font = tkfont.Font(family='Helvetica', size=18, weight="bold")
        self.small_text_font = tkfont.Font(family='Times New Roman Baltic', size=20)
        self.small_text_font_bold = tkfont.Font(family='Times New Roman Baltic', size=20, weight="bold")
        start_invis_label1 = tk.Label(self)
        start_ok_button = tk.Button(self, text="Accept", font=controller.medium_text_font_bold, command=self.begin_dungeon_run)
        remember_label = tk.Label(self, text=":REMEMBER:", font=controller.medium_text_font_bold)
        beginning_label = tk.Label(self, text="You cannot save your progress\nYou must complete the run in this current application",
                                   font=self.small_text_font_bold)
        start_ok_button.grid(row=3, column=1)
        remember_label.grid(row=1, column=1)
        beginning_label.grid(row=2, column=1)
        start_invis_label1.grid(row=0, column=0, padx=145, pady=80)
#Gets the dungeon properties from the text file database and asks the user if they want to begin playing or to leave to the Main Menu
    def begin_dungeon_run(self):
        for widget in self.winfo_children():
            widget.destroy()
        dungeon_difficulty_text = ParentClass.get_dungeon_difficulty_data(self, "difficulty")
        dungeon_name_text = ParentClass.get_dungeon_difficulty_data(self, "name")
        dungeon_name_label = tk.Label(self, text=dungeon_name_text, font=self.medium_text_font_bold)
        delve_button = tk.Button(self, text="Delve into the Dungeon (Begin Game)", font=self.lesser_text_font_bold,
                                command=lambda: self.set_dungeon_properties(dungeon_difficulty_text))
        main_menu_button = tk.Button(self, text="Leave (Main Menu)", font=self.lesser_text_font_bold,
                                command=lambda: ParentClass.show_frame(app, "MainMenu"))
        BDRinvisLabel1 = tk.Label(self)
        dungeon_name_label.grid(row=1, column=1)
        BDRinvisLabel1.grid(row=2, column=0, padx=100, pady=175)
        delve_button.grid(row=3, column=1)
        main_menu_button.grid(row=4, column=1)
#Sets the dungeons difficulty, floor and room levels
#Also calls all of the functions that set the champions variables before opening the main precombat frame
    def set_dungeon_properties(self, dungeon_settings):
        global AI_MODIFERS, dungeon_floor_frame, dungeon_game_frame, from_combat, room_level, floor_level
        if dungeon_settings == "Bronze":
            AI_MODIFERS = DungeonExpeditions.get_bronze_dungeon_modifiers(self)
        elif dungeon_settings == "Silver":
            AI_MODIFERS = DungeonExpeditions.get_silver_dungeon_modifiers(self)
        elif dungeon_settings == "Gold":
            AI_MODIFERS = DungeonExpeditions.get_gold_dungeon_modifiers(self)
        elif dungeon_settings == "Steel":
            AI_MODIFERS = DungeonExpeditions.get_steel_dungeon_modifiers(self)
        elif dungeon_settings == "Diamond":
            AI_MODIFERS = DungeonExpeditions.get_diamond_dungeon_modifiers(self)
        elif dungeon_settings == "Ruby":
            AI_MODIFERS = DungeonExpeditions.get_ruby_dungeon_modifiers(self)
        elif dungeon_settings == "Obsidian":
            AI_MODIFERS = DungeonExpeditions.get_obsidian_dungeon_modifiers(self)
        room_level = 1
        floor_level = 0
        entry_status = ""
        for widget in self.winfo_children():
            widget.destroy()
        dungeon_floor_frame = tk.Frame(self)
        dungeon_floor_frame.grid(row=0, column=0, sticky="NSEW")
        dungeon_game_frame = tk.Frame(dungeon_floor_frame)
        dungeon_game_frame.grid(row=3, column=0, sticky="NSEW")
        from_combat = 0
        self.dungeon_LabelFrame = tk.LabelFrame()
        self.dungeon_LabelFrame.grid(row=0, column=0)
        self.get_individual_champions()
        self.set_champions_stats()
        self.set_adjustable_champion_stats()
        self.DungeonFloorProgress(entry_status)
#Puts all champions in the users team into the CHAMPION_LIST base list 
    def get_individual_champions(self):
        global CHAMPION_LIST
        team = ParentClass.get_account_data(self, "champion_list")
        dungeon_team = list(team.split(":"))
        decoded_dungeon_team = CreateTeamPage.team_decode(self, dungeon_team)
        counter = 1
        CHAMPION_LIST = []
        for character in decoded_dungeon_team:
            if character == MONK.title:
                CHAMPION_LIST.insert(counter, character)
            if character == BARBARIAN.title:
                CHAMPION_LIST.insert(counter, character)
            if character == KINGS_GUARD.title:
                CHAMPION_LIST.insert(counter, character)
            if character == MASTER_FENCER.title:
                CHAMPION_LIST.insert(counter, character)
            if character == BERSERKER.title:
                CHAMPION_LIST.insert(counter, character)
            if character == ROGUE.title:
                CHAMPION_LIST.insert(counter, character)
            if character == SURVIVALIST.title:
                CHAMPION_LIST.insert(counter, character)
            if character == BRAWLIST.title:
                CHAMPION_LIST.insert(counter, character)
            if character == ACADEMIC_MAGE.title:
                CHAMPION_LIST.insert(counter, character)
            if character == DRUID.title:
                CHAMPION_LIST.insert(counter, character)
            if character == WARLOCK.title:
                CHAMPION_LIST.insert(counter, character)
            if character == BLOODMANCER.title:
                CHAMPION_LIST.insert(counter, character)
            if character == PALADIN.title:
                CHAMPION_LIST.insert(counter, character)
            if character == LEGION_RANGER.title:
                CHAMPION_LIST.insert(counter, character)
            if character == MAGNETIMANCER.title:
                CHAMPION_LIST.insert(counter, character)
            if character == POWER_CONDUIT.title:
                CHAMPION_LIST.insert(counter, character)
            if character == EARTH_SPEAKER.title:
                CHAMPION_LIST.insert(counter, character)
            if character == PRIEST.title:
                CHAMPION_LIST.insert(counter, character)
            if character == TIME_WALKER.title:
                CHAMPION_LIST.insert(counter, character)
            if character == FIELD_MEDIC.title:
                CHAMPION_LIST.insert(counter, character)
            counter += 1
#Sets the base numbered champion variables to the champions in CHAMPION_LIST
    def set_champions_stats(self):
        global CHAMPION1_HP, CHAMPION1_RP, CHAMPION1_AP, CHAMPION1_RPNAME, CHAMPION2_HP, CHAMPION2_RP, CHAMPION2_AP, CHAMPION2_RPNAME, CHAMPION3_HP, CHAMPION3_RP, CHAMPION3_AP, \
            CHAMPION3_RPNAME, CHAMPION4_HP, CHAMPION4_RP, CHAMPION4_AP, CHAMPION4_RPNAME, CHAMPION5_HP, CHAMPION5_RP, CHAMPION5_AP, CHAMPION5_RPNAME, CHAMPION1_ATTACKLIST, CHAMPION1_SPECIALLIST \
            , CHAMPION2_ATTACKLIST, CHAMPION2_SPECIALLIST, CHAMPION3_ATTACKLIST, CHAMPION3_SPECIALLIST, CHAMPION4_ATTACKLIST, CHAMPION4_SPECIALLIST, CHAMPION5_ATTACKLIST, CHAMPION5_SPECIALLIST
        counter = 1
        champion_hp_list = []
        champion_rp_list = []
        champion_ap_list = []
        champion_rpName_list = []
        champion_attack_list = ""
        champion_specials_list = ""
        for character in CHAMPION_LIST:
            if character == MONK.title:
                champion_hp_list.append(MONK.hp)
                champion_rp_list.append(MONK.rp)
                champion_ap_list.append(MONK.ap)
                champion_rpName_list.append(MONK.rp_name)
                champion_attack_list = MONK.attack_list
                champion_specials_list = MONK.specials_list
            elif character == BARBARIAN.title:
                champion_hp_list.append(BARBARIAN.hp)
                champion_rp_list.append(BARBARIAN.rp)
                champion_ap_list.append(BARBARIAN.ap)
                champion_rpName_list.append(BARBARIAN.rp_name)
                champion_attack_list = BARBARIAN.attack_list
                champion_specials_list = BARBARIAN.specials_list
            elif character == KINGS_GUARD.title:
                champion_hp_list.append(KINGS_GUARD.hp)
                champion_rp_list.append(KINGS_GUARD.rp)
                champion_ap_list.append(KINGS_GUARD.ap)
                champion_rpName_list.append(KINGS_GUARD.rp_name)
                champion_attack_list = KINGS_GUARD.attack_list
                champion_specials_list = KINGS_GUARD.specials_list
            elif character == MASTER_FENCER.title:
                champion_hp_list.append(MASTER_FENCER.hp)
                champion_rp_list.append(MASTER_FENCER.rp)
                champion_ap_list.append(MASTER_FENCER.ap)
                champion_rpName_list.append(MASTER_FENCER.rp_name)
                champion_attack_list = MASTER_FENCER.attack_list
                champion_specials_list = MASTER_FENCER.specials_list
            elif character == BERSERKER.title:
                champion_hp_list.append(BERSERKER.hp)
                champion_rp_list.append(BERSERKER.rp)
                champion_ap_list.append(BERSERKER.ap)
                champion_rpName_list.append(BERSERKER.rp_name)
                champion_attack_list = BERSERKER.attack_list
                champion_specials_list = BERSERKER.specials_list
            elif character == ROGUE.title:
                champion_hp_list.append(ROGUE.hp)
                champion_rp_list.append(ROGUE.rp)
                champion_ap_list.append(ROGUE.ap)
                champion_rpName_list.append(ROGUE.rp_name)
                champion_attack_list = ROGUE.attack_list
                champion_specials_list = ROGUE.specials_list
            elif character == SURVIVALIST.title:
                champion_hp_list.append(SURVIVALIST.hp)
                champion_rp_list.append(SURVIVALIST.rp)
                champion_ap_list.append(SURVIVALIST.ap)
                champion_rpName_list.append(SURVIVALIST.rp_name)
                champion_attack_list = SURVIVALIST.attack_list
                champion_specials_list = SURVIVALIST.specials_list
            elif character == BRAWLIST.title:
                champion_hp_list.append(BRAWLIST.hp)
                champion_rp_list.append(BRAWLIST.rp)
                champion_ap_list.append(BRAWLIST.ap)
                champion_rpName_list.append(BRAWLIST.rp_name)
                champion_attack_list = BRAWLIST.attack_list
                champion_specials_list = BRAWLIST.specials_list
            elif character == ACADEMIC_MAGE.title:
                champion_hp_list.append(ACADEMIC_MAGE.hp)
                champion_rp_list.append(ACADEMIC_MAGE.rp)
                champion_ap_list.append(ACADEMIC_MAGE.ap)
                champion_rpName_list.append(ACADEMIC_MAGE.rp_name)
                champion_attack_list = ACADEMIC_MAGE.attack_list
                champion_specials_list = ACADEMIC_MAGE.specials_list
            elif character == DRUID.title:
                champion_hp_list.append(DRUID.hp)
                champion_rp_list.append(DRUID.rp)
                champion_ap_list.append(DRUID.ap)
                champion_rpName_list.append(DRUID.rp_name)
                champion_attack_list = DRUID.attack_list
                champion_specials_list = DRUID.specials_list
            elif character == WARLOCK.title:
                champion_hp_list.append(WARLOCK.hp)
                champion_rp_list.append(WARLOCK.rp)
                champion_ap_list.append(WARLOCK.ap)
                champion_rpName_list.append(WARLOCK.rp_name)
                champion_attack_list = WARLOCK.attack_list
                champion_specials_list = WARLOCK.specials_list
            elif character == BLOODMANCER.title:
                champion_hp_list.append(BLOODMANCER.hp)
                champion_rp_list.append(BLOODMANCER.rp)
                champion_ap_list.append(BLOODMANCER.ap)
                champion_rpName_list.append(BLOODMANCER.rp_name)
                champion_attack_list = BLOODMANCER.attack_list
                champion_specials_list = BLOODMANCER.specials_list
            elif character == PALADIN.title:
                champion_hp_list.append(PALADIN.hp)
                champion_rp_list.append(PALADIN.rp)
                champion_ap_list.append(PALADIN.ap)
                champion_rpName_list.append(PALADIN.rp_name)
                champion_attack_list = PALADIN.attack_list
                champion_specials_list = PALADIN.specials_list
            elif character == LEGION_RANGER.title:
                champion_hp_list.append(LEGION_RANGER.hp)
                champion_rp_list.append(LEGION_RANGER.rp)
                champion_ap_list.append(LEGION_RANGER.ap)
                champion_rpName_list.append(LEGION_RANGER.rp_name)
                champion_attack_list = LEGION_RANGER.attack_list
                champion_specials_list = LEGION_RANGER.specials_list
            elif character == MAGNETIMANCER.title:
                champion_hp_list.append(MAGNETIMANCER.hp)
                champion_rp_list.append(MAGNETIMANCER.rp)
                champion_ap_list.append(MAGNETIMANCER.ap)
                champion_rpName_list.append(MAGNETIMANCER.rp_name)
                champion_attack_list = MAGNETIMANCER.attack_list
                champion_specials_list = MAGNETIMANCER.specials_list
            elif character == POWER_CONDUIT.title:
                champion_hp_list.append(POWER_CONDUIT.hp)
                champion_rp_list.append(POWER_CONDUIT.rp)
                champion_ap_list.append(POWER_CONDUIT.ap)
                champion_rpName_list.append(POWER_CONDUIT.rp_name)
                champion_attack_list = POWER_CONDUIT.attack_list
                champion_specials_list = POWER_CONDUIT.specials_list
            elif character == EARTH_SPEAKER.title:
                champion_hp_list.append(EARTH_SPEAKER.hp)
                champion_rp_list.append(EARTH_SPEAKER.rp)
                champion_ap_list.append(EARTH_SPEAKER.ap)
                champion_rpName_list.append(EARTH_SPEAKER.rp_name)
                champion_attack_list = EARTH_SPEAKER.attack_list
                champion_specials_list = EARTH_SPEAKER.specials_list
            elif character == PRIEST.title:
                champion_hp_list.append(PRIEST.hp)
                champion_rp_list.append(PRIEST.rp)
                champion_ap_list.append(PRIEST.ap)
                champion_rpName_list.append(PRIEST.rp_name)
                champion_attack_list = PRIEST.attack_list
                champion_specials_list = PRIEST.specials_list
            elif character == TIME_WALKER.title:
                champion_hp_list.append(TIME_WALKER.hp)
                champion_rp_list.append(TIME_WALKER.rp)
                champion_ap_list.append(TIME_WALKER.ap)
                champion_rpName_list.append(TIME_WALKER.rp_name)
                champion_attack_list = TIME_WALKER.attack_list
                champion_specials_list = TIME_WALKER.specials_list
            elif character == FIELD_MEDIC.title:
                champion_hp_list.append(FIELD_MEDIC.hp)
                champion_rp_list.append(FIELD_MEDIC.rp)
                champion_ap_list.append(FIELD_MEDIC.ap)
                champion_rpName_list.append(FIELD_MEDIC.rp_name)
                champion_attack_list = FIELD_MEDIC.attack_list
                champion_specials_list = FIELD_MEDIC.specials_list
            if counter == 1:
                CHAMPION1_HP = champion_hp_list[0]
                CHAMPION1_RP = champion_rp_list[0]
                CHAMPION1_AP = champion_ap_list[0]
                CHAMPION1_RPNAME = champion_rpName_list[0]
                CHAMPION1_ATTACKLIST = champion_attack_list
                CHAMPION1_SPECIALLIST = champion_specials_list
                champion_hp_list = []
                champion_rp_list = []
                champion_ap_list = []
                champion_rpName_list = []
                champion_attack_list = ""
                champion_specials_list = ""
            elif counter == 2:
                CHAMPION2_HP = champion_hp_list[0]
                CHAMPION2_RP = champion_rp_list[0]
                CHAMPION2_AP = champion_ap_list[0]
                CHAMPION2_RPNAME = champion_rpName_list[0]
                CHAMPION2_ATTACKLIST = champion_attack_list
                CHAMPION2_SPECIALLIST = champion_specials_list
                champion_hp_list = []
                champion_rp_list = []
                champion_ap_list = []
                champion_rpName_list = []
                champion_attack_list = ""
                champion_specials_list = ""
            elif counter == 3:
                CHAMPION3_HP = champion_hp_list[0]
                CHAMPION3_RP = champion_rp_list[0]
                CHAMPION3_AP = champion_ap_list[0]
                CHAMPION3_RPNAME = champion_rpName_list[0]
                CHAMPION3_ATTACKLIST = champion_attack_list
                CHAMPION3_SPECIALLIST = champion_specials_list
                champion_hp_list = []
                champion_rp_list = []
                champion_ap_list = []
                champion_rpName_list = []
                champion_attack_list = ""
                champion_specials_list = ""
            elif counter == 4:
                CHAMPION4_HP = champion_hp_list[0]
                CHAMPION4_RP = champion_rp_list[0]
                CHAMPION4_AP = champion_ap_list[0]
                CHAMPION4_RPNAME = champion_rpName_list[0]
                CHAMPION4_ATTACKLIST = champion_attack_list
                CHAMPION4_SPECIALLIST = champion_specials_list
                champion_hp_list = []
                champion_rp_list = []
                champion_ap_list = []
                champion_rpName_list = []
                champion_attack_list = ""
                champion_specials_list = ""
            elif counter == 5:
                CHAMPION5_HP = champion_hp_list[0]
                CHAMPION5_RP = champion_rp_list[0]
                CHAMPION5_AP = champion_ap_list[0]
                CHAMPION5_RPNAME = champion_rpName_list[0]
                CHAMPION5_ATTACKLIST = champion_attack_list
                CHAMPION5_SPECIALLIST = champion_specials_list
                champion_hp_list = []
                champion_rp_list = []
                champion_ap_list = []
                champion_rpName_list = []
                champion_attack_list = ""
                champion_specials_list = ""
            counter += 1
#Sets the adjustable variables to the base ones for later change during gameplay
    def set_adjustable_champion_stats(self):
        global champion1_hp, champion1_ap, champion1_rp, champion1_rpName, champion2_hp, champion2_ap, champion2_rp, champion2_rpName, \
            champion3_hp, champion3_ap, champion3_rp, champion3_rpName, champion4_hp, champion4_ap, champion4_rp, champion4_rpName, \
            champion5_hp, champion5_ap, champion5_rp, champion5_rpName, \
            champion2_small_external_buffs, champion2_big_external_buffs, champion3_small_external_buffs, champion3_big_external_buffs, \
            champion4_small_external_buffs, champion4_big_external_buffs, champion5_small_external_buffs, champion5_big_external_buffs, \
            legion_ranger_roundtracker, paladin_roundtracker
        champion1_hp = CHAMPION1_HP
        champion1_ap = CHAMPION1_AP
        legion_ranger_roundtracker = 0
        paladin_roundtracker = 0
        if CHAMPION1_RPNAME == "Mana":
            champion1_rp = CHAMPION1_RP
        else:
            champion1_rp = 0
        champion1_rpName = CHAMPION1_RPNAME
        champion2_hp = CHAMPION2_HP
        champion2_ap = CHAMPION2_AP
        if CHAMPION2_RPNAME == "Mana":
            champion2_rp = CHAMPION2_RP
        else:
            champion2_rp = 0
        champion2_rpName = CHAMPION2_RPNAME
        champion2_small_external_buffs = [0]
        champion2_big_external_buffs = [0]
        champion3_hp = CHAMPION3_HP
        champion3_ap = CHAMPION3_AP
        if CHAMPION3_RPNAME == "Mana":
            champion3_rp = CHAMPION3_RP
        else:
            champion3_rp = 0
        champion3_rpName = CHAMPION3_RPNAME
        champion3_small_external_buffs = [0]
        champion3_big_external_buffs = [0]
        champion4_hp = CHAMPION4_HP
        champion4_ap = CHAMPION4_AP
        if CHAMPION4_RPNAME == "Mana":
            champion4_rp = CHAMPION4_RP
        else:
            champion4_rp = 0
        champion4_rpName = CHAMPION4_RPNAME
        champion4_small_external_buffs = [0]
        champion4_big_external_buffs = [0]
        champion5_hp = CHAMPION5_HP
        champion5_ap = CHAMPION5_AP
        if CHAMPION5_RPNAME == "Mana":
            champion5_rp = CHAMPION5_RP
        else:
            champion5_rp = 0
        champion5_rpName = CHAMPION5_RPNAME
        champion5_small_external_buffs = [0]
        champion5_big_external_buffs = [0]
        global champion1_immunity, champion2_immunity, champion3_immunity, champion4_immunity, champion5_immunity, \
            champion1_statuses, champion2_statuses, champion3_statuses, champion4_statuses, champion5_statuses
        champion1_immunity = []
        champion2_immunity = []
        champion3_immunity = []
        champion4_immunity = []
        champion5_immunity = []
        champion1_statuses = []
        champion1_statuses = []
        champion2_statuses = []
        champion3_statuses = []
        champion4_statuses = []
        champion5_statuses = []
        if PALADIN.title in CHAMPION_LIST:
            champion1_statuses.append("Power Aura")
            champion2_statuses.append("Power Aura")
            champion3_statuses.append("Power Aura")
            champion4_statuses.append("Power Aura")
            champion5_statuses.append("Power Aura")
        if TIME_WALKER.title in CHAMPION_LIST:
            champion1_statuses.append("Nano-repair Bots")
            champion2_statuses.append("Nano-repair Bots")
            champion3_statuses.append("Nano-repair Bots")
            champion4_statuses.append("Nano-repair Bots")
            champion5_statuses.append("Nano-repair Bots")
        self.set_champion_abilities_default
#Function that sets the default variables for all the champions abilities and buffs
    def set_champion_abilities_default(self):
        global palm_strike_requirements, leg_sweep_requirements, harmonize_requirements, pressure_points_requirements, \
            monk_bauble_damage_list1, monk_bauble_damage_list2, monk_bauble_damage_list3, \
            bloodthirst_requirements, pulverize_requirements, challenging_shout_requirements, impactful_boast_requirements, \
            shield_bash_requirements, trainwreck_requirements, fortification_requirements, block_requirements, \
            champion1_fortification, champion2_fortification, champion3_fortification, champion4_fortification, champion5_fortification, \
            flanking_strikes_requirements, riposte_requirements, magic_reflection_requirements, evasive_manoeuvres_requirements
        #Ability Requirement Position: [0, 1, 2, 3] 
        #0 represents the cost of the ability
        #1 represents the amount of resource the ability grants
        #2 represents the cooldown the ability goes on when used
        #3 represents the storage of the cooldown (when activated, this value is changed to the value at #2 and will tick down 1 per turn, the abiltiy is usable again once it reaches 0)
        #Monk Abilities:
        palm_strike_requirements = [0, 20, 0, 0]
        leg_sweep_requirements = [30, 0, 3, 0]
        harmonize_requirements = [50, 0, 0, 0]
        pressure_points_requirements = [30, 0, 6, 0]
        monk_bauble_damage_list1 = [0, 0]
        monk_bauble_damage_list2 = [0, 0]
        monk_bauble_damage_list3 = [0, 0]
        #Barbarian abilities:
        bloodthirst_requirements = [0, 30, 0, 0]
        pulverize_requirements = [20, 0, 0, 0]
        challenging_shout_requirements = [40, 20, 3, 0]
        impactful_boast_requirements = [20, 0, 0, 0]
        #Kings-Guard Abilities:
        shield_bash_requirements = [0, 0, 0, 0]
        trainwreck_requirements = [0, 0, 2, 0]
        fortification_requirements = [0, 0, 3, 0]
        block_requirements = [0, 0, 0, 0]
        champion1_fortification = 0
        champion2_fortification = 0
        champion3_fortification = 0
        champion4_fortification = 0
        champion5_fortification = 0
        #Master Fencer Abilities
        flanking_strikes_requirements = [0, 0, 0, 0]
        riposte_requirements = [0, 0, 2, 0]
        magic_reflection_requirements = [0, 0, 3, 0]
        evasive_manoeuvres_requirements = [0, 0, 3, 0]
        global angering_strike_requirements, unbridled_rampage_requirements, pure_rage_requirements, reckless_flurry_requirements, \
            champion1_pure_rage, champion2_pure_rage, champion3_pure_rage, champion4_pure_rage, champion5_pure_rage, reckless_flurry_buff, \
            serrated_slash_requirements, eviscerate_requirements, garrote_requirements, exploit_weakness_requirements, \
            spear_thrust_requirements, scrap_bomb_requirements, play_dead_requirements, survival_kit_requirements, prepare_buff, \
            champion1_play_dead, champion2_play_dead, champion3_play_dead, champion4_play_dead, champion5_play_dead, \
            hard_hitter_requirements, uppercut_requirements, knock_out_requirements, wide_swing_requirements
        #Berserker Abilities
        angering_strike_requirements = [0, 40, 0, 0]
        unbridled_rampage_requirements = [80, 0, 0, 0]
        pure_rage_requirements = [0, 30, 0, 0]
        reckless_flurry_requirements = [40, 0, 3, 0]
        champion1_pure_rage = 0
        champion2_pure_rage = 0
        champion3_pure_rage = 0
        champion4_pure_rage = 0
        champion5_pure_rage = 0
        reckless_flurry_buff = 0
        #Rogue Abilities
        serrated_slash_requirements = [0, 0, 0, 0]
        eviscerate_requirements = [0, 0, 3, 0]
        garrote_requirements = [0, 0, 0, 0]
        exploit_weakness_requirements = [0, 0, 5, 0]
        #Survivalist Abilities
        spear_thrust_requirements = [0, 0, 0, 0]
        scrap_bomb_requirements = [0, 0, 3, 0]
        play_dead_requirements = [0, 0, 4, 0]
        survival_kit_requirements = [0, 0, 3, 0]
        champion1_play_dead = 0
        champion2_play_dead = 0
        champion3_play_dead = 0
        champion4_play_dead = 0
        champion5_play_dead = 0
        prepare_buff = 0
        #Brawlist Abilties
        hard_hitter_requirements = [0, 0, 0, 0]
        uppercut_requirements = [0, 0, 2, 0]
        knock_out_requirements = [0, 0, 3, 0]
        wide_swing_requirements = [0, 0, 1, 0]
        global frost_bolt_requirements, fireball_requirements, arcane_brilliance_requirements, magical_barrier_requirements, \
            champion1_magical_barrier, champion2_magical_barrier, champion3_magical_barrier, champion4_magical_barrier, champion5_magical_barrier, \
            invigorate_thorns_requirements, vine_swipe_requirements, barbed_bush_armour_requirements, burst_n_bloom_requirements, \
            champion1_bush_armour, champion2_bush_armour, champion3_bush_armour, champion4_bush_armour, champion5_bush_armour, \
            black_bolt_requirements, void_infusion_requirements, wound_fissure_requirements, soul_tap_requirements, void_infusion_stacks, \
            drain_life_requirements, blood_spike_requirements, blood_boil_requirements, enharden_nerves_requirements, channeling_strength, \
            champion1_enhardened_nerves, champion2_enhardened_nerves, champion3_enhardened_nerves, champion4_enhardened_nerves, champion5_enhardened_nerves, \
            blood_boil_buff
        #Academic Mage Abilities
        frost_bolt_requirements = [30, 0, 0, 0]
        fireball_requirements = [40, 0, 0, 0]
        arcane_brilliance_requirements = [150, 0, 4, 0]
        magical_barrier_requirements = [20, 0, 0, 0]
        champion1_magical_barrier = 0
        champion2_magical_barrier = 0
        champion3_magical_barrier = 0
        champion4_magical_barrier = 0
        champion5_magical_barrier = 0
        #Druid Abilities
        vine_swipe_requirements = [10, 0, 0, 0]
        invigorate_thorns_requirements = [15, 0, 1, 0]
        burst_n_bloom_requirements = [40, 0, 0, 0]
        barbed_bush_armour_requirements = [20, 0, 0, 0]
        champion1_bush_armour = 0
        champion2_bush_armour = 0
        champion3_bush_armour = 0
        champion4_bush_armour = 0
        champion5_bush_armour = 0
        #Warlock Abilities
        black_bolt_requirements = [25, 0, 0, 0]
        void_infusion_requirements = [100, 0, 0, 0]
        void_infusion_stacks = 0
        wound_fissure_requirements = [50, 0, 4, 0]
        soul_tap_requirements = [0, 0, 0, 0]
        #Bloodmancer Abilities
        drain_life_requirements = [0, 0, 0, 0]
        blood_spike_requirements = [0, 0, 0, 0]
        blood_boil_requirements = [0, 0, 3, 0]
        enharden_nerves_requirements = [0, 0, 2, 0]
        blood_boil_buff = False
        champion1_enhardened_nerves = 0
        champion2_enhardened_nerves = 0
        champion3_enhardened_nerves = 0
        champion4_enhardened_nerves = 0
        champion5_enhardened_nerves = 0
        channeling_strength = 0
        global holy_wrath_requirements, righteous_blow_requirements, crusade_requirements, damnation_requirements, paladin_aura, holywrath_multiplier, \
            steady_aim_requirements, power_shot_requirements, multi_shot_requirements, ricochet_shot_requirements, current_arrow_type, \
            chain_bolts_requirements, electrical_expulsion_requirements, energise_requirements, superconductor_requirements, energised, \
            muscle_enlarger_requirements, mistic_bloom_requirements, power_surge_requirements, full_potential_requirements, \
            champion1_muscleEnlarger, champion2_muscleEnlarger, champion3_muscleEnlarger, champion4_muscleEnlarger, champion5_muscleEnlarger, \
            champion1_fullPotential, champion2_fullPotential, champion3_fullPotential, champion4_fullPotential, champion5_fullPotential
        #Paladin Abilities
        holy_wrath_requirements = [0, 0, 0, 0]
        holywrath_multiplier = 1
        righteous_blow_requirements = [0, 0, 2, 0]
        crusade_requirements = [0, 0, 2, 0]
        damnation_requirements = [0, 0, 2, 0]
        #Aura Allocations:
        #1 = Power
        #2 = Protection
        paladin_aura = 1
        #Legion Ranger Abilitites
        steady_aim_requirements = [0, 0, 0, 0]
        power_shot_requirements = [0, 0, 2, 0]
        multi_shot_requirements = [0, 0, 4, 0]
        ricochet_shot_requirements = [0, 0, 6, 0]
        current_arrow_type = "Heavy Iron Tip"
        #Magnetimancer Abilities
        chain_bolts_requirements = [0, 0, 0, 0]
        electrical_expulsion_requirements = [0, 0, 2, 0]
        energise_requirements = [0, 0, 4, 0]
        superconductor_requirements = [0, 0, 2, 0]
        energised = 0
        #Power Conduit Abilities
        muscle_enlarger_requirements = [0, 1, 0, 0]
        champion1_muscleEnlarger = 0
        champion2_muscleEnlarger = 0
        champion3_muscleEnlarger = 0
        champion4_muscleEnlarger = 0
        champion5_muscleEnlarger = 0
        mistic_bloom_requirements = [0, 1, 0, 0]
        power_surge_requirements = [3, 0, 0, 0]
        full_potential_requirements = [3, 0, 0, 0]
        champion1_fullPotential = 0
        champion2_fullPotential = 0
        champion3_fullPotential = 0
        champion4_fullPotential = 0
        champion5_fullPotential = 0
        global rock_barrage_requirements, spring_waters_requirements, ocean_tides_requirements, boulder_cocoon_requirements, \
            champion1_springwaters, champion2_springwaters, champion3_springwaters, champion4_springwaters,champion5_springwaters, \
            champion1_oceantide, champion2_oceantide, champion3_oceantide, champion4_oceantide, champion5_oceantide, \
            shimmering_bolt_requirements, divine_smite_requirements, healing_light_requirements, diffracting_nova_requirements, \
            champion1_blessing, champion2_blessing, champion3_blessing, champion4_blessing, champion5_blessing, \
            cybernetic_blast_requirements, overclock_nanobots_requirements, reverse_wounds_requirements, alter_time_requirements,\
            champion1_nanobot, champion2_nanobot, champion3_nanobot, champion4_nanobot, champion5_nanobot, nanobot_overclock, \
            champion1_lastRoundDamageTaken_list, champion2_lastRoundDamageTaken_list, champion3_lastRoundDamageTaken_list, champion4_lastRoundDamageTaken_list,champion5_lastRoundDamageTaken_list, \
            snip_snip_requirements, bandages_requirements, tight_tourniquet_requirements, secret_remedy_requirements, \
            champion1_bandaged, champion2_bandaged, champion3_bandaged, champion4_bandaged, champion5_bandaged, \
            champion1_tighttourniquet, champion2_tighttourniquet, champion3_tighttourniquet, champion4_tighttourniquet, champion5_tighttourniquet, \
            champion1_weaktourniquet, champion2_weaktourniquet, champion3_weaktourniquet, champion4_weaktourniquet, champion5_weaktourniquet, \
            champion1_strongremedy, champion2_strongremedy, champion3_strongremedy, champion4_strongremedy, champion5_strongremedy, \
            champion1_weakremedy, champion2_weakremedy, champion3_weakremedy, champion4_weakremedy, champion5_weakremedy
        #Earth Speaker Abilities
        rock_barrage_requirements = [0, 25, 0, 0]
        spring_waters_requirements = [25, 0, 0, 0]
        champion1_springwaters = [0, 0]
        champion2_springwaters = [0, 0]
        champion3_springwaters = [0, 0]
        champion4_springwaters = [0, 0]
        champion5_springwaters = [0, 0]
        ocean_tides_requirements = [50, 0, 3, 0]
        champion1_oceantide = [0, 0]
        champion2_oceantide = [0, 0]
        champion3_oceantide = [0, 0]
        champion4_oceantide = [0, 0]
        champion5_oceantide = [0, 0]
        boulder_cocoon_requirements = [25, 0, 3, 0]
        #Priest of the Devoted Abilities
        shimmering_bolt_requirements = [0, 25, 0, 0]
        divine_smite_requirements = [50, 0, 0, 0]
        healing_light_requirements = [25, 0, 0, 0]
        diffracting_nova_requirements = [75, 0, 0, 0]
        champion1_blessing = 0
        champion2_blessing = 0
        champion3_blessing = 0
        champion4_blessing = 0
        champion5_blessing = 0
        #Time Walker Abilities
        cybernetic_blast_requirements = [0, 25, 0, 0]
        overclock_nanobots_requirements = [75, 0, 2, 0]
        champion1_nanobot = [0, 0]
        champion2_nanobot = [0, 0]
        champion3_nanobot = [0, 0]
        champion4_nanobot = [0, 0]
        champion5_nanobot = [0, 0]
        nanobot_overclock = 0
        reverse_wounds_requirements = [25, 0, 0, 0]
        champion1_lastRoundDamageTaken_list = []
        champion2_lastRoundDamageTaken_list = []
        champion3_lastRoundDamageTaken_list = []
        champion4_lastRoundDamageTaken_list = []
        champion5_lastRoundDamageTaken_list = []
        alter_time_requirements = [75, 0, 6, 0]
        #Field Medic Abilities
        snip_snip_requirements = [0, 0, 0, 0]
        bandages_requirements = [0, 0, 0, 0]
        champion1_bandaged = [0, 0]
        champion2_bandaged = [0, 0]
        champion3_bandaged = [0, 0]
        champion4_bandaged = [0, 0]
        champion5_bandaged = [0, 0]
        tight_tourniquet_requirements = [0, 0, 2, 0]
        champion1_tighttourniquet = 0
        champion2_tighttourniquet = 0
        champion3_tighttourniquet = 0
        champion4_tighttourniquet = 0
        champion5_tighttourniquet = 0
        champion1_weaktourniquet = 0
        champion2_weaktourniquet = 0
        champion3_weaktourniquet = 0
        champion4_weaktourniquet = 0
        champion5_weaktourniquet = 0
        secret_remedy_requirements = [0, 0, 4, 0]
        champion1_strongremedy = 0
        champion2_strongremedy = 0
        champion3_strongremedy = 0
        champion4_strongremedy = 0
        champion5_strongremedy = 0
        champion1_weakremedy = 0
        champion2_weakremedy = 0
        champion3_weakremedy = 0
        champion4_weakremedy = 0
        champion5_weakremedy = 0
#Function that creates the main between combat UI that displays the users current team condition as well as the dungeon difficulty and
#what floor and room they're at. User also given the options to minimise the game to browse other parts of the program while being able to return to the game later (if they don't close the program)
#and the option to forfeit the run to just collect rewards without having to wait for al their champions to die
    def DungeonFloorProgress(self, entry_status):
        global teams_current_condition_label, current_floor_label, floor_room_modifiers_label, current_dungeon_label
        if entry_status == "From Combat":
            floor_room_modifiers_label.destroy()
        dungeon_name_text = ParentClass.get_dungeon_difficulty_data(self, "name")
        current_dungeon_label = tk.Label(dungeon_floor_frame, text=dungeon_name_text, font=self.small_text_font)
        current_floor_label = tk.Label(dungeon_floor_frame, text="Floor {} : Room {}".format(floor_level, room_level),
                                       font=self.medium_text_font_bold)
        teams_current_condition_label = tk.Label(dungeon_floor_frame, text=":Your Team's Current Condition:",
                                                 font=self.small_text_font)
        champion1_label = tk.Label(dungeon_game_frame, text=CHAMPION_LIST[0], font=self.small_text_font, width=16)
        champion2_label = tk.Label(dungeon_game_frame, text=CHAMPION_LIST[1], font=self.small_text_font, width=16)
        champion3_label = tk.Label(dungeon_game_frame, text=CHAMPION_LIST[2], font=self.small_text_font, width=16)
        champion4_label = tk.Label(dungeon_game_frame, text=CHAMPION_LIST[3], font=self.small_text_font, width=16)
        champion5_label = tk.Label(dungeon_game_frame, text=CHAMPION_LIST[4], font=self.small_text_font, width=16)
        champion1_status = tk.Label(dungeon_game_frame, text=self.champion_floorMenu_status_text(1), width=20)
        champion2_status = tk.Label(dungeon_game_frame, text=self.champion_floorMenu_status_text(2), width=20)
        champion3_status = tk.Label(dungeon_game_frame, text=self.champion_floorMenu_status_text(3), width=20)
        champion4_status = tk.Label(dungeon_game_frame, text=self.champion_floorMenu_status_text(4), width=20)
        champion5_status = tk.Label(dungeon_game_frame, text=self.champion_floorMenu_status_text(5), width=20)
        proceed_button = tk.Button(dungeon_game_frame, text="Proceed", font=self.menu_button_font,
                                   command=self.combat_monster_setup)
        leave_game_button = tk.Button(dungeon_game_frame, text="Minimise Game", font=self.menu_button_font,
                                    command=self.confirm_leave_game)
        forfeit_game_button = tk.Button(dungeon_game_frame, text="Forfeit the Game", font=self.menu_button_font,
                                    command=self.confirm_forfiet_game)
        CLFinvis_label = tk.Label(dungeon_game_frame)
        teams_current_condition_label.grid(row=2, column=0)
        champion1_label.grid(row=4, column=1)
        champion2_label.grid(row=4, column=2)
        champion3_label.grid(row=4, column=3)
        champion4_label.grid(row=4, column=4)
        champion5_label.grid(row=4, column=5)
        champion1_status.grid(row=5, column=1)
        champion2_status.grid(row=5, column=2)
        champion3_status.grid(row=5, column=3)
        champion4_status.grid(row=5, column=4)
        champion5_status.grid(row=5, column=5)
        CLFinvis_label.grid(row=6, column=3, pady=100)
        proceed_button.grid(row=7, column=3)
        leave_game_button.grid(row=8, column=3)
        forfeit_game_button.grid(row=9, column=3)
        current_dungeon_label.grid(row=0, column=0)
        current_floor_label.grid(row=1, column=0)
#Asks the user in a pop-up window if they're sure they want to minimise the game and return to the Main Menu (with a warning)
    def confirm_leave_game(self):
        root = tk.Tk()
        warning_label = tk.Label(root,
                                 text="Are you sure you want to minimise this game\n(You can only return if you don't exit the program)")
        yes_button = tk.Button(root, text="Yes", command=lambda: self.dungeonfloor_to_mainmenu(root))
        no_button = tk.Button(root, text="No", command=root.destroy)
        warning_label.grid(row=1, column=1)
        yes_button.grid(row=2, column=1)
        no_button.grid(row=3, column=1)
#Quick function to destroy the pop-up window and return to the Main Menu
    def dungeonfloor_to_mainmenu(self, root):
        root.destroy()
        ParentClass.show_frame(app, "MainMenu")
#Asks the user in a pop-up window if they're sure they want to end their current run (with a warning)
    def confirm_forfiet_game(self):
        root = tk.Tk()
        warning_label = tk.Label(root,
                                 text="Are you sure you want to forfeit this game and collect your rewards\n(You won't be able to progress this run any further)")
        yes_button = tk.Button(root, text="Yes", command=lambda: self.dungeonfloor_to_endgame(root))
        no_button = tk.Button(root, text="No", command=root.destroy)
        warning_label.grid(row=1, column=1)
        yes_button.grid(row=2, column=1)
        no_button.grid(row=3, column=1)
#Quick function to destroy the pop-up window and start the end of game function
    def dungeonfloor_to_endgame(self, root):
        root.destroy()
        self.begin_endgame()
#Returns the parametered champions current health and resource status
#If their hp is at 0 then they are given a '*DEAD*' tag next to their name
    def champion_floorMenu_status_text(self, champion_position):
        if champion_position == 1:
            if CHAMPION1_RPNAME == "null":
                if champion1_hp == 0:
                    status_text = "*DEAD*\nHealth Points: {}/{}\n".format(champion1_hp, CHAMPION1_HP)
                    return status_text
                else:
                    status_text = "\nHealth Points: {}/{}\n".format(champion1_hp, CHAMPION1_HP)
                    return status_text
            else:
                if champion1_hp == 0:
                    status_text = "*DEAD*\nHealth Points: {}/{}\n{}: {}/{}".format(champion1_hp, CHAMPION1_HP,
                                                                                   CHAMPION1_RPNAME, champion1_rp,
                                                                                   CHAMPION1_RP)
                    return status_text
                else:
                    status_text = "\nHealth Points: {}/{}\n{}: {}/{}".format(champion1_hp, CHAMPION1_HP,
                                                                             CHAMPION1_RPNAME, champion1_rp,
                                                                             CHAMPION1_RP)
                    return status_text
        if champion_position == 2:
            if CHAMPION2_RPNAME == "null":
                if champion2_hp == 0:
                    status_text = "*DEAD*\nHealth Points: {}/{}\n".format(champion2_hp, CHAMPION2_HP)
                    return status_text
                else:
                    status_text = "\nHealth Points: {}/{}\n".format(champion2_hp, CHAMPION2_HP)
                    return status_text
            else:
                if champion2_hp == 0:
                    status_text = "*DEAD*\nHealth Points: {}/{}\n{}: {}/{}".format(champion2_hp, CHAMPION2_HP,
                                                                                   CHAMPION2_RPNAME, champion2_rp,
                                                                                   CHAMPION2_RP)
                    return status_text
                else:
                    status_text = "\nHealth Points: {}/{}\n{}: {}/{}".format(champion2_hp, CHAMPION2_HP,
                                                                             CHAMPION2_RPNAME, champion2_rp,
                                                                             CHAMPION2_RP)
                    return status_text
        if champion_position == 3:
            if CHAMPION3_RPNAME == "null":
                if champion3_hp == 0:
                    status_text = "*DEAD*\nHealth Points: {}/{}\n".format(champion3_hp, CHAMPION3_HP)
                    return status_text
                else:
                    status_text = "\nHealth Points: {}/{}\n".format(champion3_hp, CHAMPION3_HP)
                    return status_text
            else:
                if champion3_hp == 0:
                    status_text = "*DEAD*\nHealth Points: {}/{}\n{}: {}/{}".format(champion3_hp, CHAMPION3_HP,
                                                                                   CHAMPION3_RPNAME, champion3_rp,
                                                                                   CHAMPION3_RP)
                    return status_text
                else:
                    status_text = "\nHealth Points: {}/{}\n{}: {}/{}".format(champion3_hp, CHAMPION3_HP,
                                                                             CHAMPION3_RPNAME, champion3_rp,
                                                                             CHAMPION3_RP)
                    return status_text
        if champion_position == 4:
            if CHAMPION4_RPNAME == "null":
                if champion4_hp == 0:
                    status_text = "*DEAD*\nHealth Points: {}/{}\n".format(champion4_hp, CHAMPION4_HP)
                    return status_text
                else:
                    status_text = "\nHealth Points: {}/{}\n".format(champion4_hp, CHAMPION4_HP)
                    return status_text
            else:
                if champion4_hp == 0:
                    status_text = "*DEAD*\nHealth Points: {}/{}\n{}: {}/{}".format(champion4_hp, CHAMPION4_HP,
                                                                                   CHAMPION4_RPNAME, champion4_rp,
                                                                                   CHAMPION4_RP)
                    return status_text
                else:
                    status_text = "\nHealth Points: {}/{}\n{}: {}/{}".format(champion4_hp, CHAMPION4_HP,
                                                                             CHAMPION4_RPNAME, champion4_rp,
                                                                             CHAMPION4_RP)
                    return status_text
        if champion_position == 5:
            if CHAMPION5_RPNAME == "null":
                if champion5_hp == 0:
                    status_text = "*DEAD*\nHealth Points: {}/{}\n".format(champion5_hp, CHAMPION5_HP)
                    return status_text
                else:
                    status_text = "\nHealth Points: {}/{}\n".format(champion5_hp, CHAMPION5_HP)
                    return status_text
            else:
                if champion5_hp == 0:
                    status_text = "*DEAD*\nHealth Points: {}/{}\n{}: {}/{}".format(champion5_hp, CHAMPION5_HP,
                                                                                   CHAMPION5_RPNAME, champion5_rp,
                                                                                   CHAMPION5_RP)
                    return status_text
                else:
                    status_text = "\nHealth Points: {}/{}\n{}: {}/{}".format(champion5_hp, CHAMPION5_HP,
                                                                             CHAMPION5_RPNAME, champion5_rp,
                                                                             CHAMPION5_RP)
                    return status_text
#Sets all of the enemies ai data to default in preparation for the start of the next room
    def combat_monster_setup(self):
        global new_round, new_game, from_attack_button, from_special_button, from_turn_choice, from_end_of_turn, combat_results, current_floor_label, teams_current_condition_label, floor_room_modifiers_label, \
            ai_damage_modifier, ai_health_modifier, current_turn, ai1_stun, ai2_stun, ai3_stun, ai4_stun, ai5_stun, ai1_taunt, ai2_taunt, ai3_taunt, ai4_taunt, ai5_taunt, \
            ai1_brittle, ai2_brittle, ai3_brittle, ai4_brittle, ai5_brittle, ai1_weakness, ai2_weakness, ai3_weakness, ai4_weakness, ai5_weakness, \
            ai1_burnDot, ai2_burnDot, ai3_burnDot, ai4_burnDot, ai5_burnDot, ai1_serraSlashDot, ai2_serraSlashDot, ai3_serraSlashDot, \
            ai4_serraSlashDot, ai5_serraSlashDot, ai1_garroteDot, ai2_garroteDot, ai3_garroteDot, ai4_garroteDot, ai5_garroteDot, \
            ai1_eviscerDot, ai2_eviscerDot, ai3_eviscerDot, ai4_eviscerDot, ai5_eviscerDot, \
            ai1_hh_db, ai2_hh_db, ai3_hh_db, ai4_hh_db, ai5_hh_db, \
            ai1_ws_db, ai2_ws_db, ai3_ws_db, ai4_ws_db, ai5_ws_db, \
            ai1_uc_db, ai2_uc_db, ai3_uc_db, ai4_uc_db, ai5_uc_db,  \
            ai1_toc, ai2_toc, ai3_toc, ai4_toc, ai5_toc, \
            ai1_statuses, ai2_statuses, ai3_statuses, ai4_statuses, ai5_statuses, \
            ai1_thornsDot, ai2_thornsDot, ai3_thornsDot, ai4_thornsDot, ai5_thornsDot, \
            ai1_rottingDot, ai2_rottingDot, ai3_rottingDot, ai4_rottingDot, ai5_rottingDot, \
            ai1_barbedArrDot, ai2_barbedArrDot, ai3_barbedArrDot, ai4_barbedArrDot, ai5_barbedArrDot, \
            ai1_damnation, ai2_damnation, ai3_damnation, ai4_damnation, ai5_damnation, \
            ai1_charged, ai2_charged, ai3_charged, ai4_charged, ai5_charged, \
            ai1_superconducted, ai2_superconducted, ai3_superconducted, ai4_superconducted, ai5_superconducted, \
            ai1_shimmerDot, ai2_shimmerDot, ai3_shimmerDot, ai4_shimmerDot, ai5_shimmerDot, \
            ai1_divineDot, ai2_divineDot, ai3_divineDot, ai4_divineDot, ai5_divineDot, \
            ai1_fencer_dodgechance, ai2_fencer_dodgechance, ai3_fencer_dodgechance, ai4_fencer_dodgechance, ai5_fencer_dodgechance, \
            ai1_attack_intention, ai2_attack_intention, ai3_attack_intention, ai4_attack_intention, ai5_attack_intention, \
            champion1_turnover, champion2_turnover, champion3_turnover, champion4_turnover, champion5_turnover, target_to_attack, target_to_special
        new_round = 1
        new_game = 1
        ai_damage_modifier = AI_MODIFERS[3] * (room_level + ((floor_level) * 3))
        ai_health_modifier = AI_MODIFERS[2] * (room_level + ((floor_level) * 3))
        combat_results = ""
        ai1_attack_intention = ""
        ai2_attack_intention = ""
        ai3_attack_intention = ""
        ai4_attack_intention = ""
        ai5_attack_intention = ""
        from_attack_button = 0
        from_special_button = 0
        from_turn_choice = 0
        from_end_of_turn = 0
        target_to_attack = 0
        target_to_special = 0
        champion1_turnover = 0
        champion2_turnover = 0
        champion3_turnover = 0
        champion4_turnover = 0
        champion5_turnover = 0
        ai1_brittle = 0
        ai2_brittle = 0
        ai3_brittle = 0
        ai4_brittle = 0
        ai5_brittle = 0
        ai1_weakness = 0
        ai2_weakness = 0
        ai3_weakness = 0
        ai4_weakness = 0
        ai5_weakness = 0
        ai1_hh_db = 0
        ai2_hh_db = 0
        ai3_hh_db = 0
        ai4_hh_db = 0
        ai5_hh_db = 0
        ai1_ws_db = 0
        ai2_ws_db = 0
        ai3_ws_db = 0
        ai4_ws_db = 0
        ai5_ws_db = 0
        ai1_uc_db = 0
        ai2_uc_db = 0
        ai3_uc_db = 0
        ai4_uc_db = 0
        ai5_uc_db = 0
        ai1_stun = 0
        ai2_stun = 0
        ai3_stun = 0
        ai4_stun = 0
        ai5_stun = 0
        ai1_toc = 0
        ai2_toc = 0
        ai3_toc = 0
        ai4_toc = 0
        ai5_toc = 0
        if MASTER_FENCER.title in CHAMPION_LIST:
            ai1_fencer_dodgechance = 30
            ai2_fencer_dodgechance = 30
            ai3_fencer_dodgechance = 30
            ai4_fencer_dodgechance = 30
            ai5_fencer_dodgechance = 30
        else:
            ai1_fencer_dodgechance = 0
            ai2_fencer_dodgechance = 0
            ai3_fencer_dodgechance = 0
            ai4_fencer_dodgechance = 0
            ai5_fencer_dodgechance = 0
        ai1_statuses = []
        ai2_statuses = []
        ai3_statuses = []
        ai4_statuses = []
        ai5_statuses = []
        ai1_thornsDot = [0, 0]
        ai2_thornsDot = [0, 0]
        ai3_thornsDot = [0, 0]
        ai4_thornsDot = [0, 0]
        ai5_thornsDot = [0, 0]
        ai1_taunt = ["", 0]
        ai2_taunt = ["", 0]
        ai3_taunt = ["", 0]
        ai4_taunt = ["", 0]
        ai5_taunt = ["", 0]
        ai1_burnDot = [0, 0]
        ai2_burnDot = [0, 0]
        ai3_burnDot = [0, 0]
        ai4_burnDot = [0, 0]
        ai5_burnDot = [0, 0]
        ai1_serraSlashDot = [0, 0]
        ai2_serraSlashDot = [0, 0]
        ai3_serraSlashDot = [0, 0]
        ai4_serraSlashDot = [0, 0]
        ai5_serraSlashDot = [0, 0]
        ai1_eviscerDot = [0, 0]
        ai2_eviscerDot = [0, 0]
        ai3_eviscerDot = [0, 0]
        ai4_eviscerDot = [0, 0]
        ai5_eviscerDot = [0, 0]
        ai1_garroteDot = [0, 0]
        ai2_garroteDot = [0, 0]
        ai3_garroteDot = [0, 0]
        ai4_garroteDot = [0, 0]
        ai5_garroteDot = [0, 0]
        ai1_rottingDot = [0, 0, 0]
        ai2_rottingDot = [0, 0, 0]
        ai3_rottingDot = [0, 0, 0]
        ai4_rottingDot = [0, 0, 0]
        ai5_rottingDot = [0, 0, 0]
        ai1_shimmerDot = [0, 0]
        ai2_shimmerDot = [0, 0]
        ai3_shimmerDot = [0, 0]
        ai4_shimmerDot = [0, 0]
        ai5_shimmerDot = [0, 0]
        ai1_divineDot = [0, 0]
        ai2_divineDot = [0, 0]
        ai3_divineDot = [0, 0]
        ai4_divineDot = [0, 0]
        ai5_divineDot = [0, 0]
        ai1_damnation = [0, 0]
        ai2_damnation = [0, 0]
        ai3_damnation = [0, 0]
        ai4_damnation = [0, 0]
        ai5_damnation = [0, 0]
        ai1_barbedArrDot = [0, 0]
        ai2_barbedArrDot = [0, 0]
        ai3_barbedArrDot = [0, 0]
        ai4_barbedArrDot = [0, 0]
        ai5_barbedArrDot = [0, 0]
        ai1_charged = [0, 0]
        ai2_charged = [0, 0]
        ai3_charged = [0, 0]
        ai4_charged = [0, 0]
        ai5_charged = [0, 0]
        ai1_superconducted = 0
        ai2_superconducted = 0
        ai3_superconducted = 0
        ai4_superconducted = 0
        ai5_superconducted = 0
        ai1_statuses = []
        ai2_statuses = []
        ai3_statuses = []
        ai4_statuses = []
        ai5_statuses = []
        current_turn = ""
        for widget in dungeon_game_frame.winfo_children():
            widget.destroy()
        teams_current_condition_label.destroy()
        current_floor_label.destroy()
        current_floor_label = tk.Label(dungeon_floor_frame, text="Floor {} : Room {}".format(floor_level, room_level),
                                       font=self.small_text_font)
        current_floor_label.grid(row=1, column=0)
        floor_room_modifiers_label = tk.Label(dungeon_floor_frame,
                                              text="Enemy Damage Modifier: +{} : Enemy Health Modifier: +{}".format(ai_damage_modifier, ai_health_modifier))
        floor_room_modifiers_label.grid(row=2, column=0)
        self.set_monster_encounter()
        self.next_turn()
#Sets all base and adjustable variables for enemy ai
    def set_monster_encounter(self):
        global AI_ATTACKS, AI_GROUP_HP, AI_ATTACKPOWER, AI_SPAWNED, AI_ENTRY_WORD, AI_NICKNAME, \
            AI_NAME, AI_RESOURCE, AI_RESOURCE_NAME, AI_SIZE, ai1_hp, ai2_hp, ai3_hp, ai4_hp, ai5_hp, ai1_rp, ai2_rp, ai3_rp, \
            ai4_rp, ai5_rp, ai1_max_hp, ai2_max_hp, ai3_max_hp, ai4_max_hp, ai5_max_hp
        NUM_SPAWNED_MONSTERS = [1, 2, 3, 4, 5]
        random.shuffle(NUM_SPAWNED_MONSTERS)
        if NUM_SPAWNED_MONSTERS[0] == 1:
            ai_type = [GROTHAK_THE_DESTROYER.name]  #will create variety later
        elif NUM_SPAWNED_MONSTERS[0] == 2:
            ai_type = [WORMPULP_BROTHERS.name]  #will create variety later
        elif NUM_SPAWNED_MONSTERS[0] == 3:
            ai_type = [SIREN_TRIPLETS.name]  #will create variety later
        elif NUM_SPAWNED_MONSTERS[0] == 4:
            ai_type = [VENOMSKIN_AMPHIBOIDS.name]  #will create variety later
        elif NUM_SPAWNED_MONSTERS[0] == 5:
            ai_type = [GIANT_LOCUST_SWARM.name]  #will create variety later
        random.shuffle(ai_type)
        monster_ai = ai_type[0]
        if monster_ai == GROTHAK_THE_DESTROYER.name:
            AI_ATTACKS = GROTHAK_THE_DESTROYER.attack_list  #will add more later
            AI_GROUP_HP = AI_MODIFERS[0]
            AI_ATTACKPOWER = AI_MODIFERS[1]
            AI_SPAWNED = GROTHAK_THE_DESTROYER.ai_spawned
            AI_ENTRY_WORD = GROTHAK_THE_DESTROYER.enter_word
            AI_NICKNAME = GROTHAK_THE_DESTROYER.nickname
            AI_NAME = GROTHAK_THE_DESTROYER.name
            AI_RESOURCE = GROTHAK_THE_DESTROYER.rp
            AI_RESOURCE_NAME = GROTHAK_THE_DESTROYER.rp_name
            AI_SIZE = GROTHAK_THE_DESTROYER.size_class
        elif monster_ai == WORMPULP_BROTHERS.name:
            AI_ATTACKS = WORMPULP_BROTHERS.attack_list  #will add more later
            AI_GROUP_HP = math.ceil(AI_MODIFERS[0] / 2)
            AI_ATTACKPOWER = math.ceil(AI_MODIFERS[1] / 2)
            AI_SPAWNED = WORMPULP_BROTHERS.ai_spawned
            AI_ENTRY_WORD = WORMPULP_BROTHERS.enter_word
            AI_NICKNAME = WORMPULP_BROTHERS.nickname
            AI_NAME = WORMPULP_BROTHERS.name
            AI_RESOURCE = WORMPULP_BROTHERS.rp
            AI_RESOURCE_NAME = WORMPULP_BROTHERS.rp_name
            AI_SIZE = WORMPULP_BROTHERS.size_class
        elif monster_ai == SIREN_TRIPLETS.name:
            AI_ATTACKS = SIREN_TRIPLETS.attack_list  #will add more later
            AI_GROUP_HP = math.ceil(AI_MODIFERS[0] / 3)
            AI_ATTACKPOWER = math.ceil(AI_MODIFERS[1] / 3)
            AI_SPAWNED = SIREN_TRIPLETS.ai_spawned
            AI_ENTRY_WORD = SIREN_TRIPLETS.enter_word
            AI_NICKNAME = SIREN_TRIPLETS.nickname
            AI_NAME = SIREN_TRIPLETS.name
            AI_RESOURCE = SIREN_TRIPLETS.rp
            AI_RESOURCE_NAME = SIREN_TRIPLETS.rp_name
            AI_SIZE = SIREN_TRIPLETS.size_class
        elif monster_ai == VENOMSKIN_AMPHIBOIDS.name:
            AI_ATTACKS = VENOMSKIN_AMPHIBOIDS.attack_list  #will add more later
            AI_GROUP_HP = math.ceil(AI_MODIFERS[0] / 4)
            AI_ATTACKPOWER = math.ceil(AI_MODIFERS[1] / 4)
            AI_SPAWNED = VENOMSKIN_AMPHIBOIDS.ai_spawned
            AI_ENTRY_WORD = VENOMSKIN_AMPHIBOIDS.enter_word
            AI_NICKNAME = VENOMSKIN_AMPHIBOIDS.nickname
            AI_NAME = VENOMSKIN_AMPHIBOIDS.name
            AI_RESOURCE = VENOMSKIN_AMPHIBOIDS.rp
            AI_RESOURCE_NAME = VENOMSKIN_AMPHIBOIDS.rp_name
            AI_SIZE = VENOMSKIN_AMPHIBOIDS.size_class
        elif monster_ai == GIANT_LOCUST_SWARM.name:
            AI_ATTACKS = GIANT_LOCUST_SWARM.attack_list  #will add more later
            AI_GROUP_HP = math.ceil(AI_MODIFERS[0] / 5)
            AI_ATTACKPOWER = math.ceil(AI_MODIFERS[1] / 5)
            AI_SPAWNED = GIANT_LOCUST_SWARM.ai_spawned
            AI_ENTRY_WORD = GIANT_LOCUST_SWARM.enter_word
            AI_NICKNAME = GIANT_LOCUST_SWARM.nickname
            AI_NAME = GIANT_LOCUST_SWARM.name
            AI_RESOURCE = GIANT_LOCUST_SWARM.rp
            AI_RESOURCE_NAME = GIANT_LOCUST_SWARM.rp_name
            AI_SIZE = GIANT_LOCUST_SWARM.size_class
        aiEnemyNA = 0
        if AI_SPAWNED == 1:
            ai1_hp = math.ceil(AI_GROUP_HP + ai_health_modifier)
            ai2_hp = aiEnemyNA
            ai3_hp = aiEnemyNA
            ai4_hp = aiEnemyNA
            ai5_hp = aiEnemyNA
        if AI_SPAWNED == 2:
            ai1_hp = math.ceil(AI_GROUP_HP + ai_health_modifier)
            ai2_hp = math.ceil(AI_GROUP_HP + ai_health_modifier)
            ai3_hp = aiEnemyNA
            ai4_hp = aiEnemyNA
            ai5_hp = aiEnemyNA
        if AI_SPAWNED == 3:
            ai1_hp = math.ceil(AI_GROUP_HP + ai_health_modifier)
            ai2_hp = math.ceil(AI_GROUP_HP + ai_health_modifier)
            ai3_hp = math.ceil(AI_GROUP_HP + ai_health_modifier)
            ai4_hp = aiEnemyNA
            ai5_hp = aiEnemyNA
        if AI_SPAWNED == 4:
            ai1_hp = math.ceil(AI_GROUP_HP + ai_health_modifier)
            ai2_hp = math.ceil(AI_GROUP_HP + ai_health_modifier)
            ai3_hp = math.ceil(AI_GROUP_HP + ai_health_modifier)
            ai4_hp = math.ceil(AI_GROUP_HP + ai_health_modifier)
            ai5_hp = aiEnemyNA
        if AI_SPAWNED == 5:
            ai1_hp = math.ceil(AI_GROUP_HP + ai_health_modifier)
            ai2_hp = math.ceil(AI_GROUP_HP + ai_health_modifier)
            ai3_hp = math.ceil(AI_GROUP_HP + ai_health_modifier)
            ai4_hp = math.ceil(AI_GROUP_HP + ai_health_modifier)
            ai5_hp = math.ceil(AI_GROUP_HP + ai_health_modifier)
        if AI_RESOURCE_NAME == "null":
            ai1_rp = "null"
            ai2_rp = "null"
            ai3_rp = "null"
            ai4_rp = "null"
            ai5_rp = "null"
        else:
            ai1_rp = AI_RESOURCE
            ai2_rp = AI_RESOURCE
            ai3_rp = AI_RESOURCE
            ai4_rp = AI_RESOURCE
            ai5_rp = AI_RESOURCE
        ai1_max_hp = ai1_hp
        ai2_max_hp = ai2_hp
        ai3_max_hp = ai3_hp
        ai4_max_hp = ai4_hp
        ai5_max_hp = ai5_hp
        global club_slam_requirements, violent_thrash_requirements, twilight_beam_requirements, spear_stab_requirements, \
            bite_requirements
        if AI_NAME == "Grothak the Destroyer":
            club_slam_requirements = [0, 0, 0]
        if AI_NAME == "Wormpulp Brothers":
            violent_thrash_requirements = [0, 0, 0]
        if AI_NAME == "Siren Triplets":
            twilight_beam_requirements = [25, 0, 0]
        if AI_NAME == "Venomskin Amphiboids":
            spear_stab_requirements = [0, 0, 0]
        if AI_NAME == "Giant Locust Swarm":
            bite_requirements = [0, 0, 0]
#Checks if the enemy is alive or in the game
#If they are, then the enemy selects an attack to make
#If they aren't, then they are assigned 'null'
    def monster_attack_intentions(self):
        global ai1_attack, ai2_attack, ai3_attack, ai4_attack, ai5_attack
        if ai1_hp == 0:
            ai1_attacking = 0
        else:
            ai1_attacking = 1
        if ai2_hp == 0:
            ai2_attacking = 0
        elif ai2_hp == "out":
            ai2_attacking = 0
        else:
            ai2_attacking = 1
        if ai3_hp == 0:
            ai3_attacking = 0
        elif ai3_hp == "out":
            ai3_attacking = 0
        else:
            ai3_attacking = 1
        if ai4_hp == 0:
            ai4_attacking = 0
        elif ai4_hp == "out":
            ai4_attacking = 0
        else:
            ai4_attacking = 1
        if ai5_hp == 0:
            ai5_attacking = 0
        elif ai5_hp == "out":
            ai5_attacking = 0
        else:
            ai5_attacking = 1
        if ai1_attacking == 1:
            ai1_attack = self.select_ai_attacks()
        else:
            ai1_attack = "null"
        if ai2_attacking == 1:
            ai2_attack = self.select_ai_attacks()
        else:
            ai2_attack = "null"
        if ai3_attacking == 1:
            ai3_attack = self.select_ai_attacks()
        else:
            ai3_attack = "null"
        if ai4_attacking == 1:
            ai4_attack = self.select_ai_attacks()
        else:
            ai4_attack = "null"
        if ai5_attacking == 1:
            ai5_attack = self.select_ai_attacks()
        else:
            ai5_attack = "null"
#Puts all of the active unique enemy attacks into a list and then randomly picks one, that attack is returned as the enemies action (theres only one attack for each enemy right now)
#Each attack put into the list has a slightly random damage number to make extra variety in damage numbers to keep it from being extremelypredictable
    def select_ai_attacks(self):
        attack = []
        if AI_NAME == "Grothak the Destroyer":
            #Club_Slam
            club_slam_basenumber = [1, 1.3, 1.5]
            random.shuffle(club_slam_basenumber)
            club_slam_damage = (club_slam_basenumber[0] * (AI_ATTACKPOWER + ai_damage_modifier))
            if club_slam_requirements[1] == 0:
                if club_slam_requirements[0] <= AI_RESOURCE:
                    attack.append("Club Slam")
            random.shuffle(attack)
            if attack[0] == "Club Slam":
                attack = ["Club Slam", math.ceil(club_slam_damage), "1T", "Melee"]
        if AI_NAME == "Wormpulp Brothers":
            #Violent Thrash
            violent_thrash_basenumber = [1, 1.1, 1.2]
            random.shuffle(violent_thrash_basenumber)
            violent_thrash_damage = (violent_thrash_basenumber[0] * (AI_ATTACKPOWER + ai_damage_modifier))
            if violent_thrash_requirements[1] == 0:
                if violent_thrash_requirements[0] <= AI_RESOURCE:
                    attack.append("Violent Thrash")
            random.shuffle(attack)
            if attack[0] == "Violent Thrash":
                attack = ["Violent Thrash", math.ceil(violent_thrash_damage), "2T", "Melee"]
        if AI_NAME == "Siren Triplets":
            #Twilight Beam
            twilight_beam_basenumber = [1.2, 1.4, 1.6]
            random.shuffle(twilight_beam_basenumber)
            twilight_beam_damage = (twilight_beam_basenumber[0] * (AI_ATTACKPOWER + ai_damage_modifier))
            if twilight_beam_requirements[1] == 0:
                if twilight_beam_requirements[0] <= AI_RESOURCE:
                    attack.append("Twilight Beam")
            random.shuffle(attack)
            if attack[0] == "Twilight Beam":
                attack = ["Twilight Beam", math.ceil(twilight_beam_damage), "1T", "Magic"]
        if AI_NAME == "Venomskin Amphiboids":
            #Spear Thrust
            spear_thrust_basenumber = [1.2, 1.4, 1.6]
            random.shuffle(spear_thrust_basenumber)
            spear_thrust_damage = (spear_thrust_basenumber[0] * (AI_ATTACKPOWER + ai_damage_modifier))
            if spear_stab_requirements[1] == 0:
                if spear_stab_requirements[0] <= AI_RESOURCE:
                    attack.append("Spear Thrust")
            random.shuffle(attack)
            if attack[0] == "Spear Thrust":
                attack = ["Spear Thrust", math.ceil(spear_thrust_damage), "1T", "Melee"]
        if AI_NAME == "Giant Locust Swarm":
            #Bite
            bite_basenumber = [1.2, 1.4, 1.6]
            random.shuffle(bite_basenumber)
            bite_damage = (bite_basenumber[0] * (AI_ATTACKPOWER + ai_damage_modifier))
            if bite_requirements[1] == 0:
                if bite_requirements[0] <= AI_RESOURCE:
                    attack.append("Bite")
            random.shuffle(attack)
            if attack[0] == "Bite":
                attack = ["Bite", math.ceil(bite_damage), "1T", "Melee"]
        return attack
#Chooses the enemies attack targets randomly and takes consideration into variables like
#stunned, being taunted, survivalists play dead, if the champion is alive
#Returns a string that says who they're attacking with what ability that deals how much damage
    def ai_choose_attack_targets(self):
        global ai1_attack_intention, ai2_attack_intention, ai3_attack_intention, ai4_attack_intention, ai5_attack_intention
        ai_attack_options = []
        counter = 0
        if ai1_hp > 0:
            if ai1_attack == "null":
                ai1_attack_intention = ""
            else:
                if ai1_stun != 0:
                    ai1_attack_intention = "STUNNED"
                else:
                    if ai1_taunt[1] != 0:
                        ai_attack_target = ai1_taunt[0]
                        ai1_attack_intention = "{} <<< {} ({} Damage)".format(ai_attack_target, ai1_attack[0],
                                                                              ai1_attack[1])
                    else:
                        if "Survivalist" in ai1_attack_intention:
                            if champion1_play_dead == 0:
                                if champion2_play_dead == 0:
                                    if champion3_play_dead == 0:
                                        if champion4_play_dead == 0:
                                            if champion5_play_dead == 0:
                                                playdead_check = 0
                                            else:
                                                played_check = 1
                                        else:
                                            playdead_check = 1
                                    else:
                                        playdead_check = 1
                                else:
                                    playdead_check = 1
                            else:
                                playdead_check = 1
                            if playdead_check == 1:
                                if ai1_attack[2] == "1T":
                                    if champion1_hp != 0:
                                        if champion1_play_dead != 0:
                                            pass
                                        else:
                                            ai_attack_options.append("C1")
                                    if champion2_hp != 0:
                                        if champion2_play_dead != 0:
                                            pass
                                        else:
                                            ai_attack_options.append("C2")
                                    if champion3_hp != 0:
                                        if champion3_play_dead != 0:
                                            pass
                                        else:
                                            ai_attack_options.append("C3")
                                    if champion4_hp != 0:
                                        if champion4_play_dead != 0:
                                            pass
                                        else:
                                            ai_attack_options.append("C4")
                                    if champion5_hp != 0:
                                        if champion5_play_dead != 0:
                                            pass
                                        else:
                                            ai_attack_options.append("C5")
                                    random.shuffle(ai_attack_options)
                                    if ai_attack_options[0] == "C1":
                                        ai_attack_target = CHAMPION_LIST[0]
                                    if ai_attack_options[0] == "C2":
                                        ai_attack_target = CHAMPION_LIST[1]
                                    if ai_attack_options[0] == "C3":
                                        ai_attack_target = CHAMPION_LIST[2]
                                    if ai_attack_options[0] == "C4":
                                        ai_attack_target = CHAMPION_LIST[3]
                                    if ai_attack_options[0] == "C5":
                                        ai_attack_target = CHAMPION_LIST[4]
                                    ai1_attack_intention = "{} <<< {} ({} Damage)".format(ai_attack_target, ai1_attack[0],
                                                                                            ai1_attack[1])
                                elif ai1_attack[2] == "2T":
                                    if champion1_hp != 0:
                                        if champion1_play_dead != 0:
                                            pass
                                        else:
                                            ai_attack_options.append("C1")
                                    if champion2_hp != 0:
                                        if champion2_play_dead != 0:
                                            pass
                                        else:
                                            ai_attack_options.append("C2")
                                    if champion3_hp != 0:
                                        if champion3_play_dead != 0:
                                            pass
                                        else:
                                            ai_attack_options.append("C3")
                                    if champion4_hp != 0:
                                        if champion4_play_dead != 0:
                                            pass
                                        else:
                                            ai_attack_options.append("C4")
                                    if champion5_hp != 0:
                                        if champion5_play_dead != 0:
                                            pass
                                        else:
                                            ai_attack_options.append("C5")
                                    random.shuffle(ai_attack_options)
                                    if ai_attack_options[0] == "C1":
                                        ai_attack1_target = CHAMPION_LIST[0]
                                        ai_attack_options.remove("C1")
                                    if ai_attack_options[0] == "C2":
                                        ai_attack1_target = CHAMPION_LIST[1]
                                        ai_attack_options.remove("C2")
                                    if ai_attack_options[0] == "C3":
                                        ai_attack1_target = CHAMPION_LIST[2]
                                        ai_attack_options.remove("C3")
                                    if ai_attack_options[0] == "C4":
                                        ai_attack1_target = CHAMPION_LIST[3]
                                        ai_attack_options.remove("C4")
                                    if ai_attack_options[0] == "C5":
                                        ai_attack1_target = CHAMPION_LIST[4]
                                        ai_attack_options.remove("C5")
                                    random.shuffle(ai_attack_options)
                                    if ai_attack_options[0] == "C1":
                                        ai_attack2_target = CHAMPION_LIST[0]
                                    if ai_attack_options[0] == "C2":
                                        ai_attack2_target = CHAMPION_LIST[1]
                                    if ai_attack_options[0] == "C3":
                                        ai_attack2_target = CHAMPION_LIST[2]
                                    if ai_attack_options[0] == "C4":
                                        ai_attack2_target = CHAMPION_LIST[3]
                                    if ai_attack_options[0] == "C5":
                                        ai_attack2_target = CHAMPION_LIST[4]
                                    ai1_attack_intention = "{} and {} <<< {} ({} Damage)".format(ai_attack1_target, ai_attack2_target,
                                                                                                ai1_attack[0], ai1_attack[1])
                            else:
                                pass
                        else:
                            if new_round == 1:
                                if ai1_attack[2] == "1T":
                                    if champion1_hp != 0:
                                        ai_attack_options.append("C1")
                                    if champion2_hp != 0:
                                        ai_attack_options.append("C2")
                                    if champion3_hp != 0:
                                        ai_attack_options.append("C3")
                                    if champion4_hp != 0:
                                        ai_attack_options.append("C4")
                                    if champion5_hp != 0:
                                        ai_attack_options.append("C5")
                                    random.shuffle(ai_attack_options)
                                    if ai_attack_options[0] == "C1":
                                        ai_attack_target = CHAMPION_LIST[0]
                                    if ai_attack_options[0] == "C2":
                                        ai_attack_target = CHAMPION_LIST[1]
                                    if ai_attack_options[0] == "C3":
                                        ai_attack_target = CHAMPION_LIST[2]
                                    if ai_attack_options[0] == "C4":
                                        ai_attack_target = CHAMPION_LIST[3]
                                    if ai_attack_options[0] == "C5":
                                        ai_attack_target = CHAMPION_LIST[4]
                                    ai1_attack_intention = "{} <<< {} ({} Damage)".format(ai_attack_target, ai1_attack[0],
                                                                                        ai1_attack[1])
                                elif ai1_attack[2] == "2T":
                                    if champion1_hp != 0:
                                        ai_attack_options.append("C1")
                                    if champion2_hp != 0:
                                        ai_attack_options.append("C2")
                                    if champion3_hp != 0:
                                        ai_attack_options.append("C3")
                                    if champion4_hp != 0:
                                        ai_attack_options.append("C4")
                                    if champion5_hp != 0:
                                        ai_attack_options.append("C5")
                                    random.shuffle(ai_attack_options)
                                    if ai_attack_options[0] == "C1":
                                        ai_attack1_target = CHAMPION_LIST[0]
                                        ai_attack_options.remove("C1")
                                    if ai_attack_options[0] == "C2":
                                        ai_attack1_target = CHAMPION_LIST[1]
                                        ai_attack_options.remove("C2")
                                    if ai_attack_options[0] == "C3":
                                        ai_attack1_target = CHAMPION_LIST[2]
                                        ai_attack_options.remove("C3")
                                    if ai_attack_options[0] == "C4":
                                        ai_attack1_target = CHAMPION_LIST[3]
                                        ai_attack_options.remove("C4")
                                    if ai_attack_options[0] == "C5":
                                        ai_attack1_target = CHAMPION_LIST[4]
                                        ai_attack_options.remove("C5")
                                    random.shuffle(ai_attack_options)
                                    if ai_attack_options[0] == "C1":
                                        ai_attack2_target = CHAMPION_LIST[0]
                                    if ai_attack_options[0] == "C2":
                                        ai_attack2_target = CHAMPION_LIST[1]
                                    if ai_attack_options[0] == "C3":
                                        ai_attack2_target = CHAMPION_LIST[2]
                                    if ai_attack_options[0] == "C4":
                                        ai_attack2_target = CHAMPION_LIST[3]
                                    if ai_attack_options[0] == "C5":
                                        ai_attack2_target = CHAMPION_LIST[4]
                                    ai1_attack_intention = "{} and {} <<< {} ({} Damage)".format(ai_attack1_target, ai_attack2_target,
                                                                                                ai1_attack[0], ai1_attack[1])
                                if ai1_attack[2] == "AOE":
                                    ai1_attack_intention = "Everyone <<< {} ({} Damage)".format(ai1_attack[0], ai1_attack[1])
        if ai2_hp > 0:
            ai_attack_options = []
            if ai2_attack == "null":
                ai2_attack_intention = ""
            else:
                if ai2_stun != 0:
                    ai2_attack_intention = "STUNNED"
                else:
                    if ai2_taunt[1] != 0:
                        ai_attack_target = ai2_taunt[0]
                        ai2_attack_intention = "{} <<< {} ({} Damage)".format(ai_attack_target, ai2_attack[0],
                                                                              ai2_attack[1])
                    else:
                        if "Survivalist" in ai2_attack_intention:
                            if champion1_play_dead == 0:
                                if champion2_play_dead == 0:
                                    if champion3_play_dead == 0:
                                        if champion4_play_dead == 0:
                                            if champion5_play_dead == 0:
                                                playdead_check = 0
                                            else:
                                                played_check = 1
                                        else:
                                            playdead_check = 1
                                    else:
                                        playdead_check = 1
                                else:
                                    playdead_check = 1
                            else:
                                playdead_check = 1
                            if playdead_check == 1:
                                if ai2_attack[2] == "1T":
                                    if champion1_hp != 0:
                                        if champion1_play_dead != 0:
                                            pass
                                        else:
                                            ai_attack_options.append("C1")
                                    if champion2_hp != 0:
                                        if champion2_play_dead != 0:
                                            pass
                                        else:
                                            ai_attack_options.append("C2")
                                    if champion3_hp != 0:
                                        if champion3_play_dead != 0:
                                            pass
                                        else:
                                            ai_attack_options.append("C3")
                                    if champion4_hp != 0:
                                        if champion4_play_dead != 0:
                                            pass
                                        else:
                                            ai_attack_options.append("C4")
                                    if champion5_hp != 0:
                                        if champion5_play_dead != 0:
                                            pass
                                        else:
                                            ai_attack_options.append("C5")
                                    random.shuffle(ai_attack_options)
                                    if ai_attack_options[0] == "C1":
                                        ai_attack_target = CHAMPION_LIST[0]
                                    if ai_attack_options[0] == "C2":
                                        ai_attack_target = CHAMPION_LIST[1]
                                    if ai_attack_options[0] == "C3":
                                        ai_attack_target = CHAMPION_LIST[2]
                                    if ai_attack_options[0] == "C4":
                                        ai_attack_target = CHAMPION_LIST[3]
                                    if ai_attack_options[0] == "C5":
                                        ai_attack_target = CHAMPION_LIST[4]
                                    ai2_attack_intention = "{} <<< {} ({} Damage)".format(ai_attack_target, ai2_attack[0],
                                                                                            ai2_attack[1])
                                elif ai2_attack[2] == "2T":
                                    if champion1_hp != 0:
                                        if champion1_play_dead != 0:
                                            pass
                                        else:
                                            ai_attack_options.append("C1")
                                    if champion2_hp != 0:
                                        if champion2_play_dead != 0:
                                            pass
                                        else:
                                            ai_attack_options.append("C2")
                                    if champion3_hp != 0:
                                        if champion3_play_dead != 0:
                                            pass
                                        else:
                                            ai_attack_options.append("C3")
                                    if champion4_hp != 0:
                                        if champion4_play_dead != 0:
                                            pass
                                        else:
                                            ai_attack_options.append("C4")
                                    if champion5_hp != 0:
                                        if champion5_play_dead != 0:
                                            pass
                                        else:
                                            ai_attack_options.append("C5")
                                    random.shuffle(ai_attack_options)
                                    if ai_attack_options[0] == "C1":
                                        ai_attack1_target = CHAMPION_LIST[0]
                                        ai_attack_options.remove("C1")
                                    if ai_attack_options[0] == "C2":
                                        ai_attack1_target = CHAMPION_LIST[1]
                                        ai_attack_options.remove("C2")
                                    if ai_attack_options[0] == "C3":
                                        ai_attack1_target = CHAMPION_LIST[2]
                                        ai_attack_options.remove("C3")
                                    if ai_attack_options[0] == "C4":
                                        ai_attack1_target = CHAMPION_LIST[3]
                                        ai_attack_options.remove("C4")
                                    if ai_attack_options[0] == "C5":
                                        ai_attack1_target = CHAMPION_LIST[4]
                                        ai_attack_options.remove("C5")
                                    random.shuffle(ai_attack_options)
                                    if ai_attack_options[0] == "C1":
                                        ai_attack2_target = CHAMPION_LIST[0]
                                    if ai_attack_options[0] == "C2":
                                        ai_attack2_target = CHAMPION_LIST[1]
                                    if ai_attack_options[0] == "C3":
                                        ai_attack2_target = CHAMPION_LIST[2]
                                    if ai_attack_options[0] == "C4":
                                        ai_attack2_target = CHAMPION_LIST[3]
                                    if ai_attack_options[0] == "C5":
                                        ai_attack2_target = CHAMPION_LIST[4]
                                    ai2_attack_intention = "{} and {} <<< {} ({} Damage)".format(ai_attack1_target, ai_attack2_target,
                                                                                                ai2_attack[0], ai2_attack[1])
                            else:
                                pass
                        else:
                            if new_round == 1:
                                if ai2_attack[2] == "1T":
                                    if champion1_hp != 0:
                                        ai_attack_options.append("C1")
                                    if champion2_hp != 0:
                                        ai_attack_options.append("C2")
                                    if champion3_hp != 0:
                                        ai_attack_options.append("C3")
                                    if champion4_hp != 0:
                                        ai_attack_options.append("C4")
                                    if champion5_hp != 0:
                                        ai_attack_options.append("C5")
                                    random.shuffle(ai_attack_options)
                                    if ai_attack_options[0] == "C1":
                                        ai_attack_target = CHAMPION_LIST[0]
                                    if ai_attack_options[0] == "C2":
                                        ai_attack_target = CHAMPION_LIST[1]
                                    if ai_attack_options[0] == "C3":
                                        ai_attack_target = CHAMPION_LIST[2]
                                    if ai_attack_options[0] == "C4":
                                        ai_attack_target = CHAMPION_LIST[3]
                                    if ai_attack_options[0] == "C5":
                                        ai_attack_target = CHAMPION_LIST[4]
                                    ai2_attack_intention = "{} <<< {} ({} Damage)".format(ai_attack_target, ai2_attack[0],
                                                                                        ai2_attack[1])
                                if ai2_attack[2] == "2T":
                                    if champion1_hp != 0:
                                        ai_attack_options.append("C1")
                                    if champion2_hp != 0:
                                        ai_attack_options.append("C2")
                                    if champion3_hp != 0:
                                        ai_attack_options.append("C3")
                                    if champion4_hp != 0:
                                        ai_attack_options.append("C4")
                                    if champion5_hp != 0:
                                        ai_attack_options.append("C5")
                                    random.shuffle(ai_attack_options)
                                    if ai_attack_options[0] == "C1":
                                        ai_attack1_target = CHAMPION_LIST[0]
                                        ai_attack_options.remove("C1")
                                    if ai_attack_options[0] == "C2":
                                        ai_attack1_target = CHAMPION_LIST[1]
                                        ai_attack_options.remove("C2")
                                    if ai_attack_options[0] == "C3":
                                        ai_attack1_target = CHAMPION_LIST[2]
                                        ai_attack_options.remove("C3")
                                    if ai_attack_options[0] == "C4":
                                        ai_attack1_target = CHAMPION_LIST[3]
                                        ai_attack_options.remove("C4")
                                    if ai_attack_options[0] == "C5":
                                        ai_attack1_target = CHAMPION_LIST[4]
                                        ai_attack_options.remove("C5")
                                    random.shuffle(ai_attack_options)
                                    if ai_attack_options[0] == "C1":
                                        ai_attack2_target = CHAMPION_LIST[0]
                                    if ai_attack_options[0] == "C2":
                                        ai_attack2_target = CHAMPION_LIST[1]
                                    if ai_attack_options[0] == "C3":
                                        ai_attack2_target = CHAMPION_LIST[2]
                                    if ai_attack_options[0] == "C4":
                                        ai_attack2_target = CHAMPION_LIST[3]
                                    if ai_attack_options[0] == "C5":
                                        ai_attack2_target = CHAMPION_LIST[4]
                                    ai2_attack_intention = "{} and {} <<< {} ({} Damage)".format(ai_attack1_target, ai_attack2_target,
                                                                                                ai2_attack[0],
                                                                                                ai2_attack[1])
                                if ai2_attack[2] == "AOE":
                                    ai2_attack_intention = "Everyone <<< {} ({} Damage)".format(ai2_attack[0], ai2_attack[1])
            if ai3_hp > 0:
                ai_attack_options = []
                if ai3_attack == "null":
                    ai3_attack_intention = ""
                else:
                    if ai3_stun != 0:
                        ai3_attack_intention = "STUNNED"
                    else:
                        if ai3_taunt[1] != 0:
                            ai_attack_target = ai3_taunt[0]
                            ai3_attack_intention = "{} <<< {} ({} Damage)".format(ai_attack_target, ai3_attack[0],
                                                                                  ai3_attack[1])
                        else:
                            if "Survivalist" in ai3_attack_intention:
                                if champion1_play_dead == 0:
                                    if champion2_play_dead == 0:
                                        if champion3_play_dead == 0:
                                            if champion4_play_dead == 0:
                                                if champion5_play_dead == 0:
                                                    playdead_check = 0
                                                else:
                                                    played_check = 1
                                            else:
                                                playdead_check = 1
                                        else:
                                            playdead_check = 1
                                    else:
                                        playdead_check = 1
                                else:
                                    playdead_check = 1
                                if playdead_check == 1:
                                    if ai3_attack[2] == "1T":
                                        if champion1_hp != 0:
                                            if champion1_play_dead != 0:
                                                pass
                                            else:
                                                ai_attack_options.append("C1")
                                        if champion2_hp != 0:
                                            if champion2_play_dead != 0:
                                                pass
                                            else:
                                                ai_attack_options.append("C2")
                                        if champion3_hp != 0:
                                            if champion3_play_dead != 0:
                                                pass
                                            else:
                                                ai_attack_options.append("C3")
                                        if champion4_hp != 0:
                                            if champion4_play_dead != 0:
                                                pass
                                            else:
                                                ai_attack_options.append("C4")
                                        if champion5_hp != 0:
                                            if champion5_play_dead != 0:
                                                pass
                                            else:
                                                ai_attack_options.append("C5")
                                        random.shuffle(ai_attack_options)
                                        if ai_attack_options[0] == "C1":
                                            ai_attack_target = CHAMPION_LIST[0]
                                        if ai_attack_options[0] == "C2":
                                            ai_attack_target = CHAMPION_LIST[1]
                                        if ai_attack_options[0] == "C3":
                                            ai_attack_target = CHAMPION_LIST[2]
                                        if ai_attack_options[0] == "C4":
                                            ai_attack_target = CHAMPION_LIST[3]
                                        if ai_attack_options[0] == "C5":
                                            ai_attack_target = CHAMPION_LIST[4]
                                        ai3_attack_intention = "{} <<< {} ({} Damage)".format(ai_attack_target, ai3_attack[0],
                                                                                                ai3_attack[1])
                                    elif ai3_attack[2] == "2T":
                                        if champion1_hp != 0:
                                            if champion1_play_dead != 0:
                                                pass
                                            else:
                                                ai_attack_options.append("C1")
                                        if champion2_hp != 0:
                                            if champion2_play_dead != 0:
                                                pass
                                            else:
                                                ai_attack_options.append("C2")
                                        if champion3_hp != 0:
                                            if champion3_play_dead != 0:
                                                pass
                                            else:
                                                ai_attack_options.append("C3")
                                        if champion4_hp != 0:
                                            if champion4_play_dead != 0:
                                                pass
                                            else:
                                                ai_attack_options.append("C4")
                                        if champion5_hp != 0:
                                            if champion5_play_dead != 0:
                                                pass
                                            else:
                                                ai_attack_options.append("C5")
                                        random.shuffle(ai_attack_options)
                                        if ai_attack_options[0] == "C1":
                                            ai_attack1_target = CHAMPION_LIST[0]
                                            ai_attack_options.remove("C1")
                                        if ai_attack_options[0] == "C2":
                                            ai_attack1_target = CHAMPION_LIST[1]
                                            ai_attack_options.remove("C2")
                                        if ai_attack_options[0] == "C3":
                                            ai_attack1_target = CHAMPION_LIST[2]
                                            ai_attack_options.remove("C3")
                                        if ai_attack_options[0] == "C4":
                                            ai_attack1_target = CHAMPION_LIST[3]
                                            ai_attack_options.remove("C4")
                                        if ai_attack_options[0] == "C5":
                                            ai_attack1_target = CHAMPION_LIST[4]
                                            ai_attack_options.remove("C5")
                                        random.shuffle(ai_attack_options)
                                        if ai_attack_options[0] == "C1":
                                            ai_attack2_target = CHAMPION_LIST[0]
                                        if ai_attack_options[0] == "C2":
                                            ai_attack2_target = CHAMPION_LIST[1]
                                        if ai_attack_options[0] == "C3":
                                            ai_attack2_target = CHAMPION_LIST[2]
                                        if ai_attack_options[0] == "C4":
                                            ai_attack2_target = CHAMPION_LIST[3]
                                        if ai_attack_options[0] == "C5":
                                            ai_attack2_target = CHAMPION_LIST[4]
                                        ai3_attack_intention = "{} and {} <<< {} ({} Damage)".format(ai_attack1_target, ai_attack2_target,
                                                                                                    ai3_attack[0], ai3_attack[1])
                                else:
                                    pass
                            else:
                                if new_round == 1:
                                    if ai3_attack[2] == "1T":
                                        if champion1_hp != 0:
                                            ai_attack_options.append("C1")
                                        if champion2_hp != 0:
                                            ai_attack_options.append("C2")
                                        if champion3_hp != 0:
                                            ai_attack_options.append("C3")
                                        if champion4_hp != 0:
                                            ai_attack_options.append("C4")
                                        if champion5_hp != 0:
                                            ai_attack_options.append("C5")
                                        random.shuffle(ai_attack_options)
                                        if ai_attack_options[0] == "C1":
                                            ai_attack_target = CHAMPION_LIST[0]
                                        if ai_attack_options[0] == "C2":
                                            ai_attack_target = CHAMPION_LIST[1]
                                        if ai_attack_options[0] == "C3":
                                            ai_attack_target = CHAMPION_LIST[2]
                                        if ai_attack_options[0] == "C4":
                                            ai_attack_target = CHAMPION_LIST[3]
                                        if ai_attack_options[0] == "C5":
                                            ai_attack_target = CHAMPION_LIST[4]
                                        ai3_attack_intention = "{} <<< {} ({} Damage)".format(ai_attack_target, ai3_attack[0],
                                                                                            ai3_attack[1])
                                    if ai3_attack[2] == "2T":
                                        if champion1_hp != 0:
                                            ai_attack_options.append("C1")
                                        if champion2_hp != 0:
                                            ai_attack_options.append("C2")
                                        if champion3_hp != 0:
                                            ai_attack_options.append("C3")
                                        if champion4_hp != 0:
                                            ai_attack_options.append("C4")
                                        if champion5_hp != 0:
                                            ai_attack_options.append("C5")
                                        random.shuffle(ai_attack_options)
                                        if ai_attack_options[0] == "C1":
                                            ai_attack1_target = CHAMPION_LIST[0]
                                            ai_attack_options.remove("C1")
                                        if ai_attack_options[0] == "C2":
                                            ai_attack1_target = CHAMPION_LIST[1]
                                            ai_attack_options.remove("C2")
                                        if ai_attack_options[0] == "C3":
                                            ai_attack1_target = CHAMPION_LIST[2]
                                            ai_attack_options.remove("C3")
                                        if ai_attack_options[0] == "C4":
                                            ai_attack1_target = CHAMPION_LIST[3]
                                            ai_attack_options.remove("C4")
                                        if ai_attack_options[0] == "C5":
                                            ai_attack1_target = CHAMPION_LIST[4]
                                            ai_attack_options.remove("C5")
                                        random.shuffle(ai_attack_options)
                                        if ai_attack_options[0] == "C1":
                                            ai_attack2_target = CHAMPION_LIST[0]
                                        if ai_attack_options[0] == "C2":
                                            ai_attack2_target = CHAMPION_LIST[1]
                                        if ai_attack_options[0] == "C3":
                                            ai_attack2_target = CHAMPION_LIST[2]
                                        if ai_attack_options[0] == "C4":
                                            ai_attack2_target = CHAMPION_LIST[3]
                                        if ai_attack_options[0] == "C5":
                                            ai_attack2_target = CHAMPION_LIST[4]
                                        ai3_attack_intention = "{} and {} <<< {} ({} Damage)".format(ai_attack1_target, ai_attack2_target,
                                                                                                    ai3_attack[0],
                                                                                                    ai3_attack[1])
                                    if ai3_attack[2] == "AOE":
                                        ai3_attack_intention = "Everyone <<< {} ({} Damage)".format(ai3_attack[0], ai3_attack[1])
        if ai4_hp > 0:
            ai_attack_options = []
            if ai4_attack == "null":
                ai4_attack_intention = ""
            else:
                if ai4_stun != 0:
                    ai4_attack_intention = "STUNNED"
                else:
                    if ai4_taunt[1] != 0:
                        ai_attack_target = ai4_taunt[0]
                        ai4_attack_intention = "{} <<< {} ({} Damage)".format(ai_attack_target, ai4_attack[0],
                                                                              ai4_attack[1])
                    else:
                        if "Survivalist" in ai4_attack_intention:
                            if champion1_play_dead == 0:
                                if champion2_play_dead == 0:
                                    if champion3_play_dead == 0:
                                        if champion4_play_dead == 0:
                                            if champion5_play_dead == 0:
                                                playdead_check = 0
                                            else:
                                                played_check = 1
                                        else:
                                            playdead_check = 1
                                    else:
                                        playdead_check = 1
                                else:
                                    playdead_check = 1
                            else:
                                playdead_check = 1
                            if playdead_check == 1:
                                if ai4_attack[2] == "1T":
                                    if champion1_hp != 0:
                                        if champion1_play_dead != 0:
                                            pass
                                        else:
                                            ai_attack_options.append("C1")
                                    if champion2_hp != 0:
                                        if champion2_play_dead != 0:
                                            pass
                                        else:
                                            ai_attack_options.append("C2")
                                    if champion3_hp != 0:
                                        if champion3_play_dead != 0:
                                            pass
                                        else:
                                            ai_attack_options.append("C3")
                                    if champion4_hp != 0:
                                        if champion4_play_dead != 0:
                                            pass
                                        else:
                                            ai_attack_options.append("C4")
                                    if champion5_hp != 0:
                                        if champion5_play_dead != 0:
                                            pass
                                        else:
                                            ai_attack_options.append("C5")
                                    random.shuffle(ai_attack_options)
                                    if ai_attack_options[0] == "C1":
                                        ai_attack_target = CHAMPION_LIST[0]
                                    if ai_attack_options[0] == "C2":
                                        ai_attack_target = CHAMPION_LIST[1]
                                    if ai_attack_options[0] == "C3":
                                        ai_attack_target = CHAMPION_LIST[2]
                                    if ai_attack_options[0] == "C4":
                                        ai_attack_target = CHAMPION_LIST[3]
                                    if ai_attack_options[0] == "C5":
                                        ai_attack_target = CHAMPION_LIST[4]
                                    ai4_attack_intention = "{} <<< {} ({} Damage)".format(ai_attack_target, ai4_attack[0],
                                                                                            ai4_attack[1])
                                elif ai4_attack[2] == "2T":
                                    if champion1_hp != 0:
                                        if champion1_play_dead != 0:
                                            pass
                                        else:
                                            ai_attack_options.append("C1")
                                    if champion2_hp != 0:
                                        if champion2_play_dead != 0:
                                            pass
                                        else:
                                            ai_attack_options.append("C2")
                                    if champion3_hp != 0:
                                        if champion3_play_dead != 0:
                                            pass
                                        else:
                                            ai_attack_options.append("C3")
                                    if champion4_hp != 0:
                                        if champion4_play_dead != 0:
                                            pass
                                        else:
                                            ai_attack_options.append("C4")
                                    if champion5_hp != 0:
                                        if champion5_play_dead != 0:
                                            pass
                                        else:
                                            ai_attack_options.append("C5")
                                    random.shuffle(ai_attack_options)
                                    if ai_attack_options[0] == "C1":
                                        ai_attack1_target = CHAMPION_LIST[0]
                                        ai_attack_options.remove("C1")
                                    if ai_attack_options[0] == "C2":
                                        ai_attack1_target = CHAMPION_LIST[1]
                                        ai_attack_options.remove("C2")
                                    if ai_attack_options[0] == "C3":
                                        ai_attack1_target = CHAMPION_LIST[2]
                                        ai_attack_options.remove("C3")
                                    if ai_attack_options[0] == "C4":
                                        ai_attack1_target = CHAMPION_LIST[3]
                                        ai_attack_options.remove("C4")
                                    if ai_attack_options[0] == "C5":
                                        ai_attack1_target = CHAMPION_LIST[4]
                                        ai_attack_options.remove("C5")
                                    random.shuffle(ai_attack_options)
                                    if ai_attack_options[0] == "C1":
                                        ai_attack2_target = CHAMPION_LIST[0]
                                    if ai_attack_options[0] == "C2":
                                        ai_attack2_target = CHAMPION_LIST[1]
                                    if ai_attack_options[0] == "C3":
                                        ai_attack2_target = CHAMPION_LIST[2]
                                    if ai_attack_options[0] == "C4":
                                        ai_attack2_target = CHAMPION_LIST[3]
                                    if ai_attack_options[0] == "C5":
                                        ai_attack2_target = CHAMPION_LIST[4]
                                    ai4_attack_intention = "{} and {} <<< {} ({} Damage)".format(ai_attack1_target, ai_attack2_target,
                                                                                                ai4_attack[0], ai4_attack[1])
                            else:
                                pass
                        else:
                            if new_round == 1:
                                if ai4_attack[2] == "1T":
                                    if champion1_hp != 0:
                                        ai_attack_options.append("C1")
                                    if champion2_hp != 0:
                                        ai_attack_options.append("C2")
                                    if champion3_hp != 0:
                                        ai_attack_options.append("C3")
                                    if champion4_hp != 0:
                                        ai_attack_options.append("C4")
                                    if champion5_hp != 0:
                                        ai_attack_options.append("C5")
                                    random.shuffle(ai_attack_options)
                                    if ai_attack_options[0] == "C1":
                                        ai_attack_target = CHAMPION_LIST[0]
                                    if ai_attack_options[0] == "C2":
                                        ai_attack_target = CHAMPION_LIST[1]
                                    if ai_attack_options[0] == "C3":
                                        ai_attack_target = CHAMPION_LIST[2]
                                    if ai_attack_options[0] == "C4":
                                        ai_attack_target = CHAMPION_LIST[3]
                                    if ai_attack_options[0] == "C5":
                                        ai_attack_target = CHAMPION_LIST[4]
                                    ai4_attack_intention = "{} <<< {} ({} Damage)".format(ai_attack_target, ai4_attack[0],
                                                                                        ai4_attack[1])
                                if ai4_attack[2] == "2T":
                                    if champion1_hp != 0:
                                        ai_attack_options.append("C1")
                                    if champion2_hp != 0:
                                        ai_attack_options.append("C2")
                                    if champion3_hp != 0:
                                        ai_attack_options.append("C3")
                                    if champion4_hp != 0:
                                        ai_attack_options.append("C4")
                                    if champion5_hp != 0:
                                        ai_attack_options.append("C5")
                                    random.shuffle(ai_attack_options)
                                    if ai_attack_options[0] == "C1":
                                        ai_attack1_target = CHAMPION_LIST[0]
                                        ai_attack_options.remove("C1")
                                    if ai_attack_options[0] == "C2":
                                        ai_attack1_target = CHAMPION_LIST[1]
                                        ai_attack_options.remove("C2")
                                    if ai_attack_options[0] == "C3":
                                        ai_attack1_target = CHAMPION_LIST[2]
                                        ai_attack_options.remove("C3")
                                    if ai_attack_options[0] == "C4":
                                        ai_attack1_target = CHAMPION_LIST[3]
                                        ai_attack_options.remove("C4")
                                    if ai_attack_options[0] == "C5":
                                        ai_attack1_target = CHAMPION_LIST[4]
                                        ai_attack_options.remove("C5")
                                    random.shuffle(ai_attack_options)
                                    if ai_attack_options[0] == "C1":
                                        ai_attack2_target = CHAMPION_LIST[0]
                                    if ai_attack_options[0] == "C2":
                                        ai_attack2_target = CHAMPION_LIST[1]
                                    if ai_attack_options[0] == "C3":
                                        ai_attack2_target = CHAMPION_LIST[2]
                                    if ai_attack_options[0] == "C4":
                                        ai_attack2_target = CHAMPION_LIST[3]
                                    if ai_attack_options[0] == "C5":
                                        ai_attack2_target = CHAMPION_LIST[4]
                                    ai4_attack_intention = "{} and {} <<< {} ({} Damage)".format(ai_attack1_target, ai_attack2_target,
                                                                                                ai4_attack[0],
                                                                                                ai4_attack[1])
                                if ai4_attack[2] == "AOE":
                                    ai4_attack_intention = "Everyone <<< {} ({} Damage)".format(ai4_attack[0], ai4_attack[1])
        if ai5_hp > 0:
            ai_attack_options = []
            if ai5_attack == "null":
                ai5_attack_intention = ""
            else:
                if ai5_stun != 0:
                    ai5_attack_intention = "STUNNED"
                else:
                    if ai5_taunt[1] != 0:
                        ai_attack_target = ai5_taunt[0]
                        ai5_attack_intention = "{} <<< {} ({} Damage)".format(ai_attack_target, ai5_attack[0],
                                                                              ai5_attack[1])
                    else:
                        if "Survivalist" in ai5_attack_intention:
                            if champion1_play_dead == 0:
                                if champion2_play_dead == 0:
                                    if champion3_play_dead == 0:
                                        if champion4_play_dead == 0:
                                            if champion5_play_dead == 0:
                                                playdead_check = 0
                                            else:
                                                played_check = 1
                                        else:
                                            playdead_check = 1
                                    else:
                                        playdead_check = 1
                                else:
                                    playdead_check = 1
                            else:
                                playdead_check = 1
                            if playdead_check == 1:
                                if ai5_attack[2] == "1T":
                                    if champion1_hp != 0:
                                        if champion1_play_dead != 0:
                                            pass
                                        else:
                                            ai_attack_options.append("C1")
                                    if champion2_hp != 0:
                                        if champion2_play_dead != 0:
                                            pass
                                        else:
                                            ai_attack_options.append("C2")
                                    if champion3_hp != 0:
                                        if champion3_play_dead != 0:
                                            pass
                                        else:
                                            ai_attack_options.append("C3")
                                    if champion4_hp != 0:
                                        if champion4_play_dead != 0:
                                            pass
                                        else:
                                            ai_attack_options.append("C4")
                                    if champion5_hp != 0:
                                        if champion5_play_dead != 0:
                                            pass
                                        else:
                                            ai_attack_options.append("C5")
                                    random.shuffle(ai_attack_options)
                                    if ai_attack_options[0] == "C1":
                                        ai_attack_target = CHAMPION_LIST[0]
                                    if ai_attack_options[0] == "C2":
                                        ai_attack_target = CHAMPION_LIST[1]
                                    if ai_attack_options[0] == "C3":
                                        ai_attack_target = CHAMPION_LIST[2]
                                    if ai_attack_options[0] == "C4":
                                        ai_attack_target = CHAMPION_LIST[3]
                                    if ai_attack_options[0] == "C5":
                                        ai_attack_target = CHAMPION_LIST[4]
                                    ai5_attack_intention = "{} <<< {} ({} Damage)".format(ai_attack_target, ai5_attack[0],
                                                                                            ai5_attack[1])
                                elif ai5_attack[2] == "2T":
                                    if champion1_hp != 0:
                                        if champion1_play_dead != 0:
                                            pass
                                        else:
                                            ai_attack_options.append("C1")
                                    if champion2_hp != 0:
                                        if champion2_play_dead != 0:
                                            pass
                                        else:
                                            ai_attack_options.append("C2")
                                    if champion3_hp != 0:
                                        if champion3_play_dead != 0:
                                            pass
                                        else:
                                            ai_attack_options.append("C3")
                                    if champion4_hp != 0:
                                        if champion4_play_dead != 0:
                                            pass
                                        else:
                                            ai_attack_options.append("C4")
                                    if champion5_hp != 0:
                                        if champion5_play_dead != 0:
                                            pass
                                        else:
                                            ai_attack_options.append("C5")
                                    random.shuffle(ai_attack_options)
                                    if ai_attack_options[0] == "C1":
                                        ai_attack1_target = CHAMPION_LIST[0]
                                        ai_attack_options.remove("C1")
                                    if ai_attack_options[0] == "C2":
                                        ai_attack1_target = CHAMPION_LIST[1]
                                        ai_attack_options.remove("C2")
                                    if ai_attack_options[0] == "C3":
                                        ai_attack1_target = CHAMPION_LIST[2]
                                        ai_attack_options.remove("C3")
                                    if ai_attack_options[0] == "C4":
                                        ai_attack1_target = CHAMPION_LIST[3]
                                        ai_attack_options.remove("C4")
                                    if ai_attack_options[0] == "C5":
                                        ai_attack1_target = CHAMPION_LIST[4]
                                        ai_attack_options.remove("C5")
                                    random.shuffle(ai_attack_options)
                                    if ai_attack_options[0] == "C1":
                                        ai_attack2_target = CHAMPION_LIST[0]
                                    if ai_attack_options[0] == "C2":
                                        ai_attack2_target = CHAMPION_LIST[1]
                                    if ai_attack_options[0] == "C3":
                                        ai_attack2_target = CHAMPION_LIST[2]
                                    if ai_attack_options[0] == "C4":
                                        ai_attack2_target = CHAMPION_LIST[3]
                                    if ai_attack_options[0] == "C5":
                                        ai_attack2_target = CHAMPION_LIST[4]
                                    ai5_attack_intention = "{} and {} <<< {} ({} Damage)".format(ai_attack1_target, ai_attack2_target,
                                                                                                ai5_attack[0], ai5_attack[1])
                            else:
                                pass
                        else:
                            if new_round == 1:
                                if ai5_attack[2] == "1T":
                                    if champion1_hp != 0:
                                        ai_attack_options.append("C1")
                                    if champion2_hp != 0:
                                        ai_attack_options.append("C2")
                                    if champion3_hp != 0:
                                        ai_attack_options.append("C3")
                                    if champion4_hp != 0:
                                        ai_attack_options.append("C4")
                                    if champion5_hp != 0:
                                        ai_attack_options.append("C5")
                                    random.shuffle(ai_attack_options)
                                    if ai_attack_options[0] == "C1":
                                        ai_attack_target = CHAMPION_LIST[0]
                                    if ai_attack_options[0] == "C2":
                                        ai_attack_target = CHAMPION_LIST[1]
                                    if ai_attack_options[0] == "C3":
                                        ai_attack_target = CHAMPION_LIST[2]
                                    if ai_attack_options[0] == "C4":
                                        ai_attack_target = CHAMPION_LIST[3]
                                    if ai_attack_options[0] == "C5":
                                        ai_attack_target = CHAMPION_LIST[4]
                                    ai5_attack_intention = "{} <<< {} ({} Damage)".format(ai_attack_target, ai5_attack[0],
                                                                                        ai5_attack[1])
                                if ai5_attack[2] == "2T":
                                    if champion1_hp != 0:
                                        ai_attack_options.append("C1")
                                    if champion2_hp != 0:
                                        ai_attack_options.append("C2")
                                    if champion3_hp != 0:
                                        ai_attack_options.append("C3")
                                    if champion4_hp != 0:
                                        ai_attack_options.append("C4")
                                    if champion5_hp != 0:
                                        ai_attack_options.append("C5")
                                    random.shuffle(ai_attack_options)
                                    if ai_attack_options[0] == "C1":
                                        ai_attack1_target = CHAMPION_LIST[0]
                                        ai_attack_options.remove("C1")
                                    if ai_attack_options[0] == "C2":
                                        ai_attack1_target = CHAMPION_LIST[1]
                                        ai_attack_options.remove("C2")
                                    if ai_attack_options[0] == "C3":
                                        ai_attack1_target = CHAMPION_LIST[2]
                                        ai_attack_options.remove("C3")
                                    if ai_attack_options[0] == "C4":
                                        ai_attack1_target = CHAMPION_LIST[3]
                                        ai_attack_options.remove("C4")
                                    if ai_attack_options[0] == "C5":
                                        ai_attack1_target = CHAMPION_LIST[4]
                                        ai_attack_options.remove("C5")
                                    random.shuffle(ai_attack_options)
                                    if ai_attack_options[0] == "C1":
                                        ai_attack2_target = CHAMPION_LIST[0]
                                    if ai_attack_options[0] == "C2":
                                        ai_attack2_target = CHAMPION_LIST[1]
                                    if ai_attack_options[0] == "C3":
                                        ai_attack2_target = CHAMPION_LIST[2]
                                    if ai_attack_options[0] == "C4":
                                        ai_attack2_target = CHAMPION_LIST[3]
                                    if ai_attack_options[0] == "C5":
                                        ai_attack2_target = CHAMPION_LIST[4]
                                    ai5_attack_intention = "{} and {} <<< {} ({} Damage)".format(ai_attack1_target, ai_attack2_target,
                                                                                                ai5_attack[0],
                                                                                                ai5_attack[1])
                                if ai5_attack[2] == "AOE":
                                    ai5_attack_intention = "Everyone <<< {} ({} Damage)".format(ai5_attack[0], ai5_attack[1])
#Function that creates the main combat UI with the champions to the left and the enemy ai to the right
#The champions buttons are tied to the champion turn functions
    def combat_setup(self):
        global dungeon_game_frame, champion1_combatFrame_stats
        floor_information_dottedLine1 = tk.Label(dungeon_game_frame,
                                                 text="====================================================")
        floor_information_dottedLine2 = tk.Label(dungeon_game_frame,
                                                 text="====================================================")
        floor_information_dottedLine3 = tk.Label(dungeon_game_frame,
                                                 text="====================================================")
        floor_information_dottedLine1.grid(row=0, column=1, sticky="WE")
        floor_information_dottedLine2.grid(row=0, column=2, sticky="WE")
        floor_information_dottedLine3.grid(row=0, column=3, sticky="WE")
        champion1_combatFrame_name = tk.Label(dungeon_game_frame, text=self.champion_combat_name(1))
        champion1_combatFrame_stats = tk.Label(dungeon_game_frame, text=self.champion_combat_status_text(1))
        champion1_combatFrame_statusEffects = tk.Button(dungeon_game_frame, text="Staus Effects", command=lambda:self.display_status_effects("ally", 1))
        champion2_combatFrame_name = tk.Label(dungeon_game_frame, text=self.champion_combat_name(2))
        champion2_combatFrame_stats = tk.Label(dungeon_game_frame, text=self.champion_combat_status_text(2))
        champion2_combatFrame_statusEffects = tk.Button(dungeon_game_frame, text="Staus Effects", command=lambda:self.display_status_effects("ally", 2))
        champion3_combatFrame_name = tk.Label(dungeon_game_frame, text=self.champion_combat_name(3))
        champion3_combatFrame_stats = tk.Label(dungeon_game_frame, text=self.champion_combat_status_text(3))
        champion3_combatFrame_statusEffects = tk.Button(dungeon_game_frame, text="Staus Effects", command=lambda:self.display_status_effects("ally", 3))
        champion4_combatFrame_name = tk.Label(dungeon_game_frame, text=self.champion_combat_name(4))
        champion4_combatFrame_stats = tk.Label(dungeon_game_frame, text=self.champion_combat_status_text(4))
        champion4_combatFrame_statusEffects = tk.Button(dungeon_game_frame, text="Staus Effects", command=lambda:self.display_status_effects("ally", 4))
        champion5_combatFrame_name = tk.Label(dungeon_game_frame, text=self.champion_combat_name(5))
        champion5_combatFrame_stats = tk.Label(dungeon_game_frame, text=self.champion_combat_status_text(5))
        champion5_combatFrame_statusEffects = tk.Button(dungeon_game_frame, text="Staus Effects", command=lambda:self.display_status_effects("ally", 5))
        champion_CLF_dottedLine_label2 = tk.Label(dungeon_game_frame, text="----------------")
        champion_CLF_dottedLine_label3 = tk.Label(dungeon_game_frame, text="----------------")
        champion_CLF_dottedLine_label4 = tk.Label(dungeon_game_frame, text="----------------")
        champion_CLF_dottedLine_label5 = tk.Label(dungeon_game_frame, text="----------------")
        champion_CLF_dottedLine_label2.grid(row=3, column=1, sticky="w")
        champion_CLF_dottedLine_label3.grid(row=6, column=1, sticky="w")
        champion_CLF_dottedLine_label4.grid(row=9, column=1, sticky="w")
        champion_CLF_dottedLine_label5.grid(row=12, column=1, sticky="w")
        champion1_combatFrame_name.grid(row=1, column=1, sticky="w")
        champion1_combatFrame_stats.grid(row=2, column=1, sticky="w")
        champion1_combatFrame_statusEffects.grid(row=1, column=1)
        champion2_combatFrame_name.grid(row=4, column=1, sticky="w")
        champion2_combatFrame_stats.grid(row=5, column=1, sticky="w")
        champion2_combatFrame_statusEffects.grid(row=4, column=1)
        champion3_combatFrame_name.grid(row=7, column=1, sticky="w")
        champion3_combatFrame_stats.grid(row=8, column=1, sticky="w")
        champion3_combatFrame_statusEffects.grid(row=7, column=1)
        champion4_combatFrame_name.grid(row=10, column=1, sticky="w")
        champion4_combatFrame_stats.grid(row=11, column=1, sticky="w")
        champion4_combatFrame_statusEffects.grid(row=10, column=1)
        champion5_combatFrame_name.grid(row=13, column=1, sticky="w")
        champion5_combatFrame_stats.grid(row=14, column=1, sticky="w")
        champion5_combatFrame_statusEffects.grid(row=13, column=1)
        champion_interaction_dottedLine1 = tk.Label(dungeon_game_frame,
                                                    text="====================================================")
        champion_interaction_dottedLine2 = tk.Label(dungeon_game_frame,
                                                    text="====================================================")
        champion_interaction_dottedLine3 = tk.Label(dungeon_game_frame,
                                                    text="====================================================")
        champion_interaction_dottedLine1.grid(row=16, column=1, sticky="WE")
        champion_interaction_dottedLine2.grid(row=16, column=2, sticky="WE")
        champion_interaction_dottedLine3.grid(row=16, column=3, sticky="WE")
        champion_interaction_currentturn_button = tk.Label(dungeon_game_frame, text=self.current_champions_turn_text())
        champion_interaction_currentturn_button.grid(row=17, column=2)
        if AI_SPAWNED == 1:
            ai1_combatFrame_stats = tk.Label(dungeon_game_frame, text=self.ai_combat_status_text(1))
            ai1_combatFrame_name = tk.Label(dungeon_game_frame, text=self.ai_combat_name(1))
            AI_CLF_dottedLine_label2 = tk.Label(dungeon_game_frame, text="----------------")
            if ai1_hp != 0:
                ai1_intended_attack_label = tk.Label(dungeon_game_frame, text=ai1_attack_intention)
                ai1_intended_attack_label.grid(row=7, column=2, sticky="e")
                ai1_combatFrame_statusEffects = tk.Button(dungeon_game_frame, text="Staus Effects",
                                                          command=lambda: self.display_status_effects("enemy", 1))
                ai1_combatFrame_statusEffects.grid(row=7, column=3, sticky="w")
            ai1_combatFrame_name.grid(row=7, column=3, sticky="e")
            ai1_combatFrame_stats.grid(row=8, column=3, sticky="e")
            AI_CLF_dottedLine_label2.grid(row=9, column=3, sticky="e")
        elif AI_SPAWNED == 2:
            ai1_combatFrame_stats = tk.Label(dungeon_game_frame, text=self.ai_combat_status_text(1))
            ai1_combatFrame_name = tk.Label(dungeon_game_frame, text=self.ai_combat_name(1))
            ai1_combatFrame_name.grid(row=4, column=3, sticky="e")
            ai1_combatFrame_stats.grid(row=5, column=3, sticky="e")
            ai2_combatFrame_stats = tk.Label(dungeon_game_frame, text=self.ai_combat_status_text(2))
            ai2_combatFrame_name = tk.Label(dungeon_game_frame, text=self.ai_combat_name(2))
            ai2_combatFrame_name.grid(row=7, column=3, sticky="e")
            ai2_combatFrame_stats.grid(row=8, column=3, sticky="e")
            AI_CLF_dottedLine_label2 = tk.Label(dungeon_game_frame, text="----------------")
            AI_CLF_dottedLine_label3 = tk.Label(dungeon_game_frame, text="----------------")
            if ai1_hp != 0:
                ai1_intended_attack_label = tk.Label(dungeon_game_frame, text=ai1_attack_intention)
                ai1_intended_attack_label.grid(row=4, column=2, sticky="e")
                ai1_combatFrame_statusEffects = tk.Button(dungeon_game_frame, text="Staus Effects",
                                                          command=lambda: self.display_status_effects("enemy", 1))
                ai1_combatFrame_statusEffects.grid(row=4, column=3, sticky="w")
            if ai2_hp != 0:
                ai2_intended_attack_label = tk.Label(dungeon_game_frame, text=ai2_attack_intention)
                ai2_intended_attack_label.grid(row=7, column=2, sticky="e")
                ai2_combatFrame_statusEffects = tk.Button(dungeon_game_frame, text="Staus Effects",
                                                          command=lambda: self.display_status_effects("enemy", 2))
                ai2_combatFrame_statusEffects.grid(row=7, column=3, sticky="w")
            AI_CLF_dottedLine_label2.grid(row=6, column=3, sticky="e")
            AI_CLF_dottedLine_label3.grid(row=9, column=3, sticky="e")
        elif AI_SPAWNED == 3:
            ai1_combatFrame_stats = tk.Label(dungeon_game_frame, text=self.ai_combat_status_text(1))
            ai1_combatFrame_name = tk.Label(dungeon_game_frame, text=self.ai_combat_name(1))
            ai1_combatFrame_name.grid(row=4, column=3, sticky="e")
            ai1_combatFrame_stats.grid(row=5, column=3, sticky="e")
            ai2_combatFrame_stats = tk.Label(dungeon_game_frame, text=self.ai_combat_status_text(2))
            ai2_combatFrame_name = tk.Label(dungeon_game_frame, text=self.ai_combat_name(2))
            ai2_combatFrame_name.grid(row=7, column=3, sticky="e")
            ai2_combatFrame_stats.grid(row=8, column=3, sticky="e")
            ai3_combatFrame_stats = tk.Label(dungeon_game_frame, text=self.ai_combat_status_text(3))
            ai3_combatFrame_name = tk.Label(dungeon_game_frame, text=self.ai_combat_name(3))
            ai3_combatFrame_name.grid(row=10, column=3, sticky="e")
            ai3_combatFrame_stats.grid(row=11, column=3, sticky="e")
            AI_CLF_dottedLine_label2 = tk.Label(dungeon_game_frame, text="----------------")
            AI_CLF_dottedLine_label3 = tk.Label(dungeon_game_frame, text="----------------")
            if ai1_hp != 0:
                ai1_intended_attack_label = tk.Label(dungeon_game_frame, text=ai1_attack_intention)
                ai1_intended_attack_label.grid(row=4, column=2, sticky="e")
                ai1_combatFrame_statusEffects = tk.Button(dungeon_game_frame, text="Staus Effects",
                                                          command=lambda: self.display_status_effects("enemy", 1))
                ai1_combatFrame_statusEffects.grid(row=4, column=3, sticky="w")
            if ai2_hp != 0:
                ai2_intended_attack_label = tk.Label(dungeon_game_frame, text=ai2_attack_intention)
                ai2_intended_attack_label.grid(row=7, column=2, sticky="e")
                ai2_combatFrame_statusEffects = tk.Button(dungeon_game_frame, text="Staus Effects",
                                                          command=lambda: self.display_status_effects("enemy", 2))
                ai2_combatFrame_statusEffects.grid(row=7, column=3, sticky="w")
            if ai3_hp != 0:
                ai3_intended_attack_label = tk.Label(dungeon_game_frame, text=ai3_attack_intention)
                ai3_intended_attack_label.grid(row=10, column=2, sticky="e")
                ai3_combatFrame_statusEffects = tk.Button(dungeon_game_frame, text="Staus Effects",
                                                          command=lambda: self.display_status_effects("enemy", 3))
                ai3_combatFrame_statusEffects.grid(row=10, column=3, sticky="w")
            AI_CLF_dottedLine_label2.grid(row=6, column=3, sticky="e")
            AI_CLF_dottedLine_label3.grid(row=9, column=3, sticky="e")
        elif AI_SPAWNED == 4:
            ai1_combatFrame_stats = tk.Label(dungeon_game_frame, text=self.ai_combat_status_text(1))
            ai1_combatFrame_name = tk.Label(dungeon_game_frame, text=self.ai_combat_name(1))
            ai1_combatFrame_name.grid(row=1, column=3, sticky="e")
            ai1_combatFrame_stats.grid(row=2, column=3, sticky="e")
            ai2_combatFrame_stats = tk.Label(dungeon_game_frame, text=self.ai_combat_status_text(2))
            ai2_combatFrame_name = tk.Label(dungeon_game_frame, text=self.ai_combat_name(2))
            ai2_combatFrame_name.grid(row=4, column=3, sticky="e")
            ai2_combatFrame_stats.grid(row=5, column=3, sticky="e")
            ai3_combatFrame_stats = tk.Label(dungeon_game_frame, text=self.ai_combat_status_text(3))
            ai3_combatFrame_name = tk.Label(dungeon_game_frame, text=self.ai_combat_name(3))
            ai3_combatFrame_name.grid(row=7, column=3, sticky="e")
            ai3_combatFrame_stats.grid(row=8, column=3, sticky="e")
            ai4_combatFrame_stats = tk.Label(dungeon_game_frame, text=self.ai_combat_status_text(4))
            ai4_combatFrame_name = tk.Label(dungeon_game_frame, text=self.ai_combat_name(4))
            ai4_combatFrame_name.grid(row=10, column=3, sticky="e")
            ai4_combatFrame_stats.grid(row=11, column=3, sticky="e")
            AI_CLF_dottedLine_label2 = tk.Label(dungeon_game_frame, text="----------------")
            AI_CLF_dottedLine_label3 = tk.Label(dungeon_game_frame, text="----------------")
            AI_CLF_dottedLine_label4 = tk.Label(dungeon_game_frame, text="----------------")
            if ai1_hp != 0:
                ai1_intended_attack_label = tk.Label(dungeon_game_frame, text=ai1_attack_intention)
                ai1_intended_attack_label.grid(row=1, column=2, sticky="e")
                ai1_combatFrame_statusEffects = tk.Button(dungeon_game_frame, text="Staus Effects",
                                                          command=lambda: self.display_status_effects("enemy", 1))
                ai1_combatFrame_statusEffects.grid(row=1, column=3, sticky="w")
            if ai2_hp != 0:
                ai2_intended_attack_label = tk.Label(dungeon_game_frame, text=ai2_attack_intention)
                ai2_intended_attack_label.grid(row=4, column=2, sticky="e")
                ai2_combatFrame_statusEffects = tk.Button(dungeon_game_frame, text="Staus Effects",
                                                          command=lambda: self.display_status_effects("enemy", 2))
                ai2_combatFrame_statusEffects.grid(row=4, column=3, sticky="w")
            if ai3_hp != 0:
                ai3_intended_attack_label = tk.Label(dungeon_game_frame, text=ai3_attack_intention)
                ai3_intended_attack_label.grid(row=7, column=2, sticky="e")
                ai3_combatFrame_statusEffects = tk.Button(dungeon_game_frame, text="Staus Effects",
                                                          command=lambda: self.display_status_effects("enemy", 3))
                ai3_combatFrame_statusEffects.grid(row=7, column=3, sticky="w")
            if ai4_hp != 0:
                ai4_intended_attack_label = tk.Label(dungeon_game_frame, text=ai4_attack_intention)
                ai4_intended_attack_label.grid(row=10, column=2, sticky="e")
                ai4_combatFrame_statusEffects = tk.Button(dungeon_game_frame, text="Staus Effects",
                                                          command=lambda: self.display_status_effects("enemy", 4))
                ai4_combatFrame_statusEffects.grid(row=10, column=3, sticky="w")
            AI_CLF_dottedLine_label2.grid(row=3, column=3, sticky="e")
            AI_CLF_dottedLine_label3.grid(row=6, column=3, sticky="e")
            AI_CLF_dottedLine_label4.grid(row=9, column=3, sticky="e")
        elif AI_SPAWNED == 5:
            ai1_combatFrame_stats = tk.Label(dungeon_game_frame, text=self.ai_combat_status_text(1))
            ai1_combatFrame_name = tk.Label(dungeon_game_frame, text=self.ai_combat_name(1))
            ai1_combatFrame_name.grid(row=1, column=3, sticky="e")
            ai1_combatFrame_stats.grid(row=2, column=3, sticky="e")
            ai2_combatFrame_stats = tk.Label(dungeon_game_frame, text=self.ai_combat_status_text(2))
            ai2_combatFrame_name = tk.Label(dungeon_game_frame, text=self.ai_combat_name(2))
            ai2_combatFrame_name.grid(row=4, column=3, sticky="e")
            ai2_combatFrame_stats.grid(row=5, column=3, sticky="e")
            ai3_combatFrame_stats = tk.Label(dungeon_game_frame, text=self.ai_combat_status_text(3))
            ai3_combatFrame_name = tk.Label(dungeon_game_frame, text=self.ai_combat_name(3))
            ai3_combatFrame_name.grid(row=7, column=3, sticky="e")
            ai3_combatFrame_stats.grid(row=8, column=3, sticky="e")
            ai4_combatFrame_stats = tk.Label(dungeon_game_frame, text=self.ai_combat_status_text(4))
            ai4_combatFrame_name = tk.Label(dungeon_game_frame, text=self.ai_combat_name(4))
            ai4_combatFrame_name.grid(row=10, column=3, sticky="e")
            ai4_combatFrame_stats.grid(row=11, column=3, sticky="e")
            ai5_combatFrame_stats = tk.Label(dungeon_game_frame, text=self.ai_combat_status_text(5))
            ai5_combatFrame_name = tk.Label(dungeon_game_frame, text=self.ai_combat_name(5))
            ai5_combatFrame_name.grid(row=13, column=3, sticky="e")
            ai5_combatFrame_stats.grid(row=14, column=3, sticky="e")
            AI_CLF_dottedLine_label2 = tk.Label(dungeon_game_frame, text="----------------")
            AI_CLF_dottedLine_label3 = tk.Label(dungeon_game_frame, text="----------------")
            AI_CLF_dottedLine_label4 = tk.Label(dungeon_game_frame, text="----------------")
            AI_CLF_dottedLine_label5 = tk.Label(dungeon_game_frame, text="----------------")
            if ai1_hp != 0:
                ai1_intended_attack_label = tk.Label(dungeon_game_frame, text=ai1_attack_intention)
                ai1_intended_attack_label.grid(row=1, column=2, sticky="e")
                ai1_combatFrame_statusEffects = tk.Button(dungeon_game_frame, text="Staus Effects",
                                                          command=lambda: self.display_status_effects("enemy", 1))
                ai1_combatFrame_statusEffects.grid(row=1, column=3, sticky="w")
            if ai2_hp != 0:
                ai2_intended_attack_label = tk.Label(dungeon_game_frame, text=ai2_attack_intention)
                ai2_intended_attack_label.grid(row=4, column=2, sticky="e")
                ai2_combatFrame_statusEffects = tk.Button(dungeon_game_frame, text="Staus Effects",
                                                          command=lambda: self.display_status_effects("enemy", 2))
                ai2_combatFrame_statusEffects.grid(row=4, column=3, sticky="w")
            if ai3_hp != 0:
                ai3_intended_attack_label = tk.Label(dungeon_game_frame, text=ai3_attack_intention)
                ai3_intended_attack_label.grid(row=7, column=2, sticky="e")
                ai3_combatFrame_statusEffects = tk.Button(dungeon_game_frame, text="Staus Effects",
                                                          command=lambda: self.display_status_effects("enemy", 3))
                ai3_combatFrame_statusEffects.grid(row=7, column=3, sticky="w")
            if ai4_hp != 0:
                ai4_intended_attack_label = tk.Label(dungeon_game_frame, text=ai4_attack_intention)
                ai4_intended_attack_label.grid(row=10, column=2, sticky="e")
                ai4_combatFrame_statusEffects = tk.Button(dungeon_game_frame, text="Staus Effects",
                                                          command=lambda: self.display_status_effects("enemy", 4))
                ai4_combatFrame_statusEffects.grid(row=10, column=3, sticky="w")
            if ai5_hp != 0:
                ai5_intended_attack_label = tk.Label(dungeon_game_frame, text=ai5_attack_intention)
                ai5_intended_attack_label.grid(row=13, column=2, sticky="e")
                ai5_combatFrame_statusEffects = tk.Button(dungeon_game_frame, text="Staus Effects",
                                                          command=lambda: self.display_status_effects("enemy", 5))
                ai5_combatFrame_statusEffects.grid(row=13, column=3, sticky="w")
            AI_CLF_dottedLine_label2.grid(row=3, column=3, sticky="e")
            AI_CLF_dottedLine_label3.grid(row=6, column=3, sticky="e")
            AI_CLF_dottedLine_label4.grid(row=9, column=3, sticky="e")
            AI_CLF_dottedLine_label5.grid(row=12, column=3, sticky="e")
#Returns the name text of champions and whether they are alive or dead
    def champion_combat_name(self, champion_position):
        global champion1_hp, champion2_hp, champion3_hp, champion4_hp, champion5_hp
        name_text = ""
        if champion_position == 1:
            if champion1_hp < 0:
                champion1_hp = 0
            if champion1_hp == 0:
                name_text = "{} *DEAD*".format(CHAMPION_LIST[0])
                return name_text
            else:
                name_text = "{}".format(CHAMPION_LIST[0])
                return name_text
        if champion_position == 2:
            if champion2_hp < 0:
                champion2_hp = 0
            if champion2_hp == 0:
                name_text = "{} *DEAD*".format(CHAMPION_LIST[1])
                return name_text
            else:
                name_text = "{}".format(CHAMPION_LIST[1])
                return name_text
        if champion_position == 3:
            if champion3_hp < 0:
                champion3_hp = 0
            if champion3_hp == 0:
                name_text = "{} *DEAD*".format(CHAMPION_LIST[2])
                return name_text
            else:
                name_text = "{}".format(CHAMPION_LIST[2])
                return name_text
        if champion_position == 4:
            if champion4_hp < 0:
                champion4_hp = 0
            if champion4_hp == 0:
                name_text = "{} *DEAD*".format(CHAMPION_LIST[3])
                return name_text
            else:
                name_text = "{}".format(CHAMPION_LIST[3])
                return name_text
        if champion_position == 5:
            if champion5_hp < 0:
                champion5_hp = 0
            if champion5_hp == 0:
                name_text = "{} *DEAD*".format(CHAMPION_LIST[4])
                return name_text
            else:
                name_text = "{}".format(CHAMPION_LIST[4])
                return name_text
#Returns the visual status of champions current health total
#Also shows their resource points if they have any
    def champion_combat_status_text(self, champion_position):
        global champion1_rp, champion2_rp, champion3_rp, champion4_rp, champion5_rp
        if champion_position == 1:
            if CHAMPION1_RPNAME == "null":
                status_text = "Health Points: {}/{}".format(champion1_hp, CHAMPION1_HP)
                return status_text
            else:
                if champion1_rp > CHAMPION1_RP:
                    champion1_rp = CHAMPION1_RP
                status_text = "Health Points: {}/{}\n{}: {}/{}".format(champion1_hp, CHAMPION1_HP, CHAMPION1_RPNAME,
                                                                       champion1_rp, CHAMPION1_RP)
                return status_text
        if champion_position == 2:
            if CHAMPION2_RPNAME == "null":
                status_text = "Health Points: {}/{}".format(champion2_hp, CHAMPION2_HP)
                return status_text
            else:
                if champion2_rp > CHAMPION2_RP:
                    champion2_rp = CHAMPION2_RP
                status_text = "Health Points: {}/{}\n{}: {}/{}".format(champion2_hp, CHAMPION2_HP, CHAMPION2_RPNAME,
                                                                       champion2_rp, CHAMPION2_RP)
                return status_text
        if champion_position == 3:
            if CHAMPION3_RPNAME == "null":
                status_text = "Health Points: {}/{}".format(champion3_hp, CHAMPION3_HP)
                return status_text
            else:
                if champion3_rp > CHAMPION3_RP:
                    champion3_rp = CHAMPION3_RP
                status_text = "Health Points: {}/{}\n{}: {}/{}".format(champion3_hp, CHAMPION3_HP, CHAMPION3_RPNAME,
                                                                       champion3_rp, CHAMPION3_RP)
                return status_text
        if champion_position == 4:
            if CHAMPION4_RPNAME == "null":
                status_text = "Health Points: {}/{}".format(champion4_hp, CHAMPION4_HP)
                return status_text
            else:
                if champion4_rp > CHAMPION4_RP:
                    champion4_rp = CHAMPION4_RP
                status_text = "Health Points: {}/{}\n{}: {}/{}".format(champion4_hp, CHAMPION4_HP, CHAMPION4_RPNAME,
                                                                       champion4_rp, CHAMPION4_RP)
                return status_text
        if champion_position == 5:
            if CHAMPION5_RPNAME == "null":
                status_text = "Health Points: {}/{}".format(champion5_hp, CHAMPION5_HP)
                return status_text
            else:
                if champion5_rp > CHAMPION5_RP:
                    champion5_rp = CHAMPION5_RP
                status_text = "Health Points: {}/{}\n{}: {}/{}".format(champion5_hp, CHAMPION5_HP, CHAMPION5_RPNAME,
                                                                       champion5_rp, CHAMPION5_RP)
                return status_text
#Returns the name text of enemies and whether they are alive or dead
    def ai_combat_name(self, ai_postion):
        if ai_postion == 1:
            if AI_SPAWNED == 1:
                if ai1_hp == 0:
                    name_text = "*DEAD* {}".format(AI_NAME)
                    return name_text
                else:
                    name_text = "{}".format(AI_NAME)
                    return name_text
            else:
                if ai1_hp == 0:
                    name_text = "*DEAD* {}#1".format(AI_NICKNAME)
                    return name_text
                else:
                    name_text = "{}#1".format(AI_NICKNAME)
                    return name_text
        if ai_postion == 2:
            if ai2_hp == 0:
                name_text = "*DEAD* {}#2".format(AI_NICKNAME)
                return name_text
            else:
                name_text = "{}#2".format(AI_NICKNAME)
                return name_text
        if ai_postion == 3:
            if ai3_hp == 0:
                name_text = "*DEAD* {}#3".format(AI_NICKNAME)
                return name_text
            else:
                name_text = "{}#3".format(AI_NICKNAME)
                return name_text
        if ai_postion == 4:
            if ai4_hp == 0:
                name_text = "*DEAD* {}#4".format(AI_NICKNAME)
                return name_text
            else:
                name_text = "{}#4".format(AI_NICKNAME)
                return name_text
        if ai_postion == 5:
            if ai5_hp == 0:
                name_text = "*DEAD* {}#5".format(AI_NICKNAME)
                return name_text
            else:
                name_text = "{}#5".format(AI_NICKNAME)
                return name_text
#Returns the visual status of enemies current health total
#Also shows their resource points if they have any
    def ai_combat_status_text(self, ai_position):
        global ai1_hp, ai2_hp, ai3_hp, ai4_hp, ai5_hp
        if ai_position == 1:
            if ai1_hp <= 0:
                ai1_hp = 0
            if AI_RESOURCE_NAME == "null":
                status_text = "Health Points: {}/{}".format(ai1_hp, ai1_max_hp)
                return status_text
            else:
                status_text = "Health Points: {}/{}\n{}: {}/{}".format(ai1_hp, ai1_max_hp, AI_RESOURCE_NAME, ai1_rp,
                                                                       AI_RESOURCE)
                return status_text
        if ai_position == 2:
            if ai2_hp <= 0:
                ai2_hp = 0
            if AI_RESOURCE_NAME == "null":
                status_text = "Health Points: {}/{}".format(ai2_hp, ai2_max_hp)
                return status_text
            else:
                status_text = "Health Points: {}/{}\n{}: {}/{}".format(ai2_hp, ai2_max_hp, AI_RESOURCE_NAME, ai2_rp,
                                                                       AI_RESOURCE)
                return status_text
        if ai_position == 3:
            if ai3_hp <= 0:
                ai3_hp = 0
            if AI_RESOURCE_NAME == "null":
                status_text = "Health Points: {}/{}".format(ai3_hp, ai3_max_hp)
                return status_text
            else:
                status_text = "Health Points: {}/{}\n{}: {}/{}".format(ai3_hp, ai3_max_hp, AI_RESOURCE_NAME, ai3_rp,
                                                                       AI_RESOURCE)
                return status_text
        if ai_position == 4:
            if ai4_hp <= 0:
                ai4_hp = 0
            if AI_RESOURCE_NAME == "null":
                status_text = "Health Points: {}/{}".format(ai4_hp, ai4_max_hp)
                return status_text
            else:
                status_text = "Health Points: {}/{}\n{}: {}/{}".format(ai4_hp, ai4_max_hp, AI_RESOURCE_NAME, ai4_rp,
                                                                       AI_RESOURCE)
                return status_text
        if ai_position == 5:
            if ai5_hp <= 0:
                ai5_hp = 0
            if AI_RESOURCE_NAME == "null":
                status_text = "Health Points: {}/{}".format(ai5_hp, ai5_max_hp)
                return status_text
            else:
                status_text = "Health Points: {}/{}\n{}: {}/{}".format(ai5_hp, ai5_max_hp, AI_RESOURCE_NAME, ai5_rp,
                                                                       AI_RESOURCE)
                return status_text
#Pop-up window that displays the current status effects of whoevers button the player pressed
#Example1: ('AllyOrEnemy' = "ally" and 'position' = "2") = shows the status effects of champion 2
#Example2:('AllyOrEnemy' = "enemy" and 'position' = "4") = shows the status effects of enemy ai 4
#Status effects have been split up into different catagories, if the character doesn't have a status effect that is in a certain catagory then it's title won't appear (to reduce clutter)
#Each status effect that is displayed has its name and an attached number thats purpose is attuned to the catagory its under 
#Example1: (:Defensive Catagory: > 'Status_Effect1 [+30%]') =   Status_Effect1 reduces damage taken by 30%
#Some status effects with numbers like those under the champion abilities are just the amount of stacks of that effect the character has
#Passive names are also shown for their respective champion
#Mostly common intuition and the understanding of the ability and its effects (through 'View Deatils') will help with knowing whats what
    def display_status_effects(self, AllyOrEnemy, position):
        root = tk.Tk()
        effects_list = []
        character_name = ""
        if AllyOrEnemy == "ally":
            character_name = "Champion"
        elif AllyOrEnemy == "enemy":
            character_name = "Enemy"
        characters_status_effect_label = tk.Label(root, text="{} {}'s Current Status Effects".format(character_name, position))
        characters_status_effect_label.grid(row=1,column=1)
        if AllyOrEnemy == "ally":
            ca_display_trigger = 0
            dab_display_trigger = 0
            deb_display_trigger = 0
            hb_display_trigger = 0
            if position == 1:
                effects_list.append(":Passive:")
                if CHAMPION_LIST[0] == MONK.title:
                    effects_list.append(MONK.passive)
                if CHAMPION_LIST[0] == BARBARIAN.title:
                    effects_list.append(BARBARIAN.passive)
                if CHAMPION_LIST[0] == KINGS_GUARD.title:
                    effects_list.append(KINGS_GUARD.passive)
                if KINGS_GUARD.title in CHAMPION_LIST:
                    if champion1_fortification != 0:
                        deb_display_trigger = 1
                if CHAMPION_LIST[0] == MASTER_FENCER.title:
                    effects_list.append(MASTER_FENCER.passive)
                if CHAMPION_LIST[0] == BERSERKER.title:
                    effects_list.append(BERSERKER.passive)
                    if champion1_pure_rage != 0:
                        ca_display_trigger = 1
                    if reckless_flurry_buff != 0:
                        ca_display_trigger = 1
                if CHAMPION_LIST[0] == ROGUE.title:
                    effects_list.append(ROGUE.passive)
                if CHAMPION_LIST[0] == SURVIVALIST.title:
                    effects_list.append(SURVIVALIST.passive)
                    if champion1_play_dead != 0:
                        ca_display_trigger = 1
                    if prepare_buff != 0:
                        ca_display_trigger = 1
                if CHAMPION_LIST[0] == BRAWLIST.title:
                    effects_list.append(BRAWLIST.passive)
                if CHAMPION_LIST[0] == ACADEMIC_MAGE.title:
                    effects_list.append(ACADEMIC_MAGE.passive)
                    if champion1_magical_barrier != 0:
                        ca_display_trigger = 1
                if CHAMPION_LIST[0] == DRUID.title:
                    effects_list.append(DRUID.passive)
                if DRUID.title in CHAMPION_LIST:
                    if champion1_bush_armour != 0:
                        deb_display_trigger = 1
                if CHAMPION_LIST[0] == WARLOCK.title:
                    effects_list.append(WARLOCK.passive)
                    if void_infusion_stacks != 0:
                        ca_display_trigger = 1
                if CHAMPION_LIST[0] == BLOODMANCER.title:
                    effects_list.append(BLOODMANCER.passive)
                    if blood_boil_buff != 0:
                        ca_display_trigger = 1
                    if channeling_strength == 1:
                        ca_display_trigger = 1
                if BLOODMANCER.title in CHAMPION_LIST:
                    if champion1_enhardened_nerves != 0:
                        deb_display_trigger = 1
                if CHAMPION_LIST[0] == PALADIN.title:
                    effects_list.append(PALADIN.passive)
                if PALADIN.title in CHAMPION_LIST:
                    if paladin_aura == 1:
                        dab_display_trigger = 1
                    if paladin_aura == 2:
                        deb_display_trigger = 1
                    if holywrath_multiplier != 0:
                        ca_display_trigger = 1
                if CHAMPION_LIST[0] == LEGION_RANGER.title:
                    effects_list.append(LEGION_RANGER.passive)
                    ca_display_trigger = 1
                if CHAMPION_LIST[0] == MAGNETIMANCER.title:
                    effects_list.append(MAGNETIMANCER.passive)
                    if energised != 0:
                        ca_display_trigger = 1
                if CHAMPION_LIST[0] == POWER_CONDUIT.title:
                    effects_list.append(POWER_CONDUIT.passive)
                if POWER_CONDUIT.title in CHAMPION_LIST:
                    if champion1_muscleEnlarger != 0:
                        dab_display_trigger = 1
                    if champion1_fullPotential != 0:
                        dab_display_trigger = 1
                if CHAMPION_LIST[0] == EARTH_SPEAKER.title:
                    effects_list.append(EARTH_SPEAKER.passive)
                if EARTH_SPEAKER.title in CHAMPION_LIST:
                    if champion1_springwaters[1] != 0:
                        hb_display_trigger = 1
                    if champion1_oceantide[1] != 0:
                        hb_display_trigger = 1
                if CHAMPION_LIST[0] == TIME_WALKER.title:
                    effects_list.append(TIME_WALKER.passive)
                if TIME_WALKER.title in CHAMPION_LIST:
                    hb_display_trigger = 1
                if CHAMPION_LIST[0] == PRIEST.title:
                    effects_list.append(PRIEST.passive)
                if PRIEST.title in CHAMPION_LIST:
                    if champion1_blessing != 0:
                        hb_display_trigger = 1
                if CHAMPION_LIST[0] == FIELD_MEDIC.title:
                    effects_list.append(FIELD_MEDIC.passive)
                if FIELD_MEDIC.title in CHAMPION_LIST:
                    if champion1_strongremedy != 0:
                        dab_display_trigger = 1
                    if champion1_weakremedy != 0:
                        dab_display_trigger = 1
                    if champion1_tighttourniquet != 0:
                        deb_display_trigger = 1
                    if champion1_weaktourniquet != 0:
                        deb_display_trigger = 1
                    if champion1_bandaged[1] != 0:
                        hb_display_trigger = 1
                if ca_display_trigger == 1:
                    effects_list.append(":Champion Abilties:")
                    if CHAMPION_LIST[0] == BERSERKER.title:
                        if champion1_pure_rage != 0:
                            effects_list.append("Damage[+50%]: Pure Rage ({})".format(champion1_pure_rage))
                        if reckless_flurry_buff != 0:
                            effects_list.append("Reckless Flurry [{}]".format(reckless_flurry_buff))
                    if CHAMPION_LIST[0] == ACADEMIC_MAGE.title:
                        if champion1_magical_barrier != 0:
                            effects_list.append('Magical Barrier [{}]'.format(champion1_magical_barrier))
                    if CHAMPION_LIST[0] == WARLOCK.title:
                        if void_infusion_stacks != 0:
                            effects_list.append("Void Infused [{}]".format(void_infusion_stacks))
                    if CHAMPION_LIST[0] == BLOODMANCER.title:
                        if blood_boil_buff != 0:
                            effects_list.append("Blood Boiling")
                        if channeling_strength == 1:
                            effects_list.append("channeling Strength")
                    if CHAMPION_LIST[0] == PALADIN.title:
                        if holywrath_multiplier != 0:
                            effects_list.append("Next Holy Wrath [+{}%]".format(holywrath_multiplier*20))
                    if CHAMPION_LIST[0] == LEGION_RANGER.title:
                        effects_list.append("{}".format(current_arrow_type))
                    if CHAMPION_LIST[0] == SURVIVALIST.title:
                        if prepare_buff != 0:
                            effects_list.append("Damage[+50%]: Prepared")
                        if champion1_play_dead != 0:
                            effects_list.append("Playing Dead")
                    if CHAMPION_LIST[0] == MAGNETIMANCER.title:
                        if energised != 0:
                            effects_list.append("Energised")
                if dab_display_trigger == 1:
                    effects_list.append(":Damage Buffs:")
                    for status_effect in champion1_statuses:
                        if status_effect == "Power Aura":
                            effects_list.append("Power Aura [+20%]")
                        if status_effect == "Weak Remedy":
                            effects_list.append("Weak Remedy [+25%]: ({})".format(champion1_weakremedy))
                        if status_effect == "Strong Remedy":
                            effects_list.append("Strong Remedy [+50%]: ({})".format(champion1_strongremedy))
                        if status_effect == "Enlarged Muscles":
                            effects_list.append("Enlarged Muscles [+60%]: ({})".format(champion1_muscleEnlarger))
                        if status_effect == "Fullest Potential":
                            effects_list.append("Fullest Potential [+200%]: ({})".format(champion1_fullPotential))
                if deb_display_trigger == 1:
                    effects_list.append(":Defensive Buffs:") 
                    for status_effect in champion1_statuses:
                        if "[Immunity]" in status_effect:
                            effects_list.append("{}".format(status_effect))
                        if status_effect == "Protection Aura":
                            effects_list.append("Protection Aura [+10%]")
                        if status_effect == "Weak Tourniquet":
                            effects_list.append("Weak Tourniquet [+10%]: ({})".format(champion1_weaktourniquet))
                        if status_effect == "Flowing Water":
                            effects_list.append("Toughened Mud [+15%]")
                        elif status_effect == "Crashing Water":
                            effects_list.append("Toughened Mud [+15%]")
                        if status_effect == "Tight Tourniquet":
                            effects_list.append("Tight Tourniquet [+20%]: ({})".format(champion1_tighttourniquet))
                        if status_effect == "Fortified":
                            effects_list.append("Fortified [+30%]: ({})".format(champion1_fortification))
                        if status_effect == "Enharden Nerves":
                            effects_list.append("Enhardened Nerves [+50%]")
                        if status_effect == "Bush Armour":
                            effects_list.append("Bush Armour [-200 Incoming Damage]: ({})".format(champion1_bush_armour))
                if hb_display_trigger == 1:
                    effects_list.append(":Healing Buffs:")
                    for status_effect in champion1_statuses:
                        if status_effect == "Blessed":
                            effects_list.append("Blessed ({})".format(champion1_blessing))
                        if status_effect == "Nano-repair Bots":
                            if nanobot_overclock != 0:
                                effects_list.append("Overclocked Nano-repair Bots[+{}]: ({})".format(CHAMPION1_HP*0.20, nanobot_overclock))
                            else:    
                                effects_list.append("Nano-repair Bots[+{}]".format(CHAMPION1_HP*0.1))
                        if status_effect == "Bandaged":
                            effects_list.append("Bandaged[{}]: ({})".format(champion1_bandaged[0], champion1_bandaged[1]))
                        if status_effect == "Flowing Waters":
                            effects_list.append("Flowing Waters[{}]: ({})".format(champion1_springwaters[0], champion1_springwaters[1]))
                        if status_effect == "Crashing Waters":
                            effects_list.append("Crashing Waters[{}]: ({})".format(champion1_oceantide[0], champion1_oceantide[1]))
            if position == 2:
                effects_list.append(":Passive:")
                if CHAMPION_LIST[1] == MONK.title:
                    effects_list.append(MONK.passive)
                if CHAMPION_LIST[1] == BARBARIAN.title:
                    effects_list.append(BARBARIAN.passive)
                if CHAMPION_LIST[1] == KINGS_GUARD.title:
                    effects_list.append(KINGS_GUARD.passive)
                if KINGS_GUARD.title in CHAMPION_LIST:
                    if champion2_fortification != 0:
                        deb_display_trigger = 1
                if CHAMPION_LIST[1] == MASTER_FENCER.title:
                    effects_list.append(MASTER_FENCER.passive)
                if CHAMPION_LIST[1] == BERSERKER.title:
                    effects_list.append(BERSERKER.passive)
                    if champion2_pure_rage != 0:
                        ca_display_trigger = 1
                    if reckless_flurry_buff != 0:
                        ca_display_trigger = 1
                if CHAMPION_LIST[1] == ROGUE.title:
                    effects_list.append(ROGUE.passive)
                if CHAMPION_LIST[1] == SURVIVALIST.title:
                    effects_list.append(SURVIVALIST.passive)
                    if champion2_play_dead != 0:
                        ca_display_trigger = 1
                    if prepare_buff != 0:
                        ca_display_trigger = 1
                if CHAMPION_LIST[1] == BRAWLIST.title:
                    effects_list.append(BRAWLIST.passive)
                if CHAMPION_LIST[1] == ACADEMIC_MAGE.title:
                    effects_list.append(ACADEMIC_MAGE.passive)
                    if champion2_magical_barrier != 0:
                        ca_display_trigger = 1
                if CHAMPION_LIST[1] == DRUID.title:
                    effects_list.append(DRUID.passive)
                if DRUID.title in CHAMPION_LIST:
                    if champion2_bush_armour != 0:
                        deb_display_trigger = 1
                if CHAMPION_LIST[1] == WARLOCK.title:
                    effects_list.append(WARLOCK.passive)
                    if void_infusion_stacks != 0:
                        ca_display_trigger = 1
                if CHAMPION_LIST[1] == BLOODMANCER.title:
                    effects_list.append(BLOODMANCER.passive)
                    if blood_boil_buff != 0:
                        ca_display_trigger = 1
                    if channeling_strength == 1:
                        ca_display_trigger = 1
                if BLOODMANCER.title in CHAMPION_LIST:
                    if champion2_enhardened_nerves != 0:
                        deb_display_trigger = 1
                if CHAMPION_LIST[1] == PALADIN.title:
                    effects_list.append(PALADIN.passive)
                if PALADIN.title in CHAMPION_LIST:
                    if paladin_aura == 1:
                        dab_display_trigger = 1
                    if paladin_aura == 2:
                        deb_display_trigger = 1
                    if holywrath_multiplier != 0:
                        ca_display_trigger = 1
                if CHAMPION_LIST[1] == LEGION_RANGER.title:
                    effects_list.append(LEGION_RANGER.passive)
                    ca_display_trigger = 1
                if CHAMPION_LIST[1] == MAGNETIMANCER.title:
                    effects_list.append(MAGNETIMANCER.passive)
                    if energised != 0:
                        ca_display_trigger = 1
                if CHAMPION_LIST[1] == POWER_CONDUIT.title:
                    effects_list.append(POWER_CONDUIT.passive)
                if POWER_CONDUIT.title in CHAMPION_LIST:
                    if champion2_muscleEnlarger != 0:
                        dab_display_trigger = 1
                    if champion2_fullPotential != 0:
                        dab_display_trigger = 1
                if CHAMPION_LIST[1] == EARTH_SPEAKER.title:
                    effects_list.append(EARTH_SPEAKER.passive)
                if EARTH_SPEAKER.title in CHAMPION_LIST:
                    if champion2_springwaters[1] != 0:
                        hb_display_trigger = 1
                    if champion2_oceantide[1] != 0:
                        hb_display_trigger = 1
                if CHAMPION_LIST[1] == TIME_WALKER.title:
                    effects_list.append(TIME_WALKER.passive)
                if TIME_WALKER.title in CHAMPION_LIST:
                    hb_display_trigger = 1
                if CHAMPION_LIST[1] == PRIEST.title:
                    effects_list.append(PRIEST.passive)
                if PRIEST.title in CHAMPION_LIST:
                    if champion2_blessing != 0:
                        hb_display_trigger = 1
                if CHAMPION_LIST[1] == FIELD_MEDIC.title:
                    effects_list.append(FIELD_MEDIC.passive)
                if FIELD_MEDIC.title in CHAMPION_LIST:
                    if champion2_strongremedy != 0:
                        dab_display_trigger = 1
                    if champion2_weakremedy != 0:
                        dab_display_trigger = 1
                    if champion2_tighttourniquet != 0:
                        deb_display_trigger = 1
                    if champion2_weaktourniquet != 0:
                        deb_display_trigger = 1
                    if champion2_bandaged[1] != 0:
                        hb_display_trigger = 1
                if ca_display_trigger == 1:
                    effects_list.append(":Champion Abilties:")
                    if CHAMPION_LIST[1] == BERSERKER.title:
                        if champion2_pure_rage != 0:
                            effects_list.append("Damage[+50%]: Pure Rage ({})".format(champion2_pure_rage))
                        if reckless_flurry_buff != 0:
                            effects_list.append("Reckless Flurry [{}]".format(reckless_flurry_buff))
                    if CHAMPION_LIST[1] == ACADEMIC_MAGE.title:
                        if champion2_magical_barrier != 0:
                            effects_list.append('Magical Barrier [{}]'.format(champion2_magical_barrier))
                    if CHAMPION_LIST[1] == WARLOCK.title:
                        if void_infusion_stacks != 0:
                            effects_list.append("Void Infused [{}]".format(void_infusion_stacks))
                    if CHAMPION_LIST[1] == BLOODMANCER.title:
                        if blood_boil_buff != 0:
                            effects_list.append("Blood Boiling")
                        if channeling_strength == 1:
                            effects_list.append("channeling Strength")
                    if CHAMPION_LIST[1] == PALADIN.title:
                        if holywrath_multiplier != 0:
                            effects_list.append("Next Holy Wrath [+{}%]".format(holywrath_multiplier*20))
                    if CHAMPION_LIST[1] == LEGION_RANGER.title:
                        effects_list.append("{}".format(current_arrow_type))
                    if CHAMPION_LIST[1] == SURVIVALIST.title:
                        if prepare_buff != 0:
                            effects_list.append("Damage[+50%]: Prepared")
                        if champion2_play_dead != 0:
                            effects_list.append("Playing Dead")
                    if CHAMPION_LIST[1] == MAGNETIMANCER.title:
                        if energised != 0:
                            effects_list.append("Energised")
                if dab_display_trigger == 1:
                    effects_list.append(":Damage Buffs:")
                    for status_effect in champion2_statuses:
                        if status_effect == "Power Aura":
                            effects_list.append("Power Aura [+20%]")
                        if status_effect == "Weak Remedy":
                            effects_list.append("Weak Remedy [+25%]: ({})".format(champion2_weakremedy))
                        if status_effect == "Strong Remedy":
                            effects_list.append("Strong Remedy [+50%]: ({})".format(champion2_strongremedy))
                        if status_effect == "Enlarged Muscles":
                            effects_list.append("Enlarged Muscles [+60%]: ({})".format(champion2_muscleEnlarger))
                        if status_effect == "Fullest Potential":
                            effects_list.append("Fullest Potential [+200%]: ({})".format(champion2_fullPotential))
                if deb_display_trigger == 1:
                    effects_list.append(":Defensive Buffs:") 
                    for status_effect in champion2_statuses:
                        if "[Immunity]" in status_effect:
                            effects_list.append("{}".format(status_effect))
                        if status_effect == "Protection Aura":
                            effects_list.append("Protection Aura [+10%]")
                        if status_effect == "Weak Tourniquet":
                            effects_list.append("Weak Tourniquet [+10%]: ({})".format(champion2_weaktourniquet))
                        if status_effect == "Flowing Water":
                            effects_list.append("Toughened Mud [+15%]")
                        elif status_effect == "Crashing Water":
                            effects_list.append("Toughened Mud [+15%]")
                        if status_effect == "Tight Tourniquet":
                            effects_list.append("Tight Tourniquet [+20%]: ({})".format(champion2_tighttourniquet))
                        if status_effect == "Fortified":
                            effects_list.append("Fortified [+30%]: ({})".format(champion2_fortification))
                        if status_effect == "Enharden Nerves":
                            effects_list.append("Enhardened Nerves [+50%]")
                        if status_effect == "Bush Armour":
                            effects_list.append("Bush Armour [-200 Incoming Damage]: ({})".format(champion2_bush_armour))
                if hb_display_trigger == 1:
                    effects_list.append(":Healing Buffs:")
                    for status_effect in champion2_statuses:
                        if status_effect == "Blessed":
                            effects_list.append("Blessed ({})".format(champion2_blessing))
                        if status_effect == "Nano-repair Bots":
                            if nanobot_overclock != 0:
                                effects_list.append("Overclocked Nano-repair Bots[+{}]: ({})".format(CHAMPION2_HP*0.20, nanobot_overclock))
                            else:    
                                effects_list.append("Nano-repair Bots[+{}]".format(CHAMPION2_HP*0.1))
                        if status_effect == "Bandaged":
                            effects_list.append("Bandaged[{}]: ({})".format(champion2_bandaged[0], champion2_bandaged[1]))
                        if status_effect == "Flowing Waters":
                            effects_list.append("Flowing Waters[{}]: ({})".format(champion2_springwaters[0], champion2_springwaters[1]))
                        if status_effect == "Crashing Waters":
                            effects_list.append("Crashing Waters[{}]: ({})".format(champion2_oceantide[0], champion2_oceantide[1]))
            if position == 3:
                effects_list.append(":Passive:")
                if CHAMPION_LIST[2] == MONK.title:
                    effects_list.append(MONK.passive)
                if CHAMPION_LIST[2] == BARBARIAN.title:
                    effects_list.append(BARBARIAN.passive)
                if CHAMPION_LIST[2] == KINGS_GUARD.title:
                    effects_list.append(KINGS_GUARD.passive)
                if KINGS_GUARD.title in CHAMPION_LIST:
                    if champion3_fortification != 0:
                        deb_display_trigger = 1
                if CHAMPION_LIST[2] == MASTER_FENCER.title:
                    effects_list.append(MASTER_FENCER.passive)
                if CHAMPION_LIST[2] == BERSERKER.title:
                    effects_list.append(BERSERKER.passive)
                    if champion3_pure_rage != 0:
                        ca_display_trigger = 1
                    if reckless_flurry_buff != 0:
                        ca_display_trigger = 1
                if CHAMPION_LIST[2] == ROGUE.title:
                    effects_list.append(ROGUE.passive)
                if CHAMPION_LIST[2] == SURVIVALIST.title:
                    effects_list.append(SURVIVALIST.passive)
                    if champion3_play_dead != 0:
                        ca_display_trigger = 1
                    if prepare_buff != 0:
                        ca_display_trigger = 1
                if CHAMPION_LIST[2] == BRAWLIST.title:
                    effects_list.append(BRAWLIST.passive)
                if CHAMPION_LIST[2] == ACADEMIC_MAGE.title:
                    effects_list.append(ACADEMIC_MAGE.passive)
                    if champion3_magical_barrier != 0:
                        ca_display_trigger = 1
                if CHAMPION_LIST[2] == DRUID.title:
                    effects_list.append(DRUID.passive)
                if DRUID.title in CHAMPION_LIST:
                    if champion3_bush_armour != 0:
                        deb_display_trigger = 1
                if CHAMPION_LIST[2] == WARLOCK.title:
                    effects_list.append(WARLOCK.passive)
                    if void_infusion_stacks != 0:
                        ca_display_trigger = 1
                if CHAMPION_LIST[2] == BLOODMANCER.title:
                    effects_list.append(BLOODMANCER.passive)
                    if blood_boil_buff != 0:
                        ca_display_trigger = 1
                    if channeling_strength == 1:
                        ca_display_trigger = 1
                if BLOODMANCER.title in CHAMPION_LIST:
                    if champion3_enhardened_nerves != 0:
                        deb_display_trigger = 1
                if CHAMPION_LIST[2] == PALADIN.title:
                    effects_list.append(PALADIN.passive)
                if PALADIN.title in CHAMPION_LIST:
                    if paladin_aura == 1:
                        dab_display_trigger = 1
                    if paladin_aura == 2:
                        deb_display_trigger = 1
                    if holywrath_multiplier != 0:
                        ca_display_trigger = 1
                if CHAMPION_LIST[2] == LEGION_RANGER.title:
                    effects_list.append(LEGION_RANGER.passive)
                    ca_display_trigger = 1
                if CHAMPION_LIST[2] == MAGNETIMANCER.title:
                    effects_list.append(MAGNETIMANCER.passive)
                    if energised != 0:
                        ca_display_trigger = 1
                if CHAMPION_LIST[2] == POWER_CONDUIT.title:
                    effects_list.append(POWER_CONDUIT.passive)
                if POWER_CONDUIT.title in CHAMPION_LIST:
                    if champion3_muscleEnlarger != 0:
                        dab_display_trigger = 1
                    if champion3_fullPotential != 0:
                        dab_display_trigger = 1
                if CHAMPION_LIST[2] == EARTH_SPEAKER.title:
                    effects_list.append(EARTH_SPEAKER.passive)
                if EARTH_SPEAKER.title in CHAMPION_LIST:
                    if champion3_springwaters[1] != 0:
                        hb_display_trigger = 1
                    if champion3_oceantide[1] != 0:
                        hb_display_trigger = 1
                if CHAMPION_LIST[2] == TIME_WALKER.title:
                    effects_list.append(TIME_WALKER.passive)
                if TIME_WALKER.title in CHAMPION_LIST:
                    hb_display_trigger = 1
                if CHAMPION_LIST[2] == PRIEST.title:
                    effects_list.append(PRIEST.passive)
                if PRIEST.title in CHAMPION_LIST:
                    if champion3_blessing != 0:
                        hb_display_trigger = 1
                if CHAMPION_LIST[2] == FIELD_MEDIC.title:
                    effects_list.append(FIELD_MEDIC.passive)
                if FIELD_MEDIC.title in CHAMPION_LIST:
                    if champion3_strongremedy != 0:
                        dab_display_trigger = 1
                    if champion3_weakremedy != 0:
                        dab_display_trigger = 1
                    if champion3_tighttourniquet != 0:
                        deb_display_trigger = 1
                    if champion3_weaktourniquet != 0:
                        deb_display_trigger = 1
                    if champion3_bandaged[1] != 0:
                        hb_display_trigger = 1
                if ca_display_trigger == 1:
                    effects_list.append(":Champion Abilties:")
                    if CHAMPION_LIST[2] == BERSERKER.title:
                        if champion3_pure_rage != 0:
                            effects_list.append("Damage[+50%]: Pure Rage ({})".format(champion3_pure_rage))
                        if reckless_flurry_buff != 0:
                            effects_list.append("Reckless Flurry [{}]".format(reckless_flurry_buff))
                    if CHAMPION_LIST[2] == ACADEMIC_MAGE.title:
                        if champion3_magical_barrier != 0:
                            effects_list.append('Magical Barrier [{}]'.format(champion3_magical_barrier))
                    if CHAMPION_LIST[2] == WARLOCK.title:
                        if void_infusion_stacks != 0:
                            effects_list.append("Void Infused [{}]".format(void_infusion_stacks))
                    if CHAMPION_LIST[2] == BLOODMANCER.title:
                        if blood_boil_buff != 0:
                            effects_list.append("Blood Boiling")
                        if channeling_strength == 1:
                            effects_list.append("channeling Strength")
                    if CHAMPION_LIST[2] == PALADIN.title:
                        if holywrath_multiplier != 0:
                            effects_list.append("Next Holy Wrath [+{}%]".format(holywrath_multiplier*20))
                    if CHAMPION_LIST[2] == LEGION_RANGER.title:
                        effects_list.append("{}".format(current_arrow_type))
                    if CHAMPION_LIST[2] == SURVIVALIST.title:
                        if prepare_buff != 0:
                            effects_list.append("Damage[+50%]: Prepared")
                        if champion3_play_dead != 0:
                            effects_list.append("Playing Dead")
                    if CHAMPION_LIST[2] == MAGNETIMANCER.title:
                        if energised != 0:
                            effects_list.append("Energised")
                if dab_display_trigger == 1:
                    effects_list.append(":Damage Buffs:")
                    for status_effect in champion3_statuses:
                        if status_effect == "Power Aura":
                            effects_list.append("Power Aura [+20%]")
                        if status_effect == "Weak Remedy":
                            effects_list.append("Weak Remedy [+25%]: ({})".format(champion3_weakremedy))
                        if status_effect == "Strong Remedy":
                            effects_list.append("Strong Remedy [+50%]: ({})".format(champion3_strongremedy))
                        if status_effect == "Enlarged Muscles":
                            effects_list.append("Enlarged Muscles [+60%]: ({})".format(champion3_muscleEnlarger))
                        if status_effect == "Fullest Potential":
                            effects_list.append("Fullest Potential [+200%]: ({})".format(champion3_fullPotential))
                if deb_display_trigger == 1:
                    effects_list.append(":Defensive Buffs:") 
                    for status_effect in champion3_statuses:
                        if "[Immunity]" in status_effect:
                            effects_list.append("{}".format(status_effect))
                        if status_effect == "Protection Aura":
                            effects_list.append("Protection Aura [+10%]")
                        if status_effect == "Weak Tourniquet":
                            effects_list.append("Weak Tourniquet [+10%]: ({})".format(champion3_weaktourniquet))
                        if status_effect == "Flowing Water":
                            effects_list.append("Toughened Mud [+15%]")
                        elif status_effect == "Crashing Water":
                            effects_list.append("Toughened Mud [+15%]")
                        if status_effect == "Tight Tourniquet":
                            effects_list.append("Tight Tourniquet [+20%]: ({})".format(champion3_tighttourniquet))
                        if status_effect == "Fortified":
                            effects_list.append("Fortified [+30%]: ({})".format(champion3_fortification))
                        if status_effect == "Enharden Nerves":
                            effects_list.append("Enhardened Nerves [+50%]")
                        if status_effect == "Bush Armour":
                            effects_list.append("Bush Armour [-200 Incoming Damage]: ({})".format(champion3_bush_armour))
                if hb_display_trigger == 1:
                    effects_list.append(":Healing Buffs:")
                    for status_effect in champion3_statuses:
                        if status_effect == "Blessed":
                            effects_list.append("Blessed ({})".format(champion3_blessing))
                        if status_effect == "Nano-repair Bots":
                            if nanobot_overclock != 0:
                                effects_list.append("Overclocked Nano-repair Bots[+{}]: ({})".format(CHAMPION3_HP*0.20, nanobot_overclock))
                            else:    
                                effects_list.append("Nano-repair Bots[+{}]".format(CHAMPION3_HP*0.1))
                        if status_effect == "Bandaged":
                            effects_list.append("Bandaged[{}]: ({})".format(champion3_bandaged[0], champion3_bandaged[1]))
                        if status_effect == "Flowing Waters":
                            effects_list.append("Flowing Waters[{}]: ({})".format(champion3_springwaters[0], champion3_springwaters[1]))
                        if status_effect == "Crashing Waters":
                            effects_list.append("Crashing Waters[{}]: ({})".format(champion3_oceantide[0], champion3_oceantide[1]))
            if position == 4:
                effects_list.append(":Passive:")
                if CHAMPION_LIST[3] == MONK.title:
                    effects_list.append(MONK.passive)
                if CHAMPION_LIST[3] == BARBARIAN.title:
                    effects_list.append(BARBARIAN.passive)
                if CHAMPION_LIST[3] == KINGS_GUARD.title:
                    effects_list.append(KINGS_GUARD.passive)
                if KINGS_GUARD.title in CHAMPION_LIST:
                    if champion4_fortification != 0:
                        deb_display_trigger = 1
                if CHAMPION_LIST[3] == MASTER_FENCER.title:
                    effects_list.append(MASTER_FENCER.passive)
                if CHAMPION_LIST[3] == BERSERKER.title:
                    effects_list.append(BERSERKER.passive)
                    if champion4_pure_rage != 0:
                        ca_display_trigger = 1
                    if reckless_flurry_buff != 0:
                        ca_display_trigger = 1
                if CHAMPION_LIST[3] == ROGUE.title:
                    effects_list.append(ROGUE.passive)
                if CHAMPION_LIST[3] == SURVIVALIST.title:
                    effects_list.append(SURVIVALIST.passive)
                    if champion4_play_dead != 0:
                        ca_display_trigger = 1
                    if prepare_buff != 0:
                        ca_display_trigger = 1
                if CHAMPION_LIST[3] == BRAWLIST.title:
                    effects_list.append(BRAWLIST.passive)
                if CHAMPION_LIST[3] == ACADEMIC_MAGE.title:
                    effects_list.append(ACADEMIC_MAGE.passive)
                    if champion4_magical_barrier != 0:
                        ca_display_trigger = 1
                if CHAMPION_LIST[3] == DRUID.title:
                    effects_list.append(DRUID.passive)
                if DRUID.title in CHAMPION_LIST:
                    if champion4_bush_armour != 0:
                        deb_display_trigger = 1
                if CHAMPION_LIST[3] == WARLOCK.title:
                    effects_list.append(WARLOCK.passive)
                    if void_infusion_stacks != 0:
                        ca_display_trigger = 1
                if CHAMPION_LIST[3] == BLOODMANCER.title:
                    effects_list.append(BLOODMANCER.passive)
                    if blood_boil_buff != 0:
                        ca_display_trigger = 1
                    if channeling_strength == 1:
                        ca_display_trigger = 1
                if BLOODMANCER.title in CHAMPION_LIST:
                    if champion4_enhardened_nerves != 0:
                        deb_display_trigger = 1
                if CHAMPION_LIST[3] == PALADIN.title:
                    effects_list.append(PALADIN.passive)
                if PALADIN.title in CHAMPION_LIST:
                    if paladin_aura == 1:
                        dab_display_trigger = 1
                    if paladin_aura == 2:
                        deb_display_trigger = 1
                    if holywrath_multiplier != 0:
                        ca_display_trigger = 1
                if CHAMPION_LIST[3] == LEGION_RANGER.title:
                    effects_list.append(LEGION_RANGER.passive)
                    ca_display_trigger = 1
                if CHAMPION_LIST[3] == MAGNETIMANCER.title:
                    effects_list.append(MAGNETIMANCER.passive)
                    if energised != 0:
                        ca_display_trigger = 1
                if CHAMPION_LIST[3] == POWER_CONDUIT.title:
                    effects_list.append(POWER_CONDUIT.passive)
                if POWER_CONDUIT.title in CHAMPION_LIST:
                    if champion4_muscleEnlarger != 0:
                        dab_display_trigger = 1
                    if champion4_fullPotential != 0:
                        dab_display_trigger = 1
                if CHAMPION_LIST[3] == EARTH_SPEAKER.title:
                    effects_list.append(EARTH_SPEAKER.passive)
                if EARTH_SPEAKER.title in CHAMPION_LIST:
                    if champion4_springwaters[1] != 0:
                        hb_display_trigger = 1
                    if champion4_oceantide[1] != 0:
                        hb_display_trigger = 1
                if CHAMPION_LIST[3] == TIME_WALKER.title:
                    effects_list.append(TIME_WALKER.passive)
                if TIME_WALKER.title in CHAMPION_LIST:
                    hb_display_trigger = 1
                if CHAMPION_LIST[3] == PRIEST.title:
                    effects_list.append(PRIEST.passive)
                if PRIEST.title in CHAMPION_LIST:
                    if champion4_blessing != 0:
                        hb_display_trigger = 1
                if CHAMPION_LIST[3] == FIELD_MEDIC.title:
                    effects_list.append(FIELD_MEDIC.passive)
                if FIELD_MEDIC.title in CHAMPION_LIST:
                    if champion4_strongremedy != 0:
                        dab_display_trigger = 1
                    if champion4_weakremedy != 0:
                        dab_display_trigger = 1
                    if champion4_tighttourniquet != 0:
                        deb_display_trigger = 1
                    if champion4_weaktourniquet != 0:
                        deb_display_trigger = 1
                    if champion4_bandaged[1] != 0:
                        hb_display_trigger = 1
                if ca_display_trigger == 1:
                    effects_list.append(":Champion Abilties:")
                    if CHAMPION_LIST[3] == BERSERKER.title:
                        if champion4_pure_rage != 0:
                            effects_list.append("Damage[+50%]: Pure Rage ({})".format(champion4_pure_rage))
                        if reckless_flurry_buff != 0:
                            effects_list.append("Reckless Flurry [{}]".format(reckless_flurry_buff))
                    if CHAMPION_LIST[3] == ACADEMIC_MAGE.title:
                        if champion4_magical_barrier != 0:
                            effects_list.append('Magical Barrier [{}]'.format(champion4_magical_barrier))
                    if CHAMPION_LIST[3] == WARLOCK.title:
                        if void_infusion_stacks != 0:
                            effects_list.append("Void Infused [{}]".format(void_infusion_stacks))
                    if CHAMPION_LIST[3] == BLOODMANCER.title:
                        if blood_boil_buff != 0:
                            effects_list.append("Blood Boiling")
                        if channeling_strength == 1:
                            effects_list.append("channeling Strength")
                    if CHAMPION_LIST[3] == PALADIN.title:
                        if holywrath_multiplier != 0:
                            effects_list.append("Next Holy Wrath [+{}%]".format(holywrath_multiplier*20))
                    if CHAMPION_LIST[3] == LEGION_RANGER.title:
                        effects_list.append("{}".format(current_arrow_type))
                    if CHAMPION_LIST[3] == SURVIVALIST.title:
                        if prepare_buff != 0:
                            effects_list.append("Damage[+50%]: Prepared")
                        if champion4_play_dead != 0:
                            effects_list.append("Playing Dead")
                    if CHAMPION_LIST[3] == MAGNETIMANCER.title:
                        if energised != 0:
                            effects_list.append("Energised")
                if dab_display_trigger == 1:
                    effects_list.append(":Damage Buffs:")
                    for status_effect in champion4_statuses:
                        if status_effect == "Power Aura":
                            effects_list.append("Power Aura [+20%]")
                        if status_effect == "Weak Remedy":
                            effects_list.append("Weak Remedy [+25%]: ({})".format(champion4_weakremedy))
                        if status_effect == "Strong Remedy":
                            effects_list.append("Strong Remedy [+50%]: ({})".format(champion4_strongremedy))
                        if status_effect == "Enlarged Muscles":
                            effects_list.append("Enlarged Muscles [+60%]: ({})".format(champion4_muscleEnlarger))
                        if status_effect == "Fullest Potential":
                            effects_list.append("Fullest Potential [+200%]: ({})".format(champion4_fullPotential))
                if deb_display_trigger == 1:
                    effects_list.append(":Defensive Buffs:") 
                    for status_effect in champion4_statuses:
                        if "[Immunity]" in status_effect:
                            effects_list.append("{}".format(status_effect))
                        if status_effect == "Protection Aura":
                            effects_list.append("Protection Aura [+10%]")
                        if status_effect == "Weak Tourniquet":
                            effects_list.append("Weak Tourniquet [+10%]: ({})".format(champion4_weaktourniquet))
                        if status_effect == "Flowing Water":
                            effects_list.append("Toughened Mud [+15%]")
                        elif status_effect == "Crashing Water":
                            effects_list.append("Toughened Mud [+15%]")
                        if status_effect == "Tight Tourniquet":
                            effects_list.append("Tight Tourniquet [+20%]: ({})".format(champion4_tighttourniquet))
                        if status_effect == "Fortified":
                            effects_list.append("Fortified [+30%]: ({})".format(champion4_fortification))
                        if status_effect == "Enharden Nerves":
                            effects_list.append("Enhardened Nerves [+50%]")
                        if status_effect == "Bush Armour":
                            effects_list.append("Bush Armour [-200 Incoming Damage]: ({})".format(champion4_bush_armour))
                if hb_display_trigger == 1:
                    effects_list.append(":Healing Buffs:")
                    for status_effect in champion4_statuses:
                        if status_effect == "Blessed":
                            effects_list.append("Blessed ({})".format(champion4_blessing))
                        if status_effect == "Nano-repair Bots":
                            if nanobot_overclock != 0:
                                effects_list.append("Overclocked Nano-repair Bots[+{}]: ({})".format(CHAMPION4_HP*0.20, nanobot_overclock))
                            else:    
                                effects_list.append("Nano-repair Bots[+{}]".format(CHAMPION4_HP*0.1))
                        if status_effect == "Bandaged":
                            effects_list.append("Bandaged[{}]: ({})".format(champion4_bandaged[0], champion4_bandaged[1]))
                        if status_effect == "Flowing Waters":
                            effects_list.append("Flowing Waters[{}]: ({})".format(champion4_springwaters[0], champion4_springwaters[1]))
                        if status_effect == "Crashing Waters":
                            effects_list.append("Crashing Waters[{}]: ({})".format(champion4_oceantide[0], champion4_oceantide[1]))
            if position == 5:
                effects_list.append(":Passive:")
                if CHAMPION_LIST[4] == MONK.title:
                    effects_list.append(MONK.passive)
                if CHAMPION_LIST[4] == BARBARIAN.title:
                    effects_list.append(BARBARIAN.passive)
                if CHAMPION_LIST[4] == KINGS_GUARD.title:
                    effects_list.append(KINGS_GUARD.passive)
                if KINGS_GUARD.title in CHAMPION_LIST:
                    if champion5_fortification != 0:
                        deb_display_trigger = 1
                if CHAMPION_LIST[4] == MASTER_FENCER.title:
                    effects_list.append(MASTER_FENCER.passive)
                if CHAMPION_LIST[4] == BERSERKER.title:
                    effects_list.append(BERSERKER.passive)
                    if champion5_pure_rage != 0:
                        ca_display_trigger = 1
                    if reckless_flurry_buff != 0:
                        ca_display_trigger = 1
                if CHAMPION_LIST[4] == ROGUE.title:
                    effects_list.append(ROGUE.passive)
                if CHAMPION_LIST[4] == SURVIVALIST.title:
                    effects_list.append(SURVIVALIST.passive)
                    if champion5_play_dead != 0:
                        ca_display_trigger = 1
                    if prepare_buff != 0:
                        ca_display_trigger = 1
                if CHAMPION_LIST[4] == BRAWLIST.title:
                    effects_list.append(BRAWLIST.passive)
                if CHAMPION_LIST[4] == ACADEMIC_MAGE.title:
                    effects_list.append(ACADEMIC_MAGE.passive)
                    if champion5_magical_barrier != 0:
                        ca_display_trigger = 1
                if CHAMPION_LIST[4] == DRUID.title:
                    effects_list.append(DRUID.passive)
                if DRUID.title in CHAMPION_LIST:
                    if champion5_bush_armour != 0:
                        deb_display_trigger = 1
                if CHAMPION_LIST[4] == WARLOCK.title:
                    effects_list.append(WARLOCK.passive)
                    if void_infusion_stacks != 0:
                        ca_display_trigger = 1
                if CHAMPION_LIST[4] == BLOODMANCER.title:
                    effects_list.append(BLOODMANCER.passive)
                    if blood_boil_buff != 0:
                        ca_display_trigger = 1
                    if channeling_strength == 1:
                        ca_display_trigger = 1
                if BLOODMANCER.title in CHAMPION_LIST:
                    if champion5_enhardened_nerves != 0:
                        deb_display_trigger = 1
                if CHAMPION_LIST[4] == PALADIN.title:
                    effects_list.append(PALADIN.passive)
                if PALADIN.title in CHAMPION_LIST:
                    if paladin_aura == 1:
                        dab_display_trigger = 1
                    if paladin_aura == 2:
                        deb_display_trigger = 1
                    if holywrath_multiplier != 0:
                        ca_display_trigger = 1
                if CHAMPION_LIST[4] == LEGION_RANGER.title:
                    effects_list.append(LEGION_RANGER.passive)
                    ca_display_trigger = 1
                if CHAMPION_LIST[4] == MAGNETIMANCER.title:
                    effects_list.append(MAGNETIMANCER.passive)
                    if energised != 0:
                        ca_display_trigger = 1
                if CHAMPION_LIST[4] == POWER_CONDUIT.title:
                    effects_list.append(POWER_CONDUIT.passive)
                if POWER_CONDUIT.title in CHAMPION_LIST:
                    if champion5_muscleEnlarger != 0:
                        dab_display_trigger = 1
                    if champion5_fullPotential != 0:
                        dab_display_trigger = 1
                if CHAMPION_LIST[4] == EARTH_SPEAKER.title:
                    effects_list.append(EARTH_SPEAKER.passive)
                if EARTH_SPEAKER.title in CHAMPION_LIST:
                    if champion5_springwaters[1] != 0:
                        hb_display_trigger = 1
                    if champion5_oceantide[1] != 0:
                        hb_display_trigger = 1
                if CHAMPION_LIST[4] == TIME_WALKER.title:
                    effects_list.append(TIME_WALKER.passive)
                if TIME_WALKER.title in CHAMPION_LIST:
                    hb_display_trigger = 1
                if CHAMPION_LIST[4] == PRIEST.title:
                    effects_list.append(PRIEST.passive)
                if PRIEST.title in CHAMPION_LIST:
                    if champion5_blessing != 0:
                        hb_display_trigger = 1
                if CHAMPION_LIST[4] == FIELD_MEDIC.title:
                    effects_list.append(FIELD_MEDIC.passive)
                if FIELD_MEDIC.title in CHAMPION_LIST:
                    if champion5_strongremedy != 0:
                        dab_display_trigger = 1
                    if champion5_weakremedy != 0:
                        dab_display_trigger = 1
                    if champion5_tighttourniquet != 0:
                        deb_display_trigger = 1
                    if champion5_weaktourniquet != 0:
                        deb_display_trigger = 1
                    if champion5_bandaged[1] != 0:
                        hb_display_trigger = 1
                if ca_display_trigger == 1:
                    effects_list.append(":Champion Abilties:")
                    if CHAMPION_LIST[4] == BERSERKER.title:
                        if champion5_pure_rage != 0:
                            effects_list.append("Damage[+50%]: Pure Rage ({})".format(champion5_pure_rage))
                        if reckless_flurry_buff != 0:
                            effects_list.append("Reckless Flurry [{}]".format(reckless_flurry_buff))
                    if CHAMPION_LIST[4] == ACADEMIC_MAGE.title:
                        if champion5_magical_barrier != 0:
                            effects_list.append('Magical Barrier [{}]'.format(champion5_magical_barrier))
                    if CHAMPION_LIST[4] == WARLOCK.title:
                        if void_infusion_stacks != 0:
                            effects_list.append("Void Infused [{}]".format(void_infusion_stacks))
                    if CHAMPION_LIST[4] == BLOODMANCER.title:
                        if blood_boil_buff != 0:
                            effects_list.append("Blood Boiling")
                        if channeling_strength == 1:
                            effects_list.append("Channeling Strength")
                    if CHAMPION_LIST[4] == PALADIN.title:
                        if holywrath_multiplier != 0:
                            effects_list.append("Next Holy Wrath [+{}%]".format(holywrath_multiplier*20))
                    if CHAMPION_LIST[4] == LEGION_RANGER.title:
                        effects_list.append("{}".format(current_arrow_type))
                    if CHAMPION_LIST[4] == SURVIVALIST.title:
                        if prepare_buff != 0:
                            effects_list.append("Damage[+50%]: Prepared")
                        if champion5_play_dead != 0:
                            effects_list.append("Playing Dead")
                    if CHAMPION_LIST[4] == MAGNETIMANCER.title:
                        if energised != 0:
                            effects_list.append("Energised")
                if dab_display_trigger == 1:
                    effects_list.append(":Damage Buffs:")
                    for status_effect in champion5_statuses:
                        if status_effect == "Power Aura":
                            effects_list.append("Power Aura [+20%]")
                        if status_effect == "Weak Remedy":
                            effects_list.append("Weak Remedy [+25%]: ({})".format(champion5_weakremedy))
                        if status_effect == "Strong Remedy":
                            effects_list.append("Strong Remedy [+50%]: ({})".format(champion5_strongremedy))
                        if status_effect == "Enlarged Muscles":
                            effects_list.append("Enlarged Muscles [+60%]: ({})".format(champion5_muscleEnlarger))
                        if status_effect == "Fullest Potential":
                            effects_list.append("Fullest Potential [+200%]: ({})".format(champion5_fullPotential))
                if deb_display_trigger == 1:
                    effects_list.append(":Defensive Buffs:") 
                    for status_effect in champion5_statuses:
                        if "[Immunity]" in status_effect:
                            effects_list.append("{}".format(status_effect))
                        if status_effect == "Protection Aura":
                            effects_list.append("Protection Aura [+10%]")
                        if status_effect == "Weak Tourniquet":
                            effects_list.append("Weak Tourniquet [+10%]: ({})".format(champion5_weaktourniquet))
                        if status_effect == "Flowing Water":
                            effects_list.append("Toughened Mud [+15%]")
                        elif status_effect == "Crashing Water":
                            effects_list.append("Toughened Mud [+15%]")
                        if status_effect == "Tight Tourniquet":
                            effects_list.append("Tight Tourniquet [+20%]: ({})".format(champion5_tighttourniquet))
                        if status_effect == "Fortified":
                            effects_list.append("Fortified [+30%]: ({})".format(champion5_fortification))
                        if status_effect == "Enharden Nerves":
                            effects_list.append("Enhardened Nerves [+50%]")
                        if status_effect == "Bush Armour":
                            effects_list.append("Bush Armour [-200 Incoming Damage]: ({})".format(champion5_bush_armour))
                if hb_display_trigger == 1:
                    effects_list.append(":Healing Buffs:")
                    for status_effect in champion5_statuses:
                        if status_effect == "Blessed":
                            effects_list.append("Blessed ({})".format(champion5_blessing))
                        if status_effect == "Nano-repair Bots":
                            if nanobot_overclock != 0:
                                effects_list.append("Overclocked Nano-repair Bots[+{}]: ({})".format(CHAMPION5_HP*0.20, nanobot_overclock))
                            else:    
                                effects_list.append("Nano-repair Bots[+{}]".format(CHAMPION5_HP*0.1))
                        if status_effect == "Bandaged":
                            effects_list.append("Bandaged[{}]: ({})".format(champion5_bandaged[0], champion5_bandaged[1]))
                        if status_effect == "Flowing Waters":
                            effects_list.append("Flowing Waters[{}]: ({})".format(champion5_springwaters[0], champion5_springwaters[1]))
                        if status_effect == "Crashing Waters":
                            effects_list.append("Crashing Waters[{}]: ({})".format(champion5_oceantide[0], champion5_oceantide[1]))
        if AllyOrEnemy == "enemy":
            db_display_trigger = 0
            dot_display_trigger = 0
            dtd_display_trigger = 0
            ddd_display_trigger = 0
            if position == 1:
                if ai1_stun != 0:
                    db_display_trigger = 1
                if ai1_taunt[1] != 0:
                    db_display_trigger = 1
                if ai1_charged[0] != 0:
                    db_display_trigger = 1
                elif ai1_charged[1] != 0:
                    db_display_trigger = 1
                if ai1_serraSlashDot[1] != 0:
                    dot_display_trigger = 1
                if ai1_eviscerDot[1] != 0:
                    dot_display_trigger = 1
                if ai1_garroteDot[1] !=0:
                    dot_display_trigger = 1
                if ai1_burnDot[1] != 0:
                    dot_display_trigger = 1
                if ai1_thornsDot[1] != 0:
                    dot_display_trigger = 1
                    dtd_display_trigger = 1
                if ai1_rottingDot[1] != 0:
                    dot_display_trigger = 1
                if ai1_damnation[1] != 0:
                    dot_display_trigger = 1
                if ai1_barbedArrDot[1] != 0:
                    dot_display_trigger = 1
                if ai1_shimmerDot[1] != 0:
                    dot_display_trigger = 1
                if ai1_divineDot[1] != 0:
                    dot_display_trigger = 1
                if ai1_brittle != 0:
                    dtd_display_trigger = 1
                if ai1_hh_db != 0:
                    dtd_display_trigger = 1
                if ai1_ws_db != 0:
                    dtd_display_trigger = 1
                if ai1_uc_db != 0:
                    dtd_display_trigger = 1
                if ai1_superconducted != 0:
                    dtd_display_trigger = 1
                if ai1_weakness != 0:
                    ddd_display_trigger = 1
                if ai1_toc != 0:
                    ddd_display_trigger = 1
                if ai1_fencer_dodgechance != 0:
                    ddd_display_trigger = 1
                if db_display_trigger == 1:
                    effects_list.append(":Debuffs:")
                    for status_effect in ai1_statuses:
                        if status_effect == "Stunned":
                            effects_list.append("Stunned ({})".format(ai1_stun))
                        if status_effect == "Taunted":
                            effects_list.append("Taunted: {} ({})".format(ai1_taunt[0], ai1_taunt[1]))
                    if ai1_charged[0] != 0:
                        effects_list.append("Charged: Positive ({})".format(ai1_charged[0]))
                    if ai1_charged[1] != 0:
                        effects_list.append("Charged: Negative ({})".format(ai1_charged[1]))
                if dot_display_trigger == 1:
                    effects_list.append(":Damage Overtime:")
                    for status_effect in ai1_statuses:
                        if status_effect == "Exploding":
                            effects_list.append("Damnation[{}] Detonation in {}".format(ai1_damnation[0], ai1_damnation[1]))
                        if status_effect == "Thorns":
                            effects_list.append("Thorns[{}] [#{}]".format(ai1_thornsDot[0]*ai1_thornsDot[1], ai1_thornsDot[1]))
                        if status_effect == "Serrated":
                            effects_list.append("Serrated[{}] ({})".format(self.calculate_bleed_damage("Serrated", 1), ai1_serraSlashDot[1]))
                        if status_effect == "Eviscerated":
                            effects_list.append("Eviscerated[{}] ({})".format(self.calculate_bleed_damage("Eviscerated", 1), ai1_eviscerDot[1]))
                        if status_effect == "Garroted":
                            effects_list.append("Garroted[{}] ({})".format(self.calculate_bleed_damage("Garroted", 1), ai1_garroteDot[1]))
                        if status_effect == "Barbed Arrow":
                            effects_list.append("Barbed[{}] ({})".format(ai1_barbedArrDot[0], ai1_barbedArrDot[1]))
                        if status_effect == "Rotting":
                            effects_list.append("Rotting[{}] ({})".format(ai1_rottingDot[0], ai1_rottingDot[1]))
                        if status_effect == "Burning":
                            effects_list.append("Burning[{}] ({})".format(ai1_burnDot[0], ai1_burnDot[1]))
                        if status_effect == "Sizzling Light":
                            effects_list.append("Sizzling[{}] ({})".format(ai1_shimmerDot[0], ai1_shimmerDot[1]))
                        if status_effect == "Searing Light":
                            effects_list.append("Searing Light[{}] ({})".format(ai1_divineDot[0], ai1_divineDot[1]))
                if dtd_display_trigger == 1:
                    effects_list.append(":Damage Taken Debuffs:")
                    for status_effect in ai1_statuses:
                        if status_effect == "Thorns":
                            effects_list.append("Naturaly Vunerable [+{}%]".format(ai1_thornsDot[1]))
                        if status_effect == "Brittle":
                            effects_list.append("Brittle ({})".format(ai1_brittle))
                        if status_effect == "HardHitterDB":
                            effects_list.append("Next Wide Swing or Upper Cut [+25%]")
                        if status_effect == "WideSwingDB":
                            effects_list.append("Next Hard Hitter or Upper Cut [+25%]")
                        if status_effect == "UpperCutDB":
                            effects_list.append("Next Hard Hitter or Wide Swip [+50%]")
                        if status_effect == "SuperConducted":
                            effects_list.append("Charge Explosions [+100%] ({})".format(ai1_superconducted))
                if ddd_display_trigger == 1:
                    effects_list.append(":Damage Dealt Debuffs:")
                    for status_effect in ai1_statuses:
                        if status_effect == "Weakened":
                            effects_list.append("Weakened [-20%] ({})".format(ai1_weakness))
                        if status_effect == "Touch of Corruption":
                            effects_list.append("Corrupted [-{}%]".format(ai1_toc))
                    if ai1_fencer_dodgechance != 0:
                        effects_list.append("Chance of Fencer Dodging Increased by [{}%]".format(ai1_fencer_dodgechance))
            if position == 2:
                if ai2_stun != 0:
                    db_display_trigger = 1
                if ai2_taunt[1] != 0:
                    db_display_trigger = 1
                if ai2_charged[0] != 0:
                    db_display_trigger = 1
                elif ai2_charged[1] != 0:
                    db_display_trigger = 1
                if ai2_serraSlashDot[1] != 0:
                    dot_display_trigger = 1
                if ai2_eviscerDot[1] != 0:
                    dot_display_trigger = 1
                if ai2_garroteDot[1] !=0:
                    dot_display_trigger = 1
                if ai2_burnDot[1] != 0:
                    dot_display_trigger = 1
                if ai2_thornsDot[1] != 0:
                    dot_display_trigger = 1
                    dtd_display_trigger = 1
                if ai2_rottingDot[1] != 0:
                    dot_display_trigger = 1
                if ai2_damnation[1] != 0:
                    dot_display_trigger = 1
                if ai2_barbedArrDot[1] != 0:
                    dot_display_trigger = 1
                if ai2_shimmerDot[1] != 0:
                    dot_display_trigger = 1
                if ai2_divineDot[1] != 0:
                    dot_display_trigger = 1
                if ai2_brittle != 0:
                    dtd_display_trigger = 1
                if ai2_hh_db != 0:
                    dtd_display_trigger = 1
                if ai2_ws_db != 0:
                    dtd_display_trigger = 1
                if ai2_uc_db != 0:
                    dtd_display_trigger = 1
                if ai2_superconducted != 0:
                    dtd_display_trigger = 1
                if ai2_weakness != 0:
                    ddd_display_trigger = 1
                if ai2_toc != 0:
                    ddd_display_trigger = 1
                if ai2_fencer_dodgechance != 0:
                    ddd_display_trigger = 1
                if db_display_trigger == 1:
                    effects_list.append(":Debuffs:")
                    for status_effect in ai2_statuses:
                        if status_effect == "Stunned":
                            effects_list.append("Stunned ({})".format(ai2_stun))
                        if status_effect == "Taunted":
                            effects_list.append("Taunted: {} ({})".format(ai2_taunt[0], ai2_taunt[1]))
                    if ai2_charged[0] != 0:
                        effects_list.append("Charged: Positive ({})".format(ai2_charged[0]))
                    if ai2_charged[1] != 0:
                        effects_list.append("Charged: Negative ({})".format(ai2_charged[1]))
                if dot_display_trigger == 1:
                    effects_list.append(":Damage Overtime:")
                    for status_effect in ai2_statuses:
                        if status_effect == "Exploding":
                            effects_list.append("Damnation[{}] Detonation in {}".format(ai2_damnation[0], ai2_damnation[1]))
                        if status_effect == "Thorns":
                            effects_list.append("Thorns[{}] [#{}]".format(ai2_thornsDot[0]*ai2_thornsDot[1], ai2_thornsDot[1]))
                        if status_effect == "Serrated":
                            effects_list.append("Serrated[{}] ({})".format(self.calculate_bleed_damage("Serrated", 2), ai2_serraSlashDot[1]))
                        if status_effect == "Eviscerated":
                            effects_list.append("Eviscerated[{}] ({})".format(self.calculate_bleed_damage("Eviscerated", 2), ai2_eviscerDot[1]))
                        if status_effect == "Garroted":
                            effects_list.append("Garroted[{}] ({})".format(self.calculate_bleed_damage("Garroted", 2), ai2_garroteDot[1]))
                        if status_effect == "Barbed Arrow":
                            effects_list.append("Barbed[{}] ({})".format(ai2_barbedArrDot[0], ai2_barbedArrDot[1]))
                        if status_effect == "Rotting":
                            effects_list.append("Rotting[{}] ({})".format(ai2_rottingDot[0], ai2_rottingDot[1]))
                        if status_effect == "Burning":
                            effects_list.append("Burning[{}] ({})".format(ai2_burnDot[0], ai2_burnDot[1]))
                        if status_effect == "Sizzling Light":
                            effects_list.append("Sizzling[{}] ({})".format(ai2_shimmerDot[0], ai2_shimmerDot[1]))
                        if status_effect == "Searing Light":
                            effects_list.append("Searing Light[{}] ({})".format(ai2_divineDot[0], ai2_divineDot[1]))
                if dtd_display_trigger == 1:
                    effects_list.append(":Damage Taken Debuffs:")
                    for status_effect in ai2_statuses:
                        if status_effect == "Thorns":
                            effects_list.append("Naturaly Vunerable [+{}%]".format(ai2_thornsDot[1]))
                        if status_effect == "Brittle":
                            effects_list.append("Brittle ({})".format(ai2_brittle))
                        if status_effect == "HardHitterDB":
                            effects_list.append("Next Wide Swing or Upper Cut [+25%]")
                        if status_effect == "WideSwingDB":
                            effects_list.append("Next Hard Hitter or Upper Cut [+25%]")
                        if status_effect == "UpperCutDB":
                            effects_list.append("Next Hard Hitter or Wide Swip [+25%]")
                        if status_effect == "SuperConducted":
                            effects_list.append("Charge Explosions [+100%] ({})".format(ai2_superconducted))
                if ddd_display_trigger == 1:
                    effects_list.append(":Damage Dealt Debuffs:")
                    for status_effect in ai2_statuses:
                        if status_effect == "Weakened":
                            effects_list.append("Weakened [-20%] ({})".format(ai2_weakness))
                        if status_effect == "Touch of Corruption":
                            effects_list.append("Corrupted [-{}%]".format(ai2_toc))
                    if ai2_fencer_dodgechance != 0:
                        effects_list.append("Chance of Fencer Dodging Increased by [{}%]".format(ai2_fencer_dodgechance))
            if position == 3:
                if ai3_stun != 0:
                    db_display_trigger = 1
                if ai3_taunt[1] != 0:
                    db_display_trigger = 1
                if ai3_charged[0] != 0:
                    db_display_trigger = 1
                elif ai3_charged[1] != 0:
                    db_display_trigger = 1
                if ai3_serraSlashDot[1] != 0:
                    dot_display_trigger = 1
                if ai3_eviscerDot[1] != 0:
                    dot_display_trigger = 1
                if ai3_garroteDot[1] !=0:
                    dot_display_trigger = 1
                if ai3_burnDot[1] != 0:
                    dot_display_trigger = 1
                if ai3_thornsDot[1] != 0:
                    dot_display_trigger = 1
                    dtd_display_trigger = 1
                if ai3_rottingDot[1] != 0:
                    dot_display_trigger = 1
                if ai3_damnation[1] != 0:
                    dot_display_trigger = 1
                if ai3_barbedArrDot[1] != 0:
                    dot_display_trigger = 1
                if ai3_shimmerDot[1] != 0:
                    dot_display_trigger = 1
                if ai3_divineDot[1] != 0:
                    dot_display_trigger = 1
                if ai3_brittle != 0:
                    dtd_display_trigger = 1
                if ai3_hh_db != 0:
                    dtd_display_trigger = 1
                if ai3_ws_db != 0:
                    dtd_display_trigger = 1
                if ai3_uc_db != 0:
                    dtd_display_trigger = 1
                if ai3_superconducted != 0:
                    dtd_display_trigger = 1
                if ai3_weakness != 0:
                    ddd_display_trigger = 1
                if ai3_toc != 0:
                    ddd_display_trigger = 1
                if ai3_fencer_dodgechance != 0:
                    ddd_display_trigger = 1
                if db_display_trigger == 1:
                    effects_list.append(":Debuffs:")
                    for status_effect in ai3_statuses:
                        if status_effect == "Stunned":
                            effects_list.append("Stunned ({})".format(ai3_stun))
                        if status_effect == "Taunted":
                            effects_list.append("Taunted: {} ({})".format(ai3_taunt[0], ai3_taunt[1]))
                    if ai3_charged[0] != 0:
                        effects_list.append("Charged: Positive ({})".format(ai3_charged[0]))
                    if ai3_charged[1] != 0:
                        effects_list.append("Charged: Negative ({})".format(ai3_charged[1]))
                if dot_display_trigger == 1:
                    effects_list.append(":Damage Overtime:")
                    for status_effect in ai3_statuses:
                        if status_effect == "Exploding":
                            effects_list.append("Damnation[{}] Detonation in {}".format(ai3_damnation[0], ai3_damnation[1]))
                        if status_effect == "Thorns":
                            effects_list.append("Thorns[{}] [#{}]".format(ai3_thornsDot[0]*ai3_thornsDot[1], ai3_thornsDot[1]))
                        if status_effect == "Serrated":
                            effects_list.append("Serrated[{}] ({})".format(self.calculate_bleed_damage("Serrated", 3), ai3_serraSlashDot[1]))
                        if status_effect == "Eviscerated":
                            effects_list.append("Eviscerated[{}] ({})".format(self.calculate_bleed_damage("Eviscerated", 3), ai3_eviscerDot[1]))
                        if status_effect == "Garroted":
                            effects_list.append("Garroted[{}] ({})".format(self.calculate_bleed_damage("Garroted", 3), ai3_garroteDot[1]))
                        if status_effect == "Barbed Arrow":
                            effects_list.append("Barbed[{}] ({})".format(ai3_barbedArrDot[0], ai3_barbedArrDot[1]))
                        if status_effect == "Rotting":
                            effects_list.append("Rotting[{}] ({})".format(ai3_rottingDot[0], ai3_rottingDot[1]))
                        if status_effect == "Burning":
                            effects_list.append("Burning[{}] ({})".format(ai3_burnDot[0], ai3_burnDot[1]))
                        if status_effect == "Sizzling Light":
                            effects_list.append("Sizzling[{}] ({})".format(ai3_shimmerDot[0], ai3_shimmerDot[1]))
                        if status_effect == "Searing Light":
                            effects_list.append("Searing Light[{}] ({})".format(ai3_divineDot[0], ai3_divineDot[1]))
                if dtd_display_trigger == 1:
                    effects_list.append(":Damage Taken Debuffs:")
                    for status_effect in ai3_statuses:
                        if status_effect == "Thorns":
                            effects_list.append("Naturaly Vunerable [+{}%]".format(ai3_thornsDot[1]))
                        if status_effect == "Brittle":
                            effects_list.append("Brittle ({})".format(ai3_brittle))
                        if status_effect == "HardHitterDB":
                            effects_list.append("Next Wide Swing or Upper Cut [+25%]")
                        if status_effect == "WideSwingDB":
                            effects_list.append("Next Hard Hitter or Upper Cut [+25%]")
                        if status_effect == "UpperCutDB":
                            effects_list.append("Next Hard Hitter or Wide Swip [+25%]")
                        if status_effect == "SuperConducted":
                            effects_list.append("Charge Explosions [+100%] ({})".format(ai3_superconducted))
                if ddd_display_trigger == 1:
                    effects_list.append(":Damage Dealt Debuffs:")
                    for status_effect in ai3_statuses:
                        if status_effect == "Weakened":
                            effects_list.append("Weakened [-20%] ({})".format(ai3_weakness))
                        if status_effect == "Touch of Corruption":
                            effects_list.append("Corrupted [-{}%]".format(ai3_toc))
                    if ai3_fencer_dodgechance != 0:
                        effects_list.append("Chance of Fencer Dodging Increased by [{}%]".format(ai3_fencer_dodgechance))
            if position == 4:
                if ai4_stun != 0:
                    db_display_trigger = 1
                if ai4_taunt[1] != 0:
                    db_display_trigger = 1
                if ai4_charged[0] != 0:
                    db_display_trigger = 1
                elif ai4_charged[1] != 0:
                    db_display_trigger = 1
                if ai4_serraSlashDot[1] != 0:
                    dot_display_trigger = 1
                if ai4_eviscerDot[1] != 0:
                    dot_display_trigger = 1
                if ai4_garroteDot[1] !=0:
                    dot_display_trigger = 1
                if ai4_burnDot[1] != 0:
                    dot_display_trigger = 1
                if ai4_thornsDot[1] != 0:
                    dot_display_trigger = 1
                    dtd_display_trigger = 1
                if ai4_rottingDot[1] != 0:
                    dot_display_trigger = 1
                if ai4_damnation[1] != 0:
                    dot_display_trigger = 1
                if ai4_barbedArrDot[1] != 0:
                    dot_display_trigger = 1
                if ai4_shimmerDot[1] != 0:
                    dot_display_trigger = 1
                if ai4_divineDot[1] != 0:
                    dot_display_trigger = 1
                if ai4_brittle != 0:
                    dtd_display_trigger = 1
                if ai4_hh_db != 0:
                    dtd_display_trigger = 1
                if ai4_ws_db != 0:
                    dtd_display_trigger = 1
                if ai4_uc_db != 0:
                    dtd_display_trigger = 1
                if ai4_superconducted != 0:
                    dtd_display_trigger = 1
                if ai4_weakness != 0:
                    ddd_display_trigger = 1
                if ai4_toc != 0:
                    ddd_display_trigger = 1
                if ai4_fencer_dodgechance != 0:
                    ddd_display_trigger = 1
                if db_display_trigger == 1:
                    effects_list.append(":Debuffs:")
                    for status_effect in ai4_statuses:
                        if status_effect == "Stunned":
                            effects_list.append("Stunned ({})".format(ai4_stun))
                        if status_effect == "Taunted":
                            effects_list.append("Taunted: {} ({})".format(ai4_taunt[0], ai4_taunt[1]))
                    if ai4_charged[0] != 0:
                        effects_list.append("Charged: Positive ({})".format(ai4_charged[0]))
                    if ai4_charged[1] != 0:
                        effects_list.append("Charged: Negative ({})".format(ai4_charged[1]))
                if dot_display_trigger == 1:
                    effects_list.append(":Damage Overtime:")
                    for status_effect in ai4_statuses:
                        if status_effect == "Exploding":
                            effects_list.append("Damnation[{}] Detonation in {}".format(ai4_damnation[0], ai4_damnation[1]))
                        if status_effect == "Thorns":
                            effects_list.append("Thorns[{}] [#{}]".format(ai4_thornsDot[0]*ai4_thornsDot[1], ai4_thornsDot[1]))
                        if status_effect == "Serrated":
                            effects_list.append("Serrated[{}] ({})".format(self.calculate_bleed_damage("Serrated", 4), ai4_serraSlashDot[1]))
                        if status_effect == "Eviscerated":
                            effects_list.append("Eviscerated[{}] ({})".format(self.calculate_bleed_damage("Eviscerated", 4), ai4_eviscerDot[1]))
                        if status_effect == "Garroted":
                            effects_list.append("Garroted[{}] ({})".format(self.calculate_bleed_damage("Garroted", 4), ai4_garroteDot[1]))
                        if status_effect == "Barbed Arrow":
                            effects_list.append("Barbed[{}] ({})".format(ai4_barbedArrDot[0], ai4_barbedArrDot[1]))
                        if status_effect == "Rotting":
                            effects_list.append("Rotting[{}] ({})".format(ai4_rottingDot[0], ai4_rottingDot[1]))
                        if status_effect == "Burning":
                            effects_list.append("Burning[{}] ({})".format(ai4_burnDot[0], ai4_burnDot[1]))
                        if status_effect == "Sizzling Light":
                            effects_list.append("Sizzling[{}] ({})".format(ai4_shimmerDot[0], ai4_shimmerDot[1]))
                        if status_effect == "Searing Light":
                            effects_list.append("Searing Light[{}] ({})".format(ai4_divineDot[0], ai4_divineDot[1]))
                if dtd_display_trigger == 1:
                    effects_list.append(":Damage Taken Debuffs:")
                    for status_effect in ai4_statuses:
                        if status_effect == "Thorns":
                            effects_list.append("Naturaly Vunerable [+{}%]".format(ai4_thornsDot[1]))
                        if status_effect == "Brittle":
                            effects_list.append("Brittle ({})".format(ai4_brittle))
                        if status_effect == "HardHitterDB":
                            effects_list.append("Next Wide Swing or Upper Cut [+25%]")
                        if status_effect == "WideSwingDB":
                            effects_list.append("Next Hard Hitter or Upper Cut [+25%]")
                        if status_effect == "UpperCutDB":
                            effects_list.append("Next Hard Hitter or Wide Swip [+25%]")
                        if status_effect == "SuperConducted":
                            effects_list.append("Charge Explosions [+100%] ({})".format(ai4_superconducted))
                if ddd_display_trigger == 1:
                    effects_list.append(":Damage Dealt Debuffs:")
                    for status_effect in ai4_statuses:
                        if status_effect == "Weakened":
                            effects_list.append("Weakened [-20%] ({})".format(ai4_weakness))
                        if status_effect == "Touch of Corruption":
                            effects_list.append("Corrupted [-{}%]".format(ai4_toc))
                    if ai4_fencer_dodgechance != 0:
                        effects_list.append("Chance of Fencer Dodging Increased by [{}%]".format(ai4_fencer_dodgechance))
            if position == 5:
                if ai5_stun != 0:
                    db_display_trigger = 1
                if ai5_taunt[1] != 0:
                    db_display_trigger = 1
                if ai5_charged[0] != 0:
                    db_display_trigger = 1
                elif ai5_charged[1] != 0:
                    db_display_trigger = 1
                if ai5_serraSlashDot[1] != 0:
                    dot_display_trigger = 1
                if ai5_eviscerDot[1] != 0:
                    dot_display_trigger = 1
                if ai5_garroteDot[1] !=0:
                    dot_display_trigger = 1
                if ai5_burnDot[1] != 0:
                    dot_display_trigger = 1
                if ai5_thornsDot[1] != 0:
                    dot_display_trigger = 1
                    dtd_display_trigger = 1
                if ai5_rottingDot[1] != 0:
                    dot_display_trigger = 1
                if ai5_damnation[1] != 0:
                    dot_display_trigger = 1
                if ai5_barbedArrDot[1] != 0:
                    dot_display_trigger = 1
                if ai5_shimmerDot[1] != 0:
                    dot_display_trigger = 1
                if ai5_divineDot[1] != 0:
                    dot_display_trigger = 1
                if ai5_brittle != 0:
                    dtd_display_trigger = 1
                if ai5_hh_db != 0:
                    dtd_display_trigger = 1
                if ai5_ws_db != 0:
                    dtd_display_trigger = 1
                if ai5_uc_db != 0:
                    dtd_display_trigger = 1
                if ai5_superconducted != 0:
                    dtd_display_trigger = 1
                if ai5_weakness != 0:
                    ddd_display_trigger = 1
                if ai5_toc != 0:
                    ddd_display_trigger = 1
                if ai5_fencer_dodgechance != 0:
                    ddd_display_trigger = 1
                if db_display_trigger == 1:
                    effects_list.append(":Debuffs:")
                    for status_effect in ai5_statuses:
                        if status_effect == "Stunned":
                            effects_list.append("Stunned ({})".format(ai5_stun))
                        if status_effect == "Taunted":
                            effects_list.append("Taunted: {} ({})".format(ai5_taunt[0], ai5_taunt[1]))
                    if ai5_charged[0] != 0:
                        effects_list.append("Charged: Positive ({})".format(ai5_charged[0]))
                    if ai5_charged[1] != 0:
                        effects_list.append("Charged: Negative ({})".format(ai5_charged[1]))
                if dot_display_trigger == 1:
                    effects_list.append(":Damage Overtime:")
                    for status_effect in ai5_statuses:
                        if status_effect == "Exploding":
                            effects_list.append("Damnation[{}] Detonation in {}".format(ai5_damnation[0], ai5_damnation[1]))
                        if status_effect == "Thorns":
                            effects_list.append("Thorns[{}] [#{}]".format(ai5_thornsDot[0]*ai5_thornsDot[1], ai5_thornsDot[1]))
                        if status_effect == "Serrated":
                            effects_list.append("Serrated[{}] ({})".format(self.calculate_bleed_damage("Serrated", 5), ai5_serraSlashDot[1]))
                        if status_effect == "Eviscerated":
                            effects_list.append("Eviscerated[{}] ({})".format(self.calculate_bleed_damage("Eviscerated", 5), ai5_eviscerDot[1]))
                        if status_effect == "Garroted":
                            effects_list.append("Garroted[{}] ({})".format(self.calculate_bleed_damage("Garroted", 5), ai5_garroteDot[1]))
                        if status_effect == "Barbed Arrow":
                            effects_list.append("Barbed[{}] ({})".format(ai5_barbedArrDot[0], ai5_barbedArrDot[1]))
                        if status_effect == "Rotting":
                            effects_list.append("Rotting[{}] ({})".format(ai5_rottingDot[0], ai5_rottingDot[1]))
                        if status_effect == "Burning":
                            effects_list.append("Burning[{}] ({})".format(ai5_burnDot[0], ai5_burnDot[1]))
                        if status_effect == "Sizzling Light":
                            effects_list.append("Sizzling[{}] ({})".format(ai5_shimmerDot[0], ai5_shimmerDot[1]))
                        if status_effect == "Searing Light":
                            effects_list.append("Searing Light[{}] ({})".format(ai5_divineDot[0], ai5_divineDot[1]))
                if dtd_display_trigger == 1:
                    effects_list.append(":Damage Taken Debuffs:")
                    for status_effect in ai5_statuses:
                        if status_effect == "Thorns":
                            effects_list.append("Naturaly Vunerable [+{}%]".format(ai5_thornsDot[1]))
                        if status_effect == "Brittle":
                            effects_list.append("Brittle ({})".format(ai5_brittle))
                        if status_effect == "HardHitterDB":
                            effects_list.append("Next Wide Swing or Upper Cut [+25%]")
                        if status_effect == "WideSwingDB":
                            effects_list.append("Next Hard Hitter or Upper Cut [+25%]")
                        if status_effect == "UpperCutDB":
                            effects_list.append("Next Hard Hitter or Wide Swip [+25%]")
                        if status_effect == "SuperConducted":
                            effects_list.append("Charge Explosions [+100%] ({})".format(ai5_superconducted))
                if ddd_display_trigger == 1:
                    effects_list.append(":Damage Dealt Debuffs:")
                    for status_effect in ai5_statuses:
                        if status_effect == "Weakened":
                            effects_list.append("Weakened [-20%] ({})".format(ai5_weakness))
                        if status_effect == "Touch of Corruption":
                            effects_list.append("Corrupted [-{}%]".format(ai5_toc))
                    if ai5_fencer_dodgechance != 0:
                        effects_list.append("Chance of Fencer Dodging Increased by [{}%]".format(ai5_fencer_dodgechance))
        status_effect_text = ""
        for effect in effects_list:
            status_effect_text += effect
            status_effect_text += "\n"
        status_effects_label = tk.Label(root, text=status_effect_text)
        status_effects_label.grid(row=2, column=1)
        close_button = tk.Button(root, text="Close Window", command=root.destroy)
        close_button.grid(row=3, column=1)
#This function run inbetween the end of each turn to check if all enemies or allies are dead, resulting in a win or lose respectively
#If the fight hasn't ended, then this function resets the enemies attack UI to update any stun or taunt applications and check whether its the start of a new round or if its still yours or the monsters turn
    def next_turn(self):
        global combat_results, current_turn, new_round, from_end_of_turn, new_game,\
            champion1_turnover, champion2_turnover, champion3_turnover, champion4_turnover,champion5_turnover, \
            ranger_aura_completed, paladin_aura_completed
        if AI_SPAWNED == 1:
            if ai1_hp <= 0:
                combat_results = "win"
        elif AI_SPAWNED == 2:
            if ai1_hp <= 0:
                if ai2_hp <= 0:
                    combat_results = "win"
        elif AI_SPAWNED == 3:
            if ai1_hp <= 0:
                if ai2_hp <= 0:
                    if ai3_hp <= 0:
                        combat_results = "win"
        elif AI_SPAWNED == 4:
            if ai1_hp <= 0:
                if ai2_hp <= 0:
                    if ai3_hp <= 0:
                        if ai4_hp <= 0:
                            combat_results = "win"
        elif AI_SPAWNED == 5:
            if ai1_hp <= 0:
                if ai2_hp <= 0:
                    if ai3_hp <= 0:
                        if ai4_hp <= 0:
                            if ai5_hp <= 0:
                                combat_results = "win"
        if champion1_hp == 0:
            if champion2_hp == 0:
                if champion3_hp == 0:
                    if champion4_hp == 0:
                        if champion5_hp == 0:
                            combat_results = "lost"
        if combat_results == "win":
            self.combat_to_progression()
        elif combat_results == "lost":
            self.begin_endgame()
        else:
            for widget in dungeon_game_frame.winfo_children():
                widget.destroy()
            self.monster_attack_intentions()
            self.ai_choose_attack_targets()
            self.combat_set()
            if new_game == 1:
                ranger_aura_completed = 0
                paladin_aura_completed = 1
                new_round = 0
                self.before_round_choices()
            elif current_turn == "MN":
                champion1_turnover = 0
                champion2_turnover = 0
                champion3_turnover = 0
                champion4_turnover = 0
                champion5_turnover = 0
                new_round = 1
                self.champion_turn_ticker(1)
                self.champion_turn_ticker(2)
                self.champion_turn_ticker(3)
                self.champion_turn_ticker(4)
                self.champion_turn_ticker(5)
                ranger_aura_completed = 0
                paladin_aura_completed = 1
                self.before_round_choices()
            else:
                new_round = 0
                if champion1_turnover == 1:
                    if champion2_turnover == 1:
                        if champion3_turnover == 1:
                            if champion4_turnover == 1:
                                if champion5_turnover == 1:
                                    self.monsters_turn()
                                else:
                                    self.turn_choice()
                            else:
                                self.turn_choice()
                        else:
                            self.turn_choice()
                    else:
                        self.turn_choice()
                else:
                    self.turn_choice()
#Transition function for the end of combat that changes the combat UI to the DungeonFloorProgress UI
#Increases the room and floors level varaibles, adds 75 mana to mana champions, and runs all the ticker functions once
    def combat_to_progression(self):
        global room_level, floor_level, from_combat, champion1_rp, champion2_rp, champion3_rp, champion4_rp, champion5_rp
        self.champion_turn_ticker(1)
        self.champion_turn_ticker(2)
        self.champion_turn_ticker(3)
        self.champion_turn_ticker(4)
        self.champion_turn_ticker(5)
        self.heal_overtime_tick()
        room_level += 1
        if room_level > 3:
            floor_level += 1
            room_level = 1
        if CHAMPION1_RPNAME == "Mana":
            champion1_rp = champion1_rp + 75
            if champion1_rp > CHAMPION1_RP:
                champion1_rp = CHAMPION1_RP
        if CHAMPION2_RPNAME == "Mana":
            champion2_rp = champion2_rp + 75
            if champion2_rp > CHAMPION2_RP:
                champion2_rp = CHAMPION2_RP
        if CHAMPION3_RPNAME == "Mana":
            champion3_rp = champion3_rp + 75
            if champion3_rp > CHAMPION3_RP:
                champion3_rp = CHAMPION3_RP
        if CHAMPION4_RPNAME == "Mana":
            champion4_rp = champion4_rp + 75
            if champion4_rp > CHAMPION4_RP:
                champion4_rp = CHAMPION4_RP
        if CHAMPION5_RPNAME == "Mana":
            champion5_rp = champion5_rp + 75
            if champion5_rp > CHAMPION5_RP:
                champion5_rp = CHAMPION5_RP
        for widget in dungeon_game_frame.winfo_children():
            widget.destroy()
        entry_status = "From Combat"
        self.DungeonFloorProgress(entry_status)
#Displays the champions choices as buttons on a horizontal plane. The current champion whose turn it is and any champions whose turn has already ended have their options disabled
#so the user can only choose from champions that aren't the current one and haven't had their turn used
    def turn_choice(self):
        global from_turn_choice, back_button, champion1_turn_button, champion2_turn_button, champion3_turn_button, champion4_turn_button, champion5_turn_button, turn_choice_text
        if from_end_of_turn == 1:
            turn_choice_text = tk.Label(dungeon_game_frame, text="Which Champion will make thier action next?")
            if champion1_turnover == 1:
                champion1_turn_button = tk.Button(dungeon_game_frame, text="{}".format(CHAMPION_LIST[0]), state="disabled")
            else:
                champion1_turn_button = tk.Button(dungeon_game_frame, text="{}".format(CHAMPION_LIST[0]), command=lambda: self.champion_turn_switch(1))
            if champion2_turnover == 1:
                champion2_turn_button = tk.Button(dungeon_game_frame, text="{}".format(CHAMPION_LIST[1]), state="disabled")
            else:
                champion2_turn_button = tk.Button(dungeon_game_frame, text="{}".format(CHAMPION_LIST[1]), command=lambda: self.champion_turn_switch(2))
            if champion3_turnover == 1:
                champion3_turn_button = tk.Button(dungeon_game_frame, text="{}".format(CHAMPION_LIST[2]), state="disabled")
            else:
                champion3_turn_button = tk.Button(dungeon_game_frame, text="{}".format(CHAMPION_LIST[2]), command=lambda: self.champion_turn_switch(3))
            if champion4_turnover == 1:
                champion4_turn_button = tk.Button(dungeon_game_frame, text="{}".format(CHAMPION_LIST[3]), state="disabled")
            else:
                champion4_turn_button = tk.Button(dungeon_game_frame, text="{}".format(CHAMPION_LIST[3]), command=lambda: self.champion_turn_switch(4))
            if champion5_turnover == 1:
                champion5_turn_button = tk.Button(dungeon_game_frame, text="{}".format(CHAMPION_LIST[4]), state="disabled")
            else:
                champion5_turn_button = tk.Button(dungeon_game_frame, text="{}".format(CHAMPION_LIST[4]), command=lambda: self.champion_turn_switch(5))
            turn_choice_text.grid(row=18, column=2)
            champion1_turn_button.grid(row=19, column=1)
            champion2_turn_button.grid(row=19, column=1, sticky="e")
            champion3_turn_button.grid(row=19, column=2)
            champion4_turn_button.grid(row=19, column=3, sticky="w")
            champion5_turn_button.grid(row=19, column=3)
        else:
            from_turn_choice = 1
            if current_turn == "C1":
                attack_button_champion1.destroy()
                special_button_champion1.destroy()
                turn_choice_champion1.destroy()
                turn_choice_text = tk.Label(dungeon_game_frame, text="Which Champion will make thier action next?")
                champion1_turn_button = tk.Button(dungeon_game_frame, text="{}".format(CHAMPION_LIST[0]), state="disabled")
                if champion2_turnover == 1:
                    champion2_turn_button = tk.Button(dungeon_game_frame, text="{}".format(CHAMPION_LIST[1]), state="disabled")
                else:
                    champion2_turn_button = tk.Button(dungeon_game_frame, text="{}".format(CHAMPION_LIST[1]), command=lambda: self.champion_turn_switch(2))
                if champion3_turnover == 1:
                    champion3_turn_button = tk.Button(dungeon_game_frame, text="{}".format(CHAMPION_LIST[2]), state="disabled")
                else:
                    champion3_turn_button = tk.Button(dungeon_game_frame, text="{}".format(CHAMPION_LIST[2]), command=lambda: self.champion_turn_switch(3))
                if champion4_turnover == 1:
                    champion4_turn_button = tk.Button(dungeon_game_frame, text="{}".format(CHAMPION_LIST[3]), state="disabled")
                else:
                    champion4_turn_button = tk.Button(dungeon_game_frame, text="{}".format(CHAMPION_LIST[3]), command=lambda: self.champion_turn_switch(4))
                if champion5_turnover == 1:
                    champion5_turn_button = tk.Button(dungeon_game_frame, text="{}".format(CHAMPION_LIST[4]), state="disabled")
                else:
                    champion5_turn_button = tk.Button(dungeon_game_frame, text="{}".format(CHAMPION_LIST[4]), command=lambda: self.champion_turn_switch(5))
                back_button = tk.Button(dungeon_game_frame, text="Back", command=self.player_combat_champion1)
                turn_choice_text.grid(row=18, column=2)
                champion1_turn_button.grid(row=19, column=1)
                champion2_turn_button.grid(row=19, column=1, sticky="e")
                champion3_turn_button.grid(row=19, column=2)
                champion4_turn_button.grid(row=19, column=3, sticky="w")
                champion5_turn_button.grid(row=19, column=3)       
                back_button.grid(row=21, column=2)
            if current_turn == "C2":
                attack_button_champion2.destroy()
                special_button_champion2.destroy()
                turn_choice_champion2.destroy()
                turn_choice_text = tk.Label(dungeon_game_frame, text="Which Champion will make thier action next?")
                if champion1_turnover == 1:
                    champion1_turn_button = tk.Button(dungeon_game_frame, text="{}".format(CHAMPION_LIST[0]), state="disabled")
                else:
                    champion1_turn_button = tk.Button(dungeon_game_frame, text="{}".format(CHAMPION_LIST[0]), command=lambda: self.champion_turn_switch(1))
                champion2_turn_button = tk.Button(dungeon_game_frame, text="{}".format(CHAMPION_LIST[1]), state="disabled")
                if champion3_turnover == 1:
                    champion3_turn_button = tk.Button(dungeon_game_frame, text="{}".format(CHAMPION_LIST[2]), state="disabled")
                else:
                    champion3_turn_button = tk.Button(dungeon_game_frame, text="{}".format(CHAMPION_LIST[2]), command=lambda: self.champion_turn_switch(3))
                if champion4_turnover == 1:
                    champion4_turn_button = tk.Button(dungeon_game_frame, text="{}".format(CHAMPION_LIST[3]), state="disabled")
                else:
                    champion4_turn_button = tk.Button(dungeon_game_frame, text="{}".format(CHAMPION_LIST[3]), command=lambda: self.champion_turn_switch(4))
                if champion5_turnover == 1:
                    champion5_turn_button = tk.Button(dungeon_game_frame, text="{}".format(CHAMPION_LIST[4]), state="disabled")
                else:
                    champion5_turn_button = tk.Button(dungeon_game_frame, text="{}".format(CHAMPION_LIST[4]), command=lambda: self.champion_turn_switch(5))
                back_button =tk.Button(dungeon_game_frame, text="Back", command=self.player_combat_champion2)
                turn_choice_text.grid(row=18, column=2)
                champion1_turn_button.grid(row=19, column=1)
                champion2_turn_button.grid(row=19, column=1, sticky="e")
                champion3_turn_button.grid(row=19, column=2)
                champion4_turn_button.grid(row=19, column=3, sticky="w")
                champion5_turn_button.grid(row=19, column=3)
                back_button.grid(row=21, column=2)
            if current_turn == "C3":
                attack_button_champion3.destroy()
                special_button_champion3.destroy()
                turn_choice_champion3.destroy()
                turn_choice_text = tk.Label(dungeon_game_frame, text="Which Champion will make thier action next?")
                if champion1_turnover == 1:
                    champion1_turn_button = tk.Button(dungeon_game_frame, text="{}".format(CHAMPION_LIST[0]), state="disabled")
                else:
                    champion1_turn_button = tk.Button(dungeon_game_frame, text="{}".format(CHAMPION_LIST[0]), command=lambda: self.champion_turn_switch(1))
                if champion2_turnover == 1:
                    champion2_turn_button = tk.Button(dungeon_game_frame, text="{}".format(CHAMPION_LIST[1]), state="disabled")
                else:
                    champion2_turn_button = tk.Button(dungeon_game_frame, text="{}".format(CHAMPION_LIST[1]), command=lambda: self.champion_turn_switch(2))
                champion3_turn_button = tk.Button(dungeon_game_frame, text="{}".format(CHAMPION_LIST[2]), state="disabled")
                if champion4_turnover == 1:
                    champion4_turn_button = tk.Button(dungeon_game_frame, text="{}".format(CHAMPION_LIST[3]), state="disabled")
                else:
                    champion4_turn_button = tk.Button(dungeon_game_frame, text="{}".format(CHAMPION_LIST[3]), command=lambda: self.champion_turn_switch(4))
                if champion5_turnover == 1:
                    champion5_turn_button = tk.Button(dungeon_game_frame, text="{}".format(CHAMPION_LIST[4]), state="disabled")
                else:
                    champion5_turn_button = tk.Button(dungeon_game_frame, text="{}".format(CHAMPION_LIST[4]), command=lambda: self.champion_turn_switch(5))
                back_button = tk.Button(dungeon_game_frame, text="Back", command=self.player_combat_champion3)
                turn_choice_text.grid(row=18, column=2)
                champion1_turn_button.grid(row=19, column=1)
                champion2_turn_button.grid(row=19, column=1, sticky="e")
                champion3_turn_button.grid(row=19, column=2)
                champion4_turn_button.grid(row=19, column=3, sticky="w")
                champion5_turn_button.grid(row=19, column=3)
                back_button.grid(row=21, column=2)
            if current_turn == "C4":
                attack_button_champion4.destroy()
                special_button_champion4.destroy()
                turn_choice_champion4.destroy()
                turn_choice_text = tk.Label(dungeon_game_frame, text="Which Champion will make thier action next?")
                if champion1_turnover == 1:
                    champion1_turn_button = tk.Button(dungeon_game_frame, text="{}".format(CHAMPION_LIST[0]), state="disabled")
                else:
                    champion1_turn_button = tk.Button(dungeon_game_frame, text="{}".format(CHAMPION_LIST[0]), command=lambda: self.champion_turn_switch(1))
                if champion2_turnover == 1:
                    champion2_turn_button = tk.Button(dungeon_game_frame, text="{}".format(CHAMPION_LIST[1]), state="disabled")
                else:
                    champion2_turn_button = tk.Button(dungeon_game_frame, text="{}".format(CHAMPION_LIST[1]), command=lambda: self.champion_turn_switch(2))
                if champion3_turnover == 1:
                    champion3_turn_button = tk.Button(dungeon_game_frame, text="{}".format(CHAMPION_LIST[2]), state="disabled")
                else:
                    champion3_turn_button = tk.Button(dungeon_game_frame, text="{}".format(CHAMPION_LIST[2]), command=lambda: self.champion_turn_switch(3))
                champion4_turn_button = tk.Button(dungeon_game_frame, text="{}".format(CHAMPION_LIST[3]), state="disabled")
                if champion5_turnover == 1:
                    champion5_turn_button = tk.Button(dungeon_game_frame, text="{}".format(CHAMPION_LIST[4]), state="disabled")
                else:
                    champion5_turn_button = tk.Button(dungeon_game_frame, text="{}".format(CHAMPION_LIST[4]), command=lambda: self.champion_turn_switch(5))
                back_button = tk.Button(dungeon_game_frame, text="Back", command=self.player_combat_champion4)
                turn_choice_text.grid(row=18, column=2)
                champion1_turn_button.grid(row=19, column=1)
                champion2_turn_button.grid(row=19, column=1, sticky="e")
                champion3_turn_button.grid(row=19, column=2)
                champion4_turn_button.grid(row=19, column=3, sticky="w")
                champion5_turn_button.grid(row=19, column=3)
                back_button.grid(row=21, column=2)
            if current_turn == "C5":
                attack_button_champion5.destroy()
                special_button_champion5.destroy()
                turn_choice_champion5.destroy()
                turn_choice_text = tk.Label(dungeon_game_frame, text="Which Champion will make thier action next?")
                if champion1_turnover == 1:
                    champion1_turn_button = tk.Button(dungeon_game_frame, text="{}".format(CHAMPION_LIST[0]), state="disabled")
                else:
                    champion1_turn_button = tk.Button(dungeon_game_frame, text="{}".format(CHAMPION_LIST[0]), command=lambda: self.champion_turn_switch(1))
                if champion2_turnover == 1:
                    champion2_turn_button = tk.Button(dungeon_game_frame, text="{}".format(CHAMPION_LIST[1]), state="disabled")
                else:
                    champion2_turn_button = tk.Button(dungeon_game_frame, text="{}".format(CHAMPION_LIST[1]), command=lambda: self.champion_turn_switch(2))
                if champion3_turnover == 1:
                    champion3_turn_button = tk.Button(dungeon_game_frame, text="{}".format(CHAMPION_LIST[2]), state="disabled")
                else:
                    champion3_turn_button = tk.Button(dungeon_game_frame, text="{}".format(CHAMPION_LIST[2]), command=lambda: self.champion_turn_switch(3))
                if champion4_turnover == 1:
                    champion4_turn_button = tk.Button(dungeon_game_frame, text="{}".format(CHAMPION_LIST[3]), state="disabled")
                else:
                    champion4_turn_button = tk.Button(dungeon_game_frame, text="{}".format(CHAMPION_LIST[3]), command=lambda: self.champion_turn_switch(4))
                champion5_turn_button = tk.Button(dungeon_game_frame, text="{}".format(CHAMPION_LIST[4]), state="disabled")
                back_button = tk.Button(dungeon_game_frame, text="Back", command=self.player_combat_champion5)
                turn_choice_text.grid(row=18, column=2)
                champion1_turn_button.grid(row=19, column=1)
                champion2_turn_button.grid(row=19, column=1, sticky="e")
                champion3_turn_button.grid(row=19, column=2)
                champion4_turn_button.grid(row=19, column=3, sticky="w")
                champion5_turn_button.grid(row=19, column=3)
                back_button.grid(row=21, column=2)
#Switches the current turn to another based on the users choice
    def champion_turn_switch(self, champion_position):
        global from_end_of_turn
        if from_end_of_turn == 1:
            from_end_of_turn = 0
        champion1_turn_button.destroy()
        champion2_turn_button.destroy()
        champion3_turn_button.destroy()
        champion4_turn_button.destroy()
        champion5_turn_button.destroy()
        turn_choice_text.destroy()
        if champion_position == 1:
            self.player_combat_champion1()
        if champion_position == 2:
            self.player_combat_champion2()
        if champion_position == 3:
            self.player_combat_champion3()
        if champion_position == 4:
            self.player_combat_champion4()
        if champion_position == 5:
            self.player_combat_champion5()
#This is a function that deals with champions whose passives require a choice to be made at the start of a round every so often (Currently only Legion Rangers Arrow Tips every 3 rounds and Paladins Auras every two)
#The function only goes through one character section per function call. As only one section will be unmarked for it to look at when first
#When running through the function if the character isn't in the team, then they're automatically marked off
#Character sections that are marked off are blocked off from being ran until the start of the next round unless enabled through the previous characters section when its completed
#If the character is in the team when its section is being ran, a round tracker tied to the champion will tick up after the end of each round and if it reaches the desired threshhold, the choice will be presented to the user to make
#When they make a choice, the round tracker is reset and starting tick up from the beginning. The champions section will be marked off and will enable the next champions section. The before_round_choices function will then be recalled
#When a characters section is completed, they enable the next champions section while checking their own section off, meaning that that section will now always be skipped and the next section will be run when rerunning the function from itself
#Once all sections have been marked off, then the game will continue to the start of the new round
    def before_round_choices(self):
        global legion_ranger_roundtracker, paladin_roundtracker, new_game, paladin_aura_completed, ranger_aura_completed
        if ranger_aura_completed == 0:
            if LEGION_RANGER.title in CHAMPION_LIST:
                ARROW_TYPES = ["Heavy Iron Tip", "Barbed Tip", "Shrapnel Tip", "Venom Tip", "Bola Tip", "Vein Sensitizer Tip"]
                if legion_ranger_roundtracker < 3:
                    legion_ranger_roundtracker = legion_ranger_roundtracker + 1
                    ranger_aura_completed = 1
                    paladin_aura_completed = 0
                else:
                    global ranger_arrow_choice_label, arrow_choice_button1, arrow_choice_button2, arrow_choice_button3
                    random.shuffle(ARROW_TYPES)
                    if current_arrow_type == ARROW_TYPES[0]:
                        arrow_choice = [ARROW_TYPES[1], ARROW_TYPES[2], ARROW_TYPES[3]]
                    elif current_arrow_type == ARROW_TYPES[1]:
                        arrow_choice = [ARROW_TYPES[0], ARROW_TYPES[2], ARROW_TYPES[3]]
                    elif current_arrow_type == [2]:
                        arrow_choice = [ARROW_TYPES[0], ARROW_TYPES[1], ARROW_TYPES[3]]
                    else:
                        arrow_choice = [ARROW_TYPES[0], ARROW_TYPES[1], ARROW_TYPES[2]]
                    legion_ranger_roundtracker = 0
                    ranger_arrow_choice_label = tk.Label(dungeon_game_frame, text="Choose a new arrow for Legion Ranger to equip")
                    ranger_arrow_choice_label.grid(row=18, column=2)
                    arrow_choice_button1 = tk.Button(dungeon_game_frame, text="{}\n{}".format(arrow_choice[0], self.championaura_information(arrow_choice[0])), \
                                                    command=lambda: self.apply_before_round_choices("LEGION-RANGER", arrow_choice[0]))
                    arrow_choice_button2 = tk.Button(dungeon_game_frame, text="{}\n{}".format(arrow_choice[1], self.championaura_information(arrow_choice[1])), \
                                                    command=lambda: self.apply_before_round_choices("LEGION-RANGER", arrow_choice[1]))
                    arrow_choice_button3 = tk.Button(dungeon_game_frame, text="{}\n{}".format(arrow_choice[2], self.championaura_information(arrow_choice[2])), \
                                                    command=lambda: self.apply_before_round_choices("LEGION-RANGER", arrow_choice[2]))
                    arrow_choice_button1.grid(row=19, column=2)
                    arrow_choice_button2.grid(row=20, column=2)
                    arrow_choice_button3.grid(row=21, column=2)
            else:
                ranger_aura_completed = 1
                paladin_aura_completed = 0
        if paladin_aura_completed == 0:
            if PALADIN.title in CHAMPION_LIST:
                AURAS = ["Power Aura", "Protection Aura"]
                if paladin_roundtracker < 2:
                    paladin_roundtracker = paladin_roundtracker + 1
                    paladin_aura_completed = 1
                else:
                    global paladin_aura_choice_label, aura_choice_button1, aura_choice_button2
                    paladin_roundtracker = 0
                    paladin_aura_choice_label = tk.Label(dungeon_game_frame, text="Choose your Paladin's Aura")
                    paladin_aura_choice_label.grid(row=18, column=2)
                    aura_choice_button1 = tk.Button(dungeon_game_frame, text="{}\n{}".format(AURAS[0], self.championaura_information(AURAS[0])), command=lambda: self.apply_before_round_choices("PALADIN", AURAS[0]))
                    aura_choice_button2 = tk.Button(dungeon_game_frame, text="{}\n{}".format(AURAS[1], self.championaura_information(AURAS[1])), command=lambda: self.apply_before_round_choices("PALADIN", AURAS[1]))
                    aura_choice_button1.grid(row=19, column=2)
                    aura_choice_button2.grid(row=20, column=2)
            else:
                paladin_aura_completed = 1
        if ranger_aura_completed == 1:
            if paladin_aura_completed == 1:
                if new_game == 1:
                    new_game = 0
                    self.player_combat_champion1()
                else:
                    self.turn_choice()
#Returns the button text for the parametered option
    def championaura_information(self, name):
        if name == "Heavy Iron Tip":
            text = "Deals 1.5x Damage"
        elif name == "Barbed Tip":
            text = "Applies a Bleed effect to hit enemies"
        elif name == "Shrapnel Tip":
            text = "Hit enemies explode for extra damage to other enemies"
        elif name == "Venom Tip":
            text = "Applies the Weakness debuff to hit enemies"
        elif name == "Bola Tip":
            text = "Hit enemies are stunned"
        elif name == "Vein Sensitizer Tip":
            text = "Applies the Brittle debuff to hit enemies"
        elif name == "Power Aura":
            text = "All Champions deal 20% extra damage"
        elif name == "Protection Aura":
            text = "All Champions take 10% less damage"
        return text
#Replaces the associated variables with the new user choices
    def apply_before_round_choices(self, champion_identifier, choice):
        global current_arrow_type, paladin_aura, ranger_aura_completed, paladin_aura_completed
        if champion_identifier == "LEGION-RANGER":
            current_arrow_type = choice
            ranger_arrow_choice_label.destroy()
            arrow_choice_button1.destroy()
            arrow_choice_button2.destroy()
            arrow_choice_button3.destroy()
            ranger_aura_completed = 1
            paladin_aura_completed = 0
            self.before_round_choices()
        elif champion_identifier == "PALADIN":
            if choice == "Power Aura":
                paladin_aura = 1
                if "Protection Aura" in champion1_statuses:
                    champion1_statuses.remove("Protection Aura")
                    champion2_statuses.remove("Protection Aura")
                    champion3_statuses.remove("Protection Aura")
                    champion4_statuses.remove("Protection Aura")
                    champion5_statuses.remove("Protection Aura")
                    champion1_statuses.append("Power Aura")
                    champion2_statuses.append("Power Aura")
                    champion3_statuses.append("Power Aura")
                    champion4_statuses.append("Power Aura")
                    champion5_statuses.append("Power Aura")
            elif choice == "Protection Aura":
                paladin_aura = 2
                if "Power Aura" in champion1_statuses:
                    champion1_statuses.remove("Power Aura")
                    champion2_statuses.remove("Power Aura")
                    champion3_statuses.remove("Power Aura")
                    champion4_statuses.remove("Power Aura")
                    champion5_statuses.remove("Power Aura")
                    champion1_statuses.append("Protection Aura")
                    champion2_statuses.append("Protection Aura")
                    champion3_statuses.append("Protection Aura")
                    champion4_statuses.append("Protection Aura")
                    champion5_statuses.append("Protection Aura")
            paladin_aura_choice_label.destroy()
            aura_choice_button1.destroy()
            aura_choice_button2.destroy()
            paladin_aura_completed = 1
            self.before_round_choices()
#Returns string of which champion the player is currently controlling
    def current_champions_turn_text(self):
        if current_turn == "C1":
            text = "<{}'s Turn>".format(CHAMPION_LIST[0])
            return text
        elif current_turn == "C2":
            text = "<{}'s Turn>".format(CHAMPION_LIST[1])
            return text
        elif current_turn == "C3":
            text = "<{}'s Turn>".format(CHAMPION_LIST[2])
            return text
        elif current_turn == "C4":
            text = "<{}'s Turn>".format(CHAMPION_LIST[3])
            return text
        elif current_turn == "C5":
            text = "<{}'s Turn>".format(CHAMPION_LIST[4])
            return text
#A new room always starts on Champion1's turn
#Function that brings up the UI for the user to make decisions as champion 1
#Can choose between Attacks, Specials, or to change control to a different champion
#Function also refreshs the enemies choice of attacks on the UI so whenever they're taunted, stunned, etc it changes to that visual
#Sets up the attacks and specials data for champion 1
    def player_combat_champion1(self):
        global attack_button_champion1, special_button_champion1, turn_choice_champion1, current_turn, new_round, from_attack_button, from_special_button, from_turn_choice
        current_turn = "C1"
        if from_attack_button == 1:
            attack1_button.destroy()
            attack1_button_details.destroy()
            attack2_button.destroy()
            attack2_button_details.destroy()
            attack3_button.destroy()
            attack3_button_details.destroy()
            attack4_button.destroy()
            attack4_button_details.destroy()
            back_button.destroy()
            from_attack_button = 0
        if from_special_button == 1:
            special1_button.destroy()
            special1_button_details.destroy()
            special2_button.destroy()
            special2_button_details.destroy()
            special3_button.destroy()
            special3_button_details.destroy()
            special4_button.destroy()
            special4_button_details.destroy()
            back_button.destroy()
            from_special_button = 0
        if from_turn_choice == 1:
            turn_choice_text.destroy()
            champion1_turn_button.destroy()
            champion2_turn_button.destroy()
            champion3_turn_button.destroy()
            champion4_turn_button.destroy()
            champion5_turn_button.destroy()
            back_button.destroy()
            from_turn_choice = 0
        self.combat_set()
        if champion1_hp == 0:
            self.next_turn()
        else:
            button_text_list1 = self.get_champions_ability_button_data(1, "Attack")
            button_text_list2 = self.get_champions_ability_button_data(1, "Special")
            attack_button_champion1 = tk.Button(dungeon_game_frame, text=self.check_if_attack_user_text(), width=59,
                                                height=10, command=lambda: self.check_if_attack_user_command(button_text_list1))
            special_button_champion1 = tk.Button(dungeon_game_frame, text=self.check_if_special_user_text(), width=59, height=10,
                                                command=lambda: self.check_if_special_user_command(button_text_list2))
            turn_choice_champion1 = tk.Button(dungeon_game_frame, text="Change Champions", width=59, height=10,
                                                command=self.turn_choice)
            attack_button_champion1.grid(row=18, column=1)
            special_button_champion1.grid(row=18, column=2)
            turn_choice_champion1.grid(row=18, column=3)
#Function that brings up the UI for the user to make decisions as champion 2
#Can choose between Attacks, Specials, or to change control to a different champion
#Function also refreshs the enemies choice of attacks on the UI so whenever they're taunted, stunned, etc it changes to that visual
#Sets up the attacks and specials data for champion 2    
    def player_combat_champion2(self):
        global attack_button_champion2, special_button_champion2, turn_choice_champion2, current_turn, new_round, from_attack_button, from_special_button, from_turn_choice
        current_turn = "C2"
        if from_attack_button == 1:
            attack1_button.destroy()
            attack1_button_details.destroy()
            attack2_button.destroy()
            attack2_button_details.destroy()
            attack3_button.destroy()
            attack3_button_details.destroy()
            attack4_button.destroy()
            attack4_button_details.destroy()
            back_button.destroy()
            from_attack_button = 0
        if from_special_button == 1:
            special1_button.destroy()
            special1_button_details.destroy()
            special2_button.destroy()
            special2_button_details.destroy()
            special3_button.destroy()
            special3_button_details.destroy()
            special4_button.destroy()
            special4_button_details.destroy()
            back_button.destroy()
            from_special_button = 0
        if from_turn_choice == 1:
            turn_choice_text.destroy()
            champion1_turn_button.destroy()
            champion2_turn_button.destroy()
            champion3_turn_button.destroy()
            champion4_turn_button.destroy()
            champion5_turn_button.destroy()
            back_button.destroy()
            from_turn_choice = 0
        self.combat_set()
        if champion2_hp == 0:
            self.next_turn()
        else:
            button_text_list1 = self.get_champions_ability_button_data(2, "Attack")
            button_text_list2 = self.get_champions_ability_button_data(2, "Special")
            attack_button_champion2 = tk.Button(dungeon_game_frame, text=self.check_if_attack_user_text(), width=59,
                                                height=10, command=lambda: self.check_if_attack_user_command(button_text_list1))
            special_button_champion2 = tk.Button(dungeon_game_frame, text=self.check_if_special_user_text(), width=59, height=10,
                                                command=lambda: self.check_if_special_user_command(button_text_list2))
            turn_choice_champion2 = tk.Button(dungeon_game_frame, text="Change Champions", width=59, height=10,
                                                command=self.turn_choice)
            attack_button_champion2.grid(row=18, column=1)
            special_button_champion2.grid(row=18, column=2)
            turn_choice_champion2.grid(row=18, column=3)
#Function that brings up the UI for the user to make decisions as champion 3
#Can choose between Attacks, Specials, or to change control to a different champion
#Function also refreshs the enemies choice of attacks on the UI so whenever they're taunted, stunned, etc it changes to that visual
#Sets up the attacks and specials data for champion 3  
    def player_combat_champion3(self):
        global attack_button_champion3, special_button_champion3, turn_choice_champion3, current_turn, new_round, from_attack_button, from_special_button, from_turn_choice
        current_turn = "C3"
        if from_attack_button == 1:
            attack1_button.destroy()
            attack1_button_details.destroy()
            attack2_button.destroy()
            attack2_button_details.destroy()
            attack3_button.destroy()
            attack3_button_details.destroy()
            attack4_button.destroy()
            attack4_button_details.destroy()
            back_button.destroy()
            from_attack_button = 0
        if from_special_button == 1:
            special1_button.destroy()
            special1_button_details.destroy()
            special2_button.destroy()
            special2_button_details.destroy()
            special3_button.destroy()
            special3_button_details.destroy()
            special4_button.destroy()
            special4_button_details.destroy()
            back_button.destroy()
            from_special_button = 0
        if from_turn_choice == 1:
            turn_choice_text.destroy()
            champion1_turn_button.destroy()
            champion2_turn_button.destroy()
            champion3_turn_button.destroy()
            champion4_turn_button.destroy()
            champion5_turn_button.destroy()
            back_button.destroy()
            from_turn_choice = 0
        self.combat_set()
        if champion3_hp == 0:
            self.next_turn()
        else:
            button_text_list1 = self.get_champions_ability_button_data(3, "Attack")
            button_text_list2 = self.get_champions_ability_button_data(3, "Special")
            attack_button_champion3 = tk.Button(dungeon_game_frame, text=self.check_if_attack_user_text(), width=59,
                                                height=10, command=lambda: self.check_if_attack_user_command(button_text_list1))
            special_button_champion3 = tk.Button(dungeon_game_frame, text=self.check_if_special_user_text(), width=59, height=10,
                                                command=lambda: self.check_if_special_user_command(button_text_list2))
            turn_choice_champion3 = tk.Button(dungeon_game_frame, text="Change Champions", width=59, height=10,
                                                command=self.turn_choice)
            attack_button_champion3.grid(row=18, column=1)
            special_button_champion3.grid(row=18, column=2)
            turn_choice_champion3.grid(row=18, column=3)
#Function that brings up the UI for the user to make decisions as champion 4
#Can choose between Attacks, Specials, or to change control to a different champion
#Function also refreshs the enemies choice of attacks on the UI so whenever they're taunted, stunned, etc it changes to that visual
#Sets up the attacks and specials data for champion 4  
    def player_combat_champion4(self):
        global attack_button_champion4, special_button_champion4, turn_choice_champion4, current_turn, new_round, from_attack_button, from_special_button, from_turn_choice
        current_turn = "C4"
        if from_attack_button == 1:
            attack1_button.destroy()
            attack1_button_details.destroy()
            attack2_button.destroy()
            attack2_button_details.destroy()
            attack3_button.destroy()
            attack3_button_details.destroy()
            attack4_button.destroy()
            attack4_button_details.destroy()
            back_button.destroy()
            from_attack_button = 0
        if from_special_button == 1:
            special1_button.destroy()
            special1_button_details.destroy()
            special2_button.destroy()
            special2_button_details.destroy()
            special3_button.destroy()
            special3_button_details.destroy()
            special4_button.destroy()
            special4_button_details.destroy()
            back_button.destroy()
            from_special_button = 0
        if from_turn_choice == 1:
            turn_choice_text.destroy()
            champion1_turn_button.destroy()
            champion2_turn_button.destroy()
            champion3_turn_button.destroy()
            champion4_turn_button.destroy()
            champion5_turn_button.destroy()
            back_button.destroy()
            from_turn_choice = 0
        self.combat_set()
        if champion4_hp == 0:
            self.next_turn()
        else:
            button_text_list1 = self.get_champions_ability_button_data(4, "Attack")
            button_text_list2 = self.get_champions_ability_button_data(4, "Special")
            attack_button_champion4 = tk.Button(dungeon_game_frame, text=self.check_if_attack_user_text(), width=59,
                                                height=10, command=lambda: self.check_if_attack_user_command(button_text_list1))
            special_button_champion4 = tk.Button(dungeon_game_frame, text=self.check_if_special_user_text(), width=59, height=10,
                                                command=lambda: self.check_if_special_user_command(button_text_list2))
            turn_choice_champion4 = tk.Button(dungeon_game_frame, text="Change Champions", width=59, height=10,
                                                command=self.turn_choice)
            attack_button_champion4.grid(row=18, column=1)
            special_button_champion4.grid(row=18, column=2)
            turn_choice_champion4.grid(row=18, column=3)
#Function that brings up the UI for the user to make decisions as champion 5
#Can choose between Attacks, Specials, or to change control to a different champion
#Function also refreshs the enemies choice of attacks on the UI so whenever they're taunted, stunned, etc it changes to that visual
#Sets up the attacks and specials data for champion 5 
    def player_combat_champion5(self):
        global attack_button_champion5, special_button_champion5, turn_choice_champion5, current_turn, new_round, from_attack_button, from_special_button, from_turn_choice
        current_turn = "C5"
        if from_attack_button == 1:
            attack1_button.destroy()
            attack1_button_details.destroy()
            attack2_button.destroy()
            attack2_button_details.destroy()
            attack3_button.destroy()
            attack3_button_details.destroy()
            attack4_button.destroy()
            attack4_button_details.destroy()
            back_button.destroy()
            from_attack_button = 0
        if from_special_button == 1:
            special1_button.destroy()
            special1_button_details.destroy()
            special2_button.destroy()
            special2_button_details.destroy()
            special3_button.destroy()
            special3_button_details.destroy()
            special4_button.destroy()
            special4_button_details.destroy()
            back_button.destroy()
            from_special_button = 0
        if from_turn_choice == 1:
            turn_choice_text.destroy()
            champion1_turn_button.destroy()
            champion2_turn_button.destroy()
            champion3_turn_button.destroy()
            champion4_turn_button.destroy()
            champion5_turn_button.destroy()
            back_button.destroy()
            from_turn_choice = 0
        self.combat_set()
        if champion5_hp == 0:
            self.next_turn()
        else:
            button_text_list1 = self.get_champions_ability_button_data(5, "Attack")
            button_text_list2 = self.get_champions_ability_button_data(5, "Special")
            attack_button_champion5 = tk.Button(dungeon_game_frame, text=self.check_if_attack_user_text(), width=59,
                                                height=10, command=lambda: self.check_if_attack_user_command(button_text_list1))
            special_button_champion5 = tk.Button(dungeon_game_frame, text=self.check_if_special_user_text(), width=59, height=10,
                                                command=lambda: self.check_if_special_user_command(button_text_list2))
            turn_choice_champion5 = tk.Button(dungeon_game_frame, text="Change Champions", width=59, height=10,
                                                command=self.turn_choice)
            attack_button_champion5.grid(row=18, column=1)
            special_button_champion5.grid(row=18, column=2)
            turn_choice_champion5.grid(row=18, column=3)
#Checks over if the champion whose turn it is isn't someone who can't use attacks
#If they are someone who can use attacks, the text is the normal 'Attacks', otherwise button the text will be 'Cannot Attack'
    def check_if_attack_user_text(self):
        counter = 1
        attack_text = ""
        for character in CHAMPION_LIST:
            turn_check = "C{}".format(counter)
            if current_turn == turn_check:
                if character == "Power Conduit":
                    unattack_detected = 1
                    break
            counter += 1
        if unattack_detected == 1:
            attack_text = "Cannot Attack"
        else: 
            attack_text = "Attacks"
        return attack_text
#Checks over if the champion whose turn it is isn't someone who can't use attacks
#If they are someone who can use attacks, they're allowed through, otherwise nothing happens and they can't access the attacks tab
    def check_if_attack_user_command(self, button_text_list1):
        counter = 1
        unattack_detected = 0
        for character in CHAMPION_LIST:
            if character == "Power Conduit":
                turn_check = "C{}".format(counter)
                if current_turn == turn_check:
                    unattack_detected = 1
            counter += 1
        if unattack_detected != 1:
            self.special_button(button_text_list1)
#Checks over if the champion whose turn it is isn't someone who can't use specials
#If they are someone who can use specials, the text is the normal 'Special Moves', otherwise button the text will be 'Cannot Use Specials'
    def check_if_special_user_text(self):
        counter = 1
        special_text = ""
        for character in CHAMPION_LIST:
            turn_check = "C{}".format(counter)
            if current_turn == turn_check:
                if character == "Brawlist":
                    unspecial_detected = 1
                    break
                elif character == "Legion Ranger":
                    unspecial_detected = 1
                    break
            counter += 1
        if unspecial_detected == 1:
            special_text = "Cannot Use Specials"
        else: 
            special_text = "Special Moves"
        return special_text
#Checks over if the champion whose turn it is isn't someone who can't use specials
#If they are someone who can use specials, they're allowed through, otherwise nothing happens and they can't access the specials tab
    def check_if_special_user_command(self, button_text_list2):
        counter = 1
        unspecial_detected = 0
        for character in CHAMPION_LIST:
            if character == "Brawlist":
                turn_check = "C{}".format(counter)
                if current_turn == turn_check:
                    unspecial_detected = 1
            elif character == "Legion Ranger":
                turn_check = "C{}".format(counter)
                if current_turn == turn_check:
                    unspecial_detected = 1
            counter += 1
        if unspecial_detected != 1:
            self.special_button(button_text_list2)
#Displays all attacks available to the user to choose from with their name, cost, and remaining cooldown.
#Any button that doesn't have an ability tied to it is shown as Empty
#There is a 'View Details' button below each ability that brings up a window that tells the user everything they need to know about that ability
    def attack_button(self, button_text_list1):
        global attack1_button, attack1_button_details, attack2_button, attack2_button_details, attack3_button, attack3_button_details, attack4_button, attack4_button_details, back_button, \
            from_attack_button, target_to_attack
        if target_to_attack == 1:
            target_to_attack = 0
            if AI_SPAWNED == 1:
                ai1_attacktarget_frame.destroy()
                target_back_button.destroy()
            if AI_SPAWNED == 2:
                ai1_attacktarget_frame.destroy()
                ai2_attacktarget_frame.destroy()
                target_back_button.destroy()
            if AI_SPAWNED == 3:
                ai1_attacktarget_frame.destroy()
                ai2_attacktarget_frame.destroy()
                ai3_attacktarget_frame.destroy()
                target_back_button.destroy()
            if AI_SPAWNED == 4:
                ai1_attacktarget_frame.destroy()
                ai2_attacktarget_frame.destroy()
                ai3_attacktarget_frame.destroy()
                ai4_attacktarget_frame.destroy()
                target_back_button.destroy()
            if AI_SPAWNED == 5:
                ai1_attacktarget_frame.destroy()
                ai2_attacktarget_frame.destroy()
                ai3_attacktarget_frame.destroy()
                ai4_attacktarget_frame.destroy()
                ai5_attacktarget_frame.destroy()
                target_back_button.destroy()
        if current_turn == "C1":
            attack_button_champion1.destroy()
            special_button_champion1.destroy()
            turn_choice_champion1.destroy()
            attack1_button = tk.Button(dungeon_game_frame, text=button_text_list1[0], width=50, height=4,
                                       command=lambda: self.champion_attacks(button_text_list1[0]))
            attack1_button_details = tk.Button(dungeon_game_frame,
                                               text="{} Details".format(button_text_list1[0]), width=38,
                                               height=1, command=lambda: self.attack_details_window(button_text_list1[0]))
            attack2_button = tk.Button(dungeon_game_frame, text=button_text_list1[1], width=50, height=4,
                                       command=lambda: self.champion_attacks(button_text_list1[1]))
            attack2_button_details = tk.Button(dungeon_game_frame,
                                               text="{} Details".format(button_text_list1[1]), width=38,
                                               height=1, command=lambda: self.attack_details_window(button_text_list1[1]))
            attack3_button = tk.Button(dungeon_game_frame, text=button_text_list1[2], width=50, height=4,
                                       command=lambda: self.champion_attacks(button_text_list1[2]))
            attack3_button_details = tk.Button(dungeon_game_frame,
                                               text="{} Details".format(button_text_list1[2]), width=38,
                                               height=1, command=lambda: self.attack_details_window(button_text_list1[2]))
            attack4_button = tk.Button(dungeon_game_frame, text=button_text_list1[3], width=50, height=4,
                                       command=lambda: self.champion_attacks(button_text_list1[3]))
            attack4_button_details = tk.Button(dungeon_game_frame,
                                               text="{} Details".format(button_text_list1[3]), width=38,
                                               height=1, command=lambda: self.attack_details_window(button_text_list1[3]))
            back_button = tk.Button(dungeon_game_frame, text="Back", command=self.player_combat_champion1)
            back_button.grid(row=20, column=2, pady=20)
            attack1_button.grid(row=18, column=1)
            attack1_button_details.grid(row=19, column=1)
            attack2_button.grid(row=18, column=3)
            attack2_button_details.grid(row=19, column=3)
            attack3_button.grid(row=20, column=1)
            attack3_button_details.grid(row=21, column=1)
            attack4_button.grid(row=20, column=3)
            attack4_button_details.grid(row=21, column=3)
            from_attack_button = 1
        if current_turn == "C2":
            attack_button_champion2.destroy()
            special_button_champion2.destroy()
            turn_choice_champion2.destroy()
            attack1_button = tk.Button(dungeon_game_frame, text=button_text_list1[0], width=50, height=4,
                                       command=lambda: self.champion_attacks(button_text_list1[0]))
            attack1_button_details = tk.Button(dungeon_game_frame,
                                               text="{} Details".format(button_text_list1[0]), width=38,
                                               height=1, command=lambda: self.attack_details_window(button_text_list1[0]))
            attack2_button = tk.Button(dungeon_game_frame, text=button_text_list1[1], width=50, height=4,
                                       command=lambda: self.champion_attacks(button_text_list1[1]))
            attack2_button_details = tk.Button(dungeon_game_frame,
                                               text="{} Details".format(button_text_list1[1]), width=38,
                                               height=1, command=lambda: self.attack_details_window(button_text_list1[1]))
            attack3_button = tk.Button(dungeon_game_frame, text=button_text_list1[2], width=50, height=4,
                                       command=lambda: self.champion_attacks(button_text_list1[2]))
            attack3_button_details = tk.Button(dungeon_game_frame,
                                               text="{} Details".format(button_text_list1[2]), width=38,
                                               height=1, command=lambda: self.attack_details_window(button_text_list1[2]))
            attack4_button = tk.Button(dungeon_game_frame, text=button_text_list1[3], width=50, height=4,
                                       command=lambda: self.champion_attacks(button_text_list1[3]))
            attack4_button_details = tk.Button(dungeon_game_frame,
                                               text="{} Details".format(button_text_list1[3]), width=38,
                                               height=1, command=lambda: self.attack_details_window(button_text_list1[3]))
            back_button = tk.Button(dungeon_game_frame, text="Back", command=self.player_combat_champion2)
            back_button.grid(row=20, column=2, pady=20)
            attack1_button.grid(row=18, column=1)
            attack1_button_details.grid(row=19, column=1)
            attack2_button.grid(row=18, column=3)
            attack2_button_details.grid(row=19, column=3)
            attack3_button.grid(row=20, column=1)
            attack3_button_details.grid(row=21, column=1)
            attack4_button.grid(row=20, column=3)
            attack4_button_details.grid(row=21, column=3)
            from_attack_button = 1
        if current_turn == "C3":
            attack_button_champion3.destroy()
            special_button_champion3.destroy()
            turn_choice_champion3.destroy()
            attack1_button = tk.Button(dungeon_game_frame, text=button_text_list1[0], width=50, height=4,
                                       command=lambda: self.champion_attacks(button_text_list1[0]))
            attack1_button_details = tk.Button(dungeon_game_frame,
                                               text="{} Details".format(button_text_list1[0]), width=38,
                                               height=1, command=lambda: self.attack_details_window(button_text_list1[0]))
            attack2_button = tk.Button(dungeon_game_frame, text=button_text_list1[1], width=50, height=4,
                                       command=lambda: self.champion_attacks(button_text_list1[1]))
            attack2_button_details = tk.Button(dungeon_game_frame,
                                               text="{} Details".format(button_text_list1[1]), width=38,
                                               height=1, command=lambda: self.attack_details_window(button_text_list1[1]))
            attack3_button = tk.Button(dungeon_game_frame, text=button_text_list1[2], width=50, height=4,
                                       command=lambda: self.champion_attacks(button_text_list1[2]))
            attack3_button_details = tk.Button(dungeon_game_frame,
                                               text="{} Details".format(button_text_list1[2]), width=38,
                                               height=1, command=lambda: self.attack_details_window(button_text_list1[2]))
            attack4_button = tk.Button(dungeon_game_frame, text=button_text_list1[3], width=50, height=4,
                                       command=lambda: self.champion_attacks(button_text_list1[3]))
            attack4_button_details = tk.Button(dungeon_game_frame,
                                               text="{} Details".format(button_text_list1[3]), width=38,
                                               height=1, command=lambda: self.attack_details_window(button_text_list1[3]))
            back_button = tk.Button(dungeon_game_frame, text="Back", command=self.player_combat_champion3)
            back_button.grid(row=20, column=2, pady=20)
            attack1_button.grid(row=18, column=1)
            attack1_button_details.grid(row=19, column=1)
            attack2_button.grid(row=18, column=3)
            attack2_button_details.grid(row=19, column=3)
            attack3_button.grid(row=20, column=1)
            attack3_button_details.grid(row=21, column=1)
            attack4_button.grid(row=20, column=3)
            attack4_button_details.grid(row=21, column=3)
            from_attack_button = 1
        if current_turn == "C4":
            attack_button_champion4.destroy()
            special_button_champion4.destroy()
            turn_choice_champion4.destroy()
            attack1_button = tk.Button(dungeon_game_frame, text=button_text_list1[0], width=50, height=4,
                                       command=lambda: self.champion_attacks(button_text_list1[0]))
            attack1_button_details = tk.Button(dungeon_game_frame,
                                               text="{} Details".format(button_text_list1[0]), width=38,
                                               height=1, command=lambda: self.attack_details_window(button_text_list1[0]))
            attack2_button = tk.Button(dungeon_game_frame, text=button_text_list1[1], width=50, height=4,
                                       command=lambda: self.champion_attacks(button_text_list1[1]))
            attack2_button_details = tk.Button(dungeon_game_frame,
                                               text="{} Details".format(button_text_list1[1]), width=38,
                                               height=1, command=lambda: self.attack_details_window(button_text_list1[1]))
            attack3_button = tk.Button(dungeon_game_frame, text=button_text_list1[2], width=50, height=4,
                                       command=lambda: self.champion_attacks(button_text_list1[2]))
            attack3_button_details = tk.Button(dungeon_game_frame,
                                               text="{} Details".format(button_text_list1[2]), width=38,
                                               height=1, command=lambda: self.attack_details_window(button_text_list1[2]))
            attack4_button = tk.Button(dungeon_game_frame, text=button_text_list1[3], width=50, height=4,
                                       command=lambda: self.champion_attacks(button_text_list1[3]))
            attack4_button_details = tk.Button(dungeon_game_frame,
                                               text="{} Details".format(button_text_list1[3]), width=38,
                                               height=1, command=lambda: self.attack_details_window(button_text_list1[3]))
            back_button = tk.Button(dungeon_game_frame, text="Back", command=self.player_combat_champion4)
            back_button.grid(row=20, column=2, pady=20)
            attack1_button.grid(row=18, column=1)
            attack1_button_details.grid(row=19, column=1)
            attack2_button.grid(row=18, column=3)
            attack2_button_details.grid(row=19, column=3)
            attack3_button.grid(row=20, column=1)
            attack3_button_details.grid(row=21, column=1)
            attack4_button.grid(row=20, column=3)
            attack4_button_details.grid(row=21, column=3)
            from_attack_button = 1
        if current_turn == "C5":
            attack_button_champion5.destroy()
            special_button_champion5.destroy()
            turn_choice_champion5.destroy()
            attack1_button = tk.Button(dungeon_game_frame, text=button_text_list1[0], width=50, height=4,
                                       command=lambda: self.champion_attacks(button_text_list1[0]))
            attack1_button_details = tk.Button(dungeon_game_frame,
                                               text="{} Details".format(button_text_list1[0]), width=38,
                                               height=1, command=lambda: self.attack_details_window(button_text_list1[0]))
            attack2_button = tk.Button(dungeon_game_frame, text=button_text_list1[1], width=50, height=4,
                                       command=lambda: self.champion_attacks(button_text_list1[1]))
            attack2_button_details = tk.Button(dungeon_game_frame,
                                               text="{} Details".format(button_text_list1[1]), width=38,
                                               height=1, command=lambda: self.attack_details_window(button_text_list1[1]))
            attack3_button = tk.Button(dungeon_game_frame, text=button_text_list1[2], width=50, height=4,
                                       command=lambda: self.champion_attacks(button_text_list1[2]))
            attack3_button_details = tk.Button(dungeon_game_frame,
                                               text="{} Details".format(button_text_list1[2]), width=38,
                                               height=1, command=lambda: self.attack_details_window(button_text_list1[2]))
            attack4_button = tk.Button(dungeon_game_frame, text=button_text_list1[3], width=50, height=4,
                                       command=lambda: self.champion_attacks(button_text_list1[3]))
            attack4_button_details = tk.Button(dungeon_game_frame,
                                               text="{} Details".format(button_text_list1[3]), width=38,
                                               height=1, command=lambda: self.attack_details_window(button_text_list1[3]))
            back_button = tk.Button(dungeon_game_frame, text="Back", command=self.player_combat_champion5)
            back_button.grid(row=20, column=2, pady=20)
            attack1_button.grid(row=18, column=1)
            attack1_button_details.grid(row=19, column=1)
            attack2_button.grid(row=18, column=3)
            attack2_button_details.grid(row=19, column=3)
            attack3_button.grid(row=20, column=1)
            attack3_button_details.grid(row=21, column=1)
            attack4_button.grid(row=20, column=3)
            attack4_button_details.grid(row=21, column=3)
            from_attack_button = 1
#Adds all of the current champions attacks and specials into a list thats given to another function to turn into button text
#The list of either attacks or specials thats returned is based on whatever the 'ability_set' parameter is
    def get_champions_ability_button_data(self, champion_position, ability_set):
        attack_button_text_list_temp = []
        special_button_text_list_temp = []
        if champion_position == 1:
            for abilities in CHAMPION1_ATTACKLIST:
                attack_button_text_list_temp.append(abilities)
            while len(attack_button_text_list_temp) < 4:
                attack_button_text_list_temp.append("Empty")
            for abilities in CHAMPION1_SPECIALLIST:
                special_button_text_list_temp.append(abilities)
            while len(special_button_text_list_temp) < 4:
                special_button_text_list_temp.append("Empty")
        if champion_position == 2:
            for abilities in CHAMPION2_ATTACKLIST:
                attack_button_text_list_temp.append(abilities)
            while len(attack_button_text_list_temp) < 4:
                attack_button_text_list_temp.append("Empty")
            for abilities in CHAMPION2_SPECIALLIST:
                special_button_text_list_temp.append(abilities)
            while len(special_button_text_list_temp) < 4:
                special_button_text_list_temp.append("Empty")
        if champion_position == 3:
            for abilities in CHAMPION3_ATTACKLIST:
                attack_button_text_list_temp.append(abilities)
            while len(attack_button_text_list_temp) < 4:
                attack_button_text_list_temp.append("Empty")
            for abilities in CHAMPION3_SPECIALLIST:
                special_button_text_list_temp.append(abilities)
            while len(special_button_text_list_temp) < 4:
                special_button_text_list_temp.append("Empty")
        if champion_position == 4:
            for abilities in CHAMPION4_ATTACKLIST:
                attack_button_text_list_temp.append(abilities)
            while len(attack_button_text_list_temp) < 4:
                attack_button_text_list_temp.append("Empty")
            for abilities in CHAMPION4_SPECIALLIST:
                special_button_text_list_temp.append(abilities)
            while len(special_button_text_list_temp) < 4:
                special_button_text_list_temp.append("Empty")
        if champion_position == 5:
            for abilities in CHAMPION5_ATTACKLIST:
                attack_button_text_list_temp.append(abilities)
            while len(attack_button_text_list_temp) < 4:
                attack_button_text_list_temp.append("Empty")
            for abilities in CHAMPION5_SPECIALLIST:
                special_button_text_list_temp.append(abilities)
            while len(special_button_text_list_temp) < 4:
                special_button_text_list_temp.append("Empty")
        if ability_set == "Attack":
            button_list = self.champions_attack_button_text(attack_button_text_list_temp)
        elif ability_set == "Special":
            button_list = self.champions_special_button_text(special_button_text_list_temp)
        return button_list
#Checks which attacks are in the list and adds their costs and cooldowns remaining to a string thats added to a list thats returned
    def champions_attack_button_text(self, attack_button_text_list_temp):
        global attack_button_text_list, special_button_text_list
        attack_button_text_list = []
        special_button_text_list = []
        for attack_name in attack_button_text_list_temp:
            if attack_name == "Leg Sweep":
                if leg_sweep_requirements[0] > 0:
                    if leg_sweep_requirements[3] > 0:
                        attack_text = "Leg Sweep ({})\n{} {}".format(leg_sweep_requirements[3], MONK.rp_name,
                                                                     leg_sweep_requirements[0])
                        attack_button_text_list.append(attack_text)
                    else:
                        attack_text = "Leg Sweep\n{} {}".format(MONK.rp_name, leg_sweep_requirements[0])
                        attack_button_text_list.append(attack_text)
                elif leg_sweep_requirements[3] > 0:
                    attack_text = "Leg Sweep ({})".format(leg_sweep_requirements[3])
                    attack_button_text_list.append(attack_text)
                else:
                    attack_button_text_list.append(attack_name)
            elif attack_name == "Pulverize":
                if pulverize_requirements[0] > 0:
                    if pulverize_requirements[3] > 0:
                        attack_text = "Pulverize ({})\n{} {}".format(pulverize_requirements[3], BARBARIAN.rp_name,
                                                                     pulverize_requirements[0])
                        attack_button_text_list.append(attack_text)
                    else:
                        attack_text = "Pulverize\n{} {}".format(BARBARIAN.rp_name, pulverize_requirements[0])
                        attack_button_text_list.append(attack_text)
                elif pulverize_requirements[3] > 0:
                    attack_text = "Pulverize ({})".format(pulverize_requirements[3])
                    attack_button_text_list.append(attack_text)
                else:
                    attack_button_text_list.append(attack_name)
            elif attack_name == "Trainwreck":
                if trainwreck_requirements[0] > 0:
                    if trainwreck_requirements[3] > 0:
                        attack_text = "Trainwreck ({})\n{} {}".format(trainwreck_requirements[3],
                                                                      KINGS_GUARD.rp_name,
                                                                      trainwreck_requirements[0])
                        attack_button_text_list.append(attack_text)
                    else:
                        attack_text = "Trainwreck\n{} {}".format(KINGS_GUARD.rp_name, trainwreck_requirements[0])
                        attack_button_text_list.append(attack_text)
                elif trainwreck_requirements[3] > 0:
                    attack_text = "Trainwreck ({})".format(trainwreck_requirements[3])
                    attack_button_text_list.append(attack_text)
                else:
                    attack_button_text_list.append(attack_name)
            elif attack_name == "Riposte":
                if riposte_requirements[0] > 0:
                    if riposte_requirements[3] > 0:
                        attack_text = "Riposte ({})\n{} {}".format(riposte_requirements[3],
                                                                            MASTER_FENCER.rp_name,
                                                                            riposte_requirements[0])
                        attack_button_text_list.append(attack_text)
                    else:
                        attack_text = "Riposte\n{} {}".format(MASTER_FENCER.rp_name,
                                                                       riposte_requirements[0])
                        attack_button_text_list.append(attack_text)
                elif riposte_requirements[3] > 0:
                    attack_text = "Riposte ({})".format(riposte_requirements[3])
                    attack_button_text_list.append(attack_text)
                else:
                    attack_button_text_list.append(attack_name)
            elif attack_name == "Unbridled Rampage":
                if unbridled_rampage_requirements[0] > 0:
                    if unbridled_rampage_requirements[3] > 0:
                        attack_text = "Rampage ({})\n{} {}".format(unbridled_rampage_requirements[3], BERSERKER.rp_name,
                                                                   unbridled_rampage_requirements[0])
                        attack_button_text_list.append(attack_text)
                    else:
                        attack_text = "Rampage\n{} {}".format(BERSERKER.rp_name, unbridled_rampage_requirements[0])
                        attack_button_text_list.append(attack_text)
                elif unbridled_rampage_requirements[3] > 0:
                    attack_text = "Rampage ({})".format(unbridled_rampage_requirements[3])
                    attack_button_text_list.append(attack_text)
                else:
                    attack_button_text_list.append(attack_name)
            elif attack_name == "Eviscerate":
                if eviscerate_requirements[0] > 0:
                    if eviscerate_requirements[3] > 0:
                        attack_text = "Eviscerate ({})\n{} {}".format(eviscerate_requirements[3], ROGUE.rp_name,
                                                                      eviscerate_requirements[0])
                        attack_button_text_list.append(attack_text)
                    else:
                        attack_text = "Eviscerate\n{} {}".format(ROGUE.rp_name, eviscerate_requirements[0])
                        attack_button_text_list.append(attack_text)
                elif eviscerate_requirements[3] > 0:
                    attack_text = "Eviscerate ({})".format(eviscerate_requirements[3])
                    attack_button_text_list.append(attack_text)
                else:
                    attack_button_text_list.append(attack_name)
            elif attack_name == "Scrap Bomb":
                if scrap_bomb_requirements[0] > 0:
                    if scrap_bomb_requirements[3] > 0:
                        attack_text = "Scrap Bomb ({})\n{} {}".format(scrap_bomb_requirements[3], SURVIVALIST.rp_name,
                                                                      scrap_bomb_requirements[
                                                                          0])
                        attack_button_text_list.append(attack_text)
                    else:
                        attack_text = "Scrap Bomb\n{} {}".format(SURVIVALIST.rp_name, scrap_bomb_requirements[0])
                        attack_button_text_list.append(attack_text)
                elif scrap_bomb_requirements[3] > 0:
                    attack_text = "Scrap Bomb ({})".format(scrap_bomb_requirements[3])
                    attack_button_text_list.append(attack_text)
                else:
                    attack_button_text_list.append(attack_name)
            elif attack_name == "Uppercut":
                if uppercut_requirements[0] > 0:
                    if uppercut_requirements[3] > 0:
                        attack_text = "Uppercut ({})\n{} {}".format(uppercut_requirements[3], BRAWLIST.rp_name,
                                                                    uppercut_requirements[
                                                                        0])
                        attack_button_text_list.append(attack_text)
                    else:
                        attack_text = "Uppercut\n{} {}".format(BRAWLIST.rp_name, uppercut_requirements[0])
                        attack_button_text_list.append(attack_text)
                elif uppercut_requirements[3] > 0:
                    attack_text = "Uppercut ({})".format(uppercut_requirements[3])
                    attack_button_text_list.append(attack_text)
                else:
                    attack_button_text_list.append(attack_name)
            elif attack_name == "Knock Out":
                if knock_out_requirements[0] > 0:
                    if knock_out_requirements[3] > 0:
                        attack_text = "Knock Out ({})\n{} {}".format(knock_out_requirements[3],
                                                                             BRAWLIST.rp_name,
                                                                             knock_out_requirements[
                                                                                 0])
                        attack_button_text_list.append(attack_text)
                    else:
                        attack_text = "Knock Out\n{} {}".format(BRAWLIST.rp_name,
                                                                        knock_out_requirements[0])
                        attack_button_text_list.append(attack_text)
                elif knock_out_requirements[3] > 0:
                    attack_text = "Knock Out ({})".format(knock_out_requirements[3])
                    attack_button_text_list.append(attack_text)
                else:
                    attack_button_text_list.append(attack_name)
            elif attack_name == "Wide Swing":
                if wide_swing_requirements[0] > 0:
                    if wide_swing_requirements[3] > 0:
                        attack_text = "Wide Swing ({})\n{} {}".format(wide_swing_requirements[3], BRAWLIST.rp_name,
                                                                     wide_swing_requirements[
                                                                         0])
                        attack_button_text_list.append(attack_text)
                    else:
                        attack_text = "Wide Swing\n{} {}".format(BRAWLIST.rp_name, wide_swing_requirements[0])
                        attack_button_text_list.append(attack_text)
                elif wide_swing_requirements[3] > 0:
                    attack_text = "Wide Swing ({})".format(wide_swing_requirements[3])
                    attack_button_text_list.append(attack_text)
                else:
                    attack_button_text_list.append(attack_name)
            elif attack_name == "Frost Bolt":
                if frost_bolt_requirements[0] > 0:
                    if frost_bolt_requirements[3] > 0:
                        attack_text = "Frost Bolt ({})\n{} {}".format(frost_bolt_requirements[3], ACADEMIC_MAGE.rp_name,
                                                                      frost_bolt_requirements[
                                                                          0])
                        attack_button_text_list.append(attack_text)
                    else:
                        attack_text = "Frost Bolt\n{} {}".format(ACADEMIC_MAGE.rp_name, frost_bolt_requirements[0])
                        attack_button_text_list.append(attack_text)
                elif frost_bolt_requirements[3] > 0:

                    attack_text = "Frost Bolt ({})".format(frost_bolt_requirements[3])
                    attack_button_text_list.append(attack_text)
                else:
                    attack_button_text_list.append(attack_name)
            elif attack_name == "Fireball":
                if fireball_requirements[0] > 0:
                    if fireball_requirements[3] > 0:
                        attack_text = "Fireball ({})\n{} {}".format(fireball_requirements[3], ACADEMIC_MAGE.rp_name,
                                                                    fireball_requirements[
                                                                        0])
                        attack_button_text_list.append(attack_text)
                    else:
                        attack_text = "Fireball\n{} {}".format(ACADEMIC_MAGE.rp_name, fireball_requirements[0])
                        attack_button_text_list.append(attack_text)
                elif fireball_requirements[3] > 0:
                    attack_text = "Fireball ({})".format(fireball_requirements[3])
                    attack_button_text_list.append(attack_text)
                else:
                    attack_button_text_list.append(attack_name)
            elif attack_name == "Invigorate Thorns":
                if invigorate_thorns_requirements[0] > 0:
                    if invigorate_thorns_requirements[3] > 0:
                        attack_text = "Invigorate Thorns ({})\n{} {}".format(invigorate_thorns_requirements[3], DRUID.rp_name,
                                                                          invigorate_thorns_requirements[
                                                                              0])
                        attack_button_text_list.append(attack_text)
                    else:
                        attack_text = "Invigorate Thorns\n{} {}".format(DRUID.rp_name, invigorate_thorns_requirements[0])
                        attack_button_text_list.append(attack_text)
                elif invigorate_thorns_requirements[3] > 0:

                    attack_text = "Invigorate Thorns ({})".format(invigorate_thorns_requirements[3])
                    attack_button_text_list.append(attack_text)
                else:
                    attack_button_text_list.append(attack_name)
            elif attack_name == "Vine-Swipe":
                if vine_swipe_requirements[0] > 0:
                    if vine_swipe_requirements[3] > 0:
                        attack_text = "Vine-Swipe ({})\n{} {}".format(vine_swipe_requirements[3], DRUID.rp_name,
                                                                      vine_swipe_requirements[
                                                                          0])
                        attack_button_text_list.append(attack_text)
                    else:
                        attack_text = "Vine-Swipe\n{} {}".format(DRUID.rp_name, vine_swipe_requirements[0])
                        attack_button_text_list.append(attack_text)
                elif vine_swipe_requirements[3] > 0:

                    attack_text = "Vine-Swipe ({})".format(vine_swipe_requirements[3])
                    attack_button_text_list.append(attack_text)
                else:
                    attack_button_text_list.append(attack_name)
            elif attack_name == "Black Bolt":
                if black_bolt_requirements[0] > 0:
                    if black_bolt_requirements[3] > 0:
                        attack_text = "Black Bolt ({})\n{} {}".format(black_bolt_requirements[3], WARLOCK.rp_name,
                                                                      black_bolt_requirements[
                                                                          0])
                        attack_button_text_list.append(attack_text)
                    else:
                        attack_text = "Black Bolt\n{} {}".format(WARLOCK.rp_name, black_bolt_requirements[0])
                        attack_button_text_list.append(attack_text)
                elif black_bolt_requirements[3] > 0:
                    attack_text = "Black Bolt ({})".format(black_bolt_requirements[3])
                    attack_button_text_list.append(attack_text)
                else:
                    attack_button_text_list.append(attack_name)
            elif attack_name == "Blood Spike":
                if blood_spike_requirements[0] > 0:
                    if blood_spike_requirements[3] > 0:
                        attack_text = "Blood Spike ({})\n{} {}".format(blood_spike_requirements[3], "Health",
                                                                       blood_spike_requirements[
                                                                           0])
                        attack_button_text_list.append(attack_text)
                    else:
                        attack_text = "Blood Spike\n{} {}".format("Health", blood_spike_requirements[0])
                        attack_button_text_list.append(attack_text)
                elif blood_spike_requirements[3] > 0:

                    attack_text = "Blood Spike ({})".format(blood_spike_requirements[3])
                    attack_button_text_list.append(attack_text)
                else:
                    attack_text = "Blood Spike\n{} {}".format("Health", BLOODMANCER.ap)
                    attack_button_text_list.append(attack_text)
            elif attack_name == "Righteous Blow":
                if righteous_blow_requirements[0] > 0:
                    if righteous_blow_requirements[3] > 0:
                        attack_text = "Righteous Blow ({})\n{} {}".format(righteous_blow_requirements[3], PALADIN.rp_name,
                                                                         righteous_blow_requirements[
                                                                             0])
                        attack_button_text_list.append(attack_text)
                    else:
                        attack_text = "Righteous Blow\n{} {}".format(PALADIN.rp_name, righteous_blow_requirements[0])
                        attack_button_text_list.append(attack_text)
                elif righteous_blow_requirements[3] > 0:

                    attack_text = "Righteous Blow ({})".format(righteous_blow_requirements[3])
                    attack_button_text_list.append(attack_text)
                else:
                    attack_button_text_list.append(attack_name)
            elif attack_name == "Power Shot":
                if power_shot_requirements[0] > 0:
                    if power_shot_requirements[3] > 0:
                        attack_text = "Power Shot ({})\n{} {}".format(power_shot_requirements[3], LEGION_RANGER.rp_name,
                                                                     power_shot_requirements[
                                                                         0])
                        attack_button_text_list.append(attack_text)
                    else:
                        attack_text = "Power Shot\n{} {}".format(LEGION_RANGER.rp_name, power_shot_requirements[0])
                        attack_button_text_list.append(attack_text)
                elif power_shot_requirements[3] > 0:
                    attack_text = "Power Shot ({})".format(power_shot_requirements[3])
                    attack_button_text_list.append(attack_text)
                else:
                    attack_button_text_list.append(attack_name)
            elif attack_name == "Divine Smite":
                if divine_smite_requirements[0] > 0:
                    if divine_smite_requirements[3] > 0:
                        attack_text = "Divine Smite ({})\n{} {}".format(divine_smite_requirements[3],
                                                                        PRIEST.rp_name,
                                                                        divine_smite_requirements[
                                                                            0])
                        attack_button_text_list.append(attack_text)
                    else:
                        attack_text = "Divine Smite\n{} {}".format(PRIEST.rp_name,
                                                                   divine_smite_requirements[0])
                        attack_button_text_list.append(attack_text)
                elif divine_smite_requirements[3] > 0:
                    attack_text = "Divine Smite ({})".format(divine_smite_requirements[3])
                    attack_button_text_list.append(attack_text)
                else:
                    attack_button_text_list.append(attack_name)
            elif attack_name == "Crusade":
                if crusade_requirements[0] > 0:
                    if crusade_requirements[3] > 0:
                        attack_text = "Crusade ({})\n{} {}".format(crusade_requirements[3],
                                                                          PALADIN.rp_name, crusade_requirements[
                                                                              0])
                        attack_button_text_list.append(attack_text)
                    else:
                        attack_text = "Crusade\n{} {}".format(PALADIN.rp_name, crusade_requirements[0])
                        attack_button_text_list.append(attack_text)
                elif crusade_requirements[3] > 0:
                    attack_text = "Crusade ({})".format(crusade_requirements[3])
                    attack_button_text_list.append(attack_text)
                else:
                    attack_button_text_list.append(attack_name)
            elif attack_name == "Multi-shot":
                if multi_shot_requirements[0] > 0:
                    if multi_shot_requirements[3] > 0:
                        attack_text = "Multi-shot ({})\n{} {}".format(
                            multi_shot_requirements[3], LEGION_RANGER.rp_name,
                            multi_shot_requirements[
                                0])
                        attack_button_text_list.append(attack_text)
                    else:
                        attack_text = "Multi-shot\n{} {}".format(LEGION_RANGER.rp_name,
                                                                              multi_shot_requirements[0])
                        attack_button_text_list.append(attack_text)
                elif multi_shot_requirements[3] > 0:
                    attack_text = "Multi-shot ({})".format(multi_shot_requirements[3])
                    attack_button_text_list.append(attack_text)
                else:
                    attack_button_text_list.append(attack_name)
            elif attack_name == "Ricochet Shot":
                if ricochet_shot_requirements[0] > 0:
                    if ricochet_shot_requirements[3] > 0:
                        attack_text = "Ricochet Shot ({})\n{} {}".format(
                            ricochet_shot_requirements[3], LEGION_RANGER.rp_name,
                            ricochet_shot_requirements[
                                0])
                        attack_button_text_list.append(attack_text)
                    else:
                        attack_text = "Ricochet Shot\n{} {}".format(LEGION_RANGER.rp_name,
                                                                                   ricochet_shot_requirements[
                                                                                       0])
                        attack_button_text_list.append(attack_text)
                elif ricochet_shot_requirements[3] > 0:
                    attack_text = "Ricochet Shot ({})".format(
                        ricochet_shot_requirements[3])
                    attack_button_text_list.append(attack_text)
                else:
                    attack_button_text_list.append(attack_name)
            elif attack_name == "Electrical Expulsion":
                if electrical_expulsion_requirements[0] > 0:
                    if electrical_expulsion_requirements[3] > 0:
                        attack_text = "Electrical Expulsion ({})\n{} {}".format(
                            electrical_expulsion_requirements[3], LEGION_RANGER.rp_name,
                            electrical_expulsion_requirements[
                                0])
                        attack_button_text_list.append(attack_text)
                    else:
                        attack_text = "Electrical Expulsion\n{} {}".format(LEGION_RANGER.rp_name,
                                                                                   electrical_expulsion_requirements[
                                                                                       0])
                        attack_button_text_list.append(attack_text)
                elif electrical_expulsion_requirements[3] > 0:
                    attack_text = "Electrical Expulsion ({})".format(
                        electrical_expulsion_requirements[3])
                    attack_button_text_list.append(attack_text)
                else:
                    attack_button_text_list.append(attack_name)
            else:
                attack_button_text_list.append(attack_name)
        return attack_button_text_list
#Checks which special are in the list and adds their costs and cooldowns remaining to a string thats added to a list thats returned    
    def champions_special_button_text(special_button_text_list_temp):
        for special_name in special_button_text_list_temp:
            if special_name == "Harmonize":
                if harmonize_requirements[0] > 0:
                    if harmonize_requirements[3] > 0:
                        special_text = "Harmonize ({})\n{} {}".format(harmonize_requirements[3], MONK.rp_name,
                                                                      harmonize_requirements[0])
                        special_button_text_list.append(special_text)
                    else:
                        special_text = "Harmonize\n{} {}".format(MONK.rp_name, harmonize_requirements[0])
                        special_button_text_list.append(special_text)
                elif harmonize_requirements[3] > 0:
                    special_text = "Harmonize ({})".format(harmonize_requirements[3])
                    special_button_text_list.append(special_text)
                else:
                    special_button_text_list.append(special_name)
            elif special_name == "Pressure Points":
                if pressure_points_requirements[0] > 0:
                    if pressure_points_requirements[3] > 0:
                        special_text = "Pressure Points ({})\n{} {}".format(pressure_points_requirements[3],
                                                                            MONK.rp_name,
                                                                            pressure_points_requirements[0])
                        special_button_text_list.append(special_text)
                    else:
                        special_text = "Pressure Points\n{} {}".format(MONK.rp_name, pressure_points_requirements[0])
                        special_button_text_list.append(special_text)
                elif pressure_points_requirements[3] > 0:
                    special_text = "Pressure Points ({})".format(pressure_points_requirements[3])
                    special_button_text_list.append(special_text)
                else:
                    special_button_text_list.append(special_name)
            elif special_name == "Challenging Shout":
                if challenging_shout_requirements[0] > 0:
                    if challenging_shout_requirements[3] > 0:
                        special_text = "Challenging Shout ({})\n{} {}".format(
                            challenging_shout_requirements[3], BARBARIAN.rp_name, challenging_shout_requirements[0])
                        special_button_text_list.append(special_text)
                    else:
                        special_text = "Challenging Shout\n{} {}".format(BARBARIAN.rp_name,
                                                                                              challenging_shout_requirements[
                                                                                                  0])
                        special_button_text_list.append(special_text)
                elif challenging_shout_requirements[3] > 0:
                    special_text = "Challenging Shout ({})".format(challenging_shout_requirements[3])
                    special_button_text_list.append(special_text)
                else:
                    special_button_text_list.append(special_name)
            elif special_name == "Impactful Boast":
                if impactful_boast_requirements[0] > 0:
                    if impactful_boast_requirements[3] > 0:
                        special_text = "Impactful Boast ({})\n{} {}".format(impactful_boast_requirements[3],
                                                                            BARBARIAN.rp_name,
                                                                            impactful_boast_requirements[0])
                        special_button_text_list.append(special_text)
                    else:
                        special_text = "Impactful Boast\n{} {}".format(BARBARIAN.rp_name,
                                                                       impactful_boast_requirements[0])
                        special_button_text_list.append(special_text)
                elif impactful_boast_requirements[3] > 0:
                    special_text = "Impactful Boast ({})".format(impactful_boast_requirements[3])
                    special_button_text_list.append(special_text)
                else:
                    special_button_text_list.append(special_name)
            elif special_name == "Fortification":
                if fortification_requirements[0] > 0:
                    if fortification_requirements[3] > 0:
                        special_text = "Fortification", "Fortification ({})\n{} {}".format(
                            fortification_requirements[3], KINGS_GUARD.rp_name, fortification_requirements[0])
                        special_button_text_list.append(special_text)
                    else:
                        special_text = "Fortification", "Fortification\n{} {}".format(KINGS_GUARD.rp_name,
                                                                                      fortification_requirements[0])
                        special_button_text_list.append(special_text)
                elif fortification_requirements[3] > 0:
                    special_text = "Fortification ({})".format(fortification_requirements[3])
                    special_button_text_list.append(special_text)
                else:
                    special_button_text_list.append(special_name)
            elif special_name == "Magic Reflection":
                if magic_reflection_requirements[0] > 0:
                    if magic_reflection_requirements[3] > 0:
                        special_text = "Magic Reflection ({})\n{} {}".format(magic_reflection_requirements[3], MASTER_FENCER.rp_name,
                                                                  magic_reflection_requirements[0])
                        special_button_text_list.append(special_text)
                    else:
                        special_text = "Magic Reflection\n{} {}".format(MASTER_FENCER.rp_name, magic_reflection_requirements[0])
                        special_button_text_list.append(special_text)
                elif magic_reflection_requirements[3] > 0:
                    special_text = "Magic Reflection ({})".format(magic_reflection_requirements[3])
                    special_button_text_list.append(special_text)
                else:
                    special_button_text_list.append(special_name)
            elif special_name == "Evasive Manoeuvres":
                if evasive_manoeuvres_requirements[0] > 0:
                    if evasive_manoeuvres_requirements[3] > 0:
                        special_text = "Evasive Manoeuvres ({})\n{} {}".format(evasive_manoeuvres_requirements[3],
                                                                             MASTER_FENCER.rp_name,
                                                                             evasive_manoeuvres_requirements[0])
                        special_button_text_list.append(special_text)
                    else:
                        special_text = "Evasive Manoeuvres\n{} {}".format(MASTER_FENCER.rp_name,
                                                                        evasive_manoeuvres_requirements[0])
                        special_button_text_list.append(special_text)
                elif evasive_manoeuvres_requirements[3] > 0:
                    special_text = "Evasive Manoeuvres ({})".format(evasive_manoeuvres_requirements[3])
                    special_button_text_list.append(special_text)
                else:
                    special_button_text_list.append(special_name)
            elif special_name == "Reckless Flurry":
                if reckless_flurry_requirements[0] > 0:
                    if reckless_flurry_requirements[3] > 0:
                        special_text = "Reckless Flurry ({})\n{} {}".format(reckless_flurry_requirements[3],
                                                                            BERSERKER.rp_name,
                                                                            reckless_flurry_requirements[0])
                        special_button_text_list.append(special_text)
                    else:
                        special_text = "Reckless Flurry\n{} {}".format(BERSERKER.rp_name,
                                                                       reckless_flurry_requirements[0])
                        special_button_text_list.append(special_text)
                elif reckless_flurry_requirements[3] > 0:
                    special_text = "Reckless Flurry ({})".format(reckless_flurry_requirements[3])
                    special_button_text_list.append(special_text)
                else:
                    special_button_text_list.append(special_name)
            elif special_name == "Exploit Weakness":
                if exploit_weakness_requirements[0] > 0:
                    if exploit_weakness_requirements[3] > 0:
                        special_text = "Exploit Weakness ({})\n{} {}".format(exploit_weakness_requirements[3],
                                                                             ROGUE.rp_name,
                                                                             exploit_weakness_requirements[
                                                                                 0])
                        special_button_text_list.append(special_text)
                    else:
                        special_text = "Exploit Weakness\n{} {}".format(ROGUE.rp_name, exploit_weakness_requirements[0])
                        special_button_text_list.append(special_text)
                elif exploit_weakness_requirements[3] > 0:
                    special_text = "Exploit Weakness ({})".format(exploit_weakness_requirements[3])
                    special_button_text_list.append(special_text)
                else:
                    special_button_text_list.append(special_name)
            elif special_name == "Play Dead":
                if play_dead_requirements[0] > 0:
                    if play_dead_requirements[3] > 0:
                        special_text = "Play Dead ({})\n{} {}".format(play_dead_requirements[3], SURVIVALIST.rp_name,
                                                                      play_dead_requirements[
                                                                          0])
                        special_button_text_list.append(special_text)
                    else:
                        special_text = "Play Dead\n{} {}".format(SURVIVALIST.rp_name, play_dead_requirements[0])
                        special_button_text_list.append(special_text)
                elif play_dead_requirements[3] > 0:
                    special_text = "Play Dead ({})".format(play_dead_requirements[3])
                    special_button_text_list.append(special_text)
                else:
                    special_button_text_list.append(special_name)
            elif special_name == "Survival Kit":
                if survival_kit_requirements[0] > 0:
                    if survival_kit_requirements[3] > 0:
                        special_text = "Survival Kit ({})\n{} {}".format(survival_kit_requirements[3],
                                                                        SURVIVALIST.rp_name, survival_kit_requirements[
                                                                            0])
                        special_button_text_list.append(special_text)
                    else:
                        special_text = "Survival Kit\n{} {}".format(SURVIVALIST.rp_name, survival_kit_requirements[0])
                        special_button_text_list.append(special_text)
                elif survival_kit_requirements[3] > 0:
                    special_text = "Survival Kit ({})".format(survival_kit_requirements[3])
                    special_button_text_list.append(special_text)
                else:
                    special_button_text_list.append(special_name)
            elif special_name == "Arcane Brilliance":
                if arcane_brilliance_requirements[0] > 0:
                    if arcane_brilliance_requirements[3] > 0:
                        special_text = "Arcane Brilliance ({})\n{} {}".format(arcane_brilliance_requirements[3],
                                                                              ACADEMIC_MAGE.rp_name,
                                                                              arcane_brilliance_requirements[
                                                                                  0])
                        special_button_text_list.append(special_text)
                    else:
                        special_text = "Arcane Brilliance\n{} {}".format(ACADEMIC_MAGE.rp_name,
                                                                         arcane_brilliance_requirements[0])
                        special_button_text_list.append(special_text)
                elif arcane_brilliance_requirements[3] > 0:
                    special_text = "Arcane Brilliance ({})".format(arcane_brilliance_requirements[3])
                    special_button_text_list.append(special_text)
                else:
                    special_button_text_list.append(special_name)
            elif special_name == "Magical Barrier":
                if magical_barrier_requirements[0] > 0:
                    if magical_barrier_requirements[3] > 0:
                        special_text = "Magical Barrier ({})\n{} {}".format(magical_barrier_requirements[3],
                                                                            ACADEMIC_MAGE.rp_name,
                                                                            magical_barrier_requirements[
                                                                                0])
                        special_button_text_list.append(special_text)
                    else:
                        special_text = "Magical Barrier\n{} {}".format(ACADEMIC_MAGE.rp_name,
                                                                       magical_barrier_requirements[0])
                        special_button_text_list.append(special_text)
                elif magical_barrier_requirements[3] > 0:
                    special_text = "Magical Barrier ({})".format(magical_barrier_requirements[3])
                    special_button_text_list.append(special_text)
                else:
                    special_button_text_list.append(special_name)
            elif special_name == "Barbed Bush Armour":
                if barbed_bush_armour_requirements[0] > 0:
                    if barbed_bush_armour_requirements[3] > 0:
                        special_text = "Barbed Bush Armour ({})\n{} {}".format(barbed_bush_armour_requirements[3], DRUID.rp_name,
                                                                   barbed_bush_armour_requirements[
                                                                       0])
                        special_button_text_list.append(special_text)
                    else:
                        special_text = "Barbed Bush Armour\n{} {}".format(DRUID.rp_name, barbed_bush_armour_requirements[0])
                        special_button_text_list.append(special_text)
                elif barbed_bush_armour_requirements[3] > 0:
                    special_text = "Barbed Bush Armour ({})".format(barbed_bush_armour_requirements[3])
                    special_button_text_list.append(special_text)
                else:
                    special_button_text_list.append(special_name)
            elif special_name == "Burst N Bloom":
                if burst_n_bloom_requirements[0] > 0:
                    if burst_n_bloom_requirements[3] > 0:
                        special_text = "Burst N Bloom ({})\n{} {}".format(burst_n_bloom_requirements[3], DRUID.rp_name,
                                                                          burst_n_bloom_requirements[
                                                                              0])
                        special_button_text_list.append(special_text)
                    else:
                        special_text = "Burst N Bloom\n{} {}".format(DRUID.rp_name, burst_n_bloom_requirements[0])
                        special_button_text_list.append(special_text)
                elif burst_n_bloom_requirements[3] > 0:
                    special_text = "Burst N Bloom ({})".format(burst_n_bloom_requirements[3])
                    special_button_text_list.append(special_text)
                else:
                    special_button_text_list.append(special_name)
            elif special_name == "Void Infusion":
                if void_infusion_requirements[0] > 0:
                    if void_infusion_requirements[3] > 0:
                        special_text = "Void Infusion ({})\n{} {}".format(void_infusion_requirements[3],
                                                                          WARLOCK.rp_name, void_infusion_requirements[
                                                                              0])
                        special_button_text_list.append(special_text)
                    else:
                        special_text = "Void Infusion\n{} {}".format(WARLOCK.rp_name, void_infusion_requirements[0])
                        special_button_text_list.append(special_text)
                elif void_infusion_requirements[3] > 0:
                    special_text = "Void Infusion ({})".format(void_infusion_requirements[3])
                    special_button_text_list.append(special_text)
                else:
                    special_button_text_list.append(special_name)
            elif special_name == "Wound Fissure":
                if wound_fissure_requirements[0] > 0:
                    if wound_fissure_requirements[3] > 0:
                        special_text = "Wound Fissure ({})\n{} {}".format(wound_fissure_requirements[3],
                                                                          WARLOCK.rp_name, wound_fissure_requirements[
                                                                              0])
                        special_button_text_list.append(special_text)
                    else:
                        special_text = "Wound Fissure\n{} {}".format(WARLOCK.rp_name, wound_fissure_requirements[0])
                        special_button_text_list.append(special_text)
                elif wound_fissure_requirements[3] > 0:
                    special_text = "Wound Fissure ({})".format(wound_fissure_requirements[3])
                    special_button_text_list.append(special_text)
                else:
                    special_button_text_list.append(special_name)
            elif special_name == "Blood Boil":
                if blood_boil_requirements[0] > 0:
                    if blood_boil_requirements[3] > 0:
                        special_text = "Blood Boil ({})\n{} {}".format(blood_boil_requirements[3], BLOODMANCER.rp_name,
                                                                       blood_boil_requirements[
                                                                           0])
                        special_button_text_list.append(special_text)
                    else:
                        special_text = "Blood Boil\n{} {}".format(BLOODMANCER.rp_name, blood_boil_requirements[0])
                        special_button_text_list.append(special_text)
                elif blood_boil_requirements[3] > 0:
                    special_text = "Blood Boil ({})".format(blood_boil_requirements[3])
                    special_button_text_list.append(special_text)
                else:
                    special_button_text_list.append(special_name)
            elif special_name == "Enharden Nerves":
                if enharden_nerves_requirements[0] > 0:
                    if enharden_nerves_requirements[3] > 0:
                        special_text = "Enharden Nerves ({})\n{} {}".format(enharden_nerves_requirements[3],
                                                                            BLOODMANCER.rp_name,
                                                                            enharden_nerves_requirements[
                                                                                0])
                        special_button_text_list.append(special_text)
                    else:
                        special_text = "Enharden Nerves\n{} {}".format(BLOODMANCER.rp_name,
                                                                       enharden_nerves_requirements[0])
                        special_button_text_list.append(special_text)
                elif enharden_nerves_requirements[3] > 0:
                    special_text = "Enharden Nerves ({})".format(enharden_nerves_requirements[3])
                    special_button_text_list.append(special_text)
                else:
                    special_button_text_list.append(special_name)
            elif special_name == "Damnation":
                if damnation_requirements[0] > 0:
                    if damnation_requirements[3] > 0:
                        special_text = "Damnation ({})\n{} {}".format(damnation_requirements[3],
                                                                               PALADIN.rp_name,
                                                                               damnation_requirements[
                                                                                   0])
                        special_button_text_list.append(special_text)
                    else:
                        special_text = "Damnation\n{} {}".format(PALADIN.rp_name,
                                                                          damnation_requirements[0])
                        special_button_text_list.append(special_text)
                elif damnation_requirements[3] > 0:
                    special_text = "Damnation ({})".format(damnation_requirements[3])
                    special_button_text_list.append(special_text)
                else:
                    special_button_text_list.append(special_name)
            elif special_name == "Energise":
                if energise_requirements[0] > 0:
                    if energise_requirements[3] > 0:
                        special_text = "Energise ({})\n{} {}".format(energise_requirements[3],
                                                                          MAGNETIMANCER.rp_name,
                                                                          energise_requirements[
                                                                              0])
                        special_button_text_list.append(special_text)
                    else:
                        special_text = "Energise\n{} {}".format(MAGNETIMANCER.rp_name,
                                                                     energise_requirements[0])
                        special_button_text_list.append(special_text)
                elif energise_requirements[3] > 0:
                    special_text = "Energise ({})".format(energise_requirements[3])
                    special_button_text_list.append(special_text)
                else:
                    special_button_text_list.append(special_name)
            elif special_name == "Superconductor":
                if superconductor_requirements[0] > 0:
                    if superconductor_requirements[3] > 0:
                        special_text = "Superconductor ({})\n{} {}".format(superconductor_requirements[3],
                                                                          MAGNETIMANCER.rp_name,
                                                                          superconductor_requirements[
                                                                              0])
                        special_button_text_list.append(special_text)
                    else:
                        special_text = "Superconductor\n{} {}".format(MAGNETIMANCER.rp_name,
                                                                     superconductor_requirements[0])
                        special_button_text_list.append(special_text)
                elif superconductor_requirements[3] > 0:
                    special_text = "Superconductor ({})".format(superconductor_requirements[3])
                    special_button_text_list.append(special_text)
                else:
                    special_button_text_list.append(special_name)
            elif special_name == "Power Surge":
                if power_surge_requirements[0] > 0:
                    if power_surge_requirements[3] > 0:
                        special_text = "Power Surge ({})\n{} {}".format(power_surge_requirements[3],
                                                                        POWER_CONDUIT.rp_name, power_surge_requirements[
                                                                            0])
                        special_button_text_list.append(special_text)
                    else:
                        special_text = "Power Surge\n{} {}".format(POWER_CONDUIT.rp_name, power_surge_requirements[0])
                        special_button_text_list.append(special_text)
                elif power_surge_requirements[3] > 0:
                    special_text = "Power Surge ({})".format(power_surge_requirements[3])
                    special_button_text_list.append(special_text)
                else:
                    special_button_text_list.append(special_name)
            elif special_name == "Full Potential":
                if full_potential_requirements[0] > 0:
                    if full_potential_requirements[3] > 0:
                        special_text = "Full Potential ({})\n{} {}".format(full_potential_requirements[3],
                                                                           POWER_CONDUIT.rp_name,
                                                                           full_potential_requirements[
                                                                               0])
                        special_button_text_list.append(special_text)
                    else:
                        special_text = "Full Potential\n{} {}".format(POWER_CONDUIT.rp_name,
                                                                      full_potential_requirements[0])
                        special_button_text_list.append(special_text)
                elif full_potential_requirements[3] > 0:
                    special_text = "Full Potential ({})".format(full_potential_requirements[3])
                    special_button_text_list.append(special_text)
                else:
                    special_button_text_list.append(special_name)
            elif special_name == "Spring Waters":
                if spring_waters_requirements[0] > 0:
                    if spring_waters_requirements[3] > 0:
                        special_text = "Spring Waters ({})\n{} {}".format(spring_waters_requirements[3],
                                                                          EARTH_SPEAKER.rp_name,
                                                                          spring_waters_requirements[
                                                                              0])
                        special_button_text_list.append(special_text)
                    else:
                        special_text = "Spring Waters\n{} {}".format(EARTH_SPEAKER.rp_name,
                                                                     spring_waters_requirements[0])
                        special_button_text_list.append(special_text)
                elif spring_waters_requirements[3] > 0:
                    special_text = "Spring Waters ({})".format(spring_waters_requirements[3])
                    special_button_text_list.append(special_text)
                else:
                    special_button_text_list.append(special_name)
            elif special_name == "Ocean Tides":
                if ocean_tides_requirements[0] > 0:
                    if ocean_tides_requirements[3] > 0:
                        special_text = "Ocean Tides ({})\n{} {}".format(
                            ocean_tides_requirements[3], EARTH_SPEAKER.rp_name,
                            ocean_tides_requirements[
                                0])
                        special_button_text_list.append(special_text)
                    else:
                        special_text = "Ocean Tides\n{} {}".format(EARTH_SPEAKER.rp_name,
                                                                              ocean_tides_requirements[0])
                        special_button_text_list.append(special_text)
                elif ocean_tides_requirements[3] > 0:
                    special_text = "Ocean Tides ({})".format(ocean_tides_requirements[3])
                    special_button_text_list.append(special_text)
                else:
                    special_button_text_list.append(special_name)
            elif special_name == "Boulder Cocoon":
                if boulder_cocoon_requirements[0] > 0:
                    if boulder_cocoon_requirements[3] > 0:
                        special_text = "Boulder Cocoon ({})\n{} {}".format(boulder_cocoon_requirements[3],
                                                                           EARTH_SPEAKER.rp_name,
                                                                           boulder_cocoon_requirements[
                                                                               0])
                        special_button_text_list.append(special_text)
                    else:
                        special_text = "Boulder Cocoon\n{} {}".format(EARTH_SPEAKER.rp_name,
                                                                      boulder_cocoon_requirements[0])
                        special_button_text_list.append(special_text)
                elif boulder_cocoon_requirements[3] > 0:
                    special_text = "Boulder Cocoon ({})".format(boulder_cocoon_requirements[3])
                    special_button_text_list.append(special_text)
                else:
                    special_button_text_list.append(special_name)
            elif special_name == "Healing Light":
                if healing_light_requirements[0] > 0:
                    if healing_light_requirements[3] > 0:
                        special_text = "Healing Light ({})\n{} {}".format(healing_light_requirements[3],
                                                                          PRIEST.rp_name,
                                                                          healing_light_requirements[
                                                                              0])
                        special_button_text_list.append(special_text)
                    else:
                        special_text = "Healing Light\n{} {}".format(PRIEST.rp_name,
                                                                     healing_light_requirements[0])
                        special_button_text_list.append(special_text)
                elif healing_light_requirements[3] > 0:
                    special_text = "Healing Light ({})".format(healing_light_requirements[3])
                    special_button_text_list.append(special_text)
                else:
                    special_button_text_list.append(special_name)
            elif special_name == "Diffracting Nova":
                if diffracting_nova_requirements[0] > 0:
                    if diffracting_nova_requirements[3] > 0:
                        special_text = "Diffracting Nova ({})\n{} {}".format(diffracting_nova_requirements[3],
                                                                             PRIEST.rp_name,
                                                                             diffracting_nova_requirements[
                                                                                 0])
                        special_button_text_list.append(special_text)
                    else:
                        special_text = "Diffracting Nova\n{} {}".format(PRIEST.rp_name,
                                                                        diffracting_nova_requirements[0])
                        special_button_text_list.append(special_text)
                elif diffracting_nova_requirements[3] > 0:
                    special_text = "Diffracting Nova ({})".format(diffracting_nova_requirements[3])
                    special_button_text_list.append(special_text)
                else:
                    special_button_text_list.append(special_name)
            elif special_name == "Overclock Nanobots":
                if overclock_nanobots_requirements[0] > 0:
                    if overclock_nanobots_requirements[3] > 0:
                        special_text = "Overclock Nanobots ({})\n{} {}".format(overclock_nanobots_requirements[3],
                                                                          TIME_WALKER.rp_name,
                                                                          overclock_nanobots_requirements[
                                                                              0])
                        special_button_text_list.append(special_text)
                    else:
                        special_text = "Overclock Nanobots\n{} {}".format(TIME_WALKER.rp_name, overclock_nanobots_requirements[0])
                        special_button_text_list.append(special_text)
                elif overclock_nanobots_requirements[3] > 0:
                    special_text = "Overclock Nanobots ({})".format(overclock_nanobots_requirements[3])
                    special_button_text_list.append(special_text)
                else:
                    special_button_text_list.append(special_name)
            elif special_name == "Reverse Wounds":
                if reverse_wounds_requirements[0] > 0:
                    if reverse_wounds_requirements[3] > 0:
                        special_text = "Reverse Wounds ({})\n{} {}".format(reverse_wounds_requirements[3],
                                                                           TIME_WALKER.rp_name,
                                                                           reverse_wounds_requirements[
                                                                               0])
                        special_button_text_list.append(special_text)
                    else:
                        special_text = "Reverse Wounds\n{} {}".format(TIME_WALKER.rp_name,
                                                                      reverse_wounds_requirements[0])
                        special_button_text_list.append(special_text)
                elif reverse_wounds_requirements[3] > 0:
                    special_text = "Reverse Wounds ({})".format(reverse_wounds_requirements[3])
                    special_button_text_list.append(special_text)
                else:
                    special_button_text_list.append(special_name)
            elif special_name == "Alter Time":
                if alter_time_requirements[0] > 0:
                    if alter_time_requirements[3] > 0:
                        special_text = "Alter Time ({})\n{} {}".format(alter_time_requirements[3], TIME_WALKER.rp_name,
                                                                       alter_time_requirements[
                                                                           0])
                        special_button_text_list.append(special_text)
                    else:
                        special_text = "Alter Time\n{} {}".format(TIME_WALKER.rp_name, alter_time_requirements[0])
                        special_button_text_list.append(special_text)
                elif alter_time_requirements[3] > 0:
                    special_text = "Alter Time ({})".format(alter_time_requirements[3])
                    special_button_text_list.append(special_text)
                else:
                    special_button_text_list.append(special_name)
            elif special_name == "Tight Tourniquet":
                if tight_tourniquet_requirements[0] > 0:
                    if tight_tourniquet_requirements[3] > 0:
                        special_text = "Tight Tourniquet ({})\n{} {}".format(tight_tourniquet_requirements[3],
                                                                                 FIELD_MEDIC.rp_name,
                                                                                 tight_tourniquet_requirements[
                                                                                     0])
                        special_button_text_list.append(special_text)
                    else:
                        special_text = "Tight Tourniquet\n{} {}".format(FIELD_MEDIC.rp_name,
                                                                            tight_tourniquet_requirements[0])
                        special_button_text_list.append(special_text)
                elif tight_tourniquet_requirements[3] > 0:
                    special_text = "Tight Tourniquet ({})".format(tight_tourniquet_requirements[3])
                    special_button_text_list.append(special_text)
                else:
                    special_button_text_list.append(special_name)
            elif special_name == "Secret Remedy":
                if secret_remedy_requirements[0] > 0:
                    if secret_remedy_requirements[3] > 0:
                        special_text = "Secret Remedy ({})\n{} {}".format(secret_remedy_requirements[3],
                                                                          FIELD_MEDIC.rp_name,
                                                                          secret_remedy_requirements[
                                                                              0])
                        special_button_text_list.append(special_text)
                    else:
                        special_text = "Secret Remedy\n{} {}".format(FIELD_MEDIC.rp_name,
                                                                     secret_remedy_requirements[0])
                        special_button_text_list.append(special_text)
                elif secret_remedy_requirements[3] > 0:
                    special_text = "Secret Remedy ({})".format(secret_remedy_requirements[3])
                    special_button_text_list.append(special_text)
                else:
                    special_button_text_list.append(special_name)
            else:
                special_button_text_list.append(special_name)
        return special_button_text_list
#Pop-up window that takes the parameter attack name and displays all its details in a visual form
#Window tells them the attack name, cost, resourced gained on use, cooldown, remaining cooldowm, and what it does
    def attack_details_window(self, ability_name):
        root = tk.Tk()
        ability_cost = 0
        ability_gain = 0
        ability_cooldown = 0
        ability_remaining_cooldown = 0
        ability_resource = ""
        attack_ability_details = ""
        if ability_name == "Palm Strike":
            attack_ability_details = "Strike an enemy, dealing damage and forcing them to attack you for one turn"
            ability_cost = palm_strike_requirements[0]
            ability_gain = palm_strike_requirements[1]
            ability_cooldown = palm_strike_requirements[2]
            ability_remaining_cooldown = palm_strike_requirements[3]
            ability_resource = 'Focus'
        if ability_name == "Leg Sweep":
            attack_ability_details = "Trip up an enemy to stun them for one turn"
            ability_cost = leg_sweep_requirements[0]
            ability_gain = leg_sweep_requirements[1]
            ability_cooldown = leg_sweep_requirements[2]
            ability_remaining_cooldown = leg_sweep_requirements[3]
            ability_resource = 'Focus'
        if ability_name == "Bloodthirst":
            attack_ability_details = "Rip at an enemy, dealing damage and healing for half the damage dealt"
            ability_cost = bloodthirst_requirements[0]
            ability_gain = bloodthirst_requirements[1]
            ability_cooldown = bloodthirst_requirements[2]
            ability_remaining_cooldown = bloodthirst_requirements[3]
            ability_resource = 'Rage'
        if ability_name == "Pulverize":
            attack_ability_details = "Strike at two enemies, dealing damage and forcing them to attack you for one turn"
            ability_cost = pulverize_requirements[0]
            ability_gain = pulverize_requirements[1]
            ability_cooldown = pulverize_requirements[2]
            ability_remaining_cooldown = pulverize_requirements[3]
            ability_resource = 'Rage'
        if ability_name == "Shield Bash":
            attack_ability_details = "Ram your shield into an enemy, dealing damage and applying 'Weakness' to them"
            ability_cost = shield_bash_requirements[0]
            ability_gain = shield_bash_requirements[1]
            ability_cooldown = shield_bash_requirements[2]
            ability_remaining_cooldown = shield_bash_requirements[3]
        if ability_name == "Trainwreck":
            attack_ability_details = "Smash an enemy, dealing damage for a lot of damage"
            ability_cost = trainwreck_requirements[0]
            ability_gain = trainwreck_requirements[1]
            ability_cooldown = trainwreck_requirements[2]
            ability_remaining_cooldown = trainwreck_requirements[3]
        if ability_name == "Flanking Strikes":
            attack_ability_details = "Slash at two enemies, dealing damage and if they were intending to attack you\nincrease your chance to dodge them by 40%"
            ability_cost = flanking_strikes_requirements[0]
            ability_gain = flanking_strikes_requirements[1]
            ability_cooldown = flanking_strikes_requirements[2]
            ability_remaining_cooldown = flanking_strikes_requirements[3]
        if ability_name == "Riposte":
            attack_ability_details = "Target an enemy and stun them\nif they were using a melee attack, reflect the damage back at them"
            ability_cost = riposte_requirements[0]
            ability_gain = riposte_requirements[1]
            ability_cooldown = riposte_requirements[2]
            ability_remaining_cooldown = riposte_requirements[3]
        if ability_name == "Angering Strike":
            attack_ability_details = "Attack your target, dealing damage"
            ability_cost = angering_strike_requirements[0]
            ability_gain = angering_strike_requirements[1]
            ability_cooldown = angering_strike_requirements[2]
            ability_remaining_cooldown = angering_strike_requirements[3]
            ability_resource = 'Rage'
        if ability_name == "Unbridled Rampage":
            attack_ability_details = "Release a barrage of attacks your target, dealing huge damage"
            ability_cost = unbridled_rampage_requirements[0]
            ability_gain = unbridled_rampage_requirements[1]
            ability_cooldown = unbridled_rampage_requirements[2]
            ability_remaining_cooldown = unbridled_rampage_requirements[3]
            ability_resource = 'Rage'
        if ability_name == "Serrated Slash":
            attack_ability_details = "Slash an enemy with a serrated blade, dealing damage and making them bleed for one turn"
            ability_cost = serrated_slash_requirements[0]
            ability_gain = serrated_slash_requirements[1]
            ability_cooldown = serrated_slash_requirements[2]
            ability_remaining_cooldown = serrated_slash_requirements[3]
        if ability_name == "Eviscerate":
            attack_ability_details = "Cut an enemies vital points, dealing damage and making them bleed heavily for three turns"
            ability_cost = eviscerate_requirements[0]
            ability_gain = eviscerate_requirements[1]
            ability_cooldown = eviscerate_requirements[2]
            ability_remaining_cooldown = eviscerate_requirements[3]
        if ability_name == "Spear Thrust":
            attack_ability_details = "Strike an enemy with your spear, dealing damage"
            ability_cost = spear_thrust_requirements[0]
            ability_gain = spear_thrust_requirements[1]
            ability_cooldown = spear_thrust_requirements[2]
            ability_remaining_cooldown = spear_thrust_requirements[3]
        if ability_name == "Scrap Bomb":
            attack_ability_details = "Chuck a makeshift bomb, dealing damage and applying 'Weakness' to all enemies"
            ability_cost = scrap_bomb_requirements[0]
            ability_gain = scrap_bomb_requirements[1]
            ability_cooldown = scrap_bomb_requirements[2]
            ability_remaining_cooldown = scrap_bomb_requirements[3]
        if ability_name == "Hard Hitter":
            attack_ability_details = "Punch an enemy, dealing damage"
            ability_cost = [0]
            ability_gain = hard_hitter_requirements[1]
            ability_cooldown = hard_hitter_requirements[2]
            ability_remaining_cooldown = hard_hitter_requirements[3]
        if ability_name == "Wide Swing":
            attack_ability_details = "Swipe a punch to hit three enemies, dealing damage to all hit"
            ability_cost = wide_swing_requirements[0]
            ability_gain = wide_swing_requirements[1]
            ability_cooldown = wide_swing_requirements[2]
            ability_remaining_cooldown = wide_swing_requirements[3]
        if ability_name == "Uppercut":
            attack_ability_details = "Strike an enemies vulenerable spot, dealing high damage"
            ability_cost = uppercut_requirements[0]
            ability_gain = uppercut_requirements[1]
            ability_cooldown = uppercut_requirements[2]
            ability_remaining_cooldown = uppercut_requirements[3]
        if ability_name == "Knock Out":
            attack_ability_details = "Go for the finishing blow, instantly killing an enemy depending on their size and remaining health points\nRequirements for a knockout: Tiny: 50%, Small: 40%, Medium: 30%, Large: 20%, Huge: 10%"
            ability_cost = knock_out_requirements[0]
            ability_gain = knock_out_requirements[1]
            ability_cooldown = knock_out_requirements[2]
            ability_remaining_cooldown = knock_out_requirements[3]
        if ability_name == "Frost Bolt":
            attack_ability_details = "Launch an magical icicle at an enemy, dealing damage and applying 'Brittle' to them"
            ability_cost = frost_bolt_requirements[0]
            ability_gain = frost_bolt_requirements[1]
            ability_cooldown = frost_bolt_requirements[2]
            ability_remaining_cooldown = frost_bolt_requirements[3]
            ability_resource = 'Mana'
        if ability_name == "Fireball":
            attack_ability_details = "Shoot a flaming ball at an enemy, dealing damage and causing them to burn for two turns"
            ability_cost = fireball_requirements[0]
            ability_gain = fireball_requirements[1]
            ability_cooldown = fireball_requirements[2]
            ability_remaining_cooldown = fireball_requirements[3]
            ability_resource = 'Mana'
        if ability_name == "Vine-Swipe":
            attack_ability_details = "Whip two vines strikes two enemies, dealing damage and applying embedding two thorns"
            ability_cost = vine_swipe_requirements[0]
            ability_gain = vine_swipe_requirements[1]
            ability_cooldown = vine_swipe_requirements[2]
            ability_remaining_cooldown = vine_swipe_requirements[3]
        if ability_name == "Invigorate Thorns":
            attack_ability_details = "Sprout thorns that jump out at all enemies, embedding one thorn"
            ability_cost = invigorate_thorns_requirements[0]
            ability_gain = invigorate_thorns_requirements[1]
            ability_cooldown = invigorate_thorns_requirements[2]
            ability_remaining_cooldown = invigorate_thorns_requirements[3]
        if ability_name == "Black Bolt":
            attack_ability_details = "Fire a corrupted bolt at an enemy, dealing damage and for every stack of 'Void Infused'\na devastating rot that is applied that consumes all void infusion and deals damage enhanced by each stack"
            ability_cost = black_bolt_requirements[0]
            ability_gain = black_bolt_requirements[1]
            ability_cooldown = black_bolt_requirements[2]
            ability_remaining_cooldown = black_bolt_requirements[3]
            ability_resource = 'Mana'
        if ability_name == "Void Infusion":
            attack_ability_details = "Gain a stack of 'Void Infused' to be later used to apply a high damage dot to an enemy"
            ability_cost = void_infusion_requirements[0]
            ability_gain = void_infusion_requirements[1]
            ability_cooldown = void_infusion_requirements[2]
            ability_remaining_cooldown = void_infusion_requirements[3]
            ability_resource = 'Mana'
        if ability_name == "Drain Life":
            attack_ability_details = "Drain the life force of an enemy, dealing damage and healing back 100% of it\nEmpowered Effect: Other allies are also healed for 30% of damage dealt"
            ability_cost = drain_life_requirements[0]
            ability_gain = drain_life_requirements[1]
            ability_cooldown = drain_life_requirements[2]
            ability_remaining_cooldown = drain_life_requirements[3]
        if ability_name == "Blood Spike":
            attack_ability_details = "Draw out your own blood to launch it at en enemy, dealing damage equal to the health drawn\nEmpowered Effect: Also draw out 20% of each other allies health, adding it to Blood Spikes damage"
            ability_cost = blood_spike_requirements[0]
            ability_gain = blood_spike_requirements[1]
            ability_cooldown = blood_spike_requirements[2]
            ability_remaining_cooldown = blood_spike_requirements[3]
            ability_resource = 'Health'
        if ability_name == "Holy Wrath":
            attack_ability_details = "Bludgeon an enemy, dealing damage and causing your Holy Wraths to deal 20% extra damage permanently\nThis resets to 0% after attacking with a Holy Wrath that deals 100% additional damage"
            ability_cost = holy_wrath_requirements[0]
            ability_gain = holy_wrath_requirements[1]
            ability_cooldown = holy_wrath_requirements[2]
            ability_remaining_cooldown = holy_wrath_requirements[3]
        if ability_name == "Righteous Blow":
            attack_ability_details = "Smash an enemy, dealing damage and stunning them for two turns"
            ability_cost = righteous_blow_requirements[0]
            ability_gain = righteous_blow_requirements[1]
            ability_cooldown = righteous_blow_requirements[2]
            ability_remaining_cooldown = righteous_blow_requirements[3]
        if ability_name == "Crusade":
            attack_ability_details = "Infuse your weapon with light and hit an enemy, dealing damage and causing the light to explode\ndealing a small amount of damage to all other enemies"
            ability_cost = crusade_requirements[0]
            ability_gain = crusade_requirements[1]
            ability_cooldown = crusade_requirements[2]
            ability_remaining_cooldown = crusade_requirements[3]
        if ability_name == "Steady Aim":
            attack_ability_details = "Fire a precise arrow at an enemy, dealing damage and reducing the cooldowns of Power Shot and Ricochet Shot by one\Enemies hit are affected by the currently equipped tip"
            ability_cost = steady_aim_requirements[0]
            ability_gain = steady_aim_requirements[1]
            ability_cooldown = steady_aim_requirements[2]
            ability_remaining_cooldown = steady_aim_requirements[3]
        if ability_name == "Power Shot":
            attack_ability_details = "Fire an fire with high power at an enemy, dealing damage and reducing the cooldown of Multi-shot by two\nEnemies hit are affected two-fold by the currently equipped tip"
            ability_cost = power_shot_requirements[0]
            ability_gain = power_shot_requirements[1]
            ability_cooldown = power_shot_requirements[2]
            ability_remaining_cooldown = power_shot_requirements[3]
        if ability_name == "Multi-shot":
            attack_ability_details = "Fire two arrows hitting two enemies, dealing damage and reducing the cooldown of Ricochet Shot by three\nEnemies hit are affected by the currently equipped tip"
            ability_cost = multi_shot_requirements[0]
            ability_gain = multi_shot_requirements[1]
            ability_cooldown = multi_shot_requirements[2]
            ability_remaining_cooldown = multi_shot_requirements[3]
        if ability_name == "Ricochet Shot":
            attack_ability_details = "Masterfully fire a rubbery arrow that bounces, hitting every enemy and dealing damage\nEnemies hit are affected by the currently equipped tip"
            ability_cost = ricochet_shot_requirements[0]
            ability_gain = ricochet_shot_requirements[1]
            ability_cooldown = ricochet_shot_requirements[2]
            ability_remaining_cooldown = ricochet_shot_requirements[3]
        if ability_name == "Chain Bolts":
            attack_ability_details = "Launch a duo-bolt at two enemies, dealing damage and charging them with a random polar charge"
            ability_cost = chain_bolts_requirements[0]
            ability_gain = chain_bolts_requirements[1]
            ability_cooldown = chain_bolts_requirements[2]
            ability_remaining_cooldown = chain_bolts_requirements[3]
        if ability_name == "Electrical Expulsion":
            attack_ability_details = "Wildly release polarization charges that latch onto random enemies\nIf you're energised, release ten charges. Otherwise, release five"
            ability_cost = electrical_expulsion_requirements[0]
            ability_gain = electrical_expulsion_requirements[1]
            ability_cooldown = electrical_expulsion_requirements[2]
            ability_remaining_cooldown = electrical_expulsion_requirements[3]
        if ability_name == "Rock Barrage":
            attack_ability_details = "Launch loose stones at an enemy, dealing damage."
            ability_cost = rock_barrage_requirements[0]
            ability_gain = rock_barrage_requirements[1]
            ability_cooldown = rock_barrage_requirements[2]
            ability_remaining_cooldown = rock_barrage_requirements[3]
            ability_resource = 'Mana'
        if ability_name == "Shimmering Bolt":
            attack_ability_details = "Fire a glistening bolt of light at an enemy, dealing damage and sear them with heat"
            ability_cost = shimmering_bolt_requirements[0]
            ability_gain = shimmering_bolt_requirements[1]
            ability_cooldown = shimmering_bolt_requirements[2]
            ability_remaining_cooldown = shimmering_bolt_requirements[3]
            ability_resource = 'Mana'
        if ability_name == "Divine Smite":
            attack_ability_details = "Blast an enemy with light, dealing damage and searing them with very hot heat"
            ability_cost = divine_smite_requirements[0]
            ability_gain = divine_smite_requirements[1]
            ability_cooldown = divine_smite_requirements[2]
            ability_remaining_cooldown = divine_smite_requirements[3]
            ability_resource = 'Mana'
        if ability_name == "Cybernetic Blast":
            attack_ability_details = "Fire an energy blast from your cybernetics at an enemy, dealing damage"
            ability_cost = cybernetic_blast_requirements[0]
            ability_gain = cybernetic_blast_requirements[1]
            ability_cooldown = cybernetic_blast_requirements[2]
            ability_remaining_cooldown = cybernetic_blast_requirements[3]
            ability_resource = 'Mana'
        if ability_name == "Snip Snip":
            attack_ability_details = "Slash your scissors at an enemy, dealing damage"
            ability_cost = snip_snip_requirements[0]
            ability_gain = snip_snip_requirements[1]
            ability_cooldown = snip_snip_requirements[2]
            ability_remaining_cooldown = snip_snip_requirements[3]
        ability_title_label = tk.Label(root, text=ability_name)
        ability_title_label.grid(row=0, column=1)
        ability_description1 = ""
        ability_description2 = ""
        if ability_cost != 0:
            if ability_gain != 0:
                ability_description1 = "Ability Cost ({} {}) : Gain ({} {})".format(ability_cost, ability_resource, ability_gain, ability_resource)
            else:
                ability_description1 = "Ability Cost ({} {})".format(ability_cost, ability_resource)
            ability_requirements1_label = tk.Label(root, text=ability_description1)
            ability_requirements1_label.grid(row=1, column=1)
        elif ability_gain != 0:
            ability_description1 = "Gain ({} {})".format(ability_gain, ability_resource)
            ability_requirements1_label = tk.Label(root, text=ability_description1)
            ability_requirements1_label.grid(row=1, column=1)
        if ability_cooldown != 0:
            if ability_remaining_cooldown != 0:
                ability_description2 = "Ability Cooldown ({}) : Remaining Cooldown ({})".format(ability_cooldown, ability_remaining_cooldown)
            else:
                ability_description2 = "Ability Cooldown ({})".format(ability_cooldown)
            ability_requirements2_label = tk.Label(root, text=ability_description2)
            ability_requirements2_label.grid(row=2, column=1)
            ability_description_label = tk.Label(root, text=attack_ability_details)
            ability_description_label.grid(row=3, column=1)
            close_button = tk.Button(root, text="Close Window", command=root.destroy)
            close_button.grid(row=4, column=1)
        else:
            ability_description_label = tk.Label(root, text=attack_ability_details)
            ability_description_label.grid(row=2, column=1)
            close_button = tk.Button(root, text="Close Window", command=root.destroy)
            close_button.grid(row=3, column=1)
#Finds the ability name and sets the abilities data into a universal list that can be called upon easily
#This list 'ability_data' has four variables
#1: Ability name (string)
#2: Ability target (string) which can be 'self' (just happens, mostly self-buffs), 'enemy' (targets or hits enemies), or 'ally' (targets or effect happens to allies)
#3: Ability targeting amount (string) which can be '1T' (hits only one target), '2T' (hits two targets), '3T' (hits three targets), or 'AOE' (hits everyone alive from the target stated AKA enemies or allies)
#4: Ability power (interger), named either damage_done or healing_done based on the ability effect
#Function also finds which champion the ability belongs to and which position they're in order to add or subtract resource
    def champion_attacks(self, ability_name):
        global attack_to_target, special_to_target, ability_data, champion1_rp, champion2_rp, champion3_rp, champion4_rp, champion5_rp
        attack_to_target = 1
        special_to_target = 0
        counter = 1
        damage_done = 0
        if ability_name == "Empty":
            return
        if ability_name == "Palm Strike":
            global palm_strike_requirements
            if palm_strike_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == MONK.title:
                        if counter == 1:
                            if palm_strike_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - palm_strike_requirements[0]
                                palm_strike_requirements[3] = palm_strike_requirements[2]
                                champion1_rp = champion1_rp + palm_strike_requirements[1]
                                damage_done = math.ceil(MONK.ap * self.calculate_champion_damage(1))
                                ability_data = ["Palm Strike", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 2:
                            if palm_strike_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - palm_strike_requirements[0]
                                palm_strike_requirements[3] = palm_strike_requirements[2]
                                champion2_rp = champion2_rp + palm_strike_requirements[1]
                                damage_done = math.ceil(MONK.ap * self.calculate_champion_damage(2))
                                ability_data = ["Palm Strike", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 3:
                            if palm_strike_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - palm_strike_requirements[0]
                                palm_strike_requirements[3] = palm_strike_requirements[2]
                                champion3_rp = champion3_rp + palm_strike_requirements[1]
                                damage_done = math.ceil(MONK.ap * self.calculate_champion_damage(3))
                                ability_data = ["Palm Strike", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 4:
                            if palm_strike_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - palm_strike_requirements[0]
                                palm_strike_requirements[3] = palm_strike_requirements[2]
                                champion4_rp = champion4_rp + palm_strike_requirements[1]
                                damage_done = math.ceil(MONK.ap * self.calculate_champion_damage(4))
                                ability_data = ["Palm Strike", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 5:
                            if palm_strike_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - palm_strike_requirements[0]
                                palm_strike_requirements[3] = palm_strike_requirements[2]
                                champion5_rp = champion5_rp + palm_strike_requirements[1]
                                damage_done = math.ceil(MONK.ap * self.calculate_champion_damage(5))
                                ability_data = ["Palm Strike", "enemy", "1T", damage_done]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Leg Sweep":
            global leg_sweep_requirements
            if leg_sweep_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == MONK.title:
                        if counter == 1:
                            if counter == 1:
                                if leg_sweep_requirements[0] <= champion1_rp:
                                    champion1_rp = champion1_rp - leg_sweep_requirements[0]
                                    leg_sweep_requirements[3] = leg_sweep_requirements[2]
                                    champion1_rp = champion1_rp + leg_sweep_requirements[1]
                                    damage_done = math.ceil(MONK.ap * self.calculate_champion_damage(1))
                                    ability_data = ["Leg Sweep", "enemy", "1T", damage_done]
                                else:
                                    return
                            if counter == 2:
                                if leg_sweep_requirements[0] <= champion2_rp:
                                    champion2_rp = champion2_rp - leg_sweep_requirements[0]
                                    leg_sweep_requirements[3] = leg_sweep_requirements[2]
                                    champion2_rp = champion2_rp + leg_sweep_requirements[1]
                                    damage_done = math.ceil(MONK.ap * self.calculate_champion_damage(2))
                                    ability_data = ["Leg Sweep", "enemy", "1T", damage_done]
                                else:
                                    return
                            if counter == 3:
                                if leg_sweep_requirements[0] <= champion3_rp:
                                    champion3_rp = champion3_rp - leg_sweep_requirements[0]
                                    leg_sweep_requirements[3] = leg_sweep_requirements[2]
                                    champion3_rp = champion3_rp + leg_sweep_requirements[1]
                                    damage_done = math.ceil(MONK.ap * self.calculate_champion_damage(3))
                                    ability_data = ["Leg Sweep", "enemy", "1T", damage_done]
                                else:
                                    return
                            if counter == 4:
                                if leg_sweep_requirements[0] <= champion4_rp:
                                    champion4_rp = champion4_rp - leg_sweep_requirements[0]
                                    leg_sweep_requirements[3] = leg_sweep_requirements[2]
                                    champion4_rp = champion4_rp + leg_sweep_requirements[1]
                                    damage_done = math.ceil(MONK.ap * self.calculate_champion_damage(4))
                                    ability_data = ["Leg Sweep", "enemy", "1T", damage_done]
                                else:
                                    return
                            if counter == 5:
                                if leg_sweep_requirements[0] <= champion5_rp:
                                    champion5_rp = champion5_rp - leg_sweep_requirements[0]
                                    leg_sweep_requirements[3] = leg_sweep_requirements[2]
                                    champion5_rp = champion5_rp + leg_sweep_requirements[1]
                                    damage_done = math.ceil(MONK.ap * self.calculate_champion_damage(5))
                                    ability_data = ["Leg Sweep", "enemy", "1T", damage_done]
                                else:
                                    return
                        counter += 1
            else:
                return
        elif ability_name == "Bloodthirst":
            global bloodthirst_requirements
            if bloodthirst_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == BARBARIAN.title:
                        if counter == 1:
                            if bloodthirst_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - bloodthirst_requirements[0]
                                bloodthirst_requirements[3] = bloodthirst_requirements[2]
                                champion1_rp = champion1_rp + bloodthirst_requirements[1]
                                damage_done = math.ceil(BARBARIAN.ap * self.calculate_champion_damage(1))
                                ability_data = ["Bloodthirst", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 2:
                            if bloodthirst_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - bloodthirst_requirements[0]
                                bloodthirst_requirements[3] = bloodthirst_requirements[2]
                                champion2_rp = champion2_rp + bloodthirst_requirements[1]
                                damage_done = math.ceil(BARBARIAN.ap * self.calculate_champion_damage(2))
                                ability_data = ["Bloodthirst", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 3:
                            if bloodthirst_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - bloodthirst_requirements[0]
                                bloodthirst_requirements[3] = bloodthirst_requirements[2]
                                champion3_rp = champion3_rp + bloodthirst_requirements[1]
                                damage_done = math.ceil(BARBARIAN.ap * self.calculate_champion_damage(3))
                                ability_data = ["Bloodthirst", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 4:
                            if bloodthirst_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - bloodthirst_requirements[0]
                                bloodthirst_requirements[3] = bloodthirst_requirements[2]
                                champion4_rp = champion4_rp + bloodthirst_requirements[1]
                                damage_done = math.ceil(BARBARIAN.ap * self.calculate_champion_damage(4))
                                ability_data = ["Bloodthirst", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 5:
                            if bloodthirst_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - bloodthirst_requirements[0]
                                bloodthirst_requirements[3] = bloodthirst_requirements[2]
                                champion5_rp = champion5_rp + bloodthirst_requirements[1]
                                damage_done = math.ceil(BARBARIAN.ap * self.calculate_champion_damage(5))
                                ability_data = ["Bloodthirst", "enemy", "1T", damage_done]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Pulverize":
            global pulverize_requirements
            if pulverize_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == BARBARIAN.title:
                        if counter == 1:
                            if pulverize_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - pulverize_requirements[0]
                                pulverize_requirements[3] = pulverize_requirements[2]
                                champion1_rp = champion1_rp + pulverize_requirements[1]
                                damage_done = math.ceil(BARBARIAN.ap * self.calculate_champion_damage(1))
                                ability_data = ["Pulverize", "enemy", "2T", damage_done]
                            else:
                                return
                        if counter == 2:
                            if pulverize_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - pulverize_requirements[0]
                                pulverize_requirements[3] = pulverize_requirements[2]
                                champion2_rp = champion2_rp + pulverize_requirements[1]
                                damage_done = math.ceil(BARBARIAN.ap * self.calculate_champion_damage(2))
                                ability_data = ["Pulverize", "enemy", "2T", damage_done]
                            else:
                                return
                        if counter == 3:
                            if pulverize_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - pulverize_requirements[0]
                                pulverize_requirements[3] = pulverize_requirements[2]
                                champion3_rp = champion3_rp + pulverize_requirements[1]
                                damage_done = math.ceil(BARBARIAN.ap * self.calculate_champion_damage(3))
                                ability_data = ["Pulverize", "enemy", "2T", damage_done]
                            else:
                                return
                        if counter == 4:
                            if pulverize_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - pulverize_requirements[0]
                                pulverize_requirements[3] = pulverize_requirements[2]
                                champion4_rp = champion4_rp + pulverize_requirements[1]
                                damage_done = math.ceil(BARBARIAN.ap * self.calculate_champion_damage(4))
                                ability_data = ["Pulverize", "enemy", "2T", damage_done]
                            else:
                                return
                        if counter == 5:
                            if pulverize_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - pulverize_requirements[0]
                                pulverize_requirements[3] = pulverize_requirements[2]
                                champion5_rp = champion5_rp + pulverize_requirements[1]
                                damage_done = math.ceil(BARBARIAN.ap * self.calculate_champion_damage(5))
                                ability_data = ["Pulverize", "enemy", "2T", damage_done]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Shield Bash":
            global shield_bash_requirements
            if shield_bash_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == KINGS_GUARD.title:
                        if counter == 1:
                            if shield_bash_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - shield_bash_requirements[0]
                                shield_bash_requirements[3] = shield_bash_requirements[2]
                                champion1_rp = champion1_rp + shield_bash_requirements[1]
                                damage_done = math.ceil(KINGS_GUARD.ap * self.calculate_champion_damage(1))
                                ability_data = ["Shield Bash", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 2:
                            if shield_bash_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - shield_bash_requirements[0]
                                shield_bash_requirements[3] = shield_bash_requirements[2]
                                champion2_rp = champion2_rp + shield_bash_requirements[1]
                                damage_done = math.ceil(KINGS_GUARD.ap * self.calculate_champion_damage(2))
                                ability_data = ["Shield Bash", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 3:
                            if shield_bash_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - shield_bash_requirements[0]
                                shield_bash_requirements[3] = shield_bash_requirements[2]
                                champion3_rp = champion3_rp + shield_bash_requirements[1]
                                damage_done = math.ceil(KINGS_GUARD.ap * self.calculate_champion_damage(3))
                                ability_data = ["Shield Bash", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 4:
                            if shield_bash_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - shield_bash_requirements[0]
                                shield_bash_requirements[3] = shield_bash_requirements[2]
                                champion4_rp = champion4_rp + shield_bash_requirements[1]
                                damage_done = math.ceil(KINGS_GUARD.ap * self.calculate_champion_damage(4))
                                ability_data = ["Shield Bash", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 5:
                            if shield_bash_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - shield_bash_requirements[0]
                                shield_bash_requirements[3] = shield_bash_requirements[2]
                                champion5_rp = champion5_rp + shield_bash_requirements[1]
                                damage_done = math.ceil(KINGS_GUARD.ap * self.calculate_champion_damage(5))
                                ability_data = ["Shield Bash", "enemy", "1T", damage_done]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Trainwreck":
            global trainwreck_requirements
            if trainwreck_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == KINGS_GUARD.title:
                        if counter == 1:
                            if trainwreck_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - trainwreck_requirements[0]
                                trainwreck_requirements[3] = trainwreck_requirements[2]
                                champion1_rp = champion1_rp + trainwreck_requirements[1]
                                damage_done = math.ceil(KINGS_GUARD.ap * self.calculate_champion_damage(1))
                                ability_data = ["Trainwreck", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 2:
                            if trainwreck_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - trainwreck_requirements[0]
                                trainwreck_requirements[3] = trainwreck_requirements[2]
                                champion2_rp = champion2_rp + trainwreck_requirements[1]
                                damage_done = math.ceil(KINGS_GUARD.ap * self.calculate_champion_damage(2))
                                ability_data = ["Trainwreck", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 3:
                            if trainwreck_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - trainwreck_requirements[0]
                                trainwreck_requirements[3] = trainwreck_requirements[2]
                                champion3_rp = champion3_rp + trainwreck_requirements[1]
                                damage_done = math.ceil(KINGS_GUARD.ap * self.calculate_champion_damage(3))
                                ability_data = ["Trainwreck", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 4:
                            if trainwreck_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - trainwreck_requirements[0]
                                trainwreck_requirements[3] = trainwreck_requirements[2]
                                champion4_rp = champion4_rp + trainwreck_requirements[1]
                                damage_done = math.ceil(KINGS_GUARD.ap * self.calculate_champion_damage(4))
                                ability_data = ["Trainwreck", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 5:
                            if trainwreck_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - trainwreck_requirements[0]
                                trainwreck_requirements[3] = trainwreck_requirements[2]
                                champion5_rp = champion5_rp + trainwreck_requirements[1]
                                damage_done = math.ceil(KINGS_GUARD.ap * self.calculate_champion_damage(5))
                                ability_data = ["Trainwreck", "enemy", "1T", damage_done]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Flanking Strikes":
            global flanking_strikes_requirements
            if flanking_strikes_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == MASTER_FENCER.title:
                        if counter == 1:
                            if flanking_strikes_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - flanking_strikes_requirements[0]
                                flanking_strikes_requirements[3] = flanking_strikes_requirements[2]
                                champion1_rp = champion1_rp + flanking_strikes_requirements[1]
                                damage_done = math.ceil(MASTER_FENCER.ap * self.calculate_champion_damage(1))
                                ability_data = ["Flanking Strikes", "enemy", "2T", damage_done]
                            else:
                                return
                        if counter == 2:
                            if flanking_strikes_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - flanking_strikes_requirements[0]
                                flanking_strikes_requirements[3] = flanking_strikes_requirements[2]
                                champion2_rp = champion2_rp + flanking_strikes_requirements[1]
                                damage_done = math.ceil(MASTER_FENCER.ap * self.calculate_champion_damage(2))
                                ability_data = ["Flanking Strikes", "enemy", "2T", damage_done]
                            else:
                                return
                        if counter == 3:
                            if flanking_strikes_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - flanking_strikes_requirements[0]
                                flanking_strikes_requirements[3] = flanking_strikes_requirements[2]
                                champion3_rp = champion3_rp + flanking_strikes_requirements[1]
                                damage_done = math.ceil(MASTER_FENCER.ap * self.calculate_champion_damage(3))
                                ability_data = ["Flanking Strikes", "enemy", "2T", damage_done]
                            else:
                                return
                        if counter == 4:
                            if flanking_strikes_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - flanking_strikes_requirements[0]
                                flanking_strikes_requirements[3] = flanking_strikes_requirements[2]
                                champion4_rp = champion4_rp + flanking_strikes_requirements[1]
                                damage_done = math.ceil(MASTER_FENCER.ap * self.calculate_champion_damage(4))
                                ability_data = ["Flanking Strikes", "enemy", "2T", damage_done]
                            else:
                                return
                        if counter == 5:
                            if flanking_strikes_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - flanking_strikes_requirements[0]
                                flanking_strikes_requirements[3] = flanking_strikes_requirements[2]
                                champion5_rp = champion5_rp + flanking_strikes_requirements[1]
                                damage_done = math.ceil(MASTER_FENCER.ap * self.calculate_champion_damage(5))
                                ability_data = ["Flanking Strikes", "enemy", "2T", damage_done]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Riposte":
            global riposte_requirements
            if riposte_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == MASTER_FENCER.title:
                        if counter == 1:
                            if riposte_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - riposte_requirements[0]
                                riposte_requirements[3] = riposte_requirements[2]
                                champion1_rp = champion1_rp + riposte_requirements[1]
                                damage_done = math.ceil(MASTER_FENCER.ap * self.calculate_champion_damage(1))
                                ability_data = ["Riposte", "enemy", "2T", damage_done]
                            else:
                                return
                        if counter == 2:
                            if riposte_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - riposte_requirements[0]
                                riposte_requirements[3] = riposte_requirements[2]
                                champion2_rp = champion2_rp + riposte_requirements[1]
                                damage_done = math.ceil(MASTER_FENCER.ap * self.calculate_champion_damage(2))
                                ability_data = ["Riposte", "enemy", "2T", damage_done]
                            else:
                                return
                        if counter == 3:
                            if riposte_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - riposte_requirements[0]
                                riposte_requirements[3] = riposte_requirements[2]
                                champion3_rp = champion3_rp + riposte_requirements[1]
                                damage_done = math.ceil(MASTER_FENCER.ap * self.calculate_champion_damage(3))
                                ability_data = ["Riposte", "enemy", "2T", damage_done]
                            else:
                                return
                        if counter == 4:
                            if riposte_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - riposte_requirements[0]
                                riposte_requirements[3] = riposte_requirements[2]
                                champion4_rp = champion4_rp + riposte_requirements[1]
                                damage_done = math.ceil(MASTER_FENCER.ap * self.calculate_champion_damage(4))
                                ability_data = ["Riposte", "enemy", "2T", damage_done]
                            else:
                                return
                        if counter == 5:
                            if riposte_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - riposte_requirements[0]
                                riposte_requirements[3] = riposte_requirements[2]
                                champion5_rp = champion5_rp + riposte_requirements[1]
                                damage_done = math.ceil(MASTER_FENCER.ap * self.calculate_champion_damage(5))
                                ability_data = ["Riposte", "enemy", "2T", damage_done]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Angering Strike":
            global angering_strike_requirements
            if angering_strike_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == BERSERKER.title:
                        if counter == 1:
                            if angering_strike_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - angering_strike_requirements[0]
                                angering_strike_requirements[3] = angering_strike_requirements[2]
                                champion1_rp = champion1_rp + angering_strike_requirements[1]
                                damage_done = math.ceil(BERSERKER.ap * self.calculate_champion_damage(1))
                                ability_data = ["Angering Strike", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 2:
                            if angering_strike_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - angering_strike_requirements[0]
                                angering_strike_requirements[3] = angering_strike_requirements[2]
                                champion2_rp = champion2_rp + angering_strike_requirements[1]
                                damage_done = math.ceil(BERSERKER.ap * self.calculate_champion_damage(2))
                                ability_data = ["Angering Strike", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 3:
                            if angering_strike_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - angering_strike_requirements[0]
                                angering_strike_requirements[3] = angering_strike_requirements[2]
                                champion3_rp = champion3_rp + angering_strike_requirements[1]
                                damage_done = math.ceil(BERSERKER.ap * self.calculate_champion_damage(3))
                                ability_data = ["Angering Strike", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 4:
                            if angering_strike_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - angering_strike_requirements[0]
                                angering_strike_requirements[3] = angering_strike_requirements[2]
                                champion4_rp = champion4_rp + angering_strike_requirements[1]
                                damage_done = math.ceil(BERSERKER.ap * self.calculate_champion_damage(4))
                                ability_data = ["Angering Strike", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 5:
                            if angering_strike_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - angering_strike_requirements[0]
                                angering_strike_requirements[3] = angering_strike_requirements[2]
                                champion5_rp = champion5_rp + angering_strike_requirements[1]
                                damage_done = math.ceil(BERSERKER.ap * self.calculate_champion_damage(5))
                                ability_data = ["Angering Strike", "enemy", "1T", damage_done]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Unbridled Rampage":
            global unbridled_rampage_requirements
            if unbridled_rampage_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == BERSERKER.title:
                        if counter == 1:
                            if unbridled_rampage_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - unbridled_rampage_requirements[0]
                                unbridled_rampage_requirements[3] = unbridled_rampage_requirements[2]
                                champion1_rp = champion1_rp + unbridled_rampage_requirements[1]
                                damage_done = math.ceil(BERSERKER.ap * self.calculate_champion_damage(1))
                                ability_data = ["Unbridled Rampage", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 2:
                            if unbridled_rampage_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - unbridled_rampage_requirements[0]
                                unbridled_rampage_requirements[3] = unbridled_rampage_requirements[2]
                                champion2_rp = champion2_rp + unbridled_rampage_requirements[1]
                                damage_done = math.ceil(BERSERKER.ap * self.calculate_champion_damage(2))
                                ability_data = ["Unbridled Rampage", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 3:
                            if unbridled_rampage_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - unbridled_rampage_requirements[0]
                                unbridled_rampage_requirements[3] = unbridled_rampage_requirements[2]
                                champion3_rp = champion3_rp + unbridled_rampage_requirements[1]
                                damage_done = math.ceil(BERSERKER.ap * self.calculate_champion_damage(3))
                                ability_data = ["Unbridled Rampage", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 4:
                            if unbridled_rampage_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - unbridled_rampage_requirements[0]
                                unbridled_rampage_requirements[3] = unbridled_rampage_requirements[2]
                                champion4_rp = champion4_rp + unbridled_rampage_requirements[1]
                                damage_done = math.ceil(BERSERKER.ap * self.calculate_champion_damage(4))
                                ability_data = ["Unbridled Rampage", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 5:
                            if unbridled_rampage_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - unbridled_rampage_requirements[0]
                                unbridled_rampage_requirements[3] = unbridled_rampage_requirements[2]
                                champion5_rp = champion5_rp + unbridled_rampage_requirements[1]
                                damage_done = math.ceil(BERSERKER.ap * self.calculate_champion_damage(5))
                                ability_data = ["Unbridled Rampage", "enemy", "1T", damage_done]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Serrated Slash":
            global serrated_slash_requirements
            if serrated_slash_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == ROGUE.title:
                        if counter == 1:
                            if serrated_slash_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - serrated_slash_requirements[0]
                                serrated_slash_requirements[3] = serrated_slash_requirements[2]
                                champion1_rp = champion1_rp + serrated_slash_requirements[1]
                                damage_done = math.ceil(ROGUE.ap * self.calculate_champion_damage(1))
                                ability_data = ["Serrated Slash", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 2:
                            if serrated_slash_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - serrated_slash_requirements[0]
                                serrated_slash_requirements[3] = serrated_slash_requirements[2]
                                champion2_rp = champion2_rp + serrated_slash_requirements[1]
                                damage_done = math.ceil(ROGUE.ap * self.calculate_champion_damage(2))
                                ability_data = ["Serrated Slash", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 3:
                            if serrated_slash_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - serrated_slash_requirements[0]
                                serrated_slash_requirements[3] = serrated_slash_requirements[2]
                                champion3_rp = champion3_rp + serrated_slash_requirements[1]
                                damage_done = math.ceil(ROGUE.ap * self.calculate_champion_damage(3))
                                ability_data = ["Serrated Slash", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 4:
                            if serrated_slash_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - serrated_slash_requirements[0]
                                serrated_slash_requirements[3] = serrated_slash_requirements[2]
                                champion4_rp = champion4_rp + serrated_slash_requirements[1]
                                damage_done = math.ceil(ROGUE.ap * self.calculate_champion_damage(4))
                                ability_data = ["Serrated Slash", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 5:
                            if serrated_slash_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - serrated_slash_requirements[0]
                                serrated_slash_requirements[3] = serrated_slash_requirements[2]
                                champion5_rp = champion5_rp + serrated_slash_requirements[1]
                                damage_done = math.ceil(ROGUE.ap * self.calculate_champion_damage(5))
                                ability_data = ["Serrated Slash", "enemy", "1T", damage_done]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Eviscerate":
            global eviscerate_requirements
            if eviscerate_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == ROGUE.title:
                        if counter == 1:
                            if eviscerate_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - eviscerate_requirements[0]
                                eviscerate_requirements[3] = eviscerate_requirements[2]
                                champion1_rp = champion1_rp + eviscerate_requirements[1]
                                damage_done = math.ceil(ROGUE.ap * self.calculate_champion_damage(1))
                                ability_data = ["Eviscerate", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 2:
                            if eviscerate_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - eviscerate_requirements[0]
                                eviscerate_requirements[3] = eviscerate_requirements[2]
                                champion2_rp = champion2_rp + eviscerate_requirements[1]
                                damage_done = math.ceil(ROGUE.ap * self.calculate_champion_damage(2))
                                ability_data = ["Eviscerate", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 3:
                            if eviscerate_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - eviscerate_requirements[0]
                                eviscerate_requirements[3] = eviscerate_requirements[2]
                                champion3_rp = champion3_rp + eviscerate_requirements[1]
                                damage_done = math.ceil(ROGUE.ap * self.calculate_champion_damage(3))
                                ability_data = ["Eviscerate", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 4:
                            if eviscerate_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - eviscerate_requirements[0]
                                eviscerate_requirements[3] = eviscerate_requirements[2]
                                champion4_rp = champion4_rp + eviscerate_requirements[1]
                                damage_done = math.ceil(ROGUE.ap * self.calculate_champion_damage(4))
                                ability_data = ["Eviscerate", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 5:
                            if eviscerate_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - eviscerate_requirements[0]
                                eviscerate_requirements[3] = eviscerate_requirements[2]
                                champion5_rp = champion5_rp + eviscerate_requirements[1]
                                damage_done = math.ceil(ROGUE.ap * self.calculate_champion_damage(5))
                                ability_data = ["Eviscerate", "enemy", "1T", damage_done]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Spear Thrust":
            global spear_thrust_requirements
            if spear_thrust_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == SURVIVALIST.title:
                        if counter == 1:
                            if spear_thrust_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - spear_thrust_requirements[0]
                                spear_thrust_requirements[3] = spear_thrust_requirements[2]
                                champion1_rp = champion1_rp + spear_thrust_requirements[1]
                                damage_done = math.ceil(SURVIVALIST.ap * self.calculate_champion_damage(1))
                                ability_data = ["Spear Thrust", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 2:
                            if spear_thrust_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - spear_thrust_requirements[0]
                                spear_thrust_requirements[3] = spear_thrust_requirements[2]
                                champion2_rp = champion2_rp + spear_thrust_requirements[1]
                                damage_done = math.ceil(SURVIVALIST.ap * self.calculate_champion_damage(2))
                                ability_data = ["Spear Thrust", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 3:
                            if spear_thrust_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - spear_thrust_requirements[0]
                                spear_thrust_requirements[3] = spear_thrust_requirements[2]
                                champion3_rp = champion3_rp + spear_thrust_requirements[1]
                                damage_done = math.ceil(SURVIVALIST.ap * self.calculate_champion_damage(3))
                                ability_data = ["Spear Thrust", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 4:
                            if spear_thrust_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - spear_thrust_requirements[0]
                                spear_thrust_requirements[3] = spear_thrust_requirements[2]
                                champion4_rp = champion4_rp + spear_thrust_requirements[1]
                                damage_done = math.ceil(SURVIVALIST.ap * self.calculate_champion_damage(4))
                                ability_data = ["Spear Thrust", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 5:
                            if spear_thrust_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - spear_thrust_requirements[0]
                                spear_thrust_requirements[3] = spear_thrust_requirements[2]
                                champion5_rp = champion5_rp + spear_thrust_requirements[1]
                                damage_done = math.ceil(SURVIVALIST.ap * self.calculate_champion_damage(5))
                                ability_data = ["Spear Thrust", "enemy", "1T", damage_done]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Scrap Bomb":
            global scrap_bomb_requirements
            if scrap_bomb_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == SURVIVALIST.title:
                        if counter == 1:
                            if scrap_bomb_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - scrap_bomb_requirements[0]
                                scrap_bomb_requirements[3] = scrap_bomb_requirements[2]
                                champion1_rp = champion1_rp + scrap_bomb_requirements[1]
                                damage_done = math.ceil(SURVIVALIST.ap * self.calculate_champion_damage(1))
                                ability_data = ["Scrap Bomb", "enemy", "AOE", damage_done]
                            else:
                                return
                        if counter == 2:
                            if scrap_bomb_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - scrap_bomb_requirements[0]
                                scrap_bomb_requirements[3] = scrap_bomb_requirements[2]
                                champion2_rp = champion2_rp + scrap_bomb_requirements[1]
                                damage_done = math.ceil(SURVIVALIST.ap * self.calculate_champion_damage(2))
                                ability_data = ["Scrap Bomb", "enemy", "AOE", damage_done]
                            else:
                                return
                        if counter == 3:
                            if scrap_bomb_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - scrap_bomb_requirements[0]
                                scrap_bomb_requirements[3] = scrap_bomb_requirements[2]
                                champion3_rp = champion3_rp + scrap_bomb_requirements[1]
                                damage_done = math.ceil(SURVIVALIST.ap * self.calculate_champion_damage(3))
                                ability_data = ["Scrap Bomb", "enemy", "AOE", damage_done]
                            else:
                                return
                        if counter == 4:
                            if scrap_bomb_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - scrap_bomb_requirements[0]
                                scrap_bomb_requirements[3] = scrap_bomb_requirements[2]
                                champion4_rp = champion4_rp + scrap_bomb_requirements[1]
                                damage_done = math.ceil(SURVIVALIST.ap * self.calculate_champion_damage(4))
                                ability_data = ["Scrap Bomb", "enemy", "AOE", damage_done]
                            else:
                                return
                        if counter == 5:
                            if scrap_bomb_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - scrap_bomb_requirements[0]
                                scrap_bomb_requirements[3] = scrap_bomb_requirements[2]
                                champion5_rp = champion5_rp + scrap_bomb_requirements[1]
                                damage_done = math.ceil(SURVIVALIST.ap * self.calculate_champion_damage(5))
                                ability_data = ["Scrap Bomb", "enemy", "AOE", damage_done]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Hard Hitter":
            global hard_hitter_requirements
            if hard_hitter_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == BRAWLIST.title:
                        if counter == 1:
                            if hard_hitter_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - hard_hitter_requirements[0]
                                hard_hitter_requirements[3] = hard_hitter_requirements[2]
                                champion1_rp = champion1_rp + hard_hitter_requirements[1]
                                damage_done = math.ceil(BRAWLIST.ap * self.calculate_champion_damage(1))
                                ability_data = ["Hard Hitter", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 2:
                            if hard_hitter_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - hard_hitter_requirements[0]
                                hard_hitter_requirements[3] = hard_hitter_requirements[2]
                                champion2_rp = champion2_rp + hard_hitter_requirements[1]
                                damage_done = math.ceil(BRAWLIST.ap * self.calculate_champion_damage(2))
                                ability_data = ["Hard Hitter", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 3:
                            if hard_hitter_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - hard_hitter_requirements[0]
                                hard_hitter_requirements[3] = hard_hitter_requirements[2]
                                champion3_rp = champion3_rp + hard_hitter_requirements[1]
                                damage_done = math.ceil(BRAWLIST.ap * self.calculate_champion_damage(3))
                                ability_data = ["Hard Hitter", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 4:
                            if hard_hitter_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - hard_hitter_requirements[0]
                                hard_hitter_requirements[3] = hard_hitter_requirements[2]
                                champion4_rp = champion4_rp + hard_hitter_requirements[1]
                                damage_done = math.ceil(BRAWLIST.ap * self.calculate_champion_damage(4))
                                ability_data = ["Hard Hitter", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 5:
                            if hard_hitter_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - hard_hitter_requirements[0]
                                hard_hitter_requirements[3] = hard_hitter_requirements[2]
                                champion5_rp = champion5_rp + hard_hitter_requirements[1]
                                damage_done = math.ceil(BRAWLIST.ap * self.calculate_champion_damage(5))
                                ability_data = ["Hard Hitter", "enemy", "1T", damage_done]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Wide Swing":
            global wide_swing_requirements
            if wide_swing_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == BRAWLIST.title:
                        if counter == 1:
                            if wide_swing_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - wide_swing_requirements[0]
                                wide_swing_requirements[3] = wide_swing_requirements[2]
                                champion1_rp = champion1_rp + wide_swing_requirements[1]
                                damage_done = math.ceil(BRAWLIST.ap * self.calculate_champion_damage(1))
                                ability_data = ["Wide Swing", "enemy", "3T", damage_done]
                            else:
                                return
                        if counter == 2:
                            if wide_swing_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - wide_swing_requirements[0]
                                wide_swing_requirements[3] = wide_swing_requirements[2]
                                champion2_rp = champion2_rp + wide_swing_requirements[1]
                                damage_done = math.ceil(BRAWLIST.ap * self.calculate_champion_damage(2))
                                ability_data = ["Wide Swing", "enemy", "3T", damage_done]
                            else:
                                return
                        if counter == 3:
                            if wide_swing_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - wide_swing_requirements[0]
                                wide_swing_requirements[3] = wide_swing_requirements[2]
                                champion3_rp = champion3_rp + wide_swing_requirements[1]
                                damage_done = math.ceil(BRAWLIST.ap * self.calculate_champion_damage(3))
                                ability_data = ["Wide Swing", "enemy", "3T", damage_done]
                            else:
                                return
                        if counter == 4:
                            if wide_swing_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - wide_swing_requirements[0]
                                wide_swing_requirements[3] = wide_swing_requirements[2]
                                champion4_rp = champion4_rp + wide_swing_requirements[1]
                                damage_done = math.ceil(BRAWLIST.ap * self.calculate_champion_damage(4))
                                ability_data = ["Wide Swing", "enemy", "3T", damage_done]
                            else:
                                return
                        if counter == 5:
                            if wide_swing_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - wide_swing_requirements[0]
                                wide_swing_requirements[3] = wide_swing_requirements[2]
                                champion5_rp = champion5_rp + wide_swing_requirements[1]
                                damage_done = math.ceil(BRAWLIST.ap * self.calculate_champion_damage(5))
                                ability_data = ["Wide Swing", "enemy", "3T", damage_done]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Uppercut":
            global uppercut_requirements
            if uppercut_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == BRAWLIST.title:
                        if counter == 1:
                            if uppercut_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - uppercut_requirements[0]
                                uppercut_requirements[3] = uppercut_requirements[2]
                                champion1_rp = champion1_rp + uppercut_requirements[1]
                                damage_done = math.ceil(BRAWLIST.ap * self.calculate_champion_damage(1))
                                ability_data = ["Uppercut", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 2:
                            if uppercut_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - uppercut_requirements[0]
                                uppercut_requirements[3] = uppercut_requirements[2]
                                champion2_rp = champion2_rp + uppercut_requirements[1]
                                damage_done = math.ceil(BRAWLIST.ap * self.calculate_champion_damage(2))
                                ability_data = ["Uppercut", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 3:
                            if uppercut_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - uppercut_requirements[0]
                                uppercut_requirements[3] = uppercut_requirements[2]
                                champion3_rp = champion3_rp + uppercut_requirements[1]
                                damage_done = math.ceil(BRAWLIST.ap * self.calculate_champion_damage(3))
                                ability_data = ["Uppercut", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 4:
                            if uppercut_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - uppercut_requirements[0]
                                uppercut_requirements[3] = uppercut_requirements[2]
                                champion4_rp = champion4_rp + uppercut_requirements[1]
                                damage_done = math.ceil(BRAWLIST.ap * self.calculate_champion_damage(4))
                                ability_data = ["Uppercut", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 5:
                            if uppercut_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - uppercut_requirements[0]
                                uppercut_requirements[3] = uppercut_requirements[2]
                                champion5_rp = champion5_rp + uppercut_requirements[1]
                                damage_done = math.ceil(BRAWLIST.ap * self.calculate_champion_damage(5))
                                ability_data = ["Uppercut", "enemy", "1T", damage_done]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Knock Out":
            global knock_out_requirements
            if knock_out_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == BRAWLIST.title:
                        if counter == 1:
                            if knock_out_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - knock_out_requirements[0]
                                knock_out_requirements[3] = knock_out_requirements[2]
                                champion1_rp = champion1_rp + knock_out_requirements[1]
                                ability_data = ["Knock Out", "enemy", "1T"]
                            else:
                                return
                        if counter == 2:
                            if knock_out_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - knock_out_requirements[0]
                                knock_out_requirements[3] = knock_out_requirements[2]
                                champion2_rp = champion2_rp + knock_out_requirements[1]
                                ability_data = ["Knock Out", "enemy", "1T"]
                            else:
                                return
                        if counter == 3:
                            if knock_out_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - knock_out_requirements[0]
                                knock_out_requirements[3] = knock_out_requirements[2]
                                champion3_rp = champion3_rp + knock_out_requirements[1]
                                ability_data = ["Knock Out", "enemy", "1T"]
                            else:
                                return
                        if counter == 4:
                            if knock_out_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - knock_out_requirements[0]
                                knock_out_requirements[3] = knock_out_requirements[2]
                                champion4_rp = champion4_rp + knock_out_requirements[1]
                                ability_data = ["Knock Out", "enemy", "1T"]
                            else:
                                return
                        if counter == 5:
                            if knock_out_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - knock_out_requirements[0]
                                knock_out_requirements[3] = knock_out_requirements[2]
                                champion5_rp = champion5_rp + knock_out_requirements[1]
                                ability_data = ["Knock Out", "enemy", "1T"]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Frost Bolt":
            global frost_bolt_requirements
            if frost_bolt_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == ACADEMIC_MAGE.title:
                        if counter == 1:
                            if frost_bolt_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - frost_bolt_requirements[0]
                                frost_bolt_requirements[3] = frost_bolt_requirements[2]
                                champion1_rp = champion1_rp + frost_bolt_requirements[1]
                                damage_done = math.ceil(ACADEMIC_MAGE.ap * self.calculate_champion_damage(1))
                                ability_data = ["Frost Bolt", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 2:
                            if frost_bolt_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - frost_bolt_requirements[0]
                                frost_bolt_requirements[3] = frost_bolt_requirements[2]
                                champion2_rp = champion2_rp + frost_bolt_requirements[1]
                                damage_done = math.ceil(ACADEMIC_MAGE.ap * self.calculate_champion_damage(2))
                                ability_data = ["Frost Bolt", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 3:
                            if frost_bolt_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - frost_bolt_requirements[0]
                                frost_bolt_requirements[3] = frost_bolt_requirements[2]
                                champion3_rp = champion3_rp + frost_bolt_requirements[1]
                                damage_done = math.ceil(ACADEMIC_MAGE.ap * self.calculate_champion_damage(3))
                                ability_data = ["Frost Bolt", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 4:
                            if frost_bolt_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - frost_bolt_requirements[0]
                                frost_bolt_requirements[3] = frost_bolt_requirements[2]
                                champion4_rp = champion4_rp + frost_bolt_requirements[1]
                                damage_done = math.ceil(ACADEMIC_MAGE.ap * self.calculate_champion_damage(4))
                                ability_data = ["Frost Bolt", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 5:
                            if frost_bolt_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - frost_bolt_requirements[0]
                                frost_bolt_requirements[3] = frost_bolt_requirements[2]
                                champion5_rp = champion5_rp + frost_bolt_requirements[1]
                                damage_done = math.ceil(ACADEMIC_MAGE.ap * self.calculate_champion_damage(5))
                                ability_data = ["Frost Bolt", "enemy", "1T", damage_done]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Fireball":
            global fireball_requirements
            if fireball_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == ACADEMIC_MAGE.title:
                        if counter == 1:
                            if fireball_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - fireball_requirements[0]
                                fireball_requirements[3] = fireball_requirements[2]
                                champion1_rp = champion1_rp + fireball_requirements[1]
                                damage_done = math.ceil(ACADEMIC_MAGE.ap * self.calculate_champion_damage(1))
                                ability_data = ["Fireball", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 2:
                            if fireball_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - fireball_requirements[0]
                                fireball_requirements[3] = fireball_requirements[2]
                                champion2_rp = champion2_rp + fireball_requirements[1]
                                damage_done = math.ceil(ACADEMIC_MAGE.ap * self.calculate_champion_damage(2))
                                ability_data = ["Fireball", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 3:
                            if fireball_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - fireball_requirements[0]
                                fireball_requirements[3] = fireball_requirements[2]
                                champion3_rp = champion3_rp + fireball_requirements[1]
                                damage_done = math.ceil(ACADEMIC_MAGE.ap * self.calculate_champion_damage(3))
                                ability_data = ["Fireball", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 4:
                            if fireball_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - fireball_requirements[0]
                                fireball_requirements[3] = fireball_requirements[2]
                                champion4_rp = champion4_rp + fireball_requirements[1]
                                damage_done = math.ceil(ACADEMIC_MAGE.ap * self.calculate_champion_damage(4))
                                ability_data = ["Fireball", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 5:
                            if fireball_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - fireball_requirements[0]
                                fireball_requirements[3] = fireball_requirements[2]
                                champion5_rp = champion5_rp + fireball_requirements[1]
                                damage_done = math.ceil(ACADEMIC_MAGE.ap * self.calculate_champion_damage(5))
                                ability_data = ["Fireball", "enemy", "1T", damage_done]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Invigorate Thorns":
            global invigorate_thorns_requirements
            if invigorate_thorns_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == DRUID.title:
                        if counter == 1:
                            if invigorate_thorns_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - invigorate_thorns_requirements[0]
                                invigorate_thorns_requirements[3] = invigorate_thorns_requirements[2]
                                champion1_rp = champion1_rp + invigorate_thorns_requirements[1]
                                damage_done = math.ceil(DRUID.ap * self.calculate_champion_damage(1))
                                ability_data = ["Invigorate Thorns", "enemy", "AOE", damage_done]
                            else:
                                return
                        if counter == 2:
                            if invigorate_thorns_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - invigorate_thorns_requirements[0]
                                invigorate_thorns_requirements[3] = invigorate_thorns_requirements[2]
                                champion2_rp = champion2_rp + invigorate_thorns_requirements[1]
                                damage_done = math.ceil(DRUID.ap * self.calculate_champion_damage(2))
                                ability_data = ["Invigorate Thorns", "enemy", "AOE", damage_done]
                            else:
                                return
                        if counter == 3:
                            if invigorate_thorns_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - invigorate_thorns_requirements[0]
                                invigorate_thorns_requirements[3] = invigorate_thorns_requirements[2]
                                champion3_rp = champion3_rp + invigorate_thorns_requirements[1]
                                damage_done = math.ceil(DRUID.ap * self.calculate_champion_damage(3))
                                ability_data = ["Invigorate Thorns", "enemy", "AOE", damage_done]
                            else:
                                return
                        if counter == 4:
                            if invigorate_thorns_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - invigorate_thorns_requirements[0]
                                invigorate_thorns_requirements[3] = invigorate_thorns_requirements[2]
                                champion4_rp = champion4_rp + invigorate_thorns_requirements[1]
                                damage_done = math.ceil(DRUID.ap * self.calculate_champion_damage(4))
                                ability_data = ["Invigorate Thorns", "enemy", "AOE", damage_done]
                            else:
                                return
                        if counter == 5:
                            if invigorate_thorns_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - invigorate_thorns_requirements[0]
                                invigorate_thorns_requirements[3] = invigorate_thorns_requirements[2]
                                champion5_rp = champion5_rp + invigorate_thorns_requirements[1]
                                damage_done = math.ceil(DRUID.ap * self.calculate_champion_damage(5))
                                ability_data = ["Invigorate Thorns", "enemy", "1T", damage_done]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Vine-Swipe":
            global vine_swipe_requirements
            if vine_swipe_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == DRUID.title:
                        if counter == 1:
                            if vine_swipe_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - vine_swipe_requirements[0]
                                vine_swipe_requirements[3] = vine_swipe_requirements[2]
                                champion1_rp = champion1_rp + vine_swipe_requirements[1]
                                damage_done = math.ceil(DRUID.ap * self.calculate_champion_damage(1))
                                ability_data = ["Vine-Swipe", "enemy", "2T", damage_done]
                            else:
                                return
                        if counter == 2:
                            if vine_swipe_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - vine_swipe_requirements[0]
                                vine_swipe_requirements[3] = vine_swipe_requirements[2]
                                champion2_rp = champion2_rp + vine_swipe_requirements[1]
                                damage_done = math.ceil(DRUID.ap * self.calculate_champion_damage(2))
                                ability_data = ["Vine-Swipe", "enemy", "2T", damage_done]
                            else:
                                return
                        if counter == 3:
                            if vine_swipe_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - vine_swipe_requirements[0]
                                vine_swipe_requirements[3] = vine_swipe_requirements[2]
                                champion3_rp = champion3_rp + vine_swipe_requirements[1]
                                damage_done = math.ceil(DRUID.ap * self.calculate_champion_damage(3))
                                ability_data = ["Vine-Swipe", "enemy", "2T", damage_done]
                            else:
                                return
                        if counter == 4:
                            if vine_swipe_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - vine_swipe_requirements[0]
                                vine_swipe_requirements[3] = vine_swipe_requirements[2]
                                champion4_rp = champion4_rp + vine_swipe_requirements[1]
                                damage_done = math.ceil(DRUID.ap * self.calculate_champion_damage(4))
                                ability_data = ["Vine-Swipe", "enemy", "2T", damage_done]
                            else:
                                return
                        if counter == 5:
                            if vine_swipe_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - vine_swipe_requirements[0]
                                vine_swipe_requirements[3] = vine_swipe_requirements[2]
                                champion5_rp = champion5_rp + vine_swipe_requirements[1]
                                damage_done = math.ceil(DRUID.ap * self.calculate_champion_damage(5))
                                ability_data = ["Vine-Swipe", "enemy", "2T", damage_done]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Black Bolt":
            global black_bolt_requirements
            if black_bolt_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == WARLOCK.title:
                        if counter == 1:
                            if black_bolt_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - black_bolt_requirements[0]
                                black_bolt_requirements[3] = black_bolt_requirements[2]
                                champion1_rp = champion1_rp + black_bolt_requirements[1]
                                damage_done = math.ceil(WARLOCK.ap * self.calculate_champion_damage(1))
                                ability_data = ["Black Bolt", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 2:
                            if black_bolt_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - black_bolt_requirements[0]
                                black_bolt_requirements[3] = black_bolt_requirements[2]
                                champion2_rp = champion2_rp + black_bolt_requirements[1]
                                damage_done = math.ceil(WARLOCK.ap * self.calculate_champion_damage(2))
                                ability_data = ["Black Bolt", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 3:
                            if black_bolt_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - black_bolt_requirements[0]
                                black_bolt_requirements[3] = black_bolt_requirements[2]
                                champion3_rp = champion3_rp + black_bolt_requirements[1]
                                damage_done = math.ceil(WARLOCK.ap * self.calculate_champion_damage(3))
                                ability_data = ["Black Bolt", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 4:
                            if black_bolt_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - black_bolt_requirements[0]
                                black_bolt_requirements[3] = black_bolt_requirements[2]
                                champion4_rp = champion4_rp + black_bolt_requirements[1]
                                damage_done = math.ceil(WARLOCK.ap * self.calculate_champion_damage(4))
                                ability_data = ["Black Bolt", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 5:
                            if black_bolt_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - black_bolt_requirements[0]
                                black_bolt_requirements[3] = black_bolt_requirements[2]
                                champion5_rp = champion5_rp + black_bolt_requirements[1]
                                damage_done = math.ceil(WARLOCK.ap * self.calculate_champion_damage(5))
                                ability_data = ["Black Bolt", "enemy", "1T", damage_done]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Void Infusion":
            global void_infusion_requirements
            if void_infusion_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == WARLOCK.title:
                        if counter == 1:
                            if void_infusion_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - void_infusion_requirements[0]
                                void_infusion_requirements[3] = void_infusion_requirements[2]
                                champion1_rp = champion1_rp + void_infusion_requirements[1]
                                damage_done = math.ceil(WARLOCK.ap * self.calculate_champion_damage(1))
                                ability_data = ["Void Infusion", "self", "1T", damage_done]
                            else:
                                return
                        if counter == 2:
                            if void_infusion_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - void_infusion_requirements[0]
                                void_infusion_requirements[3] = void_infusion_requirements[2]
                                champion2_rp = champion2_rp + void_infusion_requirements[1]
                                damage_done = math.ceil(WARLOCK.ap * self.calculate_champion_damage(2))
                                ability_data = ["Void Infusion", "self", "1T", damage_done]
                            else:
                                return
                        if counter == 3:
                            if void_infusion_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - void_infusion_requirements[0]
                                void_infusion_requirements[3] = void_infusion_requirements[2]
                                champion3_rp = champion3_rp + void_infusion_requirements[1]
                                damage_done = math.ceil(WARLOCK.ap * self.calculate_champion_damage(3))
                                ability_data = ["Void Infusion", "self", "1T", damage_done]
                            else:
                                return
                        if counter == 4:
                            if void_infusion_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - void_infusion_requirements[0]
                                void_infusion_requirements[3] = void_infusion_requirements[2]
                                champion4_rp = champion4_rp + void_infusion_requirements[1]
                                damage_done = math.ceil(WARLOCK.ap * self.calculate_champion_damage(4))
                                ability_data = ["Void Infusion", "self", "1T", damage_done]
                            else:
                                return
                        if counter == 5:
                            if void_infusion_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - void_infusion_requirements[0]
                                void_infusion_requirements[3] = void_infusion_requirements[2]
                                champion5_rp = champion5_rp + void_infusion_requirements[1]
                                damage_done = math.ceil(WARLOCK.ap * self.calculate_champion_damage(5))
                                ability_data = ["Void Infusion", "self", "1T", damage_done]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Drain Life":
            global drain_life_requirements
            if drain_life_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == BLOODMANCER.title:
                        if counter == 1:
                            if drain_life_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - drain_life_requirements[0]
                                drain_life_requirements[3] = drain_life_requirements[2]
                                champion1_rp = champion1_rp + drain_life_requirements[1]
                                damage_done = math.ceil(BLOODMANCER.ap * self.calculate_champion_damage(1))
                                ability_data = ["Drain Life", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 2:
                            if drain_life_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - drain_life_requirements[0]
                                drain_life_requirements[3] = drain_life_requirements[2]
                                champion2_rp = champion2_rp + drain_life_requirements[1]
                                damage_done = math.ceil(BLOODMANCER.ap * self.calculate_champion_damage(2))
                                ability_data = ["Drain Life", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 3:
                            if drain_life_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - drain_life_requirements[0]
                                drain_life_requirements[3] = drain_life_requirements[2]
                                champion3_rp = champion3_rp + drain_life_requirements[1]
                                damage_done = math.ceil(BLOODMANCER.ap * self.calculate_champion_damage(3))
                                ability_data = ["Drain Life", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 4:
                            if drain_life_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - drain_life_requirements[0]
                                drain_life_requirements[3] = drain_life_requirements[2]
                                champion4_rp = champion4_rp + drain_life_requirements[1]
                                damage_done = math.ceil(BLOODMANCER.ap * self.calculate_champion_damage(4))
                                ability_data = ["Drain Life", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 5:
                            if drain_life_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - drain_life_requirements[0]
                                drain_life_requirements[3] = drain_life_requirements[2]
                                champion5_rp = champion5_rp + drain_life_requirements[1]
                                damage_done = math.ceil(BLOODMANCER.ap * self.calculate_champion_damage(5))
                                ability_data = ["Drain Life", "enemy", "1T", damage_done]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Blood Spike":
            global blood_spike_requirements
            if blood_spike_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == BLOODMANCER.title:
                        if counter == 1:
                            if blood_spike_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - blood_spike_requirements[0]
                                blood_spike_requirements[3] = blood_spike_requirements[2]
                                champion1_rp = champion1_rp + blood_spike_requirements[1]
                                damage_done = math.ceil((BLOODMANCER.ap * 2)* self.calculate_champion_damage(1))
                                ability_data = ["Blood Spike", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 2:
                            if blood_spike_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - blood_spike_requirements[0]
                                blood_spike_requirements[3] = blood_spike_requirements[2]
                                champion2_rp = champion2_rp + blood_spike_requirements[1]
                                damage_done = math.ceil((BLOODMANCER.ap * 2) * self.calculate_champion_damage(2))
                                ability_data = ["Blood Spike", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 3:
                            if blood_spike_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - blood_spike_requirements[0]
                                blood_spike_requirements[3] = blood_spike_requirements[2]
                                champion3_rp = champion3_rp + blood_spike_requirements[1]
                                damage_done = math.ceil((BLOODMANCER.ap * 2) * self.calculate_champion_damage(3))
                                ability_data = ["Blood Spike", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 4:
                            if blood_spike_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - blood_spike_requirements[0]
                                blood_spike_requirements[3] = blood_spike_requirements[2]
                                champion4_rp = champion4_rp + blood_spike_requirements[1]
                                damage_done = math.ceil((BLOODMANCER.ap * 2) * self.calculate_champion_damage(4))
                                ability_data = ["Blood Spike", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 5:
                            if blood_spike_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - blood_spike_requirements[0]
                                blood_spike_requirements[3] = blood_spike_requirements[2]
                                champion5_rp = champion5_rp + blood_spike_requirements[1]
                                damage_done = math.ceil((BLOODMANCER.ap * 2) * self.calculate_champion_damage(5))
                                ability_data = ["Blood Spike", "enemy", "1T", damage_done]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Holy Wrath":
            global holy_wrath_requirements
            if holy_wrath_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == PALADIN.title:
                        if counter == 1:
                            if holy_wrath_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - holy_wrath_requirements[0]
                                holy_wrath_requirements[3] = holy_wrath_requirements[2]
                                champion1_rp = champion1_rp + holy_wrath_requirements[1]
                                damage_done = math.ceil(PALADIN.ap * self.calculate_champion_damage(1))
                                ability_data = ["Holy Wrath", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 2:
                            if holy_wrath_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - holy_wrath_requirements[0]
                                holy_wrath_requirements[3] = holy_wrath_requirements[2]
                                champion2_rp = champion2_rp + holy_wrath_requirements[1]
                                damage_done = math.ceil(PALADIN.ap * self.calculate_champion_damage(2))
                                ability_data = ["Holy Wrath", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 3:
                            if holy_wrath_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - holy_wrath_requirements[0]
                                holy_wrath_requirements[3] = holy_wrath_requirements[2]
                                champion3_rp = champion3_rp + holy_wrath_requirements[1]
                                damage_done = math.ceil(PALADIN.ap * self.calculate_champion_damage(3))
                                ability_data = ["Holy Wrath", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 4:
                            if holy_wrath_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - holy_wrath_requirements[0]
                                holy_wrath_requirements[3] = holy_wrath_requirements[2]
                                champion4_rp = champion4_rp + holy_wrath_requirements[1]
                                damage_done = math.ceil(PALADIN.ap * self.calculate_champion_damage(4))
                                ability_data = ["Holy Wrath", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 5:
                            if holy_wrath_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - holy_wrath_requirements[0]
                                holy_wrath_requirements[3] = holy_wrath_requirements[2]
                                champion5_rp = champion5_rp + holy_wrath_requirements[1]
                                damage_done = math.ceil(PALADIN.ap * self.calculate_champion_damage(5))
                                ability_data = ["Holy Wrath", "enemy", "1T", damage_done]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Righteous Blow":
            global righteous_blow_requirements
            if righteous_blow_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == PALADIN.title:
                        if counter == 1:
                            if righteous_blow_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - righteous_blow_requirements[0]
                                righteous_blow_requirements[3] = righteous_blow_requirements[2]
                                champion1_rp = champion1_rp + righteous_blow_requirements[1]
                                damage_done = math.ceil(PALADIN.ap * self.calculate_champion_damage(1))
                                ability_data = ["Righteous Blow", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 2:
                            if righteous_blow_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - righteous_blow_requirements[0]
                                righteous_blow_requirements[3] = righteous_blow_requirements[2]
                                champion2_rp = champion2_rp + righteous_blow_requirements[1]
                                damage_done = math.ceil(PALADIN.ap * self.calculate_champion_damage(2))
                                ability_data = ["Righteous Blow", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 3:
                            if righteous_blow_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - righteous_blow_requirements[0]
                                righteous_blow_requirements[3] = righteous_blow_requirements[2]
                                champion3_rp = champion3_rp + righteous_blow_requirements[1]
                                damage_done = math.ceil(PALADIN.ap * self.calculate_champion_damage(3))
                                ability_data = ["Righteous Blow", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 4:
                            if righteous_blow_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - righteous_blow_requirements[0]
                                righteous_blow_requirements[3] = righteous_blow_requirements[2]
                                champion4_rp = champion4_rp + righteous_blow_requirements[1]
                                damage_done = math.ceil(PALADIN.ap * self.calculate_champion_damage(4))
                                ability_data = ["Righteous Blow", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 5:
                            if righteous_blow_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - righteous_blow_requirements[0]
                                righteous_blow_requirements[3] = righteous_blow_requirements[2]
                                champion5_rp = champion5_rp + righteous_blow_requirements[1]
                                damage_done = math.ceil(PALADIN.ap * self.calculate_champion_damage(5))
                                ability_data = ["Righteous Blow", "enemy", "1T", damage_done]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Crusade":
            global crusade_requirements
            if crusade_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == PALADIN.title:
                        if counter == 1:
                            if crusade_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - crusade_requirements[0]
                                crusade_requirements[3] = crusade_requirements[2]
                                champion1_rp = champion1_rp + crusade_requirements[1]
                                damage_done = math.ceil(PALADIN.ap * self.calculate_champion_damage(1))
                                ability_data = ["Crusade", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 2:
                            if crusade_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - crusade_requirements[0]
                                crusade_requirements[3] = crusade_requirements[2]
                                champion2_rp = champion2_rp + crusade_requirements[1]
                                damage_done = math.ceil(PALADIN.ap * self.calculate_champion_damage(2))
                                ability_data = ["Crusade", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 3:
                            if crusade_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - crusade_requirements[0]
                                crusade_requirements[3] = crusade_requirements[2]
                                champion3_rp = champion3_rp + crusade_requirements[1]
                                damage_done = math.ceil(PALADIN.ap * self.calculate_champion_damage(3))
                                ability_data = ["Crusade", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 4:
                            if crusade_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - crusade_requirements[0]
                                crusade_requirements[3] = crusade_requirements[2]
                                champion4_rp = champion4_rp + crusade_requirements[1]
                                damage_done = math.ceil(PALADIN.ap * self.calculate_champion_damage(4))
                                ability_data = ["Crusade", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 5:
                            if crusade_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - crusade_requirements[0]
                                crusade_requirements[3] = crusade_requirements[2]
                                champion5_rp = champion5_rp + crusade_requirements[1]
                                damage_done = math.ceil(PALADIN.ap * self.calculate_champion_damage(5))
                                ability_data = ["Crusade", "enemy", "1T", damage_done]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Steady Aim":
            global steady_aim_requirements
            if steady_aim_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == LEGION_RANGER.title:
                        if counter == 1:
                            if steady_aim_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - steady_aim_requirements[0]
                                steady_aim_requirements[3] = steady_aim_requirements[2]
                                champion1_rp = champion1_rp + steady_aim_requirements[1]
                                damage_done = math.ceil(LEGION_RANGER.ap * self.calculate_champion_damage(1))
                                ability_data = ["Steady Aim", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 2:
                            if steady_aim_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - steady_aim_requirements[0]
                                steady_aim_requirements[3] = steady_aim_requirements[2]
                                champion2_rp = champion2_rp + steady_aim_requirements[1]
                                damage_done = math.ceil(LEGION_RANGER.ap * self.calculate_champion_damage(2))
                                ability_data = ["Steady Aim", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 3:
                            if steady_aim_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - steady_aim_requirements[0]
                                steady_aim_requirements[3] = steady_aim_requirements[2]
                                champion3_rp = champion3_rp + steady_aim_requirements[1]
                                damage_done = math.ceil(LEGION_RANGER.ap * self.calculate_champion_damage(3))
                                ability_data = ["Steady Aim", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 4:
                            if steady_aim_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - steady_aim_requirements[0]
                                steady_aim_requirements[3] = steady_aim_requirements[2]
                                champion4_rp = champion4_rp + steady_aim_requirements[1]
                                damage_done = math.ceil(LEGION_RANGER.ap * self.calculate_champion_damage(4))
                                ability_data = ["Steady Aim", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 5:
                            if steady_aim_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - steady_aim_requirements[0]
                                steady_aim_requirements[3] = steady_aim_requirements[2]
                                champion5_rp = champion5_rp + steady_aim_requirements[1]
                                damage_done = math.ceil(LEGION_RANGER.ap * self.calculate_champion_damage(5))
                                ability_data = ["Steady Aim", "enemy", "1T", damage_done]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Power Shot":
            global power_shot_requirements
            if power_shot_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == LEGION_RANGER.title:
                        if counter == 1:
                            if power_shot_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - power_shot_requirements[0]
                                power_shot_requirements[3] = power_shot_requirements[2]
                                champion1_rp = champion1_rp + power_shot_requirements[1]
                                damage_done = math.ceil(LEGION_RANGER.ap * self.calculate_champion_damage(1))
                                ability_data = ["Power Shot", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 2:
                            if power_shot_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - power_shot_requirements[0]
                                power_shot_requirements[3] = power_shot_requirements[2]
                                champion2_rp = champion2_rp + power_shot_requirements[1]
                                damage_done = math.ceil(LEGION_RANGER.ap * self.calculate_champion_damage(2))
                                ability_data = ["Power Shot", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 3:
                            if power_shot_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - power_shot_requirements[0]
                                power_shot_requirements[3] = power_shot_requirements[2]
                                champion3_rp = champion3_rp + power_shot_requirements[1]
                                damage_done = math.ceil(LEGION_RANGER.ap * self.calculate_champion_damage(3))
                                ability_data = ["Power Shot", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 4:
                            if power_shot_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - power_shot_requirements[0]
                                power_shot_requirements[3] = power_shot_requirements[2]
                                champion4_rp = champion4_rp + power_shot_requirements[1]
                                damage_done = math.ceil(LEGION_RANGER.ap * self.calculate_champion_damage(4))
                                ability_data = ["Power Shot", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 5:
                            if power_shot_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - power_shot_requirements[0]
                                power_shot_requirements[3] = power_shot_requirements[2]
                                champion5_rp = champion5_rp + power_shot_requirements[1]
                                damage_done = math.ceil(LEGION_RANGER.ap * self.calculate_champion_damage(5))
                                ability_data = ["Power Shot", "enemy", "1T", damage_done]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Multi-shot":
            global multi_shot_requirements
            if multi_shot_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == LEGION_RANGER.title:
                        if counter == 1:
                            if multi_shot_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - multi_shot_requirements[0]
                                multi_shot_requirements[3] = multi_shot_requirements[2]
                                champion1_rp = champion1_rp + multi_shot_requirements[1]
                                damage_done = math.ceil(LEGION_RANGER.ap * self.calculate_champion_damage(1))
                                ability_data = ["Multi-shot", "enemy", "2T", damage_done]
                            else:
                                return
                        if counter == 2:
                            if multi_shot_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - multi_shot_requirements[0]
                                multi_shot_requirements[3] = multi_shot_requirements[2]
                                champion2_rp = champion2_rp + multi_shot_requirements[1]
                                damage_done = math.ceil(LEGION_RANGER.ap * self.calculate_champion_damage(2))
                                ability_data = ["Multi-shot", "enemy", "2T", damage_done]
                            else:
                                return
                        if counter == 3:
                            if multi_shot_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - multi_shot_requirements[0]
                                multi_shot_requirements[3] = multi_shot_requirements[2]
                                champion3_rp = champion3_rp + multi_shot_requirements[1]
                                damage_done = math.ceil(LEGION_RANGER.ap * self.calculate_champion_damage(3))
                                ability_data = ["Multi-shot", "enemy", "2T", damage_done]
                            else:
                                return
                        if counter == 4:
                            if multi_shot_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - multi_shot_requirements[0]
                                multi_shot_requirements[3] = multi_shot_requirements[2]
                                champion4_rp = champion4_rp + multi_shot_requirements[1]
                                damage_done = math.ceil(LEGION_RANGER.ap * self.calculate_champion_damage(4))
                                ability_data = ["Multi-shot", "enemy", "2T", damage_done]
                            else:
                                return
                        if counter == 5:
                            if multi_shot_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - multi_shot_requirements[0]
                                multi_shot_requirements[3] = multi_shot_requirements[2]
                                champion5_rp = champion5_rp + multi_shot_requirements[1]
                                damage_done = math.ceil(LEGION_RANGER.ap * self.calculate_champion_damage(5))
                                ability_data = ["Multi-shot", "enemy", "2T", damage_done]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Ricochet Shot":
            global ricochet_shot_requirements
            if ricochet_shot_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == LEGION_RANGER.title:
                        if counter == 1:
                            if ricochet_shot_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - ricochet_shot_requirements[0]
                                ricochet_shot_requirements[3] = ricochet_shot_requirements[2]
                                champion1_rp = champion1_rp + ricochet_shot_requirements[1]
                                damage_done = math.ceil(LEGION_RANGER.ap * self.calculate_champion_damage(1))
                                ability_data = ["Ricochet Shot", "enemy", "AOE", damage_done]
                            else:
                                return
                        if counter == 2:
                            if ricochet_shot_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - ricochet_shot_requirements[0]
                                ricochet_shot_requirements[3] = ricochet_shot_requirements[2]
                                champion2_rp = champion2_rp + ricochet_shot_requirements[1]
                                damage_done = math.ceil(LEGION_RANGER.ap * self.calculate_champion_damage(2))
                                ability_data = ["Ricochet Shot", "enemy", "AOE", damage_done]
                            else:
                                return
                        if counter == 3:
                            if ricochet_shot_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - ricochet_shot_requirements[0]
                                ricochet_shot_requirements[3] = ricochet_shot_requirements[2]
                                champion3_rp = champion3_rp + ricochet_shot_requirements[1]
                                damage_done = math.ceil(LEGION_RANGER.ap * self.calculate_champion_damage(3))
                                ability_data = ["Ricochet Shot", "enemy", "AOE", damage_done]
                            else:
                                return
                        if counter == 4:
                            if ricochet_shot_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - ricochet_shot_requirements[0]
                                ricochet_shot_requirements[3] = ricochet_shot_requirements[2]
                                champion4_rp = champion4_rp + ricochet_shot_requirements[1]
                                damage_done = math.ceil(LEGION_RANGER.ap * self.calculate_champion_damage(4))
                                ability_data = ["Ricochet Shot", "enemy", "AOE", damage_done]
                            else:
                                return
                        if counter == 5:
                            if ricochet_shot_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - ricochet_shot_requirements[0]
                                ricochet_shot_requirements[3] = ricochet_shot_requirements[2]
                                champion5_rp = champion5_rp + ricochet_shot_requirements[1]
                                damage_done = math.ceil(LEGION_RANGER.ap * self.calculate_champion_damage(5))
                                ability_data = ["Ricochet Shot", "enemy", "AOE", damage_done]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Chain Bolts":
            global chain_bolts_requirements
            if chain_bolts_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == MAGNETIMANCER.title:
                        if counter == 1:
                            if chain_bolts_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - chain_bolts_requirements[0]
                                chain_bolts_requirements[3] = chain_bolts_requirements[2]
                                champion1_rp = champion1_rp + chain_bolts_requirements[1]
                                damage_done = math.ceil(MAGNETIMANCER.ap * self.calculate_champion_damage(1))
                                ability_data = ["Chain Bolts", "enemy", "2T", damage_done]
                            else:
                                return
                        if counter == 2:
                            if chain_bolts_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - chain_bolts_requirements[0]
                                chain_bolts_requirements[3] = chain_bolts_requirements[2]
                                champion2_rp = champion2_rp + chain_bolts_requirements[1]
                                damage_done = math.ceil(MAGNETIMANCER.ap * self.calculate_champion_damage(2))
                                ability_data = ["Chain Bolts", "enemy", "2T", damage_done]
                            else:
                                return
                        if counter == 3:
                            if chain_bolts_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - chain_bolts_requirements[0]
                                chain_bolts_requirements[3] = chain_bolts_requirements[2]
                                champion3_rp = champion3_rp + chain_bolts_requirements[1]
                                damage_done = math.ceil(MAGNETIMANCER.ap * self.calculate_champion_damage(3))
                                ability_data = ["Chain Bolts", "enemy", "2T", damage_done]
                            else:
                                return
                        if counter == 4:
                            if chain_bolts_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - chain_bolts_requirements[0]
                                chain_bolts_requirements[3] = chain_bolts_requirements[2]
                                champion4_rp = champion4_rp + chain_bolts_requirements[1]
                                damage_done = math.ceil(MAGNETIMANCER.ap * self.calculate_champion_damage(4))
                                ability_data = ["Chain Bolts", "enemy", "2T", damage_done]
                            else:
                                return
                        if counter == 5:
                            if chain_bolts_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - chain_bolts_requirements[0]
                                chain_bolts_requirements[3] = chain_bolts_requirements[2]
                                champion5_rp = champion5_rp + chain_bolts_requirements[1]
                                damage_done = math.ceil(MAGNETIMANCER.ap * self.calculate_champion_damage(5))
                                ability_data = ["Chain Bolts", "enemy", "2T", damage_done]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Electrical Expulsion":
            global electrical_expulsion_requirements
            if electrical_expulsion_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == MAGNETIMANCER.title:
                        if counter == 1:
                            if electrical_expulsion_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - electrical_expulsion_requirements[0]
                                electrical_expulsion_requirements[3] = electrical_expulsion_requirements[2]
                                champion1_rp = champion1_rp + electrical_expulsion_requirements[1]
                                damage_done = math.ceil(MAGNETIMANCER.ap * self.calculate_champion_damage(1))
                                ability_data = ["Electrical Expulsion", "enemy", "AOE", damage_done]
                            else:
                                return
                        if counter == 2:
                            if electrical_expulsion_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - electrical_expulsion_requirements[0]
                                electrical_expulsion_requirements[3] = electrical_expulsion_requirements[2]
                                champion2_rp = champion2_rp + electrical_expulsion_requirements[1]
                                damage_done = math.ceil(MAGNETIMANCER.ap * self.calculate_champion_damage(2))
                                ability_data = ["Electrical Expulsion", "enemy", "AOE", damage_done]
                            else:
                                return
                        if counter == 3:
                            if electrical_expulsion_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - electrical_expulsion_requirements[0]
                                electrical_expulsion_requirements[3] = electrical_expulsion_requirements[2]
                                champion3_rp = champion3_rp + electrical_expulsion_requirements[1]
                                damage_done = math.ceil(MAGNETIMANCER.ap * self.calculate_champion_damage(3))
                                ability_data = ["Electrical Expulsion", "enemy", "AOE", damage_done]
                            else:
                                return
                        if counter == 4:
                            if electrical_expulsion_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - electrical_expulsion_requirements[0]
                                electrical_expulsion_requirements[3] = electrical_expulsion_requirements[2]
                                champion4_rp = champion4_rp + electrical_expulsion_requirements[1]
                                damage_done = math.ceil(MAGNETIMANCER.ap * self.calculate_champion_damage(4))
                                ability_data = ["Electrical Expulsion", "enemy", "AOE", damage_done]
                            else:
                                return
                        if counter == 5:
                            if electrical_expulsion_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - electrical_expulsion_requirements[0]
                                electrical_expulsion_requirements[3] = electrical_expulsion_requirements[2]
                                champion5_rp = champion5_rp + electrical_expulsion_requirements[1]
                                damage_done = math.ceil(MAGNETIMANCER.ap * self.calculate_champion_damage(5))
                                ability_data = ["Electrical Expulsion", "enemy", "AOE", damage_done]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Rock Barrage":
            global rock_barrage_requirements
            if rock_barrage_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == EARTH_SPEAKER.title:
                        if counter == 1:
                            if rock_barrage_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - rock_barrage_requirements[0]
                                rock_barrage_requirements[3] = rock_barrage_requirements[2]
                                champion1_rp = champion1_rp + rock_barrage_requirements[1]
                                damage_done = math.ceil(EARTH_SPEAKER.ap * self.calculate_champion_damage(1))
                                ability_data = ["Rock Barrage", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 2:
                            if rock_barrage_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - rock_barrage_requirements[0]
                                rock_barrage_requirements[3] = rock_barrage_requirements[2]
                                champion2_rp = champion2_rp + rock_barrage_requirements[1]
                                damage_done = math.ceil(EARTH_SPEAKER.ap * self.calculate_champion_damage(2))
                                ability_data = ["Rock Barrage", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 3:
                            if rock_barrage_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - rock_barrage_requirements[0]
                                rock_barrage_requirements[3] = rock_barrage_requirements[2]
                                champion3_rp = champion3_rp + rock_barrage_requirements[1]
                                damage_done = math.ceil(EARTH_SPEAKER.ap * self.calculate_champion_damage(3))
                                ability_data = ["Rock Barrage", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 4:
                            if rock_barrage_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - rock_barrage_requirements[0]
                                rock_barrage_requirements[3] = rock_barrage_requirements[2]
                                champion4_rp = champion4_rp + rock_barrage_requirements[1]
                                damage_done = math.ceil(EARTH_SPEAKER.ap * self.calculate_champion_damage(4))
                                ability_data = ["Rock Barrage", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 5:
                            if rock_barrage_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - rock_barrage_requirements[0]
                                rock_barrage_requirements[3] = rock_barrage_requirements[2]
                                champion5_rp = champion5_rp + rock_barrage_requirements[1]
                                damage_done = math.ceil(EARTH_SPEAKER.ap * self.calculate_champion_damage(5))
                                ability_data = ["Rock Barrage", "enemy", "1T", damage_done]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Shimmering Bolt":
            global shimmering_bolt_requirements
            if shimmering_bolt_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == PRIEST.title:
                        if counter == 1:
                            if shimmering_bolt_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - shimmering_bolt_requirements[0]
                                shimmering_bolt_requirements[3] = shimmering_bolt_requirements[2]
                                champion1_rp = champion1_rp + shimmering_bolt_requirements[1]
                                damage_done = math.ceil(PRIEST.ap * self.calculate_champion_damage(1))
                                ability_data = ["Shimmering Bolt", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 2:
                            if shimmering_bolt_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - shimmering_bolt_requirements[0]
                                shimmering_bolt_requirements[3] = shimmering_bolt_requirements[2]
                                champion2_rp = champion2_rp + shimmering_bolt_requirements[1]
                                damage_done = math.ceil(PRIEST.ap * self.calculate_champion_damage(2))
                                ability_data = ["Shimmering Bolt", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 3:
                            if shimmering_bolt_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - shimmering_bolt_requirements[0]
                                shimmering_bolt_requirements[3] = shimmering_bolt_requirements[2]
                                champion3_rp = champion3_rp + shimmering_bolt_requirements[1]
                                damage_done = math.ceil(PRIEST.ap * self.calculate_champion_damage(3))
                                ability_data = ["Shimmering Bolt", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 4:
                            if shimmering_bolt_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - shimmering_bolt_requirements[0]
                                shimmering_bolt_requirements[3] = shimmering_bolt_requirements[2]
                                champion4_rp = champion4_rp + shimmering_bolt_requirements[1]
                                damage_done = math.ceil(PRIEST.ap * self.calculate_champion_damage(4))
                                ability_data = ["Shimmering Bolt", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 5:
                            if shimmering_bolt_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - shimmering_bolt_requirements[0]
                                shimmering_bolt_requirements[3] = shimmering_bolt_requirements[2]
                                champion5_rp = champion5_rp + shimmering_bolt_requirements[1]
                                damage_done = math.ceil(PRIEST.ap * self.calculate_champion_damage(5))
                                ability_data = ["Shimmering Bolt", "enemy", "1T", damage_done]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Divine Smite":
            global divine_smite_requirements
            if divine_smite_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == PRIEST.title:
                        if counter == 1:
                            if divine_smite_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - divine_smite_requirements[0]
                                divine_smite_requirements[3] = divine_smite_requirements[2]
                                champion1_rp = champion1_rp + divine_smite_requirements[1]
                                damage_done = math.ceil(PRIEST.ap * self.calculate_champion_damage(1))
                                ability_data = ["Divine Smite", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 2:
                            if divine_smite_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - divine_smite_requirements[0]
                                divine_smite_requirements[3] = divine_smite_requirements[2]
                                champion2_rp = champion2_rp + divine_smite_requirements[1]
                                damage_done = math.ceil(PRIEST.ap * self.calculate_champion_damage(2))
                                ability_data = ["Divine Smite", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 3:
                            if divine_smite_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - divine_smite_requirements[0]
                                divine_smite_requirements[3] = divine_smite_requirements[2]
                                champion3_rp = champion3_rp + divine_smite_requirements[1]
                                damage_done = math.ceil(PRIEST.ap * self.calculate_champion_damage(3))
                                ability_data = ["Divine Smite", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 4:
                            if divine_smite_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - divine_smite_requirements[0]
                                divine_smite_requirements[3] = divine_smite_requirements[2]
                                champion4_rp = champion4_rp + divine_smite_requirements[1]
                                damage_done = math.ceil(PRIEST.ap * self.calculate_champion_damage(4))
                                ability_data = ["Divine Smite", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 5:
                            if divine_smite_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - divine_smite_requirements[0]
                                divine_smite_requirements[3] = divine_smite_requirements[2]
                                champion5_rp = champion5_rp + divine_smite_requirements[1]
                                damage_done = math.ceil(PRIEST.ap * self.calculate_champion_damage(5))
                                ability_data = ["Divine Smite", "enemy", "1T", damage_done]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Cybernetic Blast":
            global cybernetic_blast_requirements
            if cybernetic_blast_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == TIME_WALKER.title:
                        if counter == 1:
                            if cybernetic_blast_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - cybernetic_blast_requirements[0]
                                cybernetic_blast_requirements[3] = cybernetic_blast_requirements[2]
                                champion1_rp = champion1_rp + cybernetic_blast_requirements[1]
                                damage_done = math.ceil(TIME_WALKER.ap * self.calculate_champion_damage(1))
                                ability_data = ["Cybernetic Blast", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 2:
                            if cybernetic_blast_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - cybernetic_blast_requirements[0]
                                cybernetic_blast_requirements[3] = cybernetic_blast_requirements[2]
                                champion2_rp = champion2_rp + cybernetic_blast_requirements[1]
                                damage_done = math.ceil(TIME_WALKER.ap * self.calculate_champion_damage(2))
                                ability_data = ["Cybernetic Blast", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 3:
                            if cybernetic_blast_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - cybernetic_blast_requirements[0]
                                cybernetic_blast_requirements[3] = cybernetic_blast_requirements[2]
                                champion3_rp = champion3_rp + cybernetic_blast_requirements[1]
                                damage_done = math.ceil(TIME_WALKER.ap * self.calculate_champion_damage(3))
                                ability_data = ["Cybernetic Blast", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 4:
                            if cybernetic_blast_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - cybernetic_blast_requirements[0]
                                cybernetic_blast_requirements[3] = cybernetic_blast_requirements[2]
                                champion4_rp = champion4_rp + cybernetic_blast_requirements[1]
                                damage_done = math.ceil(TIME_WALKER.ap * self.calculate_champion_damage(4))
                                ability_data = ["Cybernetic Blast", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 5:
                            if cybernetic_blast_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - cybernetic_blast_requirements[0]
                                cybernetic_blast_requirements[3] = cybernetic_blast_requirements[2]
                                champion5_rp = champion5_rp + cybernetic_blast_requirements[1]
                                damage_done = math.ceil(TIME_WALKER.ap * self.calculate_champion_damage(5))
                                ability_data = ["Cybernetic Blast", "enemy", "1T", damage_done]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Snip Snip":
            global snip_snip_requirements
            if snip_snip_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == FIELD_MEDIC.title:
                        if counter == 1:
                            if snip_snip_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - snip_snip_requirements[0]
                                snip_snip_requirements[3] = snip_snip_requirements[2]
                                champion1_rp = champion1_rp + snip_snip_requirements[1]
                                damage_done = math.ceil(FIELD_MEDIC.ap * self.calculate_champion_damage(1))
                                ability_data = ["Snip Snip", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 2:
                            if snip_snip_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - snip_snip_requirements[0]
                                snip_snip_requirements[3] = snip_snip_requirements[2]
                                champion2_rp = champion2_rp + snip_snip_requirements[1]
                                damage_done = math.ceil(FIELD_MEDIC.ap * self.calculate_champion_damage(2))
                                ability_data = ["Snip Snip", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 3:
                            if snip_snip_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - snip_snip_requirements[0]
                                snip_snip_requirements[3] = snip_snip_requirements[2]
                                champion3_rp = champion3_rp + snip_snip_requirements[1]
                                damage_done = math.ceil(FIELD_MEDIC.ap * self.calculate_champion_damage(3))
                                ability_data = ["Snip Snip", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 4:
                            if snip_snip_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - snip_snip_requirements[0]
                                snip_snip_requirements[3] = snip_snip_requirements[2]
                                champion4_rp = champion4_rp + snip_snip_requirements[1]
                                damage_done = math.ceil(FIELD_MEDIC.ap * self.calculate_champion_damage(4))
                                ability_data = ["Snip Snip", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 5:
                            if snip_snip_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - snip_snip_requirements[0]
                                snip_snip_requirements[3] = snip_snip_requirements[2]
                                champion5_rp = champion5_rp + snip_snip_requirements[1]
                                damage_done = math.ceil(FIELD_MEDIC.ap * self.calculate_champion_damage(5))
                                ability_data = ["Snip Snip", "enemy", "1T", damage_done]
                            else:
                                return
                    counter += 1
            else:
                return
        self.player_targeting_AI()
#Displays all specials available to the user to choose from with their name, cost, and remaining cooldown.
#Any button that doesn't have an ability tied to it is shown as Empty
#There is a 'View Details' button below each ability that brings up a window that tells the user everything they need to know about that ability
    def special_button(self, button_text_list2):
        global special1_button, special1_button_details, special2_button, special2_button_details, special3_button, special3_button_details, special4_button, special4_button_details, back_button, \
            from_special_button
        if current_turn == "C1":
            attack_button_champion1.destroy()
            special_button_champion1.destroy()
            turn_choice_champion1.destroy()
            special1_button = tk.Button(dungeon_game_frame, text=button_text_list2[0], width=50, height=4,
                                       command=lambda: self.champion_specials(button_text_list2[0]))
            special1_button_details = tk.Button(dungeon_game_frame,
                                                text="{} Details".format(button_text_list2[0]), width=38,
                                                height=1, command=lambda: self.special_details_window(button_text_list2[0]))
            special2_button = tk.Button(dungeon_game_frame, text=button_text_list2[1], width=50, height=4,
                                       command=lambda: self.champion_specials(button_text_list2[1]))
            special2_button_details = tk.Button(dungeon_game_frame,
                                                text="{} Details".format(button_text_list2[1]), width=38,
                                                height=1, command=lambda: self.special_details_window(button_text_list2[1]))
            special3_button = tk.Button(dungeon_game_frame, text=button_text_list2[2], width=50, height=4,
                                       command=lambda: self.champion_specials(button_text_list2[2]))
            special3_button_details = tk.Button(dungeon_game_frame,
                                                text="{} Details".format(button_text_list2[2]), width=38,
                                                height=1, command=lambda: self.special_details_window(button_text_list2[2]))
            special4_button = tk.Button(dungeon_game_frame, text=button_text_list2[3], width=50, height=4,
                                       command=lambda: self.champion_specials(button_text_list2[3]))
            special4_button_details = tk.Button(dungeon_game_frame,
                                                text="{} Details".format(button_text_list2[3]), width=38,
                                                height=1, command=lambda: self.special_details_window(button_text_list2[3]))
            back_button = tk.Button(dungeon_game_frame, text="Back", command=self.player_combat_champion1)
            back_button.grid(row=20, column=2, pady=20)
            special1_button.grid(row=18, column=1)
            special1_button_details.grid(row=19, column=1)
            special2_button.grid(row=18, column=3)
            special2_button_details.grid(row=19, column=3)
            special3_button.grid(row=20, column=1)
            special3_button_details.grid(row=21, column=1)
            special4_button.grid(row=20, column=3)
            special4_button_details.grid(row=21, column=3)
            from_special_button = 1
        if current_turn == "C2":
            attack_button_champion2.destroy()
            special_button_champion2.destroy()
            turn_choice_champion2.destroy()
            special1_button = tk.Button(dungeon_game_frame, text=button_text_list2[0], width=50, height=4,
                                       command=lambda: self.champion_specials(button_text_list2[0]))
            special1_button_details = tk.Button(dungeon_game_frame,
                                                text="{} Details".format(button_text_list2[0]), width=38,
                                                height=1, command=lambda: self.special_details_window(button_text_list2[0]))
            special2_button = tk.Button(dungeon_game_frame, text=button_text_list2[1], width=50, height=4,
                                       command=lambda: self.champion_specials(button_text_list2[1]))
            special2_button_details = tk.Button(dungeon_game_frame,
                                                text="{} Details".format(button_text_list2[1]), width=38,
                                                height=1, command=lambda: self.special_details_window(button_text_list2[1]))
            special3_button = tk.Button(dungeon_game_frame, text=button_text_list2[2], width=50, height=4,
                                       command=lambda: self.champion_specials(button_text_list2[2]))
            special3_button_details = tk.Button(dungeon_game_frame,
                                                text="{} Details".format(button_text_list2[2]), width=38,
                                                height=1, command=lambda: self.special_details_window(button_text_list2[2]))
            special4_button = tk.Button(dungeon_game_frame, text=button_text_list2[3], width=50, height=4,
                                       command=lambda: self.champion_specials(button_text_list2[3]))
            special4_button_details = tk.Button(dungeon_game_frame,
                                                text="{} Details".format(button_text_list2[3]), width=38,
                                                height=1, command=lambda: self.special_details_window(button_text_list2[3]))
            back_button = tk.Button(dungeon_game_frame, text="Back", command=self.player_combat_champion2)
            back_button.grid(row=20, column=2, pady=20)
            special1_button.grid(row=18, column=1)
            special1_button_details.grid(row=19, column=1)
            special2_button.grid(row=18, column=3)
            special2_button_details.grid(row=19, column=3)
            special3_button.grid(row=20, column=1)
            special3_button_details.grid(row=21, column=1)
            special4_button.grid(row=20, column=3)
            special4_button_details.grid(row=21, column=3)
            from_special_button = 1
        if current_turn == "C3":
            attack_button_champion3.destroy()
            special_button_champion3.destroy()
            turn_choice_champion3.destroy()
            special1_button = tk.Button(dungeon_game_frame, text=button_text_list2[0], width=50, height=4,
                                       command=lambda: self.champion_specials(button_text_list2[0]))
            special1_button_details = tk.Button(dungeon_game_frame,
                                                text="{} Details".format(button_text_list2[0]), width=38,
                                                height=1, command=lambda: self.special_details_window(button_text_list2[0]))
            special2_button = tk.Button(dungeon_game_frame, text=button_text_list2[1], width=50, height=4,
                                       command=lambda: self.champion_specials(button_text_list2[1]))
            special2_button_details = tk.Button(dungeon_game_frame,
                                                text="{} Details".format(button_text_list2[1]), width=38,
                                                height=1, command=lambda: self.special_details_window(button_text_list2[1]))
            special3_button = tk.Button(dungeon_game_frame, text=button_text_list2[2], width=50, height=4,
                                       command=lambda: self.champion_specials(button_text_list2[2]))
            special3_button_details = tk.Button(dungeon_game_frame,
                                                text="{} Details".format(button_text_list2[2]), width=38,
                                                height=1, command=lambda: self.special_details_window(button_text_list2[2]))
            special4_button = tk.Button(dungeon_game_frame, text=button_text_list2[3], width=50, height=4,
                                       command=lambda: self.champion_specials(button_text_list2[3]))
            special4_button_details = tk.Button(dungeon_game_frame,
                                                text="{} Details".format(button_text_list2[3]), width=38,
                                                height=1, command=lambda: self.special_details_window(button_text_list2[3]))
            back_button = tk.Button(dungeon_game_frame, text="Back", command=self.player_combat_champion3)
            back_button.grid(row=20, column=2, pady=20)
            special1_button.grid(row=18, column=1)
            special1_button_details.grid(row=19, column=1)
            special2_button.grid(row=18, column=3)
            special2_button_details.grid(row=19, column=3)
            special3_button.grid(row=20, column=1)
            special3_button_details.grid(row=21, column=1)
            special4_button.grid(row=20, column=3)
            special4_button_details.grid(row=21, column=3)
            from_special_button = 1
        if current_turn == "C4":
            attack_button_champion4.destroy()
            special_button_champion4.destroy()
            turn_choice_champion4.destroy()
            special1_button = tk.Button(dungeon_game_frame, text=button_text_list2[0], width=50, height=4,
                                       command=lambda: self.champion_specials(button_text_list2[0]))
            special1_button_details = tk.Button(dungeon_game_frame,
                                                text="{} Details".format(button_text_list2[0]), width=38,
                                                height=1, command=lambda: self.special_details_window(button_text_list2[0]))
            special2_button = tk.Button(dungeon_game_frame, text=button_text_list2[1], width=50, height=4,
                                       command=lambda: self.champion_specials(button_text_list2[1]))
            special2_button_details = tk.Button(dungeon_game_frame,
                                                text="{} Details".format(button_text_list2[1]), width=38,
                                                height=1, command=lambda: self.special_details_window(button_text_list2[1]))
            special3_button = tk.Button(dungeon_game_frame, text=button_text_list2[2], width=50, height=4,
                                       command=lambda: self.champion_specials(button_text_list2[2]))
            special3_button_details = tk.Button(dungeon_game_frame,
                                                text="{} Details".format(button_text_list2[2]), width=38,
                                                height=1, command=lambda: self.special_details_window(button_text_list2[2]))
            special4_button = tk.Button(dungeon_game_frame, text=button_text_list2[3], width=50, height=4,
                                       command=lambda: self.champion_specials(button_text_list2[3]))
            special4_button_details = tk.Button(dungeon_game_frame,
                                                text="{} Details".format(button_text_list2[3]), width=38,
                                                height=1, command=lambda: self.special_details_window(button_text_list2[3]))
            back_button = tk.Button(dungeon_game_frame, text="Back", command=self.player_combat_champion4)
            back_button.grid(row=20, column=2, pady=20)
            special1_button.grid(row=18, column=1)
            special1_button_details.grid(row=19, column=1)
            special2_button.grid(row=18, column=3)
            special2_button_details.grid(row=19, column=3)
            special3_button.grid(row=20, column=1)
            special3_button_details.grid(row=21, column=1)
            special4_button.grid(row=20, column=3)
            special4_button_details.grid(row=21, column=3)
            from_special_button = 1
        if current_turn == "C5":
            attack_button_champion5.destroy()
            special_button_champion5.destroy()
            turn_choice_champion5.destroy()
            special1_button = tk.Button(dungeon_game_frame, text=button_text_list2[0], width=50, height=4,
                                       command=lambda: self.champion_specials(button_text_list2[0]))
            special1_button_details = tk.Button(dungeon_game_frame,
                                                text="{} Details".format(button_text_list2[0]), width=38,
                                                height=1, command=lambda: self.special_details_window(button_text_list2[0]))
            special2_button = tk.Button(dungeon_game_frame, text=button_text_list2[1], width=50, height=4,
                                       command=lambda: self.champion_specials(button_text_list2[1]))
            special2_button_details = tk.Button(dungeon_game_frame,
                                                text="{} Details".format(button_text_list2[1]), width=38,
                                                height=1, command=lambda: self.special_details_window(button_text_list2[1]))
            special3_button = tk.Button(dungeon_game_frame, text=button_text_list2[2], width=50, height=4,
                                       command=lambda: self.champion_specials(button_text_list2[2]))
            special3_button_details = tk.Button(dungeon_game_frame,
                                                text="{} Details".format(button_text_list2[2]), width=38,
                                                height=1, command=lambda: self.special_details_window(button_text_list2[2]))
            special4_button = tk.Button(dungeon_game_frame, text=button_text_list2[3], width=50, height=4,
                                       command=lambda: self.champion_specials(button_text_list2[3]))
            special4_button_details = tk.Button(dungeon_game_frame,
                                                text="{} Details".format(button_text_list2[3]), width=38,
                                                height=1, command=lambda: self.special_details_window(button_text_list2[3]))
            back_button = tk.Button(dungeon_game_frame, text="Back", command=self.player_combat_champion5)
            back_button.grid(row=20, column=2, pady=20)
            special1_button.grid(row=18, column=1)
            special1_button_details.grid(row=19, column=1)
            special2_button.grid(row=18, column=3)
            special2_button_details.grid(row=19, column=3)
            special3_button.grid(row=20, column=1)
            special3_button_details.grid(row=21, column=1)
            special4_button.grid(row=20, column=3)
            special4_button_details.grid(row=21, column=3)
            from_special_button = 1
#Pop-up window that takes the parameter special name and displays all its details in a visual form
#Window tells them the special name, cost, resourced gained on use, cooldown, remaining cooldowm, and what it does
    def special_details_window(self, ability_name):
        root = tk.Tk()
        ability_cost = 0
        ability_gain = 0
        ability_cooldown = 0
        ability_remaining_cooldown = 0
        ability_resource = ""
        special_ability_details = ""
        if ability_name == "Harmonize": 
            special_ability_details = "Reduce the damage inside all mind baubles by 50% and cancel out one round their damage"
            ability_cost = harmonize_requirements[0]
            ability_gain = harmonize_requirements[1]
            ability_cooldown = harmonize_requirements[2]
            ability_remaining_cooldown = harmonize_requirements[3]
            ability_resource = 'Focus'
        elif ability_name == "Pressure Points":
            special_ability_details = "Target an enemy and if they're below 30% of their maximum health points, they instantly die\nOtherwise, they are stunned for three turns"
            ability_cost = pressure_points_requirements[0]
            ability_gain = pressure_points_requirements[1]
            ability_cooldown = pressure_points_requirements[2]
            ability_remaining_cooldown = pressure_points_requirements[3]
            ability_resource = 'Focus'
        elif ability_name == "Challenging Shout":
            special_ability_details = "Force all enemies to attack you for two turns"
            ability_cost = challenging_shout_requirements[0]
            ability_gain = challenging_shout_requirements[1]
            ability_cooldown = challenging_shout_requirements[2]
            ability_remaining_cooldown = challenging_shout_requirements[3]
            ability_resource = 'Rage'
        elif ability_name == "Impactful Boast":
            special_ability_details = "Heal 300 health points per enemy that is attacking you"
            ability_cost = impactful_boast_requirements[0]
            ability_gain = impactful_boast_requirements[1]
            ability_cooldown = impactful_boast_requirements[2]
            ability_remaining_cooldown = impactful_boast_requirements[3]
            ability_resource = 'Rage'
        elif ability_name == "Fortification":
            special_ability_details = "Reduce all damage allies take by 15%"
            ability_cost = fortification_requirements[0]
            ability_gain = fortification_requirements[1]
            ability_cooldown = fortification_requirements[2]
            ability_remaining_cooldown = fortification_requirements[3]
        elif ability_name == "Block":
            special_ability_details = "Protect an ally and take all the damage that they would've for one turn\nIf targetted at self, instead take 50% reduced damage"
            ability_cost = block_requirements[0]
            ability_gain = block_requirements[1]
            ability_cooldown = block_requirements[2]
            ability_remaining_cooldown = block_requirements[3]
        elif ability_name == "Magic Reflection":
            special_ability_details = "Target an enemy and stun them\nif they were casting a magic spell, reflect the damage back at them"
            ability_cost = magic_reflection_requirements[0]
            ability_gain = magic_reflection_requirements[1]
            ability_cooldown = magic_reflection_requirements[2]
            ability_remaining_cooldown = magic_reflection_requirements[3]
        elif ability_name == "Evasive Manoeuvres":
            special_ability_details = "Set your chance to dodge and the amount of damage you dodge for to 100%"
            ability_cost = evasive_manoeuvres_requirements[0]
            ability_gain = evasive_manoeuvres_requirements[1]
            ability_cooldown = evasive_manoeuvres_requirements[2]
            ability_remaining_cooldown = evasive_manoeuvres_requirements[3]
        elif ability_name == "Pure Rage":
            special_ability_details = "Increase the damage you deal by 50%, but also increase the damage you take by 30%"
            ability_cost = pure_rage_requirements[0]
            ability_gain = pure_rage_requirements[1]
            ability_cooldown = pure_rage_requirements[2]
            ability_remaining_cooldown = pure_rage_requirements[3]
        elif ability_name == "Reckless Flurry":
            special_ability_details = "Cause your next two attacks to hit all enemies instead of just one"
            ability_cost = reckless_flurry_requirements[0]
            ability_gain = reckless_flurry_requirements[1]
            ability_cooldown = reckless_flurry_requirements[2]
            ability_remaining_cooldown = reckless_flurry_requirements[3]
            ability_resource = 'Rage'
        elif ability_name == "Garrote":
            special_ability_details = "Lash the enemy with a spiked garrote wire, dealing damage and making them bleed for two turns"
            ability_cost = garrote_requirements[0]
            ability_gain = garrote_requirements[1]
            ability_cooldown = garrote_requirements[2]
            ability_remaining_cooldown = garrote_requirements[3]
        elif ability_name == "Exploit Weakness":
            special_ability_details = "Deal damage to an enemy that increases by 30% for each status they are afflicted with"
            ability_cost = exploit_weakness_requirements[0]
            ability_gain = exploit_weakness_requirements[1]
            ability_cooldown = exploit_weakness_requirements[2]
            ability_remaining_cooldown = exploit_weakness_requirements[3]
        elif ability_name == "Play Dead":
            special_ability_details = "Enemies who were attacking you will mistake you for being already dead\n and will choose new targets to attack"
            ability_cost = play_dead_requirements[0]
            ability_gain = play_dead_requirements[1]
            ability_cooldown = play_dead_requirements[2]
            ability_remaining_cooldown = play_dead_requirements[3]
        elif ability_name == "Survival Kit":
            special_ability_details = "Heal back 60% of your maximum health points and become 'Prepared'"
            ability_cost = survival_kit_requirements[0]
            ability_gain = survival_kit_requirements[1]
            ability_cooldown = survival_kit_requirements[2]
            ability_remaining_cooldown = survival_kit_requirements[3]
        elif ability_name == "Arcane Brilliance":
            special_ability_details = "Cast randomly chosen Fireballs or Frost Bolts at enemies wildly five times"
            ability_cost = arcane_brilliance_requirements[0]
            ability_gain = arcane_brilliance_requirements[1]
            ability_cooldown = arcane_brilliance_requirements[2]
            ability_remaining_cooldown = arcane_brilliance_requirements[3]
            ability_resource = 'Mana'
        elif ability_name == "Magical Barrier":
            special_ability_details = "Surround yourself with a magical barrier that will absorb the next 500 damage you take"
            ability_cost = magical_barrier_requirements[0]
            ability_gain = magical_barrier_requirements[1]
            ability_cooldown = magical_barrier_requirements[2]
            ability_remaining_cooldown = magical_barrier_requirements[3]
            ability_resource = 'Mana'
        elif ability_name == "Barbed Bush Armour":
            special_ability_details = "Enchant an allies armour with a barbed brambles for five turns\nWhenever an enemy attacks an ally with the bush armour, they take 200 damage and are embedded with a thorn"
            ability_cost = barbed_bush_armour_requirements[0]
            ability_gain = barbed_bush_armour_requirements[1]
            ability_cooldown = barbed_bush_armour_requirements[2]
            ability_remaining_cooldown = barbed_bush_armour_requirements[3]
        elif ability_name == "Burst N Bloom":
            special_ability_details = "All active thorns explode, destroying them, and enemies take 250 damage per thorn exploded this way"
            ability_cost = burst_n_bloom_requirements[0]
            ability_gain = burst_n_bloom_requirements[1]
            ability_cooldown = burst_n_bloom_requirements[2]
            ability_remaining_cooldown = burst_n_bloom_requirements[3]
        elif ability_name == "Wound Fissure":
            special_ability_details = "Cause all damage overtime effects to instantly deal damage\nthey lose duration for up to two turns worth on an enemy"
            ability_cost = wound_fissure_requirements[0]
            ability_gain = wound_fissure_requirements[1]
            ability_cooldown = wound_fissure_requirements[2]
            ability_remaining_cooldown = wound_fissure_requirements[3]
            ability_resource = 'Mana'
        elif ability_name == "Soul Tap":
            special_ability_details = "Convert up to 200 health points into equivalent mana"
            ability_cost = soul_tap_requirements[0]
            ability_gain = soul_tap_requirements[1]
            ability_cooldown = soul_tap_requirements[2]
            ability_remaining_cooldown = soul_tap_requirements[3]
        elif ability_name == "Blood Boil":
            special_ability_details = "Erupt your blood to greatly empower the next ability you use\n View the details of your other abilities to see their empowered effects"
            ability_cost = blood_boil_requirements[0]
            ability_gain = blood_boil_requirements[1]
            ability_cooldown = blood_boil_requirements[2]
            ability_remaining_cooldown = blood_boil_requirements[3]
        elif ability_name == "Enharden Nerves":
            special_ability_details = "Reduce damage you take by 40%\nEmpowered Effect: Additionally grant all your allies 'Enhardened Nerves'"
            ability_cost = enharden_nerves_requirements[0]
            ability_gain = enharden_nerves_requirements[1]
            ability_cooldown = enharden_nerves_requirements[2]
            ability_remaining_cooldown = enharden_nerves_requirements[3]
        elif ability_name == "Damnation":
            special_ability_details = "Damn an enemy to take a high damage explosion after three turns"
            ability_cost = damnation_requirements[0]
            ability_gain = damnation_requirements[1]
            ability_cooldown = damnation_requirements[2]
            ability_remaining_cooldown = damnation_requirements[3]
        elif ability_name == "Energise":
            special_ability_details = "Reset the cooldown of Electrical Expulsion\nthe next cast of it discharges double the polarised charges"
            ability_cost = energise_requirements[0]
            ability_gain = energise_requirements[1]
            ability_cooldown = energise_requirements[2]
            ability_remaining_cooldown = energise_requirements[3]
        elif ability_name == "Superconductor":
            special_ability_details = "Cause all polarisation explosions to deal double damage to an enemy"
            ability_cost = superconductor_requirements[0]
            ability_gain = superconductor_requirements[1]
            ability_cooldown = superconductor_requirements[2]
            ability_remaining_cooldown = superconductor_requirements[3]
        elif ability_name == "Muscle Enlarger":
            special_ability_details = "Increase an allies damage by 60% for three turns"
            ability_cost = muscle_enlarger_requirements[0]
            ability_gain = muscle_enlarger_requirements[1]
            ability_cooldown = muscle_enlarger_requirements[2]
            ability_remaining_cooldown = muscle_enlarger_requirements[3]
            ability_resource = 'Charge'
        elif ability_name == "Mistic Bloom":
            special_ability_details = ["Heal an ally"]
            ability_cost = mistic_bloom_requirements[0]
            ability_gain = mistic_bloom_requirements[1]
            ability_cooldown = mistic_bloom_requirements[2]
            ability_remaining_cooldown = mistic_bloom_requirements[3]
            ability_resource = 'Charge'
        elif ability_name == "Power Surge":
            special_ability_details = "Deal damage to all enemies and apply 'Weakness' to them for two turns"
            ability_cost = power_surge_requirements[0]
            ability_gain = power_surge_requirements[1]
            ability_cooldown = power_surge_requirements[2]
            ability_remaining_cooldown = power_surge_requirements[3]
            ability_resource = 'Charges'
        elif ability_name == "Full Potential":
            special_ability_details = "Increase an allies damage by 200% for three turns"
            ability_cost = full_potential_requirements[0]
            ability_gain = full_potential_requirements[1]
            ability_cooldown = full_potential_requirements[2]
            ability_remaining_cooldown = full_potential_requirements[3]
            ability_resource = 'Charges'
        elif ability_name == "Spring Waters":
            special_ability_details = "Heal two allies wounds, giving them 'Flowing Waters' that heals them each turn"
            ability_cost = spring_waters_requirements[0]
            ability_gain = spring_waters_requirements[1]
            ability_cooldown = spring_waters_requirements[2]
            ability_remaining_cooldown = spring_waters_requirements[3]
            ability_resource = 'Mana'
        elif ability_name == "Ocean Tides":
            special_ability_details = "Heal all allies and extend the duration of any active 'Flowing Waters' buffs by one turn"
            ability_cost = ocean_tides_requirements[0]
            ability_gain = ocean_tides_requirements[1]
            ability_cooldown = ocean_tides_requirements[2]
            ability_remaining_cooldown = ocean_tides_requirements[3]
            ability_resource = 'Mana'
        elif ability_name == "Boulder Cocoon":
            special_ability_details = "Protect one ally from all incoming damage for one turn."
            ability_cost = boulder_cocoon_requirements[0]
            ability_gain = boulder_cocoon_requirements[1]
            ability_cooldown = boulder_cocoon_requirements[2]
            ability_remaining_cooldown = boulder_cocoon_requirements[3]
            ability_resource = 'Mana'
        elif ability_name == "Healing Light":
            special_ability_details = "Heal two allies and give them 'Blessed' for two turns."
            ability_cost = healing_light_requirements[0]
            ability_gain = healing_light_requirements[1]
            ability_cooldown = healing_light_requirements[2]
            ability_remaining_cooldown = healing_light_requirements[3]
            ability_resource = 'Mana'
        elif ability_name == "Diffracting Nova":
            special_ability_details = "Deal damage to all enemies and apply two turns of 'Blessed' to all allies"
            ability_cost = diffracting_nova_requirements[0]
            ability_gain = diffracting_nova_requirements[1]
            ability_cooldown = diffracting_nova_requirements[2]
            ability_remaining_cooldown = diffracting_nova_requirements[3]
            ability_resource = 'Mana'
        elif ability_name == "Overclock Nanobots":
            special_ability_details = "Double the healing output of nanobots for two turns"
            ability_cost = overclock_nanobots_requirements[0]
            ability_gain = overclock_nanobots_requirements[1]
            ability_cooldown = overclock_nanobots_requirements[2]
            ability_remaining_cooldown = overclock_nanobots_requirements[3]
            ability_resource = 'Mana'
        elif ability_name == "Reverse Wounds":
            special_ability_details = "Heal an ally of all damage they took since the previous turn"
            ability_cost = reverse_wounds_requirements[0]
            ability_gain = reverse_wounds_requirements[1]
            ability_cooldown = reverse_wounds_requirements[2]
            ability_remaining_cooldown = reverse_wounds_requirements[3]
            ability_resource = 'Mana'
        elif ability_name == "Alter Time":
            special_ability_details = "Heal an ally to full health"
            ability_cost = alter_time_requirements[0]
            ability_gain = alter_time_requirements[1]
            ability_cooldown = alter_time_requirements[2]
            ability_remaining_cooldown = alter_time_requirements[3]
            ability_resource = 'Mana'
        elif ability_name == "Bandages":
            special_ability_details = "Heal an allies wound, giving them 'Bandaged' that heals them each turn"
            ability_cost = bandages_requirements[0]
            ability_gain = bandages_requirements[1]
            ability_cooldown = bandages_requirements[2]
            ability_remaining_cooldown = bandages_requirements[3]
        elif ability_name == "Tight Tourniquet":
            special_ability_details = "Reduce an allies damage taken by 20% for one turn\nOn following turns, they recieve a diminshed version for two turns"
            ability_cost = tight_tourniquet_requirements[0]
            ability_gain = tight_tourniquet_requirements[1]
            ability_cooldown = tight_tourniquet_requirements[2]
            ability_remaining_cooldown = tight_tourniquet_requirements[3]
        elif ability_name == "Secret Remedy":
            special_ability_details = "Increase an allies damage by 50% for one turn\nOn following turns, they recieve a diminshed version for two turns"
            ability_cost = secret_remedy_requirements[0]
            ability_gain = secret_remedy_requirements[1]
            ability_cooldown = secret_remedy_requirements[2]
            ability_remaining_cooldown = secret_remedy_requirements[3]
        ability_title_label = tk.Label(root, text=ability_name)
        ability_title_label.grid(row=0, column=1)
        ability_description1 = ""
        ability_description2 = ""
        if ability_cost != 0:
            if ability_gain != 0:
                ability_description1 = "Ability Cost ({} {}) : Gain ({} {})".format(ability_cost, ability_resource, ability_gain, ability_resource)
            else:
                ability_description1 = "Ability Cost ({} {})".format(ability_cost, ability_resource)
            ability_requirements1_label = tk.Label(root, text=ability_description1)
            ability_requirements1_label.grid(row=1, column=1)
        elif ability_gain != 0:
            ability_description1 = "Gain ({} {})".format(ability_gain, ability_resource)
            ability_requirements1_label = tk.Label(root, text=ability_description1)
            ability_requirements1_label.grid(row=1, column=1)
        if ability_cooldown != 0:
            if ability_remaining_cooldown != 0:
                ability_description2 = "Ability Cooldown ({}) : Remaining Cooldown ({})".format(ability_cooldown, ability_remaining_cooldown)
            else:
                ability_description2 = "Ability Cooldown ({})".format(ability_cooldown)
            ability_requirements2_label = tk.Label(root, text=ability_description2)
            ability_requirements2_label.grid(row=2, column=1)
            ability_description_label = tk.Label(root, text=special_ability_details)
            ability_description_label.grid(row=3, column=1)
            close_button = tk.Button(root, text="Close Window", command=root.destroy)
            close_button.grid(row=4, column=1)
        else:
            ability_description_label = tk.Label(root, text=special_ability_details)
            ability_description_label.grid(row=2, column=1)
            close_button = tk.Button(root, text="Close Window", command=root.destroy)
            close_button.grid(row=3, column=1)
#Finds the ability name and sets the abilities data into a universal list that can be called upon easily
#This list 'ability_data' has four variables
#1: Ability name (string)
#2: Ability target (string) which can be 'self' (just happens, mostly self-buffs), 'enemy' (targets or hits enemies), or 'ally' (targets or effect happens to allies)
#3: Ability targeting amount (string) which can be '1T' (hits only one target), '2T' (hits two targets), '3T' (hits three targets), or 'AOE' (hits everyone alive from the target stated AKA enemies or allies)
#4: Ability power (interger), named either damage_done or healing_done based on the ability effect
#Function also finds which champion the ability belongs to and which position they're in order to add or subtract resource
    def champion_specials(self, ability_name):
        global attack_to_target, special_to_target, ability_data, champion1_rp, champion2_rp, champion3_rp, champion4_rp, champion5_rp
        attack_to_target = 0
        special_to_target = 1
        counter = 1
        damage_done = 0
        healing_done = 0
        if ability_name == "Empty":
            return
        elif ability_name == "Harmonize":
            global harmonize_requirements
            if harmonize_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == MONK.title:
                        if counter == 1:
                            if harmonize_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - harmonize_requirements[0]
                                harmonize_requirements[3] = harmonize_requirements[2]
                                champion1_rp = champion1_rp + harmonize_requirements[1]
                                ability_data =["Harmonize", "self", "1T"]
                            else:
                                return
                        if counter == 2:
                            if harmonize_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - harmonize_requirements[0]
                                harmonize_requirements[3] = harmonize_requirements[2]
                                champion2_rp = champion2_rp + harmonize_requirements[1]
                                ability_data =["Harmonize", "self", "1T"]
                            else:
                                return
                        if counter == 3:
                            if harmonize_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - harmonize_requirements[0]
                                harmonize_requirements[3] = harmonize_requirements[2]
                                champion3_rp = champion3_rp + harmonize_requirements[1]
                                ability_data =["Harmonize", "self", "1T"]
                            else:
                                return
                        if counter == 4:
                            if harmonize_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - harmonize_requirements[0]
                                harmonize_requirements[3] = harmonize_requirements[2]
                                champion4_rp = champion4_rp + harmonize_requirements[1]
                                ability_data =["Harmonize", "self", "1T"]
                            else:
                                return
                        if counter == 5:
                            if harmonize_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - harmonize_requirements[0]
                                harmonize_requirements[3] = harmonize_requirements[2]
                                champion5_rp = champion5_rp + harmonize_requirements[1]
                                ability_data =["Harmonize", "self", "1T"]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Pressure Points":
            global pressure_points_requirements
            if pressure_points_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == MONK.title:
                        if counter == 1:
                            if pressure_points_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - pressure_points_requirements[0]
                                pressure_points_requirements[3] = pressure_points_requirements[2]
                                champion1_rp = champion1_rp + pressure_points_requirements[1]
                                ability_data = ["Pressure Points", "enemy", "1T"]
                            else:
                                return
                        if counter == 2:
                            if pressure_points_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - pressure_points_requirements[0]
                                pressure_points_requirements[3] = pressure_points_requirements[2]
                                champion2_rp = champion2_rp + pressure_points_requirements[1]
                                ability_data = ["Pressure Points", "enemy", "1T"]
                            else:
                                return
                        if counter == 3:
                            if pressure_points_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - pressure_points_requirements[0]
                                pressure_points_requirements[3] = pressure_points_requirements[2]
                                champion3_rp = champion3_rp + pressure_points_requirements[1]
                                ability_data = ["Pressure Points", "enemy", "1T"]
                            else:
                                return
                        if counter == 4:
                            if pressure_points_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - pressure_points_requirements[0]
                                pressure_points_requirements[3] = pressure_points_requirements[2]
                                champion4_rp = champion4_rp + pressure_points_requirements[1]
                                ability_data = ["Pressure Points", "enemy", "1T"]
                            else:
                                return
                        if counter == 5:
                            if pressure_points_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - pressure_points_requirements[0]
                                pressure_points_requirements[3] = pressure_points_requirements[2]
                                champion5_rp = champion5_rp + pressure_points_requirements[1]
                                ability_data = ["Pressure Points", "enemy", "1T"]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Challenging Shout":
            global challenging_shout_requirements
            if challenging_shout_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == BARBARIAN.title:
                        if counter == 1:
                            if challenging_shout_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - challenging_shout_requirements[0]
                                challenging_shout_requirements[3] = challenging_shout_requirements[2]
                                champion1_rp = champion1_rp + challenging_shout_requirements[1]
                                ability_data = ["Challenging Shout", "self", "AOE"]
                            else:
                                return
                        if counter == 2:
                            if challenging_shout_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - challenging_shout_requirements[0]
                                challenging_shout_requirements[3] = challenging_shout_requirements[2]
                                champion2_rp = champion2_rp + challenging_shout_requirements[1]
                                ability_data = ["Challenging Shout", "self", "AOE"]
                            else:
                                return
                        if counter == 3:
                            if challenging_shout_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - challenging_shout_requirements[0]
                                challenging_shout_requirements[3] = challenging_shout_requirements[2]
                                champion3_rp = champion3_rp + challenging_shout_requirements[1]
                                ability_data = ["Challenging Shout", "self", "AOE"]
                            else:
                                return
                        if counter == 4:
                            if challenging_shout_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - challenging_shout_requirements[0]
                                challenging_shout_requirements[3] = challenging_shout_requirements[2]
                                champion4_rp = champion4_rp + challenging_shout_requirements[1]
                                ability_data = ["Challenging Shout", "self", "AOE"]
                            else:
                                return
                        if counter == 5:
                            if challenging_shout_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - challenging_shout_requirements[0]
                                challenging_shout_requirements[3] = challenging_shout_requirements[2]
                                champion5_rp = champion5_rp + challenging_shout_requirements[1]
                                ability_data = ["Challenging Shout", "self", "AOE"]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Impactful Boast":
            global impactful_boast_requirements
            if impactful_boast_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == BARBARIAN.title:
                        if counter == 1:
                            if impactful_boast_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - impactful_boast_requirements[0]
                                impactful_boast_requirements[3] = impactful_boast_requirements[2]
                                champion1_rp = champion1_rp + impactful_boast_requirements[1]
                                ability_data = ["Impactful Boast", "self"]
                            else:
                                return
                        if counter == 2:
                            if impactful_boast_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - impactful_boast_requirements[0]
                                impactful_boast_requirements[3] = impactful_boast_requirements[2]
                                champion2_rp = champion2_rp + impactful_boast_requirements[1]
                                ability_data = ["Impactful Boast", "self"]
                            else:
                                return
                        if counter == 3:
                            if impactful_boast_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - impactful_boast_requirements[0]
                                impactful_boast_requirements[3] = impactful_boast_requirements[2]
                                champion3_rp = champion3_rp + impactful_boast_requirements[1]
                                ability_data = ["Impactful Boast", "self"]
                            else:
                                return
                        if counter == 4:
                            if impactful_boast_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - impactful_boast_requirements[0]
                                impactful_boast_requirements[3] = impactful_boast_requirements[2]
                                champion4_rp = champion4_rp + impactful_boast_requirements[1]
                                ability_data = ["Impactful Boast", "self"]
                            else:
                                return
                        if counter == 5:
                            if impactful_boast_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - impactful_boast_requirements[0]
                                impactful_boast_requirements[3] = impactful_boast_requirements[2]
                                champion5_rp = champion5_rp + impactful_boast_requirements[1]
                                ability_data = ["Impactful Boast", "self"]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Fortification":
            global fortification_requirements
            if fortification_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == KINGS_GUARD.title:
                        if counter == 1:
                            if fortification_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - fortification_requirements[0]
                                fortification_requirements[3] = fortification_requirements[2]
                                champion1_rp = champion1_rp + fortification_requirements[1]
                                ability_data = ["Fortification", "ally", "AOE"]
                            else:
                                return
                        if counter == 2:
                            if fortification_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - fortification_requirements[0]
                                fortification_requirements[3] = fortification_requirements[2]
                                champion2_rp = champion2_rp + fortification_requirements[1]
                                ability_data = ["Fortification", "ally", "AOE"]
                            else:
                                return
                        if counter == 3:
                            if fortification_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - fortification_requirements[0]
                                fortification_requirements[3] = fortification_requirements[2]
                                champion3_rp = champion3_rp + fortification_requirements[1]
                                ability_data = ["Fortification", "ally", "AOE"]
                            else:
                                return
                        if counter == 4:
                            if fortification_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - fortification_requirements[0]
                                fortification_requirements[3] = fortification_requirements[2]
                                champion4_rp = champion4_rp + fortification_requirements[1]
                                ability_data = ["Fortification", "ally", "AOE"]
                            else:
                                return
                        if counter == 5:
                            if fortification_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - fortification_requirements[0]
                                fortification_requirements[3] = fortification_requirements[2]
                                champion5_rp = champion5_rp + fortification_requirements[1]
                                ability_data = ["Fortification", "ally", "AOE"]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Block":
            global block_requirements
            if block_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == KINGS_GUARD.title:
                        if counter == 1:
                            if block_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - block_requirements[0]
                                block_requirements[3] = block_requirements[2]
                                champion1_rp = champion1_rp + block_requirements[1]
                                ability_data = ["Block", "ally", "1T"]
                            else:
                                return
                        if counter == 2:
                            if block_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - block_requirements[0]
                                block_requirements[3] = block_requirements[2]
                                champion2_rp = champion2_rp + block_requirements[1]
                                ability_data = ["Block", "ally", "1T"]
                            else:
                                return
                        if counter == 3:
                            if block_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - block_requirements[0]
                                block_requirements[3] = block_requirements[2]
                                champion3_rp = champion3_rp + block_requirements[1]
                                ability_data = ["Block", "ally", "1T"]
                            else:
                                return
                        if counter == 4:
                            if block_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - block_requirements[0]
                                block_requirements[3] = block_requirements[2]
                                champion4_rp = champion4_rp + block_requirements[1]
                                ability_data = ["Block", "ally", "1T"]
                            else:
                                return
                        if counter == 5:
                            if block_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - block_requirements[0]
                                block_requirements[3] = block_requirements[2]
                                champion5_rp = champion5_rp + block_requirements[1]
                                ability_data = ["Block", "ally", "1T"]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Magic Reflection":
            global magic_reflection_requirements
            if magic_reflection_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == MASTER_FENCER.title:
                        if counter == 1:
                            if magic_reflection_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - magic_reflection_requirements[0]
                                magic_reflection_requirements[3] = magic_reflection_requirements[2]
                                champion1_rp = champion1_rp + magic_reflection_requirements[1]
                                ability_data = ["Magic Reflection", "enemy", "1T"]
                            else:
                                return
                        if counter == 2:
                            if magic_reflection_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - magic_reflection_requirements[0]
                                magic_reflection_requirements[3] = magic_reflection_requirements[2]
                                champion2_rp = champion2_rp + magic_reflection_requirements[1]
                                ability_data = ["Magic Reflection", "enemy", "1T"]
                            else:
                                return
                        if counter == 3:
                            if magic_reflection_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - magic_reflection_requirements[0]
                                magic_reflection_requirements[3] = magic_reflection_requirements[2]
                                champion3_rp = champion3_rp + magic_reflection_requirements[1]
                                ability_data = ["Magic Reflection", "enemy", "1T"]
                            else:
                                return
                        if counter == 4:
                            if magic_reflection_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - magic_reflection_requirements[0]
                                magic_reflection_requirements[3] = magic_reflection_requirements[2]
                                champion4_rp = champion4_rp + magic_reflection_requirements[1]
                                ability_data = ["Magic Reflection", "enemy", "1T"]
                            else:
                                return
                        if counter == 5:
                            if magic_reflection_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - magic_reflection_requirements[0]
                                magic_reflection_requirements[3] = magic_reflection_requirements[2]
                                champion5_rp = champion5_rp + magic_reflection_requirements[1]
                                ability_data = ["Magic Reflection", "enemy", "1T"]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Evasive Manoeuvres":
            global evasive_manoeuvres_requirements
            if evasive_manoeuvres_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == MASTER_FENCER.title:
                        if counter == 1:
                            if evasive_manoeuvres_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - evasive_manoeuvres_requirements[0]
                                evasive_manoeuvres_requirements[3] = evasive_manoeuvres_requirements[2]
                                champion1_rp = champion1_rp + evasive_manoeuvres_requirements[1]
                                ability_data = ["Evasive Manoeuvres", "self"]
                            else:
                                return
                        if counter == 2:
                            if evasive_manoeuvres_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - evasive_manoeuvres_requirements[0]
                                evasive_manoeuvres_requirements[3] = evasive_manoeuvres_requirements[2]
                                champion2_rp = champion2_rp + evasive_manoeuvres_requirements[1]
                                ability_data = ["Evasive Manoeuvres", "self"]
                            else:
                                return
                        if counter == 3:
                            if evasive_manoeuvres_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - evasive_manoeuvres_requirements[0]
                                evasive_manoeuvres_requirements[3] = evasive_manoeuvres_requirements[2]
                                champion3_rp = champion3_rp + evasive_manoeuvres_requirements[1]
                                ability_data = ["Evasive Manoeuvres", "self"]
                            else:
                                return
                        if counter == 4:
                            if evasive_manoeuvres_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - evasive_manoeuvres_requirements[0]
                                evasive_manoeuvres_requirements[3] = evasive_manoeuvres_requirements[2]
                                champion4_rp = champion4_rp + evasive_manoeuvres_requirements[1]
                                ability_data = ["Evasive Manoeuvres", "self"]
                            else:
                                return
                        if counter == 5:
                            if evasive_manoeuvres_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - evasive_manoeuvres_requirements[0]
                                evasive_manoeuvres_requirements[3] = evasive_manoeuvres_requirements[2]
                                champion5_rp = champion5_rp + evasive_manoeuvres_requirements[1]
                                ability_data = ["Evasive Manoeuvres", "self"]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Pure Rage":
            global pure_rage_requirements
            if pure_rage_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == BERSERKER.title:
                        if counter == 1:
                            if pure_rage_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - pure_rage_requirements[0]
                                pure_rage_requirements[3] = pure_rage_requirements[2]
                                champion1_rp = champion1_rp + pure_rage_requirements[1]
                                ability_data = ["Pure Rage", "self"]
                            else:
                                return
                        if counter == 2:
                            if pure_rage_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - pure_rage_requirements[0]
                                pure_rage_requirements[3] = pure_rage_requirements[2]
                                champion2_rp = champion2_rp + pure_rage_requirements[1]
                                ability_data = ["Pure Rage", "self"]
                            else:
                                return
                        if counter == 3:
                            if pure_rage_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - pure_rage_requirements[0]
                                pure_rage_requirements[3] = pure_rage_requirements[2]
                                champion3_rp = champion3_rp + pure_rage_requirements[1]
                                ability_data = ["Pure Rage", "self"]
                            else:
                                return
                        if counter == 4:
                            if pure_rage_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - pure_rage_requirements[0]
                                pure_rage_requirements[3] = pure_rage_requirements[2]
                                champion4_rp = champion4_rp + pure_rage_requirements[1]
                                ability_data = ["Pure Rage", "self"]
                            else:
                                return
                        if counter == 5:
                            if pure_rage_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - pure_rage_requirements[0]
                                pure_rage_requirements[3] = pure_rage_requirements[2]
                                champion5_rp = champion5_rp + pure_rage_requirements[1]
                                ability_data = ["Pure Rage", "self"]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Reckless Flurry":
            global reckless_flurry_requirements
            if reckless_flurry_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == BERSERKER.title:
                        if counter == 1:
                            if reckless_flurry_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - reckless_flurry_requirements[0]
                                reckless_flurry_requirements[3] = reckless_flurry_requirements[2]
                                champion1_rp = champion1_rp + reckless_flurry_requirements[1]
                                ability_data = ["Reckless Flurry", "self"]
                            else:
                                return
                        if counter == 2:
                            if reckless_flurry_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - reckless_flurry_requirements[0]
                                reckless_flurry_requirements[3] = reckless_flurry_requirements[2]
                                champion2_rp = champion2_rp + reckless_flurry_requirements[1]
                                ability_data = ["Reckless Flurry", "self"]
                            else:
                                return
                        if counter == 3:
                            if reckless_flurry_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - reckless_flurry_requirements[0]
                                reckless_flurry_requirements[3] = reckless_flurry_requirements[2]
                                champion3_rp = champion3_rp + reckless_flurry_requirements[1]
                                ability_data = ["Reckless Flurry", "self"]
                            else:
                                return
                        if counter == 4:
                            if reckless_flurry_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - reckless_flurry_requirements[0]
                                reckless_flurry_requirements[3] = reckless_flurry_requirements[2]
                                champion4_rp = champion4_rp + reckless_flurry_requirements[1]
                                ability_data = ["Reckless Flurry", "self"]
                            else:
                                return
                        if counter == 5:
                            if reckless_flurry_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - reckless_flurry_requirements[0]
                                reckless_flurry_requirements[3] = reckless_flurry_requirements[2]
                                champion5_rp = champion5_rp + reckless_flurry_requirements[1]
                                ability_data = ["Reckless Flurry", "self"]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Garrote":
            global garrote_requirements
            if garrote_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == ROGUE.title:
                        if counter == 1:
                            if garrote_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - garrote_requirements[0]
                                garrote_requirements[3] = garrote_requirements[2]
                                champion1_rp = champion1_rp + garrote_requirements[1]
                                damage_done = math.ceil(ROGUE.ap * self.calculate_champion_damage(1))
                                damage_done = math.ceil(ROGUE.ap * self.calculate_champion_damage(1))
                                ability_data = ["Garrote", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 2:
                            if garrote_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - garrote_requirements[0]
                                garrote_requirements[3] = garrote_requirements[2]
                                champion2_rp = champion2_rp + garrote_requirements[1]
                                damage_done = math.ceil(ROGUE.ap * self.calculate_champion_damage(2))
                                damage_done = math.ceil(ROGUE.ap * self.calculate_champion_damage(2))
                                ability_data = ["Garrote", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 3:
                            if garrote_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - garrote_requirements[0]
                                garrote_requirements[3] = garrote_requirements[2]
                                champion3_rp = champion3_rp + garrote_requirements[1]
                                damage_done = math.ceil(ROGUE.ap * self.calculate_champion_damage(3))
                                damage_done = math.ceil(ROGUE.ap * self.calculate_champion_damage(3))
                                ability_data = ["Garrote", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 4:
                            if garrote_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - garrote_requirements[0]
                                garrote_requirements[3] = garrote_requirements[2]
                                champion4_rp = champion4_rp + garrote_requirements[1]
                                damage_done = math.ceil(ROGUE.ap * self.calculate_champion_damage(4))
                                damage_done = math.ceil(ROGUE.ap * self.calculate_champion_damage(4))
                                ability_data = ["Garrote", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 5:
                            if garrote_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - garrote_requirements[0]
                                garrote_requirements[3] = garrote_requirements[2]
                                champion5_rp = champion5_rp + garrote_requirements[1]
                                damage_done = math.ceil(ROGUE.ap * self.calculate_champion_damage(5))
                                damage_done = math.ceil(ROGUE.ap * self.calculate_champion_damage(5))
                                ability_data = ["Garrote", "enemy", "1T", damage_done]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Exploit Weakness":
            global exploit_weakness_requirements
            if exploit_weakness_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == ROGUE.title:
                        if counter == 1:
                            if exploit_weakness_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - exploit_weakness_requirements[0]
                                exploit_weakness_requirements[3] = exploit_weakness_requirements[2]
                                champion1_rp = champion1_rp + exploit_weakness_requirements[1]
                                damage_done = math.ceil(ROGUE.ap * self.calculate_champion_damage(1))
                                damage_done = math.ceil(ROGUE.ap * self.calculate_champion_damage(1))
                                ability_data = ["Exploit Weakness", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 2:
                            if exploit_weakness_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - exploit_weakness_requirements[0]
                                exploit_weakness_requirements[3] = exploit_weakness_requirements[2]
                                champion2_rp = champion2_rp + exploit_weakness_requirements[1]
                                damage_done = math.ceil(ROGUE.ap * self.calculate_champion_damage(2))
                                damage_done = math.ceil(ROGUE.ap * self.calculate_champion_damage(2))
                                ability_data = ["Exploit Weakness", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 3:
                            if exploit_weakness_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - exploit_weakness_requirements[0]
                                exploit_weakness_requirements[3] = exploit_weakness_requirements[2]
                                champion3_rp = champion3_rp + exploit_weakness_requirements[1]
                                damage_done = math.ceil(ROGUE.ap * self.calculate_champion_damage(3))
                                damage_done = math.ceil(ROGUE.ap * self.calculate_champion_damage(3))
                                ability_data = ["Exploit Weakness", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 4:
                            if exploit_weakness_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - exploit_weakness_requirements[0]
                                exploit_weakness_requirements[3] = exploit_weakness_requirements[2]
                                champion4_rp = champion4_rp + exploit_weakness_requirements[1]
                                damage_done = math.ceil(ROGUE.ap * self.calculate_champion_damage(4))
                                damage_done = math.ceil(ROGUE.ap * self.calculate_champion_damage(4))
                                ability_data = ["Exploit Weakness", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 5:
                            if exploit_weakness_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - exploit_weakness_requirements[0]
                                exploit_weakness_requirements[3] = exploit_weakness_requirements[2]
                                champion5_rp = champion5_rp + exploit_weakness_requirements[1]
                                damage_done = math.ceil(ROGUE.ap * self.calculate_champion_damage(5))
                                damage_done = math.ceil(ROGUE.ap * self.calculate_champion_damage(5))
                                ability_data = ["Exploit Weakness", "enemy", "1T", damage_done]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Play Dead":
            global play_dead_requirements
            if play_dead_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == SURVIVALIST.title:
                        if counter == 1:
                            if play_dead_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - play_dead_requirements[0]
                                play_dead_requirements[3] = play_dead_requirements[2]
                                champion1_rp = champion1_rp + play_dead_requirements[1]
                                ability_data = ["Play Dead", "self"]
                            else:
                                return
                        if counter == 2:
                            if play_dead_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - play_dead_requirements[0]
                                play_dead_requirements[3] = play_dead_requirements[2]
                                champion2_rp = champion2_rp + play_dead_requirements[1]
                                ability_data = ["Play Dead", "self"]
                            else:
                                return
                        if counter == 3:
                            if play_dead_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - play_dead_requirements[0]
                                play_dead_requirements[3] = play_dead_requirements[2]
                                champion3_rp = champion3_rp + play_dead_requirements[1]
                                ability_data = ["Play Dead", "self"]
                            else:
                                return
                        if counter == 4:
                            if play_dead_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - play_dead_requirements[0]
                                play_dead_requirements[3] = play_dead_requirements[2]
                                champion4_rp = champion4_rp + play_dead_requirements[1]
                                ability_data = ["Play Dead", "self"]
                            else:
                                return
                        if counter == 5:
                            if play_dead_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - play_dead_requirements[0]
                                play_dead_requirements[3] = play_dead_requirements[2]
                                champion5_rp = champion5_rp + play_dead_requirements[1]
                                ability_data = ["Play Dead", "self"]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Survival Kit":
            global survival_kit_requirements
            if survival_kit_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == SURVIVALIST.title:
                        if counter == 1:
                            if survival_kit_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - survival_kit_requirements[0]
                                survival_kit_requirements[3] = survival_kit_requirements[2]
                                champion1_rp = champion1_rp + survival_kit_requirements[1]
                                ability_data = ["Survival Kit", "self"]
                            else:
                                return
                        if counter == 2:
                            if survival_kit_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - survival_kit_requirements[0]
                                survival_kit_requirements[3] = survival_kit_requirements[2]
                                champion2_rp = champion2_rp + survival_kit_requirements[1]
                                ability_data = ["Survival Kit", "self"]
                            else:
                                return
                        if counter == 3:
                            if survival_kit_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - survival_kit_requirements[0]
                                survival_kit_requirements[3] = survival_kit_requirements[2]
                                champion3_rp = champion3_rp + survival_kit_requirements[1]
                                ability_data = ["Survival Kit", "self"]
                            else:
                                return
                        if counter == 4:
                            if survival_kit_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - survival_kit_requirements[0]
                                survival_kit_requirements[3] = survival_kit_requirements[2]
                                champion4_rp = champion4_rp + survival_kit_requirements[1]
                                ability_data = ["Survival Kit", "self"]
                            else:
                                return
                        if counter == 5:
                            if survival_kit_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - survival_kit_requirements[0]
                                survival_kit_requirements[3] = survival_kit_requirements[2]
                                champion5_rp = champion5_rp + survival_kit_requirements[1]
                                ability_data = ["Survival Kit", "self"]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Arcane Brilliance":
            global arcane_brilliance_requirements
            if arcane_brilliance_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == ACADEMIC_MAGE.title:
                        if counter == 1:
                            if arcane_brilliance_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - arcane_brilliance_requirements[0]
                                arcane_brilliance_requirements[3] = arcane_brilliance_requirements[2]
                                champion1_rp = champion1_rp + arcane_brilliance_requirements[1]
                                damage_done = math.ceil(ACADEMIC_MAGE.ap * self.calculate_champion_damage(1))
                                damage_done = math.ceil(ACADEMIC_MAGE.ap * self.calculate_champion_damage(1))
                                ability_data = ["Arcane Brilliance", "enemy", "AOE", damage_done]
                            else:
                                return
                        if counter == 2:
                            if arcane_brilliance_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - arcane_brilliance_requirements[0]
                                arcane_brilliance_requirements[3] = arcane_brilliance_requirements[2]
                                champion2_rp = champion2_rp + arcane_brilliance_requirements[1]
                                damage_done = math.ceil(ACADEMIC_MAGE.ap * self.calculate_champion_damage(2))
                                damage_done = math.ceil(ACADEMIC_MAGE.ap * self.calculate_champion_damage(2))
                                ability_data = ["Arcane Brilliance", "enemy", "AOE", damage_done]
                            else:
                                return
                        if counter == 3:
                            if arcane_brilliance_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - arcane_brilliance_requirements[0]
                                arcane_brilliance_requirements[3] = arcane_brilliance_requirements[2]
                                champion3_rp = champion3_rp + arcane_brilliance_requirements[1]
                                damage_done = math.ceil(ACADEMIC_MAGE.ap * self.calculate_champion_damage(3))
                                damage_done = math.ceil(ACADEMIC_MAGE.ap * self.calculate_champion_damage(3))
                                ability_data = ["Arcane Brilliance", "enemy", "AOE", damage_done]
                            else:
                                return
                        if counter == 4:
                            if arcane_brilliance_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - arcane_brilliance_requirements[0]
                                arcane_brilliance_requirements[3] = arcane_brilliance_requirements[2]
                                champion4_rp = champion4_rp + arcane_brilliance_requirements[1]
                                damage_done = math.ceil(ACADEMIC_MAGE.ap * self.calculate_champion_damage(4))
                                damage_done = math.ceil(ACADEMIC_MAGE.ap * self.calculate_champion_damage(4))
                                ability_data = ["Arcane Brilliance", "enemy", "AOE", damage_done]
                            else:
                                return
                        if counter == 5:
                            if arcane_brilliance_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - arcane_brilliance_requirements[0]
                                arcane_brilliance_requirements[3] = arcane_brilliance_requirements[2]
                                champion5_rp = champion5_rp + arcane_brilliance_requirements[1]
                                damage_done = math.ceil(ACADEMIC_MAGE.ap * self.calculate_champion_damage(5))
                                damage_done = math.ceil(ACADEMIC_MAGE.ap * self.calculate_champion_damage(5))
                                ability_data = ["Arcane Brilliance", "enemy", "AOE", damage_done]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Magical Barrier":
            global magical_barrier_requirements
            if magical_barrier_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == ACADEMIC_MAGE.title:
                        if counter == 1:
                            if magical_barrier_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - magical_barrier_requirements[0]
                                magical_barrier_requirements[3] = magical_barrier_requirements[2]
                                champion1_rp = champion1_rp + magical_barrier_requirements[1]
                                ability_data = ["Magical Barrier", "self"]
                            else:
                                return
                        if counter == 2:
                            if magical_barrier_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - magical_barrier_requirements[0]
                                magical_barrier_requirements[3] = magical_barrier_requirements[2]
                                champion2_rp = champion2_rp + magical_barrier_requirements[1]
                                ability_data = ["Magical Barrier", "self"]
                            else:
                                return
                        if counter == 3:
                            if magical_barrier_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - magical_barrier_requirements[0]
                                magical_barrier_requirements[3] = magical_barrier_requirements[2]
                                champion3_rp = champion3_rp + magical_barrier_requirements[1]
                                ability_data = ["Magical Barrier", "self"]
                            else:
                                return
                        if counter == 4:
                            if magical_barrier_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - magical_barrier_requirements[0]
                                magical_barrier_requirements[3] = magical_barrier_requirements[2]
                                champion4_rp = champion4_rp + magical_barrier_requirements[1]
                                ability_data = ["Magical Barrier", "self"]
                            else:
                                return
                        if counter == 5:
                            if magical_barrier_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - magical_barrier_requirements[0]
                                magical_barrier_requirements[3] = magical_barrier_requirements[2]
                                champion5_rp = champion5_rp + magical_barrier_requirements[1]
                                ability_data = ["Magical Barrier", "self"]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Barbed Bush Armour":
            global barbed_bush_armour_requirements
            if barbed_bush_armour_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == DRUID.title:
                        if counter == 1:
                            if barbed_bush_armour_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - barbed_bush_armour_requirements[0]
                                barbed_bush_armour_requirements[3] = barbed_bush_armour_requirements[2]
                                champion1_rp = champion1_rp + barbed_bush_armour_requirements[1]
                                damage_done = math.ceil(DRUID.ap * self.calculate_champion_damage(1))
                                ability_data = ["Barbed Bush Armour", "ally", "1T", damage_done]
                            else:
                                return
                        if counter == 2:
                            if barbed_bush_armour_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - barbed_bush_armour_requirements[0]
                                barbed_bush_armour_requirements[3] = barbed_bush_armour_requirements[2]
                                champion2_rp = champion2_rp + barbed_bush_armour_requirements[1]
                                damage_done = math.ceil(DRUID.ap * self.calculate_champion_damage(2))
                                ability_data = ["Barbed Bush Armour", "ally", "1T", damage_done]
                            else:
                                return
                        if counter == 3:
                            if barbed_bush_armour_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - barbed_bush_armour_requirements[0]
                                barbed_bush_armour_requirements[3] = barbed_bush_armour_requirements[2]
                                champion3_rp = champion3_rp + barbed_bush_armour_requirements[1]
                                damage_done = math.ceil(DRUID.ap * self.calculate_champion_damage(3))
                                ability_data = ["Barbed Bush Armour", "ally", "1T", damage_done]
                            else:
                                return
                        if counter == 4:
                            if barbed_bush_armour_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - barbed_bush_armour_requirements[0]
                                barbed_bush_armour_requirements[3] = barbed_bush_armour_requirements[2]
                                champion4_rp = champion4_rp + barbed_bush_armour_requirements[1]
                                damage_done = math.ceil(DRUID.ap * self.calculate_champion_damage(4))
                                ability_data = ["Barbed Bush Armour", "ally", "1T", damage_done]
                            else:
                                return
                        if counter == 5:
                            if barbed_bush_armour_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - barbed_bush_armour_requirements[0]
                                barbed_bush_armour_requirements[3] = barbed_bush_armour_requirements[2]
                                champion5_rp = champion5_rp + barbed_bush_armour_requirements[1]
                                damage_done = math.ceil(DRUID.ap * self.calculate_champion_damage(5))
                                ability_data = ["Barbed Bush Armour", "ally", "1T", damage_done]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Burst N Bloom":
            global burst_n_bloom_requirements
            if burst_n_bloom_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == DRUID.title:
                        if counter == 1:
                            if burst_n_bloom_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - burst_n_bloom_requirements[0]
                                burst_n_bloom_requirements[3] = burst_n_bloom_requirements[2]
                                champion1_rp = champion1_rp + burst_n_bloom_requirements[1]
                                damage_done = math.ceil(DRUID.ap * self.calculate_champion_damage(1))
                                ability_data = ["Burst N Bloom", "enemy", "AOE", damage_done]
                            else:
                                return
                        if counter == 2:
                            if burst_n_bloom_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - burst_n_bloom_requirements[0]
                                burst_n_bloom_requirements[3] = burst_n_bloom_requirements[2]
                                champion2_rp = champion2_rp + burst_n_bloom_requirements[1]
                                damage_done = math.ceil(DRUID.ap * self.calculate_champion_damage(2))
                                ability_data = ["Burst N Bloom", "enemy", "AOE", damage_done]
                            else:
                                return
                        if counter == 3:
                            if burst_n_bloom_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - burst_n_bloom_requirements[0]
                                burst_n_bloom_requirements[3] = burst_n_bloom_requirements[2]
                                champion3_rp = champion3_rp + burst_n_bloom_requirements[1]
                                damage_done = math.ceil(DRUID.ap * self.calculate_champion_damage(3))
                                ability_data = ["Burst N Bloom", "enemy", "AOE", damage_done]
                            else:
                                return
                        if counter == 4:
                            if burst_n_bloom_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - burst_n_bloom_requirements[0]
                                burst_n_bloom_requirements[3] = burst_n_bloom_requirements[2]
                                champion4_rp = champion4_rp + burst_n_bloom_requirements[1]
                                damage_done = math.ceil(DRUID.ap * self.calculate_champion_damage(4))
                                ability_data = ["Burst N Bloom", "enemy", "AOE", damage_done]
                            else:
                                return
                        if counter == 5:
                            if burst_n_bloom_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - burst_n_bloom_requirements[0]
                                burst_n_bloom_requirements[3] = burst_n_bloom_requirements[2]
                                champion5_rp = champion5_rp + burst_n_bloom_requirements[1]
                                damage_done = math.ceil(DRUID.ap * self.calculate_champion_damage(5))
                                ability_data = ["Burst N Bloom", "enemy", "AOE", damage_done]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Wound Fissure":
            global wound_fissure_requirements
            if wound_fissure_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == WARLOCK.title:
                        if counter == 1:
                            if wound_fissure_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - wound_fissure_requirements[0]
                                wound_fissure_requirements[3] = wound_fissure_requirements[2]
                                champion1_rp = champion1_rp + wound_fissure_requirements[1]
                                ability_data = ["Wound Fissure", "enemy", "1T"]
                            else:
                                return
                        if counter == 2:
                            if wound_fissure_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - wound_fissure_requirements[0]
                                wound_fissure_requirements[3] = wound_fissure_requirements[2]
                                champion2_rp = champion2_rp + wound_fissure_requirements[1]
                                ability_data = ["Wound Fissure", "enemy", "1T"]
                            else:
                                return
                        if counter == 3:
                            if wound_fissure_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - wound_fissure_requirements[0]
                                wound_fissure_requirements[3] = wound_fissure_requirements[2]
                                champion3_rp = champion3_rp + wound_fissure_requirements[1]
                                ability_data = ["Wound Fissure", "enemy", "1T"]
                            else:
                                return
                        if counter == 4:
                            if wound_fissure_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - wound_fissure_requirements[0]
                                wound_fissure_requirements[3] = wound_fissure_requirements[2]
                                champion4_rp = champion4_rp + wound_fissure_requirements[1]
                                ability_data = ["Wound Fissure", "enemy", "1T"]
                            else:
                                return
                        if counter == 5:
                            if wound_fissure_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - wound_fissure_requirements[0]
                                wound_fissure_requirements[3] = wound_fissure_requirements[2]
                                champion5_rp = champion5_rp + wound_fissure_requirements[1]
                                ability_data = ["Wound Fissure", "enemy", "1T"]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Soul Tap":
            global soul_tap_requirements
            if soul_tap_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == WARLOCK.title:
                        if counter == 1:
                            if soul_tap_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - soul_tap_requirements[0]
                                soul_tap_requirements[3] = soul_tap_requirements[2]
                                champion1_rp = champion1_rp + soul_tap_requirements[1]
                                ability_data = ["Soul Tap", "self"]
                            else:
                                return
                        if counter == 2:
                            if soul_tap_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - soul_tap_requirements[0]
                                soul_tap_requirements[3] = soul_tap_requirements[2]
                                champion2_rp = champion2_rp + soul_tap_requirements[1]
                                ability_data = ["Soul Tap", "self"]
                            else:
                                return
                        if counter == 3:
                            if soul_tap_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - soul_tap_requirements[0]
                                soul_tap_requirements[3] = soul_tap_requirements[2]
                                champion3_rp = champion3_rp + soul_tap_requirements[1]
                                ability_data = ["Soul Tap", "self"]
                            else:
                                return
                        if counter == 4:
                            if soul_tap_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - soul_tap_requirements[0]
                                soul_tap_requirements[3] = soul_tap_requirements[2]
                                champion4_rp = champion4_rp + soul_tap_requirements[1]
                                ability_data = ["Soul Tap", "self"]
                            else:
                                return
                        if counter == 5:
                            if soul_tap_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - soul_tap_requirements[0]
                                soul_tap_requirements[3] = soul_tap_requirements[2]
                                champion5_rp = champion5_rp + soul_tap_requirements[1]
                                ability_data = ["Soul Tap", "self"]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Blood Boil":
            global blood_boil_requirements
            if blood_boil_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == BLOODMANCER.title:
                        if counter == 1:
                            if blood_boil_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - blood_boil_requirements[0]
                                blood_boil_requirements[3] = blood_boil_requirements[2]
                                champion1_rp = champion1_rp + blood_boil_requirements[1]
                                ability_data = ["Blood Boil", "self"]
                            else:
                                return
                        if counter == 2:
                            if blood_boil_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - blood_boil_requirements[0]
                                blood_boil_requirements[3] = blood_boil_requirements[2]
                                champion2_rp = champion2_rp + blood_boil_requirements[1]
                                ability_data = ["Blood Boil", "self"]
                            else:
                                return
                        if counter == 3:
                            if blood_boil_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - blood_boil_requirements[0]
                                blood_boil_requirements[3] = blood_boil_requirements[2]
                                champion3_rp = champion3_rp + blood_boil_requirements[1]
                                ability_data = ["Blood Boil", "self"]
                            else:
                                return
                        if counter == 4:
                            if blood_boil_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - blood_boil_requirements[0]
                                blood_boil_requirements[3] = blood_boil_requirements[2]
                                champion4_rp = champion4_rp + blood_boil_requirements[1]
                                ability_data = ["Blood Boil", "self"]
                            else:
                                return
                        if counter == 5:
                            if blood_boil_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - blood_boil_requirements[0]
                                blood_boil_requirements[3] = blood_boil_requirements[2]
                                champion5_rp = champion5_rp + blood_boil_requirements[1]
                                ability_data = ["Blood Boil", "self"]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Enharden Nerves":
            global enharden_nerves_requirements
            if enharden_nerves_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == BLOODMANCER.title:
                        if counter == 1:
                            if enharden_nerves_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - enharden_nerves_requirements[0]
                                enharden_nerves_requirements[3] = enharden_nerves_requirements[2]
                                champion1_rp = champion1_rp + enharden_nerves_requirements[1]
                                ability_data = ["Enharden Nerves", "self"]
                            else:
                                return
                        if counter == 2:
                            if enharden_nerves_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - enharden_nerves_requirements[0]
                                enharden_nerves_requirements[3] = enharden_nerves_requirements[2]
                                champion2_rp = champion2_rp + enharden_nerves_requirements[1]
                                ability_data = ["Enharden Nerves", "self"]
                            else:
                                return
                        if counter == 3:
                            if enharden_nerves_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - enharden_nerves_requirements[0]
                                enharden_nerves_requirements[3] = enharden_nerves_requirements[2]
                                champion3_rp = champion3_rp + enharden_nerves_requirements[1]
                                ability_data = ["Enharden Nerves", "self"]
                            else:
                                return
                        if counter == 4:
                            if enharden_nerves_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - enharden_nerves_requirements[0]
                                enharden_nerves_requirements[3] = enharden_nerves_requirements[2]
                                champion4_rp = champion4_rp + enharden_nerves_requirements[1]
                                ability_data = ["Enharden Nerves", "self"]
                            else:
                                return
                        if counter == 5:
                            if enharden_nerves_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - enharden_nerves_requirements[0]
                                enharden_nerves_requirements[3] = enharden_nerves_requirements[2]
                                champion5_rp = champion5_rp + enharden_nerves_requirements[1]
                                ability_data = ["Enharden Nerves", "self"]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Damnation":
            global damnation_requirements
            if damnation_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == PALADIN.title:
                        if counter == 1:
                            if damnation_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - damnation_requirements[0]
                                damnation_requirements[3] = damnation_requirements[2]
                                champion1_rp = champion1_rp + damnation_requirements[1]
                                damage_done = math.ceil(PALADIN.ap * self.calculate_champion_damage(1))
                                ability_data = ["Damnation", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 2:
                            if damnation_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - damnation_requirements[0]
                                damnation_requirements[3] = damnation_requirements[2]
                                champion2_rp = champion2_rp + damnation_requirements[1]
                                damage_done = math.ceil(PALADIN.ap * self.calculate_champion_damage(2))
                                ability_data = ["Damnation", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 3:
                            if damnation_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - damnation_requirements[0]
                                damnation_requirements[3] = damnation_requirements[2]
                                champion3_rp = champion3_rp + damnation_requirements[1]
                                damage_done = math.ceil(PALADIN.ap * self.calculate_champion_damage(3))
                                ability_data = ["Damnation", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 4:
                            if damnation_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - damnation_requirements[0]
                                damnation_requirements[3] = damnation_requirements[2]
                                champion4_rp = champion4_rp + damnation_requirements[1]
                                damage_done = math.ceil(PALADIN.ap * self.calculate_champion_damage(4))
                                ability_data = ["Damnation", "enemy", "1T", damage_done]
                            else:
                                return
                        if counter == 5:
                            if damnation_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - damnation_requirements[0]
                                damnation_requirements[3] = damnation_requirements[2]
                                champion5_rp = champion5_rp + damnation_requirements[1]
                                damage_done = math.ceil(PALADIN.ap * self.calculate_champion_damage(5))
                                ability_data = ["Damnation", "enemy", "1T", damage_done]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Energise":
            global energise_requirements
            if energise_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == MAGNETIMANCER.title:
                        if counter == 1:
                            if energise_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - energise_requirements[0]
                                energise_requirements[3] = energise_requirements[2]
                                champion1_rp = champion1_rp + energise_requirements[1]
                                ability_data = ["Energise", "enemy", "AOE"]
                            else:
                                return
                        if counter == 2:
                            if energise_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - energise_requirements[0]
                                energise_requirements[3] = energise_requirements[2]
                                champion2_rp = champion2_rp + energise_requirements[1]
                                ability_data = ["Energise", "enemy", "AOE"]
                            else:
                                return
                        if counter == 3:
                            if energise_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - energise_requirements[0]
                                energise_requirements[3] = energise_requirements[2]
                                champion3_rp = champion3_rp + energise_requirements[1]
                                ability_data = ["Energise", "enemy", "AOE"]
                            else:
                                return
                        if counter == 4:
                            if energise_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - energise_requirements[0]
                                energise_requirements[3] = energise_requirements[2]
                                champion4_rp = champion4_rp + energise_requirements[1]
                                ability_data = ["Energise", "enemy", "AOE"]
                            else:
                                return
                        if counter == 5:
                            if energise_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - energise_requirements[0]
                                energise_requirements[3] = energise_requirements[2]
                                champion5_rp = champion5_rp + energise_requirements[1]
                                ability_data = ["Energise", "enemy", "AOE"]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Superconductor":
            global superconductor_requirements
            if superconductor_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == MAGNETIMANCER.title:
                        if counter == 1:
                            if superconductor_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - superconductor_requirements[0]
                                superconductor_requirements[3] = superconductor_requirements[2]
                                champion1_rp = champion1_rp + superconductor_requirements[1]
                                ability_data = ["Superconductor", "enemy", "1T"]
                            else:
                                return
                        if counter == 2:
                            if superconductor_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - superconductor_requirements[0]
                                superconductor_requirements[3] = superconductor_requirements[2]
                                champion2_rp = champion2_rp + superconductor_requirements[1]
                                ability_data = ["Superconductor", "enemy", "1T"]
                            else:
                                return
                        if counter == 3:
                            if superconductor_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - superconductor_requirements[0]
                                superconductor_requirements[3] = superconductor_requirements[2]
                                champion3_rp = champion3_rp + superconductor_requirements[1]
                                ability_data = ["Superconductor", "enemy", "1T"]
                            else:
                                return
                        if counter == 4:
                            if superconductor_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - superconductor_requirements[0]
                                superconductor_requirements[3] = superconductor_requirements[2]
                                champion4_rp = champion4_rp + superconductor_requirements[1]
                                ability_data = ["Superconductor", "enemy", "1T"]
                            else:
                                return
                        if counter == 5:
                            if superconductor_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - superconductor_requirements[0]
                                superconductor_requirements[3] = superconductor_requirements[2]
                                champion5_rp = champion5_rp + superconductor_requirements[1]
                                ability_data = ["Superconductor", "enemy", "1T"]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Muscle Enlarger":
            global muscle_enlarger_requirements
            if muscle_enlarger_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == POWER_CONDUIT.title:
                        if counter == 1:
                            if muscle_enlarger_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - muscle_enlarger_requirements[0]
                                muscle_enlarger_requirements[3] = muscle_enlarger_requirements[2]
                                champion1_rp = champion1_rp + muscle_enlarger_requirements[1]
                                ability_data = ["Muscle Enlarger", "ally", "1T"]
                            else:
                                return
                        if counter == 2:
                            if muscle_enlarger_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - muscle_enlarger_requirements[0]
                                muscle_enlarger_requirements[3] = muscle_enlarger_requirements[2]
                                champion2_rp = champion2_rp + muscle_enlarger_requirements[1]
                                ability_data = ["Muscle Enlarger", "ally", "1T"]
                            else:
                                return
                        if counter == 3:
                            if muscle_enlarger_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - muscle_enlarger_requirements[0]
                                muscle_enlarger_requirements[3] = muscle_enlarger_requirements[2]
                                champion3_rp = champion3_rp + muscle_enlarger_requirements[1]
                                ability_data = ["Muscle Enlarger", "ally", "1T"]
                            else:
                                return
                        if counter == 4:
                            if muscle_enlarger_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - muscle_enlarger_requirements[0]
                                muscle_enlarger_requirements[3] = muscle_enlarger_requirements[2]
                                champion4_rp = champion4_rp + muscle_enlarger_requirements[1]
                                ability_data = ["Muscle Enlarger", "ally", "1T"]
                            else:
                                return
                        if counter == 5:
                            if muscle_enlarger_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - muscle_enlarger_requirements[0]
                                muscle_enlarger_requirements[3] = muscle_enlarger_requirements[2]
                                champion5_rp = champion5_rp + muscle_enlarger_requirements[1]
                                ability_data = ["Muscle Enlarger", "ally", "1T"]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Mistic Bloom":
            global mistic_bloom_requirements
            if mistic_bloom_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == POWER_CONDUIT.title:
                        if counter == 1:
                            if mistic_bloom_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - mistic_bloom_requirements[0]
                                mistic_bloom_requirements[3] = mistic_bloom_requirements[2]
                                champion1_rp = champion1_rp + mistic_bloom_requirements[1]
                                healing_done = math.ceil(500 * self.calculate_champion_damage(1))
                                healing_done = math.ceil(500 * self.calculate_champion_damage(1))
                                ability_data = ["Mistic Bloom", "ally", "1T", healing_done]
                            else:
                                return
                        if counter == 2:
                            if mistic_bloom_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - mistic_bloom_requirements[0]
                                mistic_bloom_requirements[3] = mistic_bloom_requirements[2]
                                champion2_rp = champion2_rp + mistic_bloom_requirements[1]
                                healing_done = math.ceil(500 * self.calculate_champion_damage(2))
                                healing_done = math.ceil(500 * self.calculate_champion_damage(2))
                                ability_data = ["Mistic Bloom", "ally", "1T", healing_done]
                            else:
                                return
                        if counter == 3:
                            if mistic_bloom_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - mistic_bloom_requirements[0]
                                mistic_bloom_requirements[3] = mistic_bloom_requirements[2]
                                champion3_rp = champion3_rp + mistic_bloom_requirements[1]
                                healing_done = math.ceil(500 * self.calculate_champion_damage(3))
                                healing_done = math.ceil(500 * self.calculate_champion_damage(3))
                                ability_data = ["Mistic Bloom", "ally", "1T", healing_done]
                            else:
                                return
                        if counter == 4:
                            if mistic_bloom_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - mistic_bloom_requirements[0]
                                mistic_bloom_requirements[3] = mistic_bloom_requirements[2]
                                champion4_rp = champion4_rp + mistic_bloom_requirements[1]
                                healing_done = math.ceil(500 * self.calculate_champion_damage(4))
                                healing_done = math.ceil(500 * self.calculate_champion_damage(4))
                                ability_data = ["Mistic Bloom", "ally", "1T", healing_done]
                            else:
                                return
                        if counter == 5:
                            if mistic_bloom_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - mistic_bloom_requirements[0]
                                mistic_bloom_requirements[3] = mistic_bloom_requirements[2]
                                champion5_rp = champion5_rp + mistic_bloom_requirements[1]
                                healing_done = math.ceil(500 * self.calculate_champion_damage(5))
                                healing_done = math.ceil(500 * self.calculate_champion_damage(5))
                                ability_data = ["Mistic Bloom", "ally", "1T", healing_done]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Power Surge":
            global power_surge_requirements
            if power_surge_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == POWER_CONDUIT.title:
                        if counter == 1:
                            if power_surge_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - power_surge_requirements[0]
                                power_surge_requirements[3] = power_surge_requirements[2]
                                champion1_rp = champion1_rp + power_surge_requirements[1]
                                damage_done = math.ceil(500 * self.calculate_champion_damage(1))
                                damage_done = math.ceil(500 * self.calculate_champion_damage(1))
                                ability_data = ["Power Surge", "enemy", "AOE", damage_done]
                            else:
                                return
                        if counter == 2:
                            if power_surge_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - power_surge_requirements[0]
                                power_surge_requirements[3] = power_surge_requirements[2]
                                champion2_rp = champion2_rp + power_surge_requirements[1]
                                damage_done = math.ceil(500 * self.calculate_champion_damage(2))
                                damage_done = math.ceil(500 * self.calculate_champion_damage(2))
                                ability_data = ["Power Surge", "enemy", "AOE", damage_done]
                            else:
                                return
                        if counter == 3:
                            if power_surge_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - power_surge_requirements[0]
                                power_surge_requirements[3] = power_surge_requirements[2]
                                champion3_rp = champion3_rp + power_surge_requirements[1]
                                damage_done = math.ceil(500 * self.calculate_champion_damage(3))
                                damage_done = math.ceil(500 * self.calculate_champion_damage(3))
                                ability_data = ["Power Surge", "enemy", "AOE", damage_done]
                            else:
                                return
                        if counter == 4:
                            if power_surge_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - power_surge_requirements[0]
                                power_surge_requirements[3] = power_surge_requirements[2]
                                champion4_rp = champion4_rp + power_surge_requirements[1]
                                damage_done = math.ceil(500 * self.calculate_champion_damage(4))
                                damage_done = math.ceil(500 * self.calculate_champion_damage(4))
                                ability_data = ["Power Surge", "enemy", "AOE", damage_done]
                            else:
                                return
                        if counter == 5:
                            if power_surge_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - power_surge_requirements[0]
                                power_surge_requirements[3] = power_surge_requirements[2]
                                champion5_rp = champion5_rp + power_surge_requirements[1]
                                damage_done = math.ceil(500 * self.calculate_champion_damage(5))
                                damage_done = math.ceil(500 * self.calculate_champion_damage(5))
                                ability_data = ["Power Surge", "enemy", "AOE", damage_done]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Full Potential":
            global full_potential_requirements
            if full_potential_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == POWER_CONDUIT.title:
                        if counter == 1:
                            if full_potential_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - full_potential_requirements[0]
                                full_potential_requirements[3] = full_potential_requirements[2]
                                champion1_rp = champion1_rp + full_potential_requirements[1]
                                ability_data = ["Full Potential", "ally", "1T"]
                            else:
                                return
                        if counter == 2:
                            if full_potential_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - full_potential_requirements[0]
                                full_potential_requirements[3] = full_potential_requirements[2]
                                champion2_rp = champion2_rp + full_potential_requirements[1]
                                ability_data = ["Full Potential", "ally", "1T"]
                            else:
                                return
                        if counter == 3:
                            if full_potential_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - full_potential_requirements[0]
                                full_potential_requirements[3] = full_potential_requirements[2]
                                champion3_rp = champion3_rp + full_potential_requirements[1]
                                ability_data = ["Full Potential", "ally", "1T"]
                            else:
                                return
                        if counter == 4:
                            if full_potential_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - full_potential_requirements[0]
                                full_potential_requirements[3] = full_potential_requirements[2]
                                champion4_rp = champion4_rp + full_potential_requirements[1]
                                ability_data = ["Full Potential", "ally", "1T"]
                            else:
                                return
                        if counter == 5:
                            if full_potential_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - full_potential_requirements[0]
                                full_potential_requirements[3] = full_potential_requirements[2]
                                champion5_rp = champion5_rp + full_potential_requirements[1]
                                ability_data = ["Full Potential", "ally", "1T"]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Spring Waters":
            global spring_waters_requirements
            if spring_waters_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == EARTH_SPEAKER.title:
                        if counter == 1:
                            if spring_waters_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - spring_waters_requirements[0]
                                spring_waters_requirements[3] = spring_waters_requirements[2]
                                champion1_rp = champion1_rp + spring_waters_requirements[1]
                                healing_done = math.ceil(300 * self.calculate_champion_damage(1))
                                healing_done = math.ceil(300 * self.calculate_champion_damage(1))
                                ability_data = ["Spring Waters", "ally", "2T", healing_done]
                            else:
                                return
                        if counter == 2:
                            if spring_waters_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - spring_waters_requirements[0]
                                spring_waters_requirements[3] = spring_waters_requirements[2]
                                champion2_rp = champion2_rp + spring_waters_requirements[1]
                                healing_done = math.ceil(300 * self.calculate_champion_damage(2))
                                healing_done = math.ceil(300 * self.calculate_champion_damage(2))
                                ability_data = ["Spring Waters", "ally", "2T", healing_done]
                            else:
                                return
                        if counter == 3:
                            if spring_waters_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - spring_waters_requirements[0]
                                spring_waters_requirements[3] = spring_waters_requirements[2]
                                champion3_rp = champion3_rp + spring_waters_requirements[1]
                                healing_done = math.ceil(300 * self.calculate_champion_damage(3))
                                healing_done = math.ceil(300 * self.calculate_champion_damage(3))
                                ability_data = ["Spring Waters", "ally", "2T", healing_done]
                            else:
                                return
                        if counter == 4:
                            if spring_waters_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - spring_waters_requirements[0]
                                spring_waters_requirements[3] = spring_waters_requirements[2]
                                champion4_rp = champion4_rp + spring_waters_requirements[1]
                                healing_done = math.ceil(300 * self.calculate_champion_damage(4))
                                healing_done = math.ceil(300 * self.calculate_champion_damage(4))
                                ability_data = ["Spring Waters", "ally", "2T", healing_done]
                            else:
                                return
                        if counter == 5:
                            if spring_waters_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - spring_waters_requirements[0]
                                spring_waters_requirements[3] = spring_waters_requirements[2]
                                champion5_rp = champion5_rp + spring_waters_requirements[1]
                                healing_done = math.ceil(300 * self.calculate_champion_damage(5))
                                healing_done = math.ceil(300 * self.calculate_champion_damage(5))
                                ability_data = ["Spring Waters", "ally", "2T", healing_done]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Ocean Tides":
            global ocean_tides_requirements
            if ocean_tides_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == EARTH_SPEAKER.title:
                        if counter == 1:
                            if ocean_tides_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - ocean_tides_requirements[0]
                                ocean_tides_requirements[3] = ocean_tides_requirements[2]
                                champion1_rp = champion1_rp + ocean_tides_requirements[1]
                                healing_done = math.ceil(300 * self.calculate_champion_damage(1))
                                healing_done = math.ceil(300 * self.calculate_champion_damage(1))
                                ability_data = ["Ocean Tides", "ally", "AOE", healing_done]
                            else:
                                return
                        if counter == 2:
                            if ocean_tides_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - ocean_tides_requirements[0]
                                ocean_tides_requirements[3] = ocean_tides_requirements[2]
                                champion2_rp = champion2_rp + ocean_tides_requirements[1]
                                healing_done = math.ceil(300 * self.calculate_champion_damage(2))
                                healing_done = math.ceil(300 * self.calculate_champion_damage(2))
                                ability_data = ["Ocean Tides", "ally", "AOE", healing_done]
                            else:
                                return
                        if counter == 3:
                            if ocean_tides_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - ocean_tides_requirements[0]
                                ocean_tides_requirements[3] = ocean_tides_requirements[2]
                                champion3_rp = champion3_rp + ocean_tides_requirements[1]
                                healing_done = math.ceil(300 * self.calculate_champion_damage(3))
                                healing_done = math.ceil(300 * self.calculate_champion_damage(3))
                                ability_data = ["Ocean Tides", "ally", "AOE", healing_done]
                            else:
                                return
                        if counter == 4:
                            if ocean_tides_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - ocean_tides_requirements[0]
                                ocean_tides_requirements[3] = ocean_tides_requirements[2]
                                champion4_rp = champion4_rp + ocean_tides_requirements[1]
                                healing_done = math.ceil(300 * self.calculate_champion_damage(4))
                                healing_done = math.ceil(300 * self.calculate_champion_damage(4))
                                ability_data = ["Ocean Tides", "ally", "AOE", healing_done]
                            else:
                                return
                        if counter == 5:
                            if ocean_tides_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - ocean_tides_requirements[0]
                                ocean_tides_requirements[3] = ocean_tides_requirements[2]
                                champion5_rp = champion5_rp + ocean_tides_requirements[1]
                                healing_done = math.ceil(300 * self.calculate_champion_damage(5))
                                healing_done = math.ceil(300 * self.calculate_champion_damage(5))
                                ability_data = ["Ocean Tides", "ally", "AOE", healing_done]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Boulder Cocoon":
            global boulder_cocoon_requirements
            if boulder_cocoon_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == EARTH_SPEAKER.title:
                        if counter == 1:
                            if boulder_cocoon_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - boulder_cocoon_requirements[0]
                                boulder_cocoon_requirements[3] = boulder_cocoon_requirements[2]
                                champion1_rp = champion1_rp + boulder_cocoon_requirements[1]
                                ability_data = ["Boulder Cocoon", "ally", "1T"]
                            else:
                                return
                        if counter == 2:
                            if boulder_cocoon_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - boulder_cocoon_requirements[0]
                                boulder_cocoon_requirements[3] = boulder_cocoon_requirements[2]
                                champion2_rp = champion2_rp + boulder_cocoon_requirements[1]
                                ability_data = ["Boulder Cocoon", "ally", "1T"]
                            else:
                                return
                        if counter == 3:
                            if boulder_cocoon_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - boulder_cocoon_requirements[0]
                                boulder_cocoon_requirements[3] = boulder_cocoon_requirements[2]
                                champion3_rp = champion3_rp + boulder_cocoon_requirements[1]
                                ability_data = ["Boulder Cocoon", "ally", "1T"]
                            else:
                                return
                        if counter == 4:
                            if boulder_cocoon_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - boulder_cocoon_requirements[0]
                                boulder_cocoon_requirements[3] = boulder_cocoon_requirements[2]
                                champion4_rp = champion4_rp + boulder_cocoon_requirements[1]
                                ability_data = ["Boulder Cocoon", "ally", "1T"]
                            else:
                                return
                        if counter == 5:
                            if boulder_cocoon_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - boulder_cocoon_requirements[0]
                                boulder_cocoon_requirements[3] = boulder_cocoon_requirements[2]
                                champion5_rp = champion5_rp + boulder_cocoon_requirements[1]
                                ability_data = ["Boulder Cocoon", "ally", "1T"]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Healing Light":
            global healing_light_requirements
            if healing_light_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == PRIEST.title:
                        if counter == 1:
                            if healing_light_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - healing_light_requirements[0]
                                healing_light_requirements[3] = healing_light_requirements[2]
                                champion1_rp = champion1_rp + healing_light_requirements[1]
                                healing_done = math.ceil(300 * self.calculate_champion_damage(1))
                                healing_done = math.ceil(300 * self.calculate_champion_damage(1))
                                ability_data = ["Healing Light", "ally", "2T", healing_done]
                            else:
                                return
                        if counter == 2:
                            if healing_light_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - healing_light_requirements[0]
                                healing_light_requirements[3] = healing_light_requirements[2]
                                champion2_rp = champion2_rp + healing_light_requirements[1]
                                healing_done = math.ceil(300 * self.calculate_champion_damage(2))
                                healing_done = math.ceil(300 * self.calculate_champion_damage(2))
                                ability_data = ["Healing Light", "ally", "2T", healing_done]
                            else:
                                return
                        if counter == 3:
                            if healing_light_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - healing_light_requirements[0]
                                healing_light_requirements[3] = healing_light_requirements[2]
                                champion3_rp = champion3_rp + healing_light_requirements[1]
                                healing_done = math.ceil(300 * self.calculate_champion_damage(3))
                                healing_done = math.ceil(300 * self.calculate_champion_damage(3))
                                ability_data = ["Healing Light", "ally", "2T", healing_done]
                            else:
                                return
                        if counter == 4:
                            if healing_light_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - healing_light_requirements[0]
                                healing_light_requirements[3] = healing_light_requirements[2]
                                champion4_rp = champion4_rp + healing_light_requirements[1]
                                healing_done = math.ceil(300 * self.calculate_champion_damage(4))
                                healing_done = math.ceil(300 * self.calculate_champion_damage(4))
                                ability_data = ["Healing Light", "ally", "2T", healing_done]
                            else:
                                return
                        if counter == 5:
                            if healing_light_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - healing_light_requirements[0]
                                healing_light_requirements[3] = healing_light_requirements[2]
                                champion5_rp = champion5_rp + healing_light_requirements[1]
                                healing_done = math.ceil(300 * self.calculate_champion_damage(5))
                                healing_done = math.ceil(300 * self.calculate_champion_damage(5))
                                ability_data = ["Healing Light", "ally", "2T", healing_done]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Diffracting Nova":
            global diffracting_nova_requirements
            if diffracting_nova_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == PRIEST.title:
                        if counter == 1:
                            if diffracting_nova_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - diffracting_nova_requirements[0]
                                diffracting_nova_requirements[3] = diffracting_nova_requirements[2]
                                champion1_rp = champion1_rp + diffracting_nova_requirements[1]
                                damage_done = math.ceil(300 * self.calculate_champion_damage(1))
                                damage_done = math.ceil(300 * self.calculate_champion_damage(1))
                                ability_data = ["Diffracting Nova", "enemy", "AOE", damage_done]
                            else:
                                return
                        if counter == 2:
                            if diffracting_nova_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - diffracting_nova_requirements[0]
                                diffracting_nova_requirements[3] = diffracting_nova_requirements[2]
                                champion2_rp = champion2_rp + diffracting_nova_requirements[1]
                                damage_done = math.ceil(300 * self.calculate_champion_damage(2))
                                damage_done = math.ceil(300 * self.calculate_champion_damage(2))
                                ability_data = ["Diffracting Nova", "enemy", "AOE", damage_done]
                            else:
                                return
                        if counter == 3:
                            if diffracting_nova_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - diffracting_nova_requirements[0]
                                diffracting_nova_requirements[3] = diffracting_nova_requirements[2]
                                champion3_rp = champion3_rp + diffracting_nova_requirements[1]
                                damage_done = math.ceil(300 * self.calculate_champion_damage(3))
                                damage_done = math.ceil(300 * self.calculate_champion_damage(3))
                                ability_data = ["Diffracting Nova", "enemy", "AOE", damage_done]
                            else:
                                return
                        if counter == 4:
                            if diffracting_nova_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - diffracting_nova_requirements[0]
                                diffracting_nova_requirements[3] = diffracting_nova_requirements[2]
                                champion4_rp = champion4_rp + diffracting_nova_requirements[1]
                                damage_done = math.ceil(300 * self.calculate_champion_damage(4))
                                damage_done = math.ceil(300 * self.calculate_champion_damage(4))
                                ability_data = ["Diffracting Nova", "enemy", "AOE", damage_done]
                            else:
                                return
                        if counter == 5:
                            if diffracting_nova_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - diffracting_nova_requirements[0]
                                diffracting_nova_requirements[3] = diffracting_nova_requirements[2]
                                champion5_rp = champion5_rp + diffracting_nova_requirements[1]
                                damage_done = math.ceil(300 * self.calculate_champion_damage(5))
                                damage_done = math.ceil(300 * self.calculate_champion_damage(5))
                                ability_data = ["Diffracting Nova", "enemy", "AOE", damage_done]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Overclock Nanobots":
            global overclock_nanobots_requirements
            if overclock_nanobots_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == TIME_WALKER.title:
                        if counter == 1:
                            if overclock_nanobots_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - overclock_nanobots_requirements[0]
                                overclock_nanobots_requirements[3] = overclock_nanobots_requirements[2]
                                champion1_rp = champion1_rp + overclock_nanobots_requirements[1]
                                healing_done = math.ceil(300 * self.calculate_champion_damage(1))
                                healing_done = math.ceil(300 * self.calculate_champion_damage(1))
                                ability_data = ["Overclock Nanobots", "ally", "AOE", healing_done]
                            else:
                                return
                        if counter == 2:
                            if overclock_nanobots_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - overclock_nanobots_requirements[0]
                                overclock_nanobots_requirements[3] = overclock_nanobots_requirements[2]
                                champion2_rp = champion2_rp + overclock_nanobots_requirements[1]
                                healing_done = math.ceil(300 * self.calculate_champion_damage(2))
                                healing_done = math.ceil(300 * self.calculate_champion_damage(2))
                                ability_data = ["Overclock Nanobots", "ally", "AOE", healing_done]
                            else:
                                return
                        if counter == 3:
                            if overclock_nanobots_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - overclock_nanobots_requirements[0]
                                overclock_nanobots_requirements[3] = overclock_nanobots_requirements[2]
                                champion3_rp = champion3_rp + overclock_nanobots_requirements[1]
                                healing_done = math.ceil(300 * self.calculate_champion_damage(3))
                                healing_done = math.ceil(300 * self.calculate_champion_damage(3))
                                ability_data = ["Overclock Nanobots", "ally", "AOE", healing_done]
                            else:
                                return
                        if counter == 4:
                            if overclock_nanobots_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - overclock_nanobots_requirements[0]
                                overclock_nanobots_requirements[3] = overclock_nanobots_requirements[2]
                                champion4_rp = champion4_rp + overclock_nanobots_requirements[1]
                                healing_done = math.ceil(300 * self.calculate_champion_damage(4))
                                healing_done = math.ceil(300 * self.calculate_champion_damage(4))
                                ability_data = ["Overclock Nanobots", "ally", "AOE", healing_done]
                            else:
                                return
                        if counter == 5:
                            if overclock_nanobots_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - overclock_nanobots_requirements[0]
                                overclock_nanobots_requirements[3] = overclock_nanobots_requirements[2]
                                champion5_rp = champion5_rp + overclock_nanobots_requirements[1]
                                healing_done = math.ceil(300 * self.calculate_champion_damage(5))
                                healing_done = math.ceil(300 * self.calculate_champion_damage(5))
                                ability_data = ["Overclock Nanobots", "ally", "AOE", healing_done]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Reverse Wounds":
            global reverse_wounds_requirements
            if reverse_wounds_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == TIME_WALKER.title:
                        if counter == 1:
                            if reverse_wounds_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - reverse_wounds_requirements[0]
                                reverse_wounds_requirements[3] = reverse_wounds_requirements[2]
                                champion1_rp = champion1_rp + reverse_wounds_requirements[1]
                                ability_data = ["Reverse Wounds", "ally", "1T"]
                            else:
                                return
                        if counter == 2:
                            if reverse_wounds_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - reverse_wounds_requirements[0]
                                reverse_wounds_requirements[3] = reverse_wounds_requirements[2]
                                champion2_rp = champion2_rp + reverse_wounds_requirements[1]
                                ability_data = ["Reverse Wounds", "ally", "1T"]
                            else:
                                return
                        if counter == 3:
                            if reverse_wounds_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - reverse_wounds_requirements[0]
                                reverse_wounds_requirements[3] = reverse_wounds_requirements[2]
                                champion3_rp = champion3_rp + reverse_wounds_requirements[1]
                                ability_data = ["Reverse Wounds", "ally", "1T"]
                            else:
                                return
                        if counter == 4:
                            if reverse_wounds_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - reverse_wounds_requirements[0]
                                reverse_wounds_requirements[3] = reverse_wounds_requirements[2]
                                champion4_rp = champion4_rp + reverse_wounds_requirements[1]
                                ability_data = ["Reverse Wounds", "ally", "1T"]
                            else:
                                return
                        if counter == 5:
                            if reverse_wounds_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - reverse_wounds_requirements[0]
                                reverse_wounds_requirements[3] = reverse_wounds_requirements[2]
                                champion5_rp = champion5_rp + reverse_wounds_requirements[1]
                                ability_data = ["Reverse Wounds", "ally", "1T"]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Alter Time":
            global alter_time_requirements
            if alter_time_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == TIME_WALKER.title:
                        if counter == 1:
                            if alter_time_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - alter_time_requirements[0]
                                alter_time_requirements[3] = alter_time_requirements[2]
                                champion1_rp = champion1_rp + alter_time_requirements[1]
                                ability_data = ["Alter Time", "ally", "AOE"]
                            else:
                                return
                        if counter == 2:
                            if alter_time_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - alter_time_requirements[0]
                                alter_time_requirements[3] = alter_time_requirements[2]
                                champion2_rp = champion2_rp + alter_time_requirements[1]
                                ability_data = ["Alter Time", "ally", "AOE"]
                            else:
                                return
                        if counter == 3:
                            if alter_time_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - alter_time_requirements[0]
                                alter_time_requirements[3] = alter_time_requirements[2]
                                champion3_rp = champion3_rp + alter_time_requirements[1]
                                ability_data = ["Alter Time", "ally", "AOE"]
                            else:
                                return
                        if counter == 4:
                            if alter_time_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - alter_time_requirements[0]
                                alter_time_requirements[3] = alter_time_requirements[2]
                                champion4_rp = champion4_rp + alter_time_requirements[1]
                                ability_data = ["Alter Time", "ally", "AOE"]
                            else:
                                return
                        if counter == 5:
                            if alter_time_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - alter_time_requirements[0]
                                alter_time_requirements[3] = alter_time_requirements[2]
                                champion5_rp = champion5_rp + alter_time_requirements[1]
                                ability_data = ["Alter Time", "ally", "AOE"]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Bandages":
            global bandages_requirements
            if bandages_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == FIELD_MEDIC.title:
                        if counter == 1:
                            if bandages_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - bandages_requirements[0]
                                bandages_requirements[3] = bandages_requirements[2]
                                champion1_rp = champion1_rp + bandages_requirements[1]
                                healing_done = math.ceil(FIELD_MEDIC.ap * self.calculate_champion_damage(1))
                                healing_done = math.ceil(FIELD_MEDIC.ap * self.calculate_champion_damage(1))
                                ability_data = ["Bandages", "ally", "1T", healing_done]
                            else:
                                return
                        if counter == 2:
                            if bandages_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - bandages_requirements[0]
                                bandages_requirements[3] = bandages_requirements[2]
                                champion2_rp = champion2_rp + bandages_requirements[1]
                                healing_done = math.ceil(FIELD_MEDIC.ap * self.calculate_champion_damage(2))
                                healing_done = math.ceil(FIELD_MEDIC.ap * self.calculate_champion_damage(2))
                                ability_data = ["Bandages", "ally", "1T", healing_done]
                            else:
                                return
                        if counter == 3:
                            if bandages_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - bandages_requirements[0]
                                bandages_requirements[3] = bandages_requirements[2]
                                champion3_rp = champion3_rp + bandages_requirements[1]
                                healing_done = math.ceil(FIELD_MEDIC.ap * self.calculate_champion_damage(3))
                                healing_done = math.ceil(FIELD_MEDIC.ap * self.calculate_champion_damage(3))
                                ability_data = ["Bandages", "ally", "1T", healing_done]
                            else:
                                return
                        if counter == 4:
                            if bandages_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - bandages_requirements[0]
                                bandages_requirements[3] = bandages_requirements[2]
                                champion4_rp = champion4_rp + bandages_requirements[1]
                                healing_done = math.ceil(FIELD_MEDIC.ap * self.calculate_champion_damage(4))
                                healing_done = math.ceil(FIELD_MEDIC.ap * self.calculate_champion_damage(4))
                                ability_data = ["Bandages", "ally", "1T", healing_done]
                            else:
                                return
                        if counter == 5:
                            if bandages_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - bandages_requirements[0]
                                bandages_requirements[3] = bandages_requirements[2]
                                champion5_rp = champion5_rp + bandages_requirements[1]
                                healing_done = math.ceil(FIELD_MEDIC.ap * self.calculate_champion_damage(5))
                                healing_done = math.ceil(FIELD_MEDIC.ap * self.calculate_champion_damage(5))
                                ability_data = ["Bandages", "ally", "1T", healing_done]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Tight Tourniquet":
            global tight_tourniquet_requirements
            if tight_tourniquet_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == FIELD_MEDIC.title:
                        if counter == 1:
                            if tight_tourniquet_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - tight_tourniquet_requirements[0]
                                tight_tourniquet_requirements[3] = tight_tourniquet_requirements[2]
                                champion1_rp = champion1_rp + tight_tourniquet_requirements[1]
                                healing_done = math.ceil(FIELD_MEDIC.ap * self.calculate_champion_damage(1))
                                healing_done = math.ceil(FIELD_MEDIC.ap * self.calculate_champion_damage(1))
                                ability_data = ["Tight Tourniquet", "ally", "1T", healing_done]
                            else:
                                return
                        if counter == 2:
                            if tight_tourniquet_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - tight_tourniquet_requirements[0]
                                tight_tourniquet_requirements[3] = tight_tourniquet_requirements[2]
                                champion2_rp = champion2_rp + tight_tourniquet_requirements[1]
                                healing_done = math.ceil(FIELD_MEDIC.ap * self.calculate_champion_damage(2))
                                healing_done = math.ceil(FIELD_MEDIC.ap * self.calculate_champion_damage(2))
                                ability_data = ["Tight Tourniquet", "ally", "1T", healing_done]
                            else:
                                return
                        if counter == 3:
                            if tight_tourniquet_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - tight_tourniquet_requirements[0]
                                tight_tourniquet_requirements[3] = tight_tourniquet_requirements[2]
                                champion3_rp = champion3_rp + tight_tourniquet_requirements[1]
                                healing_done = math.ceil(FIELD_MEDIC.ap * self.calculate_champion_damage(3))
                                healing_done = math.ceil(FIELD_MEDIC.ap * self.calculate_champion_damage(3))
                                ability_data = ["Tight Tourniquet", "ally", "1T", healing_done]
                            else:
                                return
                        if counter == 4:
                            if tight_tourniquet_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - tight_tourniquet_requirements[0]
                                tight_tourniquet_requirements[3] = tight_tourniquet_requirements[2]
                                champion4_rp = champion4_rp + tight_tourniquet_requirements[1]
                                healing_done = math.ceil(FIELD_MEDIC.ap * self.calculate_champion_damage(4))
                                healing_done = math.ceil(FIELD_MEDIC.ap * self.calculate_champion_damage(4))
                                ability_data = ["Tight Tourniquet", "ally", "1T", healing_done]
                            else:
                                return
                        if counter == 5:
                            if tight_tourniquet_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - tight_tourniquet_requirements[0]
                                tight_tourniquet_requirements[3] = tight_tourniquet_requirements[2]
                                champion5_rp = champion5_rp + tight_tourniquet_requirements[1]
                                healing_done = math.ceil(FIELD_MEDIC.ap * self.calculate_champion_damage(5))
                                healing_done = math.ceil(FIELD_MEDIC.ap * self.calculate_champion_damage(5))
                                ability_data = ["Tight Tourniquet", "ally", "1T", healing_done]
                            else:
                                return
                    counter += 1
            else:
                return
        elif ability_name == "Secret Remedy":
            global secret_remedy_requirements
            if secret_remedy_requirements[3] == 0:
                for character in CHAMPION_LIST:
                    if character == FIELD_MEDIC.title:
                        if counter == 1:
                            if secret_remedy_requirements[0] <= champion1_rp:
                                champion1_rp = champion1_rp - secret_remedy_requirements[0]
                                secret_remedy_requirements[3] = secret_remedy_requirements[2]
                                champion1_rp = champion1_rp + secret_remedy_requirements[1]
                                ability_data = ["Secret Remedy", "ally", "1T"]
                            else:
                                return
                        if counter == 2:
                            if secret_remedy_requirements[0] <= champion2_rp:
                                champion2_rp = champion2_rp - secret_remedy_requirements[0]
                                secret_remedy_requirements[3] = secret_remedy_requirements[2]
                                champion2_rp = champion2_rp + secret_remedy_requirements[1]
                                ability_data = ["Secret Remedy", "ally", "1T"]
                            else:
                                return
                        if counter == 3:
                            if secret_remedy_requirements[0] <= champion3_rp:
                                champion3_rp = champion3_rp - secret_remedy_requirements[0]
                                secret_remedy_requirements[3] = secret_remedy_requirements[2]
                                champion3_rp = champion3_rp + secret_remedy_requirements[1]
                                ability_data = ["Secret Remedy", "ally", "1T"]
                            else:
                                return
                        if counter == 4:
                            if secret_remedy_requirements[0] <= champion4_rp:
                                champion4_rp = champion4_rp - secret_remedy_requirements[0]
                                secret_remedy_requirements[3] = secret_remedy_requirements[2]
                                champion4_rp = champion4_rp + secret_remedy_requirements[1]
                                ability_data = ["Secret Remedy", "ally", "1T"]
                            else:
                                return
                        if counter == 5:
                            if secret_remedy_requirements[0] <= champion5_rp:
                                champion5_rp = champion5_rp - secret_remedy_requirements[0]
                                secret_remedy_requirements[3] = secret_remedy_requirements[2]
                                champion5_rp = champion5_rp + secret_remedy_requirements[1]
                                ability_data = ["Secret Remedy", "ally", "1T"]
                            else:
                                return
                    counter += 1
            else:
                return
        self.player_targeting_AI()
#Pop-up window that checks the parameter champion name and displays their passives name and what it does
    def passive_details_window(self, champion_name):
        root = tk.Tk()
        if champion_name == "Monk": 
            passive_name = MONK.passive
            passive_details = "The Monk wields three damage baubles that slows down the rate of damage taken\nWhenver he takes damage, if there is an available bauble, the damage is absorbed by the bauble and is split into three charges\nEach charge contains one third of the damage absorbed, meaning that all three charges contain in total the full hit\nAt the beginning of each turn, each bauble releases one charge dealing one charges worth of damage to the monk\nBaubles that still have charges cannot absorb more attacks, if all baubles have charges, the monk takes full damage"
        elif champion_name == "Barbarian": 
            passive_name = BARBARIAN.passive
            passive_details = "The Barbarian deals an additionl 20% damage for each enemy attacking him"
        elif champion_name == "Kings-Guard": 
            passive_name = KINGS_GUARD.passive
            passive_details = "15% of all damage taken by other allies is instead taken by the Kings-Guard"
        elif champion_name == "Fencer": 
            passive_name = MASTER_FENCER.passive
            passive_details = "You have a 30% chance to reduce the damage of attacks dependng on the enemies size class\nIf the damage is successfully reduced, the enemy is taunted for one turn\nAmount of damage reduced (Tiny > 50%, Small > 40%, Medium > 30%, Large > 20%, Huge > 15%)"
        elif champion_name == "Berserker": 
            passive_name = BERSERKER.passive
            passive_details = "The Berserker deals more damage depending on the amount of enemies in combat, dealing more the less there are\n_________________________________________________________________________________________________________\n(5 Enemies > 100%)  (4 Enemies > 110%)  (3 Enemies > 120)  (2 Enemies > 135%)  (1 Enemy > 150%)"
        elif champion_name == "Rogue": 
            passive_name = ROGUE.passive
            passive_details = "The Rogues bleed damage is increased by 10% with each unquie bleed applied to the target\nBleeds that are applied by other champions also count towards this passive"
        elif champion_name == "Survivalist": 
            passive_name = SURVIVALIST.passive
            passive_details = "After using a special, the Survivalist will gain 'Prepared'\n_______________________________________________________\nPrepared: Your next attack deals 50% extra damage"
        elif champion_name == "Brawlist": 
            passive_name = BRAWLIST.passive
            passive_details = "When the Brawlist attacks an enemy, the enemy takes extra damage from his next attack other than the one that left the debuff"
        elif champion_name == "Academics Mage": 
            passive_name = ACADEMIC_MAGE.passive
            passive_details = "When the Mage casts a spell, every ally that uses Mana as a resource gains 20"
        elif champion_name == "Druid": 
            passive_name = DRUID.passive
            passive_details = "Enemies take 2% extra damage from all sources for each thorn embedded into them"
        elif champion_name == "Warlock": 
            passive_name = WARLOCK.passive
            passive_details = "Whenever an enemy takes damage from the Warlock, they receive one stack of 'Touch of Corruption', up to 10 maximum\n_______________________________________________________________________\nTouch of Corruption: All damage dealt is reduced by 1% per stack"
        elif champion_name == "Bloodmancer": 
            passive_name = BLOODMANCER.passive
            passive_details = "Whenever the Bloodmancer casts an empowered ability, the next ability an ally uses that heals or deals damage is amplified by 50%"
        elif champion_name == "Paladin": 
            passive_name = PALADIN.passive
            passive_details = "Every two turns, the Paladin can choose to give all their allies either Power Aura or Protection Aura\n__________________________________________________________________________________________________________\n(Power Aura: Damage dealt is increased by 20%) (Protection Aura: Damage taken is reduced by 10%)"
        elif champion_name == "Ranger": 
            passive_name = LEGION_RANGER.passive
            passive_details = "Every three turns, the Ranger is given a choice of three random arrow tips that enhances their attacks\n"
        elif champion_name == "Magnetimancer": 
            passive_name = MAGNETIMANCER.passive
            passive_details = "All attacks apply charges to enemies hit that have a polarity of either Positive or Negative\nWhen an enemy is charged with both polarities, the charges explode dealing damage to the them and lower damage to all other enemies\nAn enemy can only have two of the same charge"
        elif champion_name == "Power Conduit": 
            passive_name = POWER_CONDUIT.passive
            passive_details = "Whenever the Power Conduit is damaged by an enemy it's core reacts violently, releasing volitile energy dealing damage back to their attacker."
        elif champion_name == "Earth Speaker": 
            passive_name = EARTH_SPEAKER.passive
            passive_details = "Whenever an ally has a healing overtime effect on them, they are also encased with Toughened Mud\nReducing damage they take by 15%, the mud is removed when the healing effect disappears"
        elif champion_name == "Priest": 
            passive_name = PRIEST.passive
            passive_details = "Special abilities the Priest casts give 'Blessed' to allies, making all damage the Priest deals also heal allies with this buff"
        elif champion_name == "Time Walker": 
            passive_name = TIME_WALKER.passive
            passive_details = "The Time Walker has implanted Nano Repair Bots inside all his allies\nHealing them by 5% of their max health points at the start of each turn"
        elif champion_name == "Field Medic": 
            passive_name = FIELD_MEDIC.passive
            passive_details = "The Field Medic's special abilties are extremely resourceful\nWhen the original effect of a special is over, a weaker version will linger for double the duration"
        passive_title_label = tk.Label(root, text=passive_name)
        passive_title_label.grid(row=0, column=1)
        passive_details_label = tk.Label(root, text=passive_details)
        passive_details_label.grid(row=1, column=1)
        close_button = tk.Button(root, text="Close Window", command=root.destroy)
        close_button.grid(row=2, column=1)
#Lets the user choose targets for their abilities depending on the target type (ability_data[1])
    def player_targeting_AI(self):
        global attack_to_target, special_to_target, ai1_attacktarget_frame, ai2_attacktarget_frame, ai3_attacktarget_frame, \
            ai4_attacktarget_frame, ai5_attacktarget_frame, champion1_supporttarget_frame, champion2_supporttarget_frame, \
            champion3_supporttarget_frame, champion4_supporttarget_frame, champion5_supporttarget_frame, target_to_attack, target_to_special, target_back_button
        if attack_to_target == 1:
            attack1_button.destroy()
            attack1_button_details.destroy()
            attack2_button.destroy()
            attack2_button_details.destroy()
            attack3_button.destroy()
            attack3_button_details.destroy()
            attack4_button.destroy()
            attack4_button_details.destroy()
            back_button.destroy()
            attack_to_target = 0
            target_to_attack = 1
        if special_to_target == 1:
            special1_button.destroy()
            special1_button_details.destroy()
            special2_button.destroy()
            special2_button_details.destroy()
            special3_button.destroy()
            special3_button_details.destroy()
            special4_button.destroy()
            special4_button_details.destroy()
            back_button.destroy()
            special_to_target = 0
            target_to_special = 1
        if ability_data[1] == "enemy":
            if ability_data[2] == "AOE":
                target_list = []
                self.complete_turn(target_list)
            else:
                if AI_SPAWNED == 1:
                    ai1_attacktarget_frame = tk.Button(dungeon_game_frame, text=self.target_frame_ai_champion_text("ai", 1),
                                                       command=lambda: self.multi_target_check(1))
                    ai1_attacktarget_frame.grid(row=19, column=2)
                    target_back_button = tk.Button(dungeon_game_frame, text="Back", command= self.attack_button)
                    target_back_button.grid(row=20, column=2)
                elif AI_SPAWNED == 2:
                    ai1_attacktarget_frame = tk.Button(dungeon_game_frame, text=self.target_frame_ai_champion_text("ai", 1),
                                                       command=lambda: self.multi_target_check(1))
                    ai1_attacktarget_frame.grid(row=19, column=2, sticky="w")
                    ai2_attacktarget_frame = tk.Button(dungeon_game_frame, text=self.target_frame_ai_champion_text("ai", 2),
                                                       command=lambda: self.multi_target_check(2))
                    ai2_attacktarget_frame.grid(row=19, column=2, sticky="e")
                    if ai1_hp == 0:
                        ai1_attacktarget_frame["state"] = 'disable'
                    if ai2_hp == 0:
                        ai2_attacktarget_frame["state"] = 'disable'
                    target_back_button = tk.Button(dungeon_game_frame, text="Back", command= self.attack_button)
                    target_back_button.grid(row=20, column=2)
                elif AI_SPAWNED == 3:
                    ai1_attacktarget_frame = tk.Button(dungeon_game_frame, text=self.target_frame_ai_champion_text("ai", 1),
                                                       command=lambda: self.multi_target_check(1))
                    ai1_attacktarget_frame.grid(row=19, column=1)
                    ai2_attacktarget_frame = tk.Button(dungeon_game_frame, text=self.target_frame_ai_champion_text("ai", 2),
                                                       command=lambda: self.multi_target_check(2))
                    ai2_attacktarget_frame.grid(row=19, column=2)
                    ai3_attacktarget_frame = tk.Button(dungeon_game_frame, text=self.target_frame_ai_champion_text("ai", 3),
                                                       command=lambda: self.multi_target_check(3))
                    ai3_attacktarget_frame.grid(row=19, column=3)
                    if ai1_hp == 0:
                        ai1_attacktarget_frame["state"] = 'disable'
                    if ai2_hp == 0:
                        ai2_attacktarget_frame["state"] = 'disable'
                    if ai3_hp == 0:
                        ai3_attacktarget_frame["state"] = 'disable'
                    target_back_button = tk.Button(dungeon_game_frame, text="Back", command= self.attack_button)
                    target_back_button.grid(row=20, column=2)
                elif AI_SPAWNED == 4:
                    ai1_attacktarget_frame = tk.Button(dungeon_game_frame, text=self.target_frame_ai_champion_text("ai", 1),
                                                       command=lambda: self.multi_target_check(1))
                    ai1_attacktarget_frame.grid(row=19, column=1, sticky="e")
                    ai2_attacktarget_frame = tk.Button(dungeon_game_frame, text=self.target_frame_ai_champion_text("ai", 2),
                                                       command=lambda: self.multi_target_check(2))
                    ai2_attacktarget_frame.grid(row=19, column=3, sticky="w")
                    ai3_attacktarget_frame = tk.Button(dungeon_game_frame, text=self.target_frame_ai_champion_text("ai", 3),
                                                       command=lambda: self.multi_target_check(3))
                    ai3_attacktarget_frame.grid(row=20, column=1, sticky="e")
                    ai4_attacktarget_frame = tk.Button(dungeon_game_frame, text=self.target_frame_ai_champion_text("ai", 4),
                                                       command=lambda: self.multi_target_check(4))
                    ai4_attacktarget_frame.grid(row=20, column=3, sticky="w")
                    if ai1_hp == 0:
                        ai1_attacktarget_frame["state"] = 'disable'
                    if ai2_hp == 0:
                        ai2_attacktarget_frame["state"] = 'disable'
                    if ai3_hp == 0:
                        ai3_attacktarget_frame["state"] = 'disable'
                    if ai4_hp == 0:
                        ai4_attacktarget_frame["state"] = 'disable'
                    target_back_button = tk.Button(dungeon_game_frame, text="Back", command= self.attack_button)
                    target_back_button.grid(row=20, column=2)
                elif AI_SPAWNED == 5:
                    ai1_attacktarget_frame = tk.Button(dungeon_game_frame, text=self.target_frame_ai_champion_text("ai", 1),
                                                       command=lambda: self.multi_target_check(1))
                    ai1_attacktarget_frame.grid(row=19, column=1)
                    ai2_attacktarget_frame = tk.Button(dungeon_game_frame, text=self.target_frame_ai_champion_text("ai", 2),
                                                       command=lambda: self.multi_target_check(2))
                    ai2_attacktarget_frame.grid(row=19, column=1, sticky="e")
                    ai3_attacktarget_frame = tk.Button(dungeon_game_frame, text=self.target_frame_ai_champion_text("ai", 3),
                                                       command=lambda: self.multi_target_check(3))
                    ai3_attacktarget_frame.grid(row=19, column=2)
                    ai4_attacktarget_frame = tk.Button(dungeon_game_frame, text=self.target_frame_ai_champion_text("ai", 4),
                                                       command=lambda: self.multi_target_check(4))
                    ai4_attacktarget_frame.grid(row=19, column=3, sticky="w")
                    ai5_attacktarget_frame = tk.Button(dungeon_game_frame, text=self.target_frame_ai_champion_text("ai", 5),
                                                       command=lambda: self.multi_target_check(5))
                    ai5_attacktarget_frame.grid(row=19, column=3)
                    if ai1_hp == 0:
                        ai1_attacktarget_frame["state"] = 'disable'
                    if ai2_hp == 0:
                        ai2_attacktarget_frame["state"] = 'disable'
                    if ai3_hp == 0:
                        ai3_attacktarget_frame["state"] = 'disable'
                    if ai4_hp == 0:
                        ai4_attacktarget_frame["state"] = 'disable'
                    if ai5_hp == 0:
                        ai5_attacktarget_frame["state"] = 'disable'
                    target_back_button = tk.Button(dungeon_game_frame, text="Back", command= self.attack_button)
                    target_back_button.grid(row=20, column=2)
        if ability_data[1] == "ally":
            if ability_data[2] == "AOE":
                target_list = []
                self.complete_turn(target_list)
            else:
                champion1_supporttarget_frame = tk.Button(dungeon_game_frame,
                                                          text=self.target_frame_ai_champion_text("champion", 1), command=lambda: self.multi_target_check(1))
                champion1_supporttarget_frame.grid(row=19, column=1, sticky="e")
                champion2_supporttarget_frame = tk.Button(dungeon_game_frame,
                                                          text=self.target_frame_ai_champion_text("champion", 2), command=lambda: self.multi_target_check(2))
                champion2_supporttarget_frame.grid(row=19, column=2, sticky="w")
                champion3_supporttarget_frame = tk.Button(dungeon_game_frame,
                                                          text=self.target_frame_ai_champion_text("champion", 3), command=lambda: self.multi_target_check(3))
                champion3_supporttarget_frame.grid(row=19, column=2)
                champion4_supporttarget_frame = tk.Button(dungeon_game_frame,
                                                          text=self.target_frame_ai_champion_text("champion", 4), command=lambda: self.multi_target_check(4))
                champion4_supporttarget_frame.grid(row=19, column=2, sticky="e")
                champion5_supporttarget_frame = tk.Button(dungeon_game_frame,
                                                          text=self.target_frame_ai_champion_text("champion", 5), command=lambda: self.multi_target_check(5))
                champion5_supporttarget_frame.grid(row=19, column=3, sticky="w")
                if champion1_hp == 0:
                    champion1_supporttarget_frame["state"] = 'disable'
                if champion2_hp == 0:
                    champion2_supporttarget_frame["state"] = 'disable'
                if champion3_hp == 0:
                    champion3_supporttarget_frame["state"] = 'disable'
                if champion4_hp == 0:
                    champion4_supporttarget_frame["state"] = 'disable'
                if champion5_hp == 0:
                    champion5_supporttarget_frame["state"] = 'disable'
                target_back_button = tk.Button(dungeon_game_frame, text="Back", command= self.attack_button)
                target_back_button.grid(row=20, column=2)
        if ability_data[1] == "self":
            target_list = []
            self.complete_turn(target_list)
#Checks the abilities target amount to see if the user needs to target more than one individual.
#If not (1T), then the ability resolves instantly and the functions that happen due to it occur
#Otherwise (2T or 3T), then the user is given another choice to choose from
#The target chosen first and dead targets are disabled meaning they cannot be chosen
#If the ability does need more than one target and there are no more available targets, then the program moves forwards without the need for a 2nd target
    def multi_target_check(self, target):
        global ai1_attacktarget_frame, ai2_attacktarget_frame, ai3_attacktarget_frame, \
        ai4_attacktarget_frame, ai5_attacktarget_frame
        target_list = []
        target_list.append(target)
        if ability_data[2] == "1T":
            self.complete_turn(target_list)
        else:
            self.clean_up()
            if ability_data[1] == "enemy":
                if ability_data[2] == "2T":
                    if AI_SPAWNED == 1:
                        self.complete_turn(target_list)
                    elif AI_SPAWNED == 2:
                        disabled_frame_counter = 0
                        ai1_attacktarget_frame = tk.Button(dungeon_game_frame, text=self.target_frame_ai_champion_text("ai", 1),
                                                        command=lambda: self.add_additonal_targets(1, target_list))
                        ai1_attacktarget_frame.grid(row=19, column=2, sticky="w")
                        ai2_attacktarget_frame = tk.Button(dungeon_game_frame, text=self.target_frame_ai_champion_text("ai", 2),
                                                        command=lambda: self.add_additonal_targets(2, target_list))
                        ai2_attacktarget_frame.grid(row=19, column=2, sticky="e")
                        if ai1_hp == 0:
                            ai1_attacktarget_frame["state"] = 'disable'
                            disabled_frame_counter = disabled_frame_counter + 1
                        elif 1 in target_list:
                            ai1_attacktarget_frame["state"] = 'disable'
                            disabled_frame_counter = disabled_frame_counter + 1
                        if ai2_hp == 0:
                            ai2_attacktarget_frame["state"] = 'disable'
                            disabled_frame_counter = disabled_frame_counter + 1
                        elif 2 in target_list:
                            ai2_attacktarget_frame["state"] = 'disable'
                            disabled_frame_counter = disabled_frame_counter + 1
                        if disabled_frame_counter == AI_SPAWNED:
                            self.complete_turn(target_list)
                    elif AI_SPAWNED == 3:
                        disabled_frame_counter = 0
                        ai1_attacktarget_frame = tk.Button(dungeon_game_frame, text=self.target_frame_ai_champion_text("ai", 1),
                                                        command=lambda: self.add_additonal_targets(1, target_list))
                        ai1_attacktarget_frame.grid(row=19, column=1)
                        ai2_attacktarget_frame = tk.Button(dungeon_game_frame, text=self.target_frame_ai_champion_text("ai", 2),
                                                        command=lambda: self.add_additonal_targets(2, target_list))
                        ai2_attacktarget_frame.grid(row=19, column=2)
                        ai3_attacktarget_frame = tk.Button(dungeon_game_frame, text=self.target_frame_ai_champion_text("ai", 3),
                                                        command=lambda: self.add_additonal_targets(3, target_list))
                        ai3_attacktarget_frame.grid(row=19, column=3)
                        if ai1_hp == 0:
                            ai1_attacktarget_frame["state"] = 'disable'
                            disabled_frame_counter = disabled_frame_counter + 1
                        elif 1 in target_list:
                            ai1_attacktarget_frame["state"] = 'disable'
                            disabled_frame_counter = disabled_frame_counter + 1
                        if ai2_hp == 0:
                            ai2_attacktarget_frame["state"] = 'disable'
                            disabled_frame_counter = disabled_frame_counter + 1
                        elif 2 in target_list:
                            ai2_attacktarget_frame["state"] = 'disable'
                            disabled_frame_counter = disabled_frame_counter + 1
                        if ai3_hp == 0:
                            ai3_attacktarget_frame["state"] = 'disable'
                            disabled_frame_counter = disabled_frame_counter + 1
                        elif 3 in target_list:
                            ai3_attacktarget_frame["state"] = 'disable'
                            disabled_frame_counter = disabled_frame_counter + 1
                        if disabled_frame_counter == AI_SPAWNED:
                            self.complete_turn(target_list)
                    elif AI_SPAWNED == 4:
                        disabled_frame_counter = 0
                        ai1_attacktarget_frame = tk.Button(dungeon_game_frame, text=self.target_frame_ai_champion_text("ai", 1),
                                                        command=lambda: self.add_additonal_targets(1, target_list))
                        ai1_attacktarget_frame.grid(row=19, column=1, sticky="e")
                        ai2_attacktarget_frame = tk.Button(dungeon_game_frame, text=self.target_frame_ai_champion_text("ai", 2),
                                                        command=lambda: self.add_additonal_targets(2, target_list))
                        ai2_attacktarget_frame.grid(row=19, column=3, sticky="w")
                        ai3_attacktarget_frame = tk.Button(dungeon_game_frame, text=self.target_frame_ai_champion_text("ai", 3),
                                                        command=lambda: self.add_additonal_targets(3, target_list))
                        ai3_attacktarget_frame.grid(row=20, column=1, sticky="e")
                        ai4_attacktarget_frame = tk.Button(dungeon_game_frame, text=self.target_frame_ai_champion_text("ai", 4),
                                                        command=lambda: self.add_additonal_targets(4, target_list))
                        ai4_attacktarget_frame.grid(row=20, column=3, sticky="w")
                        if ai1_hp == 0:
                            ai1_attacktarget_frame["state"] = 'disable'
                            disabled_frame_counter = disabled_frame_counter + 1
                        elif 1 in target_list:
                            ai1_attacktarget_frame["state"] = 'disable'
                            disabled_frame_counter = disabled_frame_counter + 1
                        if ai2_hp == 0:
                            ai2_attacktarget_frame["state"] = 'disable'
                            disabled_frame_counter = disabled_frame_counter + 1
                        elif 2 in target_list:
                            ai2_attacktarget_frame["state"] = 'disable'
                            disabled_frame_counter = disabled_frame_counter + 1
                        if ai3_hp == 0:
                            ai3_attacktarget_frame["state"] = 'disable'
                            disabled_frame_counter = disabled_frame_counter + 1
                        elif 3 in target_list:
                            ai3_attacktarget_frame["state"] = 'disable'
                            disabled_frame_counter = disabled_frame_counter + 1
                        if ai4_hp == 0:
                            ai4_attacktarget_frame["state"] = 'disable'
                            disabled_frame_counter = disabled_frame_counter + 1
                        elif 4 in target_list:
                            ai4_attacktarget_frame["state"] = 'disable'
                            disabled_frame_counter = disabled_frame_counter + 1
                        if disabled_frame_counter == AI_SPAWNED:
                            self.complete_turn(target_list)
                    elif AI_SPAWNED == 5:
                        disabled_frame_counter = 0
                        ai1_attacktarget_frame = tk.Button(dungeon_game_frame, text=self.target_frame_ai_champion_text("ai", 1),
                                                        command=lambda: self.add_additonal_targets(1, target_list))
                        ai1_attacktarget_frame.grid(row=19, column=1)
                        ai2_attacktarget_frame = tk.Button(dungeon_game_frame, text=self.target_frame_ai_champion_text("ai", 2),
                                                        command=lambda: self.add_additonal_targets(2, target_list))
                        ai2_attacktarget_frame.grid(row=19, column=1, sticky="e")
                        ai3_attacktarget_frame = tk.Button(dungeon_game_frame, text=self.target_frame_ai_champion_text("ai", 3),
                                                        command=lambda: self.add_additonal_targets(3, target_list))
                        ai3_attacktarget_frame.grid(row=19, column=2)
                        ai4_attacktarget_frame = tk.Button(dungeon_game_frame, text=self.target_frame_ai_champion_text("ai", 4),
                                                        command=lambda: self.add_additonal_targets(4, target_list))
                        ai4_attacktarget_frame.grid(row=19, column=3, sticky="w")
                        ai5_attacktarget_frame = tk.Button(dungeon_game_frame, text=self.target_frame_ai_champion_text("ai", 5),
                                                        command=lambda: self.add_additonal_targets(5, target_list))
                        ai5_attacktarget_frame.grid(row=19, column=3)
                        if ai1_hp == 0:
                            ai1_attacktarget_frame["state"] = 'disable'
                            disabled_frame_counter = disabled_frame_counter + 1
                        elif 1 in target_list:
                            ai1_attacktarget_frame["state"] = 'disable'
                            disabled_frame_counter = disabled_frame_counter + 1
                        if ai2_hp == 0:
                            ai2_attacktarget_frame["state"] = 'disable'
                            disabled_frame_counter = disabled_frame_counter + 1
                        elif 2 in target_list:
                            ai2_attacktarget_frame["state"] = 'disable'
                            disabled_frame_counter = disabled_frame_counter + 1
                        if ai3_hp == 0:
                            ai3_attacktarget_frame["state"] = 'disable'
                            disabled_frame_counter = disabled_frame_counter + 1
                        elif 3 in target_list:
                            ai3_attacktarget_frame["state"] = 'disable'
                            disabled_frame_counter = disabled_frame_counter + 1
                        if ai4_hp == 0:
                            ai4_attacktarget_frame["state"] = 'disable'
                            disabled_frame_counter = disabled_frame_counter + 1
                        elif 4 in target_list:
                            ai4_attacktarget_frame["state"] = 'disable'
                            disabled_frame_counter = disabled_frame_counter + 1
                        if ai5_hp == 0:
                            ai5_attacktarget_frame["state"] = 'disable'
                            disabled_frame_counter = disabled_frame_counter + 1
                        elif 5 in target_list:
                            ai5_attacktarget_frame["state"] = 'disable'
                            disabled_frame_counter = disabled_frame_counter + 1
                        if disabled_frame_counter == AI_SPAWNED:
                            self.complete_turn(target_list)
                elif ability_data[2] == "3T":
                    if AI_SPAWNED == 1:
                        self.complete_turn(target_list)
                    elif AI_SPAWNED == 2:
                        disabled_frame_counter = 0
                        ai1_attacktarget_frame = tk.Button(dungeon_game_frame, text=self.target_frame_ai_champion_text("ai", 1),
                                                        command=lambda: self.add_additonal_targets(1, target_list))
                        ai1_attacktarget_frame.grid(row=19, column=2, sticky="w")
                        ai2_attacktarget_frame = tk.Button(dungeon_game_frame, text=self.target_frame_ai_champion_text("ai", 2),
                                                        command=lambda: self.add_additonal_targets(2, target_list))
                        ai2_attacktarget_frame.grid(row=19, column=2, sticky="e")
                        if ai1_hp == 0:
                            ai1_attacktarget_frame["state"] = 'disable'
                            disabled_frame_counter = disabled_frame_counter + 1
                        elif 1 in target_list:
                            ai1_attacktarget_frame["state"] = 'disable'
                            disabled_frame_counter = disabled_frame_counter + 1
                        if ai2_hp == 0:
                            ai2_attacktarget_frame["state"] = 'disable'
                            disabled_frame_counter = disabled_frame_counter + 1
                        elif 2 in target_list:
                            ai2_attacktarget_frame["state"] = 'disable'
                            disabled_frame_counter = disabled_frame_counter + 1
                        if disabled_frame_counter == AI_SPAWNED:
                            self.complete_turn(target_list)
                    elif AI_SPAWNED == 3:
                        disabled_frame_counter = 0
                        ai1_attacktarget_frame = tk.Button(dungeon_game_frame, text=self.target_frame_ai_champion_text("ai", 1),
                                                        command=lambda: self.add_additonal_targets(1, target_list))
                        ai1_attacktarget_frame.grid(row=19, column=1)
                        ai2_attacktarget_frame = tk.Button(dungeon_game_frame, text=self.target_frame_ai_champion_text("ai", 2),
                                                        command=lambda: self.add_additonal_targets(2, target_list))
                        ai2_attacktarget_frame.grid(row=19, column=2)
                        ai3_attacktarget_frame = tk.Button(dungeon_game_frame, text=self.target_frame_ai_champion_text("ai", 3),
                                                        command=lambda: self.add_additonal_targets(3, target_list))
                        ai3_attacktarget_frame.grid(row=19, column=3)
                        if ai1_hp == 0:
                            ai1_attacktarget_frame["state"] = 'disable'
                            disabled_frame_counter = disabled_frame_counter + 1
                        elif 1 in target_list:
                            ai1_attacktarget_frame["state"] = 'disable'
                            disabled_frame_counter = disabled_frame_counter + 1
                        if ai2_hp == 0:
                            ai2_attacktarget_frame["state"] = 'disable'
                            disabled_frame_counter = disabled_frame_counter + 1
                        elif 2 in target_list:
                            ai2_attacktarget_frame["state"] = 'disable'
                            disabled_frame_counter = disabled_frame_counter + 1
                        if ai3_hp == 0:
                            ai3_attacktarget_frame["state"] = 'disable'
                            disabled_frame_counter = disabled_frame_counter + 1
                        elif 3 in target_list:
                            ai3_attacktarget_frame["state"] = 'disable'
                            disabled_frame_counter = disabled_frame_counter + 1
                        if disabled_frame_counter == AI_SPAWNED:
                            self.complete_turn(target_list)
                    elif AI_SPAWNED == 4:
                        disabled_frame_counter = 0
                        ai1_attacktarget_frame = tk.Button(dungeon_game_frame, text=self.target_frame_ai_champion_text("ai", 1),
                                                        command=lambda: self.add_additonal_targets(1, target_list))
                        ai1_attacktarget_frame.grid(row=19, column=1, sticky="e")
                        ai2_attacktarget_frame = tk.Button(dungeon_game_frame, text=self.target_frame_ai_champion_text("ai", 2),
                                                        command=lambda: self.add_additonal_targets(2, target_list))
                        ai2_attacktarget_frame.grid(row=19, column=3, sticky="w")
                        ai3_attacktarget_frame = tk.Button(dungeon_game_frame, text=self.target_frame_ai_champion_text("ai", 3),
                                                        command=lambda: self.add_additonal_targets(3, target_list))
                        ai3_attacktarget_frame.grid(row=20, column=1, sticky="e")
                        ai4_attacktarget_frame = tk.Button(dungeon_game_frame, text=self.target_frame_ai_champion_text("ai", 4),
                                                        command=lambda: self.add_additonal_targets(4, target_list))
                        ai4_attacktarget_frame.grid(row=20, column=3, sticky="w")
                        if ai1_hp == 0:
                            ai1_attacktarget_frame["state"] = 'disable'
                            disabled_frame_counter = disabled_frame_counter + 1
                        elif 1 in target_list:
                            ai1_attacktarget_frame["state"] = 'disable'
                            disabled_frame_counter = disabled_frame_counter + 1
                        if ai2_hp == 0:
                            ai2_attacktarget_frame["state"] = 'disable'
                            disabled_frame_counter = disabled_frame_counter + 1
                        elif 2 in target_list:
                            ai2_attacktarget_frame["state"] = 'disable'
                            disabled_frame_counter = disabled_frame_counter + 1
                        if ai3_hp == 0:
                            ai3_attacktarget_frame["state"] = 'disable'
                            disabled_frame_counter = disabled_frame_counter + 1
                        elif 3 in target_list:
                            ai3_attacktarget_frame["state"] = 'disable'
                            disabled_frame_counter = disabled_frame_counter + 1
                        if ai4_hp == 0:
                            ai4_attacktarget_frame["state"] = 'disable'
                            disabled_frame_counter = disabled_frame_counter + 1
                        elif 4 in target_list:
                            ai4_attacktarget_frame["state"] = 'disable'
                            disabled_frame_counter = disabled_frame_counter + 1
                        if disabled_frame_counter == AI_SPAWNED:
                            self.complete_turn(target_list)
                    elif AI_SPAWNED == 5:
                        disabled_frame_counter = 0
                        ai1_attacktarget_frame = tk.Button(dungeon_game_frame, text=self.target_frame_ai_champion_text("ai", 1),
                                                        command=lambda: self.add_additonal_targets(1, target_list))
                        ai1_attacktarget_frame.grid(row=19, column=1)
                        ai2_attacktarget_frame = tk.Button(dungeon_game_frame, text=self.target_frame_ai_champion_text("ai", 2),
                                                        command=lambda: self.add_additonal_targets(2, target_list))
                        ai2_attacktarget_frame.grid(row=19, column=1, sticky="e")
                        ai3_attacktarget_frame = tk.Button(dungeon_game_frame, text=self.target_frame_ai_champion_text("ai", 3),
                                                        command=lambda: self.add_additonal_targets(3, target_list))
                        ai3_attacktarget_frame.grid(row=19, column=2)
                        ai4_attacktarget_frame = tk.Button(dungeon_game_frame, text=self.target_frame_ai_champion_text("ai", 4),
                                                        command=lambda: self.add_additonal_targets(4, target_list))
                        ai4_attacktarget_frame.grid(row=19, column=3, sticky="w")
                        ai5_attacktarget_frame = tk.Button(dungeon_game_frame, text=self.target_frame_ai_champion_text("ai", 5),
                                                        command=lambda: self.add_additonal_targets(5, target_list))
                        ai5_attacktarget_frame.grid(row=19, column=3)
                        if ai1_hp == 0:
                            ai1_attacktarget_frame["state"] = 'disable'
                            disabled_frame_counter = disabled_frame_counter + 1
                        elif 1 in target_list:
                            ai1_attacktarget_frame["state"] = 'disable'
                            disabled_frame_counter = disabled_frame_counter + 1
                        if ai2_hp == 0:
                            ai2_attacktarget_frame["state"] = 'disable'
                            disabled_frame_counter = disabled_frame_counter + 1
                        elif 2 in target_list:
                            ai2_attacktarget_frame["state"] = 'disable'
                            disabled_frame_counter = disabled_frame_counter + 1
                        if ai3_hp == 0:
                            ai3_attacktarget_frame["state"] = 'disable'
                            disabled_frame_counter = disabled_frame_counter + 1
                        elif 3 in target_list:
                            ai3_attacktarget_frame["state"] = 'disable'
                            disabled_frame_counter = disabled_frame_counter + 1
                        if ai4_hp == 0:
                            ai4_attacktarget_frame["state"] = 'disable'
                            disabled_frame_counter = disabled_frame_counter + 1
                        elif 4 in target_list:
                            ai4_attacktarget_frame["state"] = 'disable'
                            disabled_frame_counter = disabled_frame_counter + 1
                        if ai5_hp == 0:
                            ai5_attacktarget_frame["state"] = 'disable'
                            disabled_frame_counter = disabled_frame_counter + 1
                        elif 5 in target_list:
                            ai5_attacktarget_frame["state"] = 'disable'
                            disabled_frame_counter = disabled_frame_counter + 1
                        if disabled_frame_counter == AI_SPAWNED:
                            self.complete_turn(target_list)
            elif ability_data[1] == "ally":
                if champion1_hp and champion2_hp and champion3_hp and champion4_hp == 0:
                    self.complete_turn(target_list)
                elif champion1_hp and champion2_hp and champion3_hp and champion5_hp == 0:
                    self.complete_turn(target_list)
                elif champion1_hp and champion2_hp and champion4_hp and champion5_hp == 0:
                    self.complete_turn(target_list)
                elif champion1_hp and champion3_hp and champion4_hp and champion5_hp == 0:
                    self.complete_turn(target_list)
                elif champion2_hp and champion3_hp and champion4_hp and champion5_hp == 0:
                    self.complete_turn(target_list)
                else:
                    champion1_supporttarget_frame = tk.Button(dungeon_game_frame,
                                                            text=self.target_frame_ai_champion_text("champion", 1), command=lambda: self.add_additonal_targets(1, target_list))
                    champion1_supporttarget_frame.grid(row=19, column=1, sticky="e")
                    champion2_supporttarget_frame = tk.Button(dungeon_game_frame,
                                                            text=self.target_frame_ai_champion_text("champion", 2), command=lambda: self.add_additonal_targets(2, target_list))
                    champion2_supporttarget_frame.grid(row=19, column=2, sticky="w")
                    champion3_supporttarget_frame = tk.Button(dungeon_game_frame,
                                                            text=self.target_frame_ai_champion_text("champion", 3), command=lambda: self.add_additonal_targets(3, target_list))
                    champion3_supporttarget_frame.grid(row=19, column=2)
                    champion4_supporttarget_frame = tk.Button(dungeon_game_frame,
                                                            text=self.target_frame_ai_champion_text("champion", 4), command=lambda: self.add_additonal_targets(4, target_list))
                    champion4_supporttarget_frame.grid(row=19, column=2, sticky="e")
                    champion5_supporttarget_frame = tk.Button(dungeon_game_frame,
                                                            text=self.target_frame_ai_champion_text("champion", 5), command=lambda: self.add_additonal_targets(5, target_list))
                    champion5_supporttarget_frame.grid(row=19, column=3, sticky="w")
                    if champion1_hp == 0:
                        champion1_supporttarget_frame["state"] = 'disable'
                    elif target == 1:
                        champion1_supporttarget_frame["state"] = 'disable'
                    if champion2_hp == 0:
                        champion2_supporttarget_frame["state"] = 'disable'
                    elif target == 2:
                        champion2_supporttarget_frame["state"] = 'disable'
                    if champion3_hp == 0:
                        champion3_supporttarget_frame["state"] = 'disable'
                    elif target == 3:
                        champion3_supporttarget_frame["state"] = 'disable'
                    if champion4_hp == 0:
                        champion4_supporttarget_frame["state"] = 'disable'
                    elif target == 4:
                        champion4_supporttarget_frame["state"] = 'disable'
                    if champion5_hp == 0:
                        champion5_supporttarget_frame["state"] = 'disable'
                    elif target == 5:
                        champion5_supporttarget_frame["state"] = 'disable'
#Similar check to multi_target_check. See' whether or not more targets need to be chosen
#If not (2T), program moves forwards, otherwise (3T) they are once again allowed to pick another target
#Same rules apply as the last check, previously chosen and dead targets are disabled and if there are no more available targets then the program moves forward
    def add_additonal_targets(self, next_target, target_list):
        target_list.append(next_target)
        if ability_data[2] == "2T":
            self.complete_turn(target_list)
        elif ability_data[2] == "3T":
            if len(target_list) < 3:
                self.clean_up()
                if AI_SPAWNED == 1:
                    self.complete_turn(target_list)
                elif AI_SPAWNED == 2:
                    self.complete_turn(target_list)
                elif AI_SPAWNED == 3:
                    disabled_frame_counter = 0
                    ai1_attacktarget_frame = tk.Button(dungeon_game_frame, text=self.target_frame_ai_champion_text("ai", 1),
                                                    command=lambda: self.add_additonal_targets(1, target_list))
                    ai1_attacktarget_frame.grid(row=19, column=1)
                    ai2_attacktarget_frame = tk.Button(dungeon_game_frame, text=self.target_frame_ai_champion_text("ai", 2),
                                                    command=lambda: self.add_additonal_targets(2, target_list))
                    ai2_attacktarget_frame.grid(row=19, column=2)
                    ai3_attacktarget_frame = tk.Button(dungeon_game_frame, text=self.target_frame_ai_champion_text("ai", 3),
                                                    command=lambda: self.add_additonal_targets(3, target_list))
                    ai3_attacktarget_frame.grid(row=19, column=3)
                    if ai1_hp == 0:
                        ai1_attacktarget_frame["state"] = 'disable'
                        disabled_frame_counter = disabled_frame_counter + 1
                    elif 1 in target_list:
                        ai1_attacktarget_frame["state"] = 'disable'
                        disabled_frame_counter = disabled_frame_counter + 1
                    if ai2_hp == 0:
                        ai2_attacktarget_frame["state"] = 'disable'
                        disabled_frame_counter = disabled_frame_counter + 1
                    elif 2 in target_list:
                        ai2_attacktarget_frame["state"] = 'disable'
                        disabled_frame_counter = disabled_frame_counter + 1
                    if ai3_hp == 0:
                        ai3_attacktarget_frame["state"] = 'disable'
                        disabled_frame_counter = disabled_frame_counter + 1
                    elif 3 in target_list:
                        ai3_attacktarget_frame["state"] = 'disable'
                        disabled_frame_counter = disabled_frame_counter + 1
                    if disabled_frame_counter == AI_SPAWNED:
                        self.complete_turn(target_list)
                elif AI_SPAWNED == 4:
                    disabled_frame_counter = 0
                    ai1_attacktarget_frame = tk.Button(dungeon_game_frame, text=self.target_frame_ai_champion_text("ai", 1),
                                                    command=lambda: self.add_additonal_targets(1, target_list))
                    ai1_attacktarget_frame.grid(row=19, column=1, sticky="e")
                    ai2_attacktarget_frame = tk.Button(dungeon_game_frame, text=self.target_frame_ai_champion_text("ai", 2),
                                                    command=lambda: self.add_additonal_targets(2, target_list))
                    ai2_attacktarget_frame.grid(row=19, column=3, sticky="w")
                    ai3_attacktarget_frame = tk.Button(dungeon_game_frame, text=self.target_frame_ai_champion_text("ai", 3),
                                                    command=lambda: self.add_additonal_targets(3, target_list))
                    ai3_attacktarget_frame.grid(row=20, column=1, sticky="e")
                    ai4_attacktarget_frame = tk.Button(dungeon_game_frame, text=self.target_frame_ai_champion_text("ai", 4),
                                                    command=lambda: self.add_additonal_targets(4, target_list))
                    ai4_attacktarget_frame.grid(row=20, column=3, sticky="w")
                    if ai1_hp == 0:
                        ai1_attacktarget_frame["state"] = 'disable'
                        disabled_frame_counter = disabled_frame_counter + 1
                    elif 1 in target_list:
                        ai1_attacktarget_frame["state"] = 'disable'
                        disabled_frame_counter = disabled_frame_counter + 1
                    if ai2_hp == 0:
                        ai2_attacktarget_frame["state"] = 'disable'
                        disabled_frame_counter = disabled_frame_counter + 1
                    elif 2 in target_list:
                        ai2_attacktarget_frame["state"] = 'disable'
                        disabled_frame_counter = disabled_frame_counter + 1
                    if ai3_hp == 0:
                        ai3_attacktarget_frame["state"] = 'disable'
                        disabled_frame_counter = disabled_frame_counter + 1
                    elif 3 in target_list:
                        ai3_attacktarget_frame["state"] = 'disable'
                        disabled_frame_counter = disabled_frame_counter + 1
                    if ai4_hp == 0:
                        ai4_attacktarget_frame["state"] = 'disable'
                        disabled_frame_counter = disabled_frame_counter + 1
                    elif 4 in target_list:
                        ai4_attacktarget_frame["state"] = 'disable'
                        disabled_frame_counter = disabled_frame_counter + 1
                    if disabled_frame_counter == AI_SPAWNED:
                        self.complete_turn(target_list)
                elif AI_SPAWNED == 5:
                    disabled_frame_counter = 0
                    ai1_attacktarget_frame = tk.Button(dungeon_game_frame, text=self.target_frame_ai_champion_text("ai", 1),
                                            command=lambda: self.add_additonal_targets(1, target_list))
                    ai1_attacktarget_frame.grid(row=19, column=1)
                    ai2_attacktarget_frame = tk.Button(dungeon_game_frame, text=self.target_frame_ai_champion_text("ai", 2),
                                            command=lambda: self.add_additonal_targets(2, target_list))
                    ai2_attacktarget_frame.grid(row=19, column=1, sticky="e")
                    ai3_attacktarget_frame = tk.Button(dungeon_game_frame, text=self.target_frame_ai_champion_text("ai", 3),
                                            command=lambda: self.add_additonal_targets(3, target_list))
                    ai3_attacktarget_frame.grid(row=19, column=2)
                    ai4_attacktarget_frame = tk.Button(dungeon_game_frame, text=self.target_frame_ai_champion_text("ai", 4),
                                            command=lambda: self.add_additonal_targets(4, target_list))
                    ai4_attacktarget_frame.grid(row=19, column=3, sticky="w")
                    ai5_attacktarget_frame = tk.Button(dungeon_game_frame, text=self.target_frame_ai_champion_text("ai", 5),
                                            command=lambda: self.add_additonal_targets(5, target_list))
                    ai5_attacktarget_frame.grid(row=19, column=3)
                    if ai1_hp == 0:
                        ai1_attacktarget_frame["state"] = 'disable'
                        disabled_frame_counter = disabled_frame_counter + 1
                    elif 1 in target_list:
                        ai1_attacktarget_frame["state"] = 'disable'
                        disabled_frame_counter = disabled_frame_counter + 1
                    if ai2_hp == 0:
                        ai2_attacktarget_frame["state"] = 'disable'
                        disabled_frame_counter = disabled_frame_counter + 1
                    elif 2 in target_list:
                        ai2_attacktarget_frame["state"] = 'disable'
                        disabled_frame_counter = disabled_frame_counter + 1
                    if ai3_hp == 0:
                        ai3_attacktarget_frame["state"] = 'disable'
                        disabled_frame_counter = disabled_frame_counter + 1
                    elif 3 in target_list:
                        ai3_attacktarget_frame["state"] = 'disable'
                        disabled_frame_counter = disabled_frame_counter + 1
                    if ai4_hp == 0:
                        ai4_attacktarget_frame["state"] = 'disable'
                        disabled_frame_counter = disabled_frame_counter + 1
                    elif 4 in target_list:
                        ai4_attacktarget_frame["state"] = 'disable'
                        disabled_frame_counter = disabled_frame_counter + 1
                    if ai5_hp == 0:
                        ai5_attacktarget_frame["state"] = 'disable'
                        disabled_frame_counter = disabled_frame_counter + 1
                    elif 5 in target_list:
                        ai5_attacktarget_frame["state"] = 'disable'
                        disabled_frame_counter = disabled_frame_counter + 1
                    if disabled_frame_counter == AI_SPAWNED:
                        self.complete_turn(target_list)
#Function that occurs after chosen targets have been confirmed
#Depending on ability_data[1] (type of target) the respective function is run which makes the effect of the ability happen
#finalise_damage_dealt > make ability deal damage and do special effects
#finalise_healing_done > make ability heal an ally and do special effects
#finalise_self_buff > make ability do special effects
#Function then deletes remaining targeting widgets and marks the current champions turn as over before allowing the player to pick whose turn it is next
    def complete_turn(self, target_list):
        global champion1_turnover, champion2_turnover, champion3_turnover, champion4_turnover, champion5_turnover, from_end_of_turn
        if ability_data[1] == "enemy":
            self.finalise_damage_dealt(target_list)
        if ability_data[1] == "ally":
            self.finalise_healing_done(target_list)
        if ability_data[1] == "self":
            self.finalise_self_buff()
        self.clean_up()
        if current_turn == "C1":
            champion1_turnover = 1
        if current_turn == "C2":
            champion2_turnover = 1
        if current_turn == "C3":
            champion3_turnover = 1
        if current_turn == "C4":
            champion4_turnover = 1
        if current_turn == "C5":
            champion5_turnover = 1
        from_end_of_turn = 1
        self.next_turn()
#Function that activates the chosen abilities effect
#Globals that are referenced in more than one ability are globaled at the beginning of the function, whereas ability specific ones are globaled inside their ability effect
    def finalise_damage_dealt(self, target_list):
        global ai1_hp, ai2_hp, ai3_hp, ai4_hp, ai5_hp, champion1_hp, champion2_hp, champion3_hp, champion4_hp, champion5_hp, \
            reckless_flurry_buff, berserker_passive, ai1_statuses, ai2_statuses, ai3_statuses, ai4_statuses, ai5_statuses, \
            ai1_rottingDot, ai2_rottingDot, ai3_rottingDot, ai4_rottingDot, ai5_rottingDot, prepare_buff, \
            ai1_hh_db, ai2_hh_db, ai3_hh_db, ai4_hh_db, ai5_hh_db, \
            ai1_ws_db, ai2_ws_db, ai3_ws_db, ai4_ws_db, ai5_ws_db, \
            ai1_uc_db, ai2_uc_db, ai3_uc_db, ai4_uc_db, ai5_uc_db, \
            champion1_rp, champion2_rp, champion3_rp, champion4_rp, champion5_rp, \
            ai1_thornsDot, ai2_thornsDot, ai3_thornsDot, ai4_thornsDot, ai5_thornsDot, \
            channeling_strength, ability_data
        counter = 0
        #Checks for the Bloodmancers 'Channeling Strength' buff
        #If he has it and the ability has a healing or damage value (ability_data[3]), the buff is consumed and it increases ability_data[3] by 50%
        if channeling_strength != 0:
            ability_data[3] = ability_data[3] * 1.5
            channeling_strength = 0
        #Deals damage to chosen enemy and applies the 'Taunted' debuff to them
        #Causing them to forcibly attack the Monk
        if ability_data[0] == "Palm Strike":
            if 1 in target_list:
                ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1))
                self.apply_taunt(1, MONK.title, 2)
            if 2 in target_list:
                ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2))
                self.apply_taunt(2, MONK.title, 2)
            if 3 in target_list:
                ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3))
                self.apply_taunt(3, MONK.title, 2)
            if 4 in target_list:
                ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4))
                self.apply_taunt(4, MONK.title, 2)
            if 5 in target_list:
                ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5))
                self.apply_taunt(5, MONK.title, 2)
        #Deals damage to chosen enemy and applies the 'Stunned' debuff to them
        #Causing them to not be able to attack
        elif ability_data[0] == "Leg Sweep":
            if 1 in target_list:
                ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1))
                self.apply_stun(1, 1)
            if 2 in target_list:
                ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2))
                self.apply_stun(2, 1)
            if 3 in target_list:
                ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3))
                self.apply_stun(3, 1)
            if 4 in target_list:
                ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4))
                self.apply_stun(4, 1)
            if 5 in target_list:
                ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5))
                self.apply_stun(5, 1)
        #Instantly kills the chosen enemy if their current health points is below 30% of their maximum health points
        #If the chosen enemy is above 30%, then they are stunned instead
        #Causing them to not be able to attack
        elif ability_data[0] == "Pressure Points":
            if 1 in target_list:
                if ai1_hp < (AI_GROUP_HP + ai_health_modifier) * 0.3:
                    ai1_hp = 0
                else:
                    self.apply_stun(1, 3)
            if 2 in target_list:
                if ai2_hp < (AI_GROUP_HP + ai_health_modifier) * 0.3:
                    ai2_hp = 0
                else:
                    self.apply_stun(2, 3)
            if 3 in target_list:
                if ai3_hp < (AI_GROUP_HP + ai_health_modifier) * 0.3:
                    ai3_hp = 0
                else:
                    self.apply_stun(3, 3)
            if 4 in target_list:
                if ai4_hp < (AI_GROUP_HP + ai_health_modifier) * 0.3:
                    ai4_hp = 0
                else:
                    self.apply_stun(4, 3)
            if 5 in target_list:
                if ai5_hp < (AI_GROUP_HP + ai_health_modifier) * 0.3:
                    ai5_hp = 0
                else:
                    self.apply_stun(5, 3)
        #Deals damage to chosen enemy and heals the Barbarian for half the damage dealt
        #Damage of Bloodthirst is increased by 20% for each enemy that is attacking the Barbarian
        elif ability_data[0] == "Bloodthirst":
            temp_ability_data = ability_data[3]
            point = 0
            if AI_SPAWNED == 1:
                if BARBARIAN.title in ai1_attack_intention:
                    point += 1
            if AI_SPAWNED == 2:
                if BARBARIAN.title in ai1_attack_intention:
                    point += 1
                if BARBARIAN.title in ai2_attack_intention:
                    point += 1
            if AI_SPAWNED == 3:
                if BARBARIAN.title in ai1_attack_intention:
                    point += 1
                if BARBARIAN.title in ai2_attack_intention:
                    point += 1
                if BARBARIAN.title in ai3_attack_intention:
                    point += 1
            if AI_SPAWNED == 4:
                if BARBARIAN.title in ai1_attack_intention:
                    point += 1
                if BARBARIAN.title in ai2_attack_intention:
                    point += 1
                if BARBARIAN.title in ai3_attack_intention:
                    point += 1
                if BARBARIAN.title in ai4_attack_intention:
                    point += 1
            if AI_SPAWNED == 5:
                if BARBARIAN.title in ai1_attack_intention:
                    point += 1
                if BARBARIAN.title in ai2_attack_intention:
                    point += 1
                if BARBARIAN.title in ai3_attack_intention:
                    point += 1
                if BARBARIAN.title in ai4_attack_intention:
                    point += 1
                if BARBARIAN.title in ai5_attack_intention:
                    point += 1
            if point > 0:
                ability_data[3] = ability_data[3] * (1 +(0.2 * point))
            else:
                ability_data[3] = ability_data[3]
            if 1 in target_list:
                ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1))
                for champions in CHAMPION_LIST:
                    counter += 1
                    if champions == BARBARIAN.title:
                        if counter == 1:
                            champion1_hp = champion1_hp + math.ceil(ability_data[3] * self.check_enemy_vunerability(1) / 2)
                            if champion1_hp > CHAMPION1_HP:
                                 champion1_hp = CHAMPION1_HP
                        elif counter == 2:
                            champion2_hp = champion2_hp + math.ceil(ability_data[3] * self.check_enemy_vunerability(1) / 2)
                            if champion2_hp > CHAMPION2_HP:
                                 champion2_hp = CHAMPION2_HP
                        elif counter == 3:
                            champion3_hp = champion3_hp + math.ceil(ability_data[3] * self.check_enemy_vunerability(1) / 2)
                            if champion3_hp > CHAMPION3_HP:
                                 champion3_hp = CHAMPION3_HP
                        elif counter == 4:
                            champion4_hp = champion4_hp + math.ceil(ability_data[3] * self.check_enemy_vunerability(1) / 2)
                            if champion4_hp > CHAMPION4_HP:
                                 champion4_hp = CHAMPION4_HP
                        elif counter == 5:
                            champion5_hp = champion5_hp + math.ceil(ability_data[3] * self.check_enemy_vunerability(1) / 2)
                            if champion5_hp > CHAMPION5_HP:
                                champion5_hp = CHAMPION5_HP
            if 2 in target_list:
                ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2))
                for champions in CHAMPION_LIST:
                    counter += 1
                    if champions == BARBARIAN.title:
                        if counter == 1:
                            champion1_hp = champion1_hp + math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(2)) / 2)
                            if champion1_hp > CHAMPION1_HP:
                                champion1_hp = CHAMPION1_HP
                        elif counter == 2:
                            champion2_hp = champion2_hp + math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(2)) / 2)
                            if champion2_hp > CHAMPION2_HP:
                                champion2_hp = CHAMPION2_HP
                        elif counter == 3:
                            champion3_hp = champion3_hp + math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(2)) / 2)
                            if champion3_hp > CHAMPION3_HP:
                                champion3_hp = CHAMPION3_HP
                        elif counter == 4:
                            champion4_hp = champion4_hp + math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(2)) / 2)
                            if champion4_hp > CHAMPION4_HP:
                                champion4_hp = CHAMPION4_HP
                        elif counter == 5:
                            champion5_hp = champion5_hp + math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(2)) / 2)
                            if champion5_hp > CHAMPION5_HP:
                                champion5_hp = CHAMPION5_HP
            if 3 in target_list:
                ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3))
                for champions in CHAMPION_LIST:
                    counter += 1
                    if champions == BARBARIAN.title:
                        if counter == 1:
                            champion1_hp = champion1_hp + math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(3)) / 2)
                            if champion1_hp > CHAMPION1_HP:
                                champion1_hp = CHAMPION1_HP
                        elif counter == 2:
                            champion2_hp = champion2_hp + math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(3)) / 2)
                            if champion2_hp > CHAMPION2_HP:
                                champion2_hp = CHAMPION2_HP
                        elif counter == 3:
                            champion3_hp = champion3_hp + math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(3)) / 2)
                            if champion3_hp > CHAMPION3_HP:
                                champion3_hp = CHAMPION3_HP
                        elif counter == 4:
                            champion4_hp = champion4_hp + math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(3)) / 2)
                            if champion4_hp > CHAMPION4_HP:
                                champion4_hp = CHAMPION4_HP
                        elif counter == 5:
                            champion5_hp = champion5_hp + math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(3)) / 2)
                            if champion5_hp > CHAMPION5_HP:
                                champion5_hp = CHAMPION5_HP
            if 4 in target_list:
                ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4))
                for champions in CHAMPION_LIST:
                    counter += 1
                    if champions == BARBARIAN.title:
                        if counter == 1:
                            champion1_hp = champion1_hp + math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(4)) / 2)
                            if champion1_hp > CHAMPION1_HP:
                                champion1_hp = CHAMPION1_HP
                        elif counter == 2:
                            champion2_hp = champion2_hp + math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(4)) / 2)
                            if champion2_hp > CHAMPION2_HP:
                                champion2_hp = CHAMPION2_HP
                        elif counter == 3:
                            champion3_hp = champion3_hp + math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(4)) / 2)
                            if champion3_hp > CHAMPION3_HP:
                                champion3_hp = CHAMPION3_HP
                        elif counter == 4:
                            champion4_hp = champion4_hp + math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(4)) / 2)
                            if champion4_hp > CHAMPION4_HP:
                                champion4_hp = CHAMPION4_HP
                        elif counter == 5:
                            champion5_hp = champion5_hp + math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(4)) / 2)
                            if champion5_hp > CHAMPION5_HP:
                                champion5_hp = CHAMPION5_HP
            if 5 in target_list:
                ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5))
                for champions in CHAMPION_LIST:
                    counter += 1
                    if champions == BARBARIAN.title:
                        if counter == 1:
                            champion1_hp = champion1_hp + math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(5)) / 2)
                            if champion1_hp > CHAMPION1_HP:
                                champion1_hp = CHAMPION1_HP
                        elif counter == 2:
                            champion2_hp = champion2_hp + math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(5)) / 2)
                            if champion2_hp > CHAMPION2_HP:
                                champion2_hp = CHAMPION2_HP
                        elif counter == 3:
                            champion3_hp = champion3_hp + math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(5)) / 2)
                            if champion3_hp > CHAMPION3_HP:
                                champion3_hp = CHAMPION3_HP
                        elif counter == 4:
                            champion4_hp = champion4_hp + math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(5)) / 2)
                            if champion4_hp > CHAMPION4_HP:
                                champion4_hp = CHAMPION4_HP
                        elif counter == 5:
                            champion5_hp = champion5_hp + math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(5)) / 2)
                            if champion5_hp > CHAMPION5_HP:
                                champion5_hp = CHAMPION5_HP
            ability_data[3] = temp_ability_data
        #Deals damage to chosen enemies and applies the 'Taunted' debuff to them
        #Causing them to forcibly attack the Barbarian
        #Damage of Pulverize is increased by 20% for each enemy that is attacking the Barbarian
        elif ability_data[0] == "Pulverize":
            temp_ability_data = ability_data[3]
            point = 0
            if AI_SPAWNED == 1:
                if BARBARIAN.title in ai1_attack_intention:
                    point += 1
            if AI_SPAWNED == 2:
                if BARBARIAN.title in ai1_attack_intention:
                    point += 1
                if BARBARIAN.title in ai2_attack_intention:
                    point += 1
            if AI_SPAWNED == 3:
                if BARBARIAN.title in ai1_attack_intention:
                    point += 1
                if BARBARIAN.title in ai2_attack_intention:
                    point += 1
                if BARBARIAN.title in ai3_attack_intention:
                    point += 1
            if AI_SPAWNED == 4:
                if BARBARIAN.title in ai1_attack_intention:
                    point += 1
                if BARBARIAN.title in ai2_attack_intention:
                    point += 1
                if BARBARIAN.title in ai3_attack_intention:
                    point += 1
                if BARBARIAN.title in ai4_attack_intention:
                    point += 1
            if AI_SPAWNED == 5:
                if BARBARIAN.title in ai1_attack_intention:
                    point += 1
                if BARBARIAN.title in ai2_attack_intention:
                    point += 1
                if BARBARIAN.title in ai3_attack_intention:
                    point += 1
                if BARBARIAN.title in ai4_attack_intention:
                    point += 1
                if BARBARIAN.title in ai5_attack_intention:
                    point += 1
            if point > 0:
                ability_data[3] = ability_data[3] * (1 +(0.2 * point))
            else:
                ability_data[3] = ability_data[3]
            if 1 in target_list:
                ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1))
                self.apply_taunt(1, BARBARIAN.title, 1)
            if 2 in target_list:
                ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2))
                self.apply_taunt(2, BARBARIAN.title, 1)
            if 3 in target_list:
                ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3))
                self.apply_taunt(3, BARBARIAN.title, 1)
            if 4 in target_list:
                ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4))
                self.apply_taunt(4, BARBARIAN.title, 1)
            if 5 in target_list:
                ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5))
                self.apply_taunt(5, BARBARIAN.title, 1)
            ability_data[3] = temp_ability_data
        #Deals damage to chosen enemy and applies 'Weakened' to them
        #Causing their attacks to deal less damage 
        elif ability_data[0] == "Shield Bash":
            if 1 in target_list:
                ai1_hp = ai1_hp -math.ceil(ability_data[3] * self.check_enemy_vunerability(1))
                self.apply_weakness(1, 2)
            if 2 in target_list:
                ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2))
                self.apply_weakness(2, 2)
            if 3 in target_list:
                ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3))
                self.apply_weakness(3, 2)
            if 4 in target_list:
                ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4))
                self.apply_weakness(4, 2)
            if 5 in target_list:
                ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5))
                self.apply_weakness(5, 2)
        #Deals damage to chosen enemy
        elif ability_data[0] == "Trainwreck":
            if 1 in target_list:
                ai1_hp = ai1_hp -math.ceil(ability_data[3] * self.check_enemy_vunerability(1)) * 3
            if 2 in target_list:
                ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2)) * 3
            if 3 in target_list:
                ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3)) * 3
            if 4 in target_list:
                ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4)) * 3
            if 5 in target_list:
                ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5)) * 3
        #Deals damage to chosen enemies, they were attacking the Fencer, her chance to dodge their next attack is increased by 40%
        elif ability_data[0] == "Flanking Strikes":
            global ai1_fencer_dodgechance, ai2_fencer_dodgechance, ai3_fencer_dodgechance, ai4_fencer_dodgechance, ai5_fencer_dodgechance
            if 1 in target_list:
                ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1))
                if MASTER_FENCER.title in ai1_attack_intention:
                    ai1_fencer_dodgechance = ai1_fencer_dodgechance + 40
            if 2 in target_list:
                ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2))
                if MASTER_FENCER.title in ai2_attack_intention:
                    ai2_fencer_dodgechance = ai2_fencer_dodgechance + 40
            if 3 in target_list:
                ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3))
                if MASTER_FENCER.title in ai3_attack_intention:
                    ai3_fencer_dodgechance = ai3_fencer_dodgechance + 40
            if 4 in target_list:
                ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4))
                if MASTER_FENCER.title in ai4_attack_intention:
                    ai4_fencer_dodgechance = ai4_fencer_dodgechance + 40
            if 5 in target_list:
                ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5))
                if MASTER_FENCER.title in ai5_attack_intention:
                    ai5_fencer_dodgechance = ai5_fencer_dodgechance + 40
        #If the chosen enemy is using a 'Melee' attack, the enemy is stunned and takes damage equal it the of its own attack
        #If the chosen enemy was attacking the Fencer, her chance to dodge their next attack is increased by 40%
        elif ability_data[0] == "Riposte":
            if 1 in target_list:
                if ai1_attack_intention != "STUNNED":
                    if MASTER_FENCER.title in ai1_attack_intention:
                        ai1_fencer_dodgechance = ai1_fencer_dodgechance + 40
                    if ai1_attack[3] == "Melee":
                        ai1_hp = ai1_hp - ai1_attack[1]
                        if ai1_hp < 0:
                            ai1_hp = 0
                        self.apply_stun(1, 1)
            if 2 in target_list:
                if ai2_attack_intention != "STUNNED":
                    if MASTER_FENCER.title in ai2_attack_intention:
                        ai2_fencer_dodgechance = ai2_fencer_dodgechance + 40
                    if ai2_attack[3] == "Melee":
                        ai2_hp = ai2_hp - ai2_attack[1]
                        if ai2_hp < 0:
                            ai2_hp = 0
                        self.apply_stun(2, 1)
            if 3 in target_list:
                if ai3_attack_intention != "STUNNED":
                    if MASTER_FENCER.title in ai3_attack_intention:
                        ai3_fencer_dodgechance = ai3_fencer_dodgechance + 40
                    if ai3_attack[3] == "Melee":
                        ai3_hp = ai3_hp - ai3_attack[1]
                        if ai3_hp < 0:
                            ai3_hp = 0
                        self.apply_stun(3, 1)
            if 4 in target_list:
                if ai4_attack_intention != "STUNNED":
                    if MASTER_FENCER.title in ai4_attack_intention:
                        ai4_fencer_dodgechance = ai4_fencer_dodgechance + 40
                    if ai4_attack[3] == "Melee":
                        ai4_hp = ai4_hp - ai4_attack[1]
                        if ai4_hp < 0:
                            ai4_hp = 0
                        self.apply_stun(4, 1)
            if 5 in target_list:
                if ai5_attack_intention != "STUNNED":
                    if MASTER_FENCER.title in ai5_attack_intention:
                        ai5_fencer_dodgechance = ai5_fencer_dodgechance + 40
                    if ai5_attack[3] == "Melee":
                        ai5_hp = ai5_hp - ai5_attack[1]
                        if ai5_hp < 0:
                            ai5_hp = 0
                        self.apply_stun(5, 1)
        #If the chosen enemy is using a 'Magic' attack, the enemy is stunned and takes damage equal it the of its own attack
        elif ability_data[0] == "Magic Reflection":
            if 1 in target_list:
                if ai1_attack_intention != "STUNNED":
                    if ai1_attack[3] == "Magic":
                        ai1_hp = ai1_hp - ai1_attack[1]
                        if ai1_hp < 0:
                            ai1_hp = 0
                        self.apply_stun(1, 1)
            if 2 in target_list:
                if ai2_attack_intention != "STUNNED":
                    if ai2_attack[3] == "Magic":
                        ai2_hp = ai2_hp - ai2_attack[1]
                        if ai2_hp < 0:
                            ai2_hp = 0
                        self.apply_stun(2, 1)
            if 3 in target_list:
                if ai3_attack_intention != "STUNNED":
                    if ai3_attack[3] == "Magic":
                        ai3_hp = ai3_hp - ai3_attack[1]
                        if ai3_hp < 0:
                            ai3_hp = 0
                        self.apply_stun(3, 1)
            if 4 in target_list:
                if ai4_attack_intention != "STUNNED":
                    if ai4_attack[3] == "Magic":
                        ai4_hp = ai4_hp - ai4_attack[1]
                        if ai4_hp < 0:
                            ai4_hp = 0
                        self.apply_stun(4, 1)
            if 5 in target_list:
                if ai5_attack_intention != "STUNNED":
                    if ai5_attack[3] == "Magic":
                        ai5_hp = ai5_hp - ai5_attack[1]
                        if ai5_hp < 0:
                            ai5_hp = 0
                        self.apply_stun(5, 1)
        #Deals damage to chosen enemy, damage of Angering Strike is increased by the lack of enemies
        #(Number of Enemies: 5 = 0% Extra Damage)
        #(Number of Enemies: 4 = 10% Extra Damage)
        #(Number of Enemies: 3 = 20% Extra Damage)
        #(Number of Enemies: 2 = 35% Extra Damage)
        #(Number of Enemies: 1 = 50% Extra Damage)
        #If the Berserker has the 'Reckless Flurry' buff, instead of hitting the chosen enemy, the attack hits all alive enemies
        elif ability_data[0] == "Angering Strike":
            counter = 0
            if AI_SPAWNED == 1:
                berserker_passive = 1.5
            if AI_SPAWNED == 2:
                if ai1_hp == 0:
                    counter = counter + 1
                if ai2_hp == 0:
                    counter = counter + 1
                if counter == 1:
                    berserker_passive = 1.5
                else:
                    berserker_passive = 1.35
            if AI_SPAWNED == 3:
                if ai1_hp == 0:
                    counter = counter + 1
                if ai2_hp == 0:
                    counter = counter + 1
                if ai3_hp == 0:
                    counter = counter + 1
                if counter == 1:
                    berserker_passive = 1.5
                elif counter == 2:
                    berserker_passive = 1.35
                else:
                    berserker_passive = 1.2
            if AI_SPAWNED == 4:
                if ai1_hp == 0:
                    counter = counter + 1
                if ai2_hp == 0:
                    counter = counter + 1
                if ai3_hp == 0:
                    counter = counter + 1
                if ai4_hp == 0:
                    counter = counter + 1
                elif counter == 1:
                    berserker_passive = 1.5
                elif counter == 2:
                    berserker_passive = 1.35
                elif counter == 3:
                    berserker_passive = 1.2
                else:
                    berserker_passive = 1.1
            if AI_SPAWNED == 5:
                if ai1_hp == 0:
                    counter = counter + 1
                if ai2_hp == 0:
                    counter = counter + 1
                if ai3_hp == 0:
                    counter = counter + 1
                if ai4_hp == 0:
                    counter = counter + 1
                if ai5_hp == 0:
                    counter = counter + 1
                if counter == 1:
                    berserker_passive = 1.5
                elif counter == 2:
                    berserker_passive = 1.35
                elif counter == 3:
                    berserker_passive = 1.2
                elif counter == 4:
                    berserker_passive = 1.1
                else:
                    berserker_passive = 1
            if reckless_flurry_buff != 0:
                if AI_SPAWNED == 1:
                    ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * berserker_passive)
                if AI_SPAWNED == 2:
                    if ai1_hp != 0:
                        ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * berserker_passive)
                    if ai2_hp != 0:
                        ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * berserker_passive)
                if AI_SPAWNED == 3:
                    if ai1_hp != 0:
                        ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * berserker_passive)
                    if ai2_hp != 0:
                        ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * berserker_passive)
                    if ai3_hp != 0:
                        ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3) * berserker_passive)
                if AI_SPAWNED == 4:
                    if ai1_hp != 0:
                        ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * berserker_passive)
                    if ai2_hp != 0:
                        ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * berserker_passive)
                    if ai3_hp != 0:
                        ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3) * berserker_passive )
                    if ai4_hp != 0:
                        ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4) * berserker_passive )
                if AI_SPAWNED == 5:
                    if ai1_hp != 0:
                        ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * berserker_passive)
                    if ai2_hp != 0:
                        ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * berserker_passive)
                    if ai3_hp != 0:
                        ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3) * berserker_passive)
                    if ai4_hp != 0:
                        ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4) * berserker_passive)
                    if ai5_hp != 0:
                        ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5) * berserker_passive)
                reckless_flurry_buff = reckless_flurry_buff - 1
            else:
                if 1 in target_list:
                    ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * berserker_passive)
                if 2 in target_list:
                    ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * berserker_passive)
                if 3 in target_list:
                    ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3) * berserker_passive)
                if 4 in target_list:
                    ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4) * berserker_passive)
                if 5 in target_list:
                    ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5) * berserker_passive)
        #Deals damage to chosen enemy, damage of Unbridled Rampage is increased by the lack of enemies
        #(Number of Enemies: 5 = 0% Extra Damage)
        #(Number of Enemies: 4 = 10% Extra Damage)
        #(Number of Enemies: 3 = 20% Extra Damage)
        #(Number of Enemies: 2 = 35% Extra Damage)
        #(Number of Enemies: 1 = 50% Extra Damage)
        #If the Berserker has the 'Reckless Flurry' buff, instead of hitting the chosen enemy, the attack hits all alive enemies
        elif ability_data[0] == "Unbridled Rampage":
            counter = 0
            if AI_SPAWNED == 1:
                berserker_passive = 1.5
            if AI_SPAWNED == 2:
                if ai1_hp == 0:
                    counter = counter + 1
                if ai2_hp == 0:
                    counter = counter + 1
                if counter == 1:
                    berserker_passive = 1.5
                else:
                    berserker_passive = 1.35
            if AI_SPAWNED == 3:
                if ai1_hp == 0:
                    counter = counter + 1
                if ai2_hp == 0:
                    counter = counter + 1
                if ai3_hp == 0:
                    counter = counter + 1
                if counter == 1:
                    berserker_passive = 1.5
                elif counter == 2:
                    berserker_passive = 1.35
                else:
                    berserker_passive = 1.2
            if AI_SPAWNED == 4:
                if ai1_hp == 0:
                    counter = counter + 1
                if ai2_hp == 0:
                    counter = counter + 1
                if ai3_hp == 0:
                    counter = counter + 1
                if ai4_hp == 0:
                    counter = counter + 1
                elif counter == 1:
                    berserker_passive = 1.5
                elif counter == 2:
                    berserker_passive = 1.35
                elif counter == 3:
                    berserker_passive = 1.2
                else:
                    berserker_passive = 1.1
            if AI_SPAWNED == 5:
                if ai1_hp == 0:
                    counter = counter + 1
                if ai2_hp == 0:
                    counter = counter + 1
                if ai3_hp == 0:
                    counter = counter + 1
                if ai4_hp == 0:
                    counter = counter + 1
                if ai5_hp == 0:
                    counter = counter + 1
                if counter == 1:
                    berserker_passive = 1.5
                elif counter == 2:
                    berserker_passive = 1.35
                elif counter == 3:
                    berserker_passive = 1.2
                elif counter == 4:
                    berserker_passive = 1.1
                else:
                    berserker_passive = 1
            if reckless_flurry_buff != 0:
                if AI_SPAWNED == 1:
                    ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * berserker_passive * 2.5)
                if AI_SPAWNED == 2:
                    if ai1_hp != 0:
                        ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * berserker_passive * 2.5)
                    if ai2_hp != 0:
                        ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * berserker_passive * 2.5)
                if AI_SPAWNED == 3:
                    if ai1_hp != 0:
                        ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * berserker_passive * 2.5)
                    if ai2_hp != 0:
                        ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * berserker_passive * 2.5)
                    if ai3_hp != 0:
                        ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3) * berserker_passive * 2.5)
                if AI_SPAWNED == 4:
                    if ai1_hp != 0:
                        ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * berserker_passive * 2.5)
                    if ai2_hp != 0:
                        ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * berserker_passive * 2.5)
                    if ai3_hp != 0:
                        ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3) * berserker_passive * 2.5)
                    if ai4_hp != 0:
                        ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4) * berserker_passive * 2.5)
                if AI_SPAWNED == 5:
                    if ai1_hp != 0:
                        ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * berserker_passive * 2.5)
                    if ai2_hp != 0:
                        ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * berserker_passive * 2.5)
                    if ai3_hp != 0:
                        ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3) * berserker_passive * 2.5)
                    if ai4_hp != 0:
                        ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4) * berserker_passive * 2.5)
                    if ai5_hp != 0:
                        ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5) * berserker_passive * 2.5)
                reckless_flurry_buff = reckless_flurry_buff - 1
            else:
                if 1 in target_list:
                    ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * berserker_passive * 2.5)
                if 2 in target_list:
                    ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * berserker_passive * 2.5)
                if 3 in target_list:
                    ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3) * berserker_passive * 2.5)
                if 4 in target_list:
                    ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4) * berserker_passive * 2.5)
                if 5 in target_list:
                    ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5) * berserker_passive * 2.5)
        #Deals damage to chosen enemy and applies the 'Serrated' damage over time effect to them
        #Damage of 'Serrated' is increased by the number of other unique bleeds the affected enemy has on them when applied
        elif ability_data[0] == "Serrated Slash":
            if 1 in target_list:
                ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1))
                self.apply_serratedSlashDot(1, 1)
            if 2 in target_list:
                ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2))
                self.apply_serratedSlashDot(2, 1)
            if 3 in target_list:
                ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3))
                self.apply_serratedSlashDot(3, 1)
            if 4 in target_list:
                ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4))
                self.apply_serratedSlashDot(4, 1)
            if 5 in target_list:
                ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5))
                self.apply_serratedSlashDot(5, 1)
        #Deals damage to chosen enemy and applies the 'Eviscerated' damage over time effect to them
        #Damage of 'Eviscerated' is increased by the number of other unique bleeds the affected enemy has on them when applied
        elif ability_data[0] == "Eviscerate":
            if 1 in target_list:
                ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1)) * 1.5
                self.apply_eviscerateDot(1, 3)
            if 2 in target_list:
                ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2)) * 1.5
                self.apply_eviscerateDot(2, 3)
            if 3 in target_list:
                ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3)) * 1.5
                self.apply_eviscerateDot(3, 3)
            if 4 in target_list:
                ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4)) * 1.5
                self.apply_eviscerateDot(4, 3)
            if 5 in target_list:
                ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5)) * 1.5
                self.apply_eviscerateDot(5, 3)
        #Deals damage to chosen enemy and applies the 'Garroted' damage over time effect to them
        #Damage of 'Garroted' is increased by the number of other unique bleeds the affected enemy has on them when applied
        elif ability_data[0] == "Garrote":
            if 1 in target_list:
                ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1))
                self.apply_garroteDot(1, 2)
            if 2 in target_list:
                ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2))
                self.apply_garroteDot(2, 2)
            if 3 in target_list:
                ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3))
                self.apply_garroteDot(3, 2)
            if 4 in target_list:
                ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4))
                self.apply_garroteDot(4, 2)
            if 5 in target_list:
                ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5))
                self.apply_garroteDot(5, 2)
        #Deals damage to chosen enemy that increases by 30% for each debuff they have
        elif ability_data[0] == "Exploit Weakness":
            damage_multipler = 0
            if 1 in target_list:
                if len(ai1_statuses) != 0:
                    for status_effect in ai1_statuses:
                        damage_multipler += 1
                ai1_hp = ai1_hp - (math.ceil(ability_data[3] * self.check_enemy_vunerability(1)) * (1 + (damage_multipler * 0.3)))
            if 2 in target_list:
                for status_effect in ai2_statuses:
                    damage_multipler += 1
                ai2_hp = ai2_hp - (math.ceil(ability_data[3] * self.check_enemy_vunerability(2)) * (1 + (damage_multipler * 0.3)))
            if 3 in target_list:
                for status_effect in ai3_statuses:
                    damage_multipler += 1
                ai3_hp = ai3_hp - (math.ceil(ability_data[3] * self.check_enemy_vunerability(3)) * (1 + (damage_multipler * 0.3)))
            if 4 in target_list:
                for status_effect in ai4_statuses:
                    damage_multipler += 1
                ai4_hp = ai4_hp - (math.ceil(ability_data[3] * self.check_enemy_vunerability(4)) * (1 + (damage_multipler * 0.3)))
            if 5 in target_list:
                for status_effect in ai5_statuses:
                    damage_multipler += 1
                ai5_hp = ai5_hp - (math.ceil(ability_data[3] * self.check_enemy_vunerability(5)) * (1 + (damage_multipler * 0.3)))
        #Deals damage to chosen enemy
        #If the Survivalist has the 'Prepared' buff, Spear Thrust deals 50% more damage
        elif ability_data[0] == "Spear Thrust":
            prep_extra_damage = 1
            if prepare_buff != 0:
                prep_extra_damage = 1.5
                prepare_buff = 0
            if 1 in target_list:
                ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1)) * 1.4 * prep_extra_damage
            if 2 in target_list:
                ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2)) * 1.4 * prep_extra_damage
            if 3 in target_list:
                ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3)) * 1.4 * prep_extra_damage
            if 4 in target_list:
                ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4)) * 1.4 * prep_extra_damage
            if 5 in target_list:
                ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5)) * 1.4 * prep_extra_damage
            prep_extra_damage = 1
        #Deals damage to all alive enemies and applied 'Weakened' to them
        #If the Survivalist has the 'Prepared' buff, Scrap Bomb deals 50% more damage
        elif ability_data[0] == "Scrap Bomb":
            prep_extra_damage = 1
            if prepare_buff != 0:
                prep_extra_damage = 1.5
                prepare_buff = 0
            if AI_SPAWNED == 1:
                ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * prep_extra_damage)
                self.apply_weakness(1, 2)
            if AI_SPAWNED == 2:
                ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1)* prep_extra_damage)
                ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2)* prep_extra_damage)
                self.apply_weakness(1, 2)
                self.apply_weakness(2, 2)
            if AI_SPAWNED == 3:
                ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1)* prep_extra_damage)
                ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2)* prep_extra_damage)
                ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3)* prep_extra_damage)
                self.apply_weakness(1, 2)
                self.apply_weakness(2, 2)
                self.apply_weakness(3, 2)
            if AI_SPAWNED == 4:
                ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1)* prep_extra_damage)
                ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2)* prep_extra_damage)
                ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3)* prep_extra_damage)
                ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4)* prep_extra_damage)
                self.apply_weakness(1, 2)
                self.apply_weakness(2, 2)
                self.apply_weakness(3, 2)
                self.apply_weakness(4, 2)
            if AI_SPAWNED == 5:
                ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1)* prep_extra_damage)
                ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2)* prep_extra_damage)
                ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3)* prep_extra_damage)
                ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4)* prep_extra_damage)
                ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5)* prep_extra_damage)
                self.apply_weakness(1, 2)
                self.apply_weakness(2, 2)
                self.apply_weakness(3, 2)
                self.apply_weakness(4, 2)
                self.apply_weakness(5, 2)
            prep_extra_damage = 1
        #Deals damage to chosen enemy and applies a debuff to them that makes the next 'Wide Swing' or 'Uppercut' deal 25% more damage
        #If the chosen enemy has the debuff left by 'Wide Swing' or 'Uppercut' hitting them, Wide Swing deals 25% or 50% more damage respectively and then removes the debuff
        elif ability_data[0] == "Hard Hitter":
            WSDB = 1
            UCDB = 1
            if 1 in target_list:
                if "WideSwingDB" in ai1_statuses:
                    WSDB = 1.25
                    ai1_statuses.remove("WideSwingDB")
                    ai1_ws_db = 0
                if "UpperCutDB" in ai1_statuses:
                    UCDB = 1.5
                    ai1_statuses.remove("UpperCutDB")
                    ai1_uc_db = 0
                ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1)) * (1 * WSDB * UCDB)
                ai1_statuses.append("HardHitterDB")
                ai1_hh_db = 1
            if 2 in target_list:
                if "WideSwingDB" in ai2_statuses:
                    WSDB = 1.25
                    ai2_statuses.remove("WideSwingDB")
                    ai2_ws_db = 0
                if "UpperCutDB" in ai2_statuses:
                    UCDB = 1.5
                    ai2_statuses.remove("UpperCutDB")
                    ai2_uc_db = 0
                ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2)) * (1 * WSDB * UCDB)
                ai2_statuses.append("HardHitterDB")
                ai2_hh_db = 1
            if 3 in target_list:
                if "WideSwingDB" in ai3_statuses:
                    WSDB = 1.25
                    ai3_statuses.remove("WideSwingDB")
                    ai3_ws_db = 0
                if "UpperCutDB" in ai3_statuses:
                    UCDB = 1.5
                    ai3_statuses.remove("UpperCutDB")
                    ai3_uc_db = 0
                ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3)) * (1 * WSDB * UCDB)
                ai3_statuses.append("HardHitterDB")
                ai3_hh_db = 1
            if 4 in target_list:
                if "WideSwingDB" in ai4_statuses:
                    WSDB = 1.25
                    ai4_statuses.remove("WideSwingDB")
                    ai4_ws_db = 0
                if "UpperCutDB" in ai4_statuses:
                    UCDB = 1.5
                    ai4_statuses.remove("UpperCutDB")
                    ai4_uc_db = 0
                ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4)) * (1 * WSDB * UCDB)
                ai4_statuses.append("HardHitterDB")
                ai4_hh_db = 1
            if 5 in target_list:
                if "WideSwingDB" in ai5_statuses:
                    WSDB = 1.25
                    ai5_ws_db = 0
                    ai5_statuses.remove("WideSwingDB")
                if "UpperCutDB" in ai5_statuses:
                    UCDB = 1.5
                    ai5_statuses.remove("UpperCutDB")
                    ai5_uc_db = 0
                ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5)) * (1 * WSDB * UCDB)
                ai5_statuses.append("HardHitterDB")
                ai5_hh_db = 1
        #Deals damage to chosen enemies and applies a debuff to all of them that makes the next 'Hard Hitter' or 'Uppercut' deal 25% more damage
        #If any of the chosen enemies has the debuff left by 'Hard Hitter' or 'Uppercut' hitting them, Wide Swing deals 25% or 50% more damage respectively and then removes the debuff
        elif ability_data[0] == "Wide Swing":
            HHDB = 1
            UCDB = 1
            if 1 in target_list:
                if "HardHitterDB" in ai1_statuses:
                    HHDB = 1.25
                    ai1_statuses.remove("HardHitterDB")
                    ai1_hh_db = 0
                if "UpperCutDB" in ai1_statuses:
                    UCDB = 1.5
                    ai1_statuses.remove("UpperCutDB")
                    ai1_uc_db = 0
                ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1)) * 0.5 * (1 * HHDB * UCDB)
                ai1_statuses.append("WideSwingDB")
                ai1_ws_db = 1
            if 2 in target_list:
                if "HardHitterDB" in ai2_statuses:
                    HHDB = 1.25
                    ai2_statuses.remove("HardHitterDB")
                    ai2_hh_db = 0
                if "UpperCutDB" in ai2_statuses:
                    UCDB = 1.5
                    ai2_statuses.remove("UpperCutDB")
                    ai2_uc_db = 0
                ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2)) * 0.5 * (1 * HHDB * UCDB)
                ai2_statuses.append("WideSwingDB")
                ai2_ws_db = 1
            if 3 in target_list:
                if "HardHitterDB" in ai3_statuses:
                    HHDB = 1.25
                    ai3_statuses.remove("HardHitterDB")
                    ai3_hh_db = 0
                if "UpperCutDB" in ai3_statuses:
                    UCDB = 1.5
                    ai3_statuses.remove("UpperCutDB")
                    ai3_uc_db = 0
                ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3)) * 0.5 * (1 * HHDB * UCDB)
                ai3_statuses.append("WideSwingDB")
                ai3_ws_db = 1
            if 4 in target_list:
                if "HardHitterDB" in ai4_statuses:
                    HHDB = 1.25
                    ai4_statuses.remove("HardHitterDB")
                    ai4_hh_db = 0
                if "UpperCutDB" in ai4_statuses:
                    UCDB = 1.5
                    ai4_statuses.remove("UpperCutDB")
                    ai4_uc_db = 0
                ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4)) * 0.5 * (1 * HHDB * UCDB)
                ai4_statuses.append("WideSwingDB")
                ai4_ws_db = 1
            if 5 in target_list:
                if "HardHitterDB" in ai5_statuses:
                    HHDB = 1.25
                    ai5_statuses.remove("HardHitterDB")
                    ai5_hh_db = 0
                if "UpperCutDB" in ai5_statuses:
                    UCDB = 1.5
                    ai5_statuses.remove("UpperCutDB")
                    ai5_uc_db = 0
                ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5)) * 0.5 * (1 * HHDB * UCDB)
                ai5_statuses.append("WideSwingDB")
                ai5_ws_db = 1
        #Deals damage to chosen enemy and applies a debuff to them that makes the next 'Hard Hitter' or 'Wide Swing' deal 50% more damage
        #If the chosen enemy has the debuff left by 'Hard Hitter' or 'Wide Swing' hitting them, Uppercut deals 25% more damage and then removes the debuff
        elif ability_data[0] == "Uppercut":
            HHDB = 1
            WSDB = 1
            if 1 in target_list:
                if "HardHitterDB" in ai1_statuses:
                    HHDB = 1.25
                    ai1_statuses.remove("HardHitterDB")
                    ai1_hh_db = 0
                if "WideSwingDB" in ai1_statuses:
                    WSDB = 1.25
                    ai1_statuses.remove("WideSwingDB")
                    ai1_ws_db = 0
                ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1)) * 1.8 * (1 * HHDB * WSDB)
                ai1_statuses.append("UpperCutDB")
                ai1_uc_db = 1
            if 2 in target_list:
                if "HardHitterDB" in ai2_statuses:
                    HHDB = 1.25
                    ai2_statuses.remove("HardHitterDB")
                    ai2_hh_db = 0
                if "WideSwingDB" in ai2_statuses:
                    WSDB = 1.25
                    ai2_statuses.remove("WideSwingDB")
                    ai2_ws_db = 0
                ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2)) * 1.8 * (1 * HHDB * WSDB)
                ai2_statuses.append("UpperCutDB")
                ai2_uc_db = 1
            if 3 in target_list:
                if "HardHitterDB" in ai3_statuses:
                    HHDB = 1.25
                    ai3_statuses.remove("HardHitterDB")
                    ai3_hh_db = 0
                if "WideSwingDB" in ai3_statuses:
                    WSDB = 1.25
                    ai3_statuses.remove("WideSwingDB")
                    ai3_ws_db = 0
                ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3)) * 1.8 * (1 * HHDB * WSDB)
                ai3_statuses.append("UpperCutDB")
                ai3_uc_db = 1
            if 4 in target_list:
                if "HardHitterDB" in ai4_statuses:
                    HHDB = 1.25
                    ai4_statuses.remove("HardHitterDB")
                    ai4_hh_db = 0
                if "WideSwingDB" in ai4_statuses:
                    WSDB = 1.25
                    ai4_statuses.remove("WideSwingDB")
                    ai4_ws_db = 0
                ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4)) * 1.8 * (1 * HHDB * WSDB)
                ai4_statuses.append("UpperCutDB")
                ai4_uc_db = 1
            if 5 in target_list:
                if "HardHitterDB" in ai5_statuses:
                    HHDB = 1.25
                    ai5_statuses.remove("HardHitterDB")
                    ai5_hh_db = 0
                if "WideSwingDB" in ai5_statuses:
                    WSDB = 1.25
                    ai5_statuses.remove("WideSwingDB")
                    ai5_ws_db = 0
                ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5)) * 1.8 * (1 * HHDB * WSDB)
                ai5_statuses.append("UpperCutDB")
                ai5_uc_db = 1
        #Instantly kills chosen enemy if their remaining health points is lower than an amount of their maximum health depending on their size class
        #(Tiny > 50%) (Small > 40%) (Medium > 30%) (Large > 20%) (Huge > 10%)
        elif ability_data[0] == "Knock Out":
            if 1 in target_list:
                if AI_SIZE == "Tiny":
                    if ai1_hp < 0.5 * (AI_GROUP_HP + ai_health_modifier):
                        ai1_hp = 0
                if AI_SIZE == "Small":
                    if ai1_hp < 0.4 * (AI_GROUP_HP + ai_health_modifier):
                        ai1_hp = 0
                if AI_SIZE == "Medium":
                    if ai1_hp < 0.3 * (AI_GROUP_HP + ai_health_modifier):
                        ai1_hp = 0
                if AI_SIZE == "Large":
                    if ai1_hp < 0.2 * (AI_GROUP_HP + ai_health_modifier):
                        ai1_hp = 0
                if AI_SIZE == "Huge":
                    if ai1_hp < 0.1 * (AI_GROUP_HP + ai_health_modifier):
                        ai1_hp = 0
            if 2 in target_list:
                if AI_SIZE == "Tiny":
                    if ai2_hp < 0.5 * (AI_GROUP_HP + ai_health_modifier):
                        ai2_hp = 0
                if AI_SIZE == "Small":
                    if ai2_hp < 0.4 * (AI_GROUP_HP + ai_health_modifier):
                        ai2_hp = 0
                if AI_SIZE == "Medium":
                    if ai2_hp < 0.3 * (AI_GROUP_HP + ai_health_modifier):
                        ai2_hp = 0
                if AI_SIZE == "Large":
                    if ai2_hp < 0.2 * (AI_GROUP_HP + ai_health_modifier):
                        ai2_hp = 0
                if AI_SIZE == "Huge":
                    if ai2_hp < 0.1 * (AI_GROUP_HP + ai_health_modifier):
                        ai2_hp = 0
            if 3 in target_list:
                if AI_SIZE == "Tiny":
                    if ai3_hp < 0.5 * (AI_GROUP_HP + ai_health_modifier):
                        ai3_hp = 0
                if AI_SIZE == "Small":
                    if ai3_hp < 0.4 * (AI_GROUP_HP + ai_health_modifier):
                        ai3_hp = 0
                if AI_SIZE == "Medium":
                    if ai3_hp < 0.3 * (AI_GROUP_HP + ai_health_modifier):
                        ai3_hp = 0
                if AI_SIZE == "Large":
                    if ai3_hp < 0.2 * (AI_GROUP_HP + ai_health_modifier):
                        ai3_hp = 0
                if AI_SIZE == "Huge":
                    if ai3_hp < 0.1 * (AI_GROUP_HP + ai_health_modifier):
                        ai3_hp = 0
            if 4 in target_list:
                if AI_SIZE == "Tiny":
                    if ai4_hp < 0.5 * (AI_GROUP_HP + ai_health_modifier):
                        ai4_hp = 0
                if AI_SIZE == "Small":
                    if ai4_hp < 0.4 * (AI_GROUP_HP + ai_health_modifier):
                        ai4_hp = 0
                if AI_SIZE == "Medium":
                    if ai4_hp < 0.3 * (AI_GROUP_HP + ai_health_modifier):
                        ai4_hp = 0
                if AI_SIZE == "Large":
                    if ai4_hp < 0.2 * (AI_GROUP_HP + ai_health_modifier):
                        ai4_hp = 0
                if AI_SIZE == "Huge":
                    if ai4_hp < 0.1 * (AI_GROUP_HP + ai_health_modifier):
                        ai4_hp = 0
            if 5 in target_list:
                if AI_SIZE == "Tiny":
                    if ai5_hp < 0.5 * (AI_GROUP_HP + ai_health_modifier):
                        ai5_hp = 0
                if AI_SIZE == "Small":
                    if ai5_hp < 0.4 * (AI_GROUP_HP + ai_health_modifier):
                        ai5_hp = 0
                if AI_SIZE == "Medium":
                    if ai5_hp < 0.3 * (AI_GROUP_HP + ai_health_modifier):
                        ai5_hp = 0
                if AI_SIZE == "Large":
                    if ai5_hp < 0.2 * (AI_GROUP_HP + ai_health_modifier):
                        ai5_hp = 0
                if AI_SIZE == "Huge":
                    if ai5_hp < 0.1 * (AI_GROUP_HP + ai_health_modifier):
                        ai5_hp = 0
        #Deals damage to chosen enemy and applies the 'Brittle' debuff to them
        #Causing the affected enemy to take extra damage
        #Also gives all champions that use Mana 20 points of it
        elif ability_data[0] == "Frost Bolt":
            if 1 in target_list:
                ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1))
                self.apply_brittle(1, 2)
            if 2 in target_list:
                ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2))
                self.apply_brittle(2, 2)
            if 3 in target_list:
                ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3))
                self.apply_brittle(3, 2)
            if 4 in target_list:
                ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4))
                self.apply_brittle(4, 2)
            if 5 in target_list:
                ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5))
                self.apply_brittle(5, 2)
            if CHAMPION1_RPNAME == "Mana":
                champion1_rp = champion1_rp + 20
                if champion1_rp > CHAMPION1_RP:
                    champion1_rp = CHAMPION1_RP
            if CHAMPION2_RPNAME == "Mana":
                champion2_rp = champion2_rp + 20
                if champion2_rp > CHAMPION2_RP:
                    champion2_rp = CHAMPION2_RP
            if CHAMPION3_RPNAME == "Mana":
                champion3_rp = champion3_rp + 20
                if champion3_rp > CHAMPION3_RP:
                    champion3_rp = CHAMPION3_RP
            if CHAMPION4_RPNAME == "Mana":
                champion4_rp = champion4_rp + 20
                if champion4_rp > CHAMPION4_RP:
                    champion4_rp = CHAMPION4_RP
            if CHAMPION5_RPNAME == "Mana":
                champion5_rp = champion5_rp + 20
                if champion5_rp > CHAMPION5_RP:
                    champion5_rp = CHAMPION5_RP
        #Deals damage to chosen enemy and applies the 'Burning' damage over time effect to them
        #Also gives all champions that use Mana 20 points of it
        elif ability_data[0] == "Fireball":
            if 1 in target_list:
                ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1))
                self.apply_burnDot(1, 2)
            if 2 in target_list:
                ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2))
                self.apply_burnDot(2, 2)
            if 3 in target_list:
                ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3))
                self.apply_burnDot(3, 2)
            if 4 in target_list:
                ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4))
                self.apply_burnDot(4, 2)
            if 5 in target_list:
                ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5))
                self.apply_burnDot(5, 2)
            if CHAMPION1_RPNAME == "Mana":
                champion1_rp = champion1_rp + 20
                if champion1_rp > CHAMPION1_RP:
                    champion1_rp = CHAMPION1_RP
            if CHAMPION2_RPNAME == "Mana":
                champion2_rp = champion2_rp + 20
                if champion2_rp > CHAMPION2_RP:
                    champion2_rp = CHAMPION2_RP
            if CHAMPION3_RPNAME == "Mana":
                champion3_rp = champion3_rp + 20
                if champion3_rp > CHAMPION3_RP:
                    champion3_rp = CHAMPION3_RP
            if CHAMPION4_RPNAME == "Mana":
                champion4_rp = champion4_rp + 20
                if champion4_rp > CHAMPION4_RP:
                    champion4_rp = CHAMPION4_RP
            if CHAMPION5_RPNAME == "Mana":
                champion5_rp = champion5_rp + 20
                if champion5_rp > CHAMPION5_RP:
                    champion5_rp = CHAMPION5_RP
        #Randomly casts either Frostbolt or Fireball at random enemies five times
        elif ability_data[0] == "Arcane Brilliance":
            ai_list = []
            attacks = ["Frost Bolt", "Fireball"]
            if AI_SPAWNED == 1:
                ai_list.append(1)
            elif AI_SPAWNED == 2:
                if ai1_hp != 0:
                    ai_list.append(1)
                if ai2_hp != 0:
                    ai_list.append(2)
            elif AI_SPAWNED == 2:
                if ai1_hp != 0:
                    ai_list.append(1)
                if ai2_hp != 0:
                    ai_list.append(2)
            elif AI_SPAWNED == 3:
                if ai1_hp != 0:
                    ai_list.append(1)
                if ai2_hp != 0:
                    ai_list.append(2)
                if ai3_hp != 0:
                    ai_list.append(3)
            elif AI_SPAWNED == 4:
                if ai1_hp != 0:
                    ai_list.append(1)
                if ai2_hp != 0:
                    ai_list.append(2)
                if ai3_hp != 0:
                    ai_list.append(3)
                if ai4_hp != 0:
                    ai_list.append(4)
            elif AI_SPAWNED == 5:
                if ai1_hp != 0:
                    ai_list.append(1)
                if ai2_hp != 0:
                    ai_list.append(2)
                if ai3_hp != 0:
                    ai_list.append(3)
                if ai4_hp != 0:
                    ai_list.append(4)
                if ai5_hp != 0:
                    ai_list.append(5)
            for i in range(5):
                random.shuffle(ai_list)
                random.shuffle(attacks)
                if ai_list[0] == 1:
                    if attacks[0] == "Frost Bolt":
                        ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1))
                        self.apply_brittle(1, 2)
                    if attacks[0] == "Fireball":
                        self.apply_burnDot(1, 2)
                        ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1))
                if ai_list[0] == 2:
                    if attacks[0] == "Frost Bolt":
                        ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2))
                        self.apply_brittle(2, 2)
                    if attacks[0] == "Fireball":
                        ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2))
                        self.apply_burnDot(2, 2)
                if ai_list[0] == 3:
                    if attacks[0] == "Frost Bolt":
                        ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3))
                        self.apply_brittle(3, 2)
                        if attacks[0] == "Fireball":
                            ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3))
                            self.apply_burnDot(3, 2)
                if ai_list[0] == 4:
                    if attacks[0] == "Frost Bolt":
                        ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4))
                        self.apply_brittle(4, 2)
                        if attacks[0] == "Fireball":
                            ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4))
                            self.apply_burnDot(4, 2)
                if ai_list[0] == 5:
                    if attacks[0] == "Frost Bolt":
                        ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5))
                        self.apply_brittle(5, 2)
                        if attacks[0] == "Fireball":
                            ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5))
                            self.apply_burnDot(5, 2)
            if CHAMPION1_RPNAME == "Mana":
                champion1_rp = champion1_rp + 100
                if champion1_rp > CHAMPION1_RP:
                    champion1_rp = CHAMPION1_RP
            if CHAMPION2_RPNAME == "Mana":
                champion2_rp = champion2_rp + 100
                if champion2_rp > CHAMPION2_RP:
                    champion2_rp = CHAMPION2_RP
            if CHAMPION3_RPNAME == "Mana":
                champion3_rp = champion3_rp + 100
                if champion3_rp > CHAMPION3_RP:
                    champion3_rp = CHAMPION3_RP
            if CHAMPION4_RPNAME == "Mana":
                champion4_rp = champion4_rp + 100
                if champion4_rp > CHAMPION4_RP:
                    champion4_rp = CHAMPION4_RP
            if CHAMPION5_RPNAME == "Mana":
                champion5_rp = champion5_rp + 100
                if champion5_rp > CHAMPION5_RP:
                    champion5_rp = CHAMPION5_RP
        #Deals damage to chosen enemies and embeds them with two thorns
        elif ability_data[0] == "Vine-Swipe":
            if 1 in target_list:
                ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1))
                self.apply_thornsDot(1, 2)
            if 2 in target_list:
                ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2))
                self.apply_thornsDot(2, 2)
            if 3 in target_list:
                ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3))
                self.apply_thornsDot(3, 2)
            if 4 in target_list:
                ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4))
                self.apply_thornsDot(4, 2)
            if 5 in target_list:
                ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5))
                self.apply_thornsDot(5, 2)
        #Embeds one thorn into every alive enemy
        elif ability_data[0] == "Invigorate Thorns":
            if AI_SPAWNED == 1:
                self.apply_thornsDot(1, 1)
            if AI_SPAWNED == 2:
                if ai1_hp != 0:
                    self.apply_thornsDot(1, 1)
                if ai2_hp != 0:
                    self.apply_thornsDot(2, 1)
            if AI_SPAWNED == 3:
                if ai1_hp != 0:
                    self.apply_thornsDot(1, 1)
                if ai2_hp != 0:
                    self.apply_thornsDot(2, 1)
                if ai3_hp != 0:
                    self.apply_thornsDot(3, 1)
            if AI_SPAWNED == 4:
                if ai1_hp != 0:
                    self.apply_thornsDot(1, 1)
                if ai2_hp != 0:
                    self.apply_thornsDot(2, 1)
                if ai3_hp != 0:
                    self.apply_thornsDot(3, 1)
                if ai4_hp != 0:
                    self.apply_thornsDot(4, 1)
            if AI_SPAWNED == 5:
                if ai1_hp != 0:
                    self.apply_thornsDot(1, 1)
                if ai2_hp != 0:
                    self.apply_thornsDot(2, 1)
                if ai3_hp != 0:
                    self.apply_thornsDot(3, 1)
                if ai4_hp != 0:
                    self.apply_thornsDot(4, 1)
                if ai5_hp != 0:
                    self.apply_thornsDot(5, 1)
        #Causes all enemies 'Thorns' debuffs to explode
        #removing the stacks and causes each enemy to take damage equal to the amount of thorns removed from them
        elif ability_data[0] == "Burst N Bloom":
            if AI_SPAWNED == 1:
                if ai1_thornsDot[1] != 0:
                    ai1_hp = ai1_hp - 250 * ai1_thornsDot[1]
                    if ai1_hp < 0:
                        ai1_hp = 0
                    ai1_thornsDot = [0, 0]
            if AI_SPAWNED == 2:
                if ai1_thornsDot[1] != 0:
                    ai1_hp = ai1_hp - 250 * ai1_thornsDot[1]
                    if ai1_hp < 0:
                        ai1_hp = 0
                    ai1_thornsDot = [0, 0]
                if ai2_thornsDot[1] != 0:
                    ai2_hp = ai2_hp - 250 * ai2_thornsDot[1]
                    if ai2_hp < 0:
                        ai2_hp = 0
                    ai2_thornsDot = [0, 0]
            if AI_SPAWNED == 3:
                if ai1_thornsDot[1] != 0:
                    ai1_hp = ai1_hp - 250 * ai1_thornsDot[1]
                    if ai1_hp < 0:
                        ai1_hp = 0
                    ai1_thornsDot = [0, 0]
                if ai2_thornsDot[1] != 0:
                    ai2_hp = ai2_hp - 250 * ai2_thornsDot[1]
                    if ai2_hp < 0:
                        ai2_hp = 0
                    ai2_thornsDot = [0, 0]
                if ai3_thornsDot[1] != 0:
                    ai3_hp = ai3_hp - 250 * ai3_thornsDot[1]
                    if ai3_hp < 0:
                        ai3_hp = 0
                    ai3_thornsDot = [0, 0]
            if AI_SPAWNED == 4:
                if ai1_thornsDot[1] != 0:
                    ai1_hp = ai1_hp - 250 * ai1_thornsDot[1]
                    if ai1_hp < 0:
                        ai1_hp = 0
                    ai1_thornsDot = [0, 0]
                if ai2_thornsDot[1] != 0:
                    ai2_hp = ai2_hp - 250 * ai2_thornsDot[1]
                    if ai2_hp < 0:
                        ai2_hp = 0
                    ai2_thornsDot = [0, 0]
                if ai3_thornsDot[1] != 0:
                    ai3_hp = ai3_hp - 250 * ai3_thornsDot[1]
                    if ai3_hp < 0:
                        ai3_hp = 0
                    ai3_thornsDot = [0, 0]
                if ai4_thornsDot[1] != 0:
                    ai4_hp = ai4_hp - 250 * ai4_thornsDot[1]
                    if ai4_hp < 0:
                        ai4_hp = 0
                    ai4_thornsDot = [0, 0]
            if AI_SPAWNED == 5:
                if ai1_thornsDot[1] != 0:
                    ai1_hp = ai1_hp - 250 * ai1_thornsDot[1]
                    if ai1_hp < 0:
                        ai1_hp = 0
                    ai1_thornsDot = [0, 0]
                if ai2_thornsDot[1] != 0:
                    ai2_hp = ai2_hp - 250 * ai2_thornsDot[1]
                    if ai2_hp < 0:
                        ai2_hp = 0
                    ai2_thornsDot = [0, 0]
                if ai3_thornsDot[1] != 0:
                    ai3_hp = ai3_hp - 250 * ai3_thornsDot[1]
                    if ai3_hp < 0:
                        ai3_hp = 0
                    ai3_thornsDot = [0, 0]
                if ai4_thornsDot[1] != 0:
                    ai4_hp = ai4_hp - 250 * ai4_thornsDot[1]
                    if ai4_hp < 0:
                        ai4_hp = 0
                    ai4_thornsDot = [0, 0]
                if ai5_thornsDot[1] != 0:
                    ai5_hp = ai5_hp - 250 * ai5_thornsDot[1]
                    if ai5_hp < 0:
                        ai5_hp = 0
                    ai5_thornsDot = [0, 0]
        #Deals damage to chosen enemy, if the Warlock has the 'Void Infused' buff, the enemy is then given the 'Rotting' damage over time effect 
        #the damage of Rotting is proportional to the number of Void Infused stacks
        #If the chosen enemy already has the Rotting damage over time effect, the debuff is spread to another random alive enemy with the same damage and duration left
        #The chosen enemy is also given the 'Touch of Corruption' debuff
        #Which reduces the affected enemies damage dealt by 1%, stacking up to 10%
        elif ability_data[0] == "Black Bolt":
            global void_infusion_stacks
            if 1 in target_list:
                ai1_hp = ai1_hp - (math.ceil(ability_data[3] * self.check_enemy_vunerability(1)))
                self.apply_toc(1)
                if ai1_rottingDot[1] > 0:
                    if AI_SPAWNED == 1:
                        pass
                    if AI_SPAWNED == 2:
                        rottingSpread_list = []
                        if ai2_hp > 0:
                            rottingSpread_list.append(2)
                        random.shuffle(rottingSpread_list)
                        if rottingSpread_list[0] == 2:
                            self.apply_rottingDot(2, ai1_rottingDot[1], ai1_rottingDot[2])
                    if AI_SPAWNED == 3:
                        rottingSpread_list = []
                        if ai2_hp > 0:
                            rottingSpread_list.append(2)
                        if ai3_hp > 0:
                            rottingSpread_list.append(3)
                        random.shuffle(rottingSpread_list)
                        if rottingSpread_list[0] == 2:
                            self.apply_rottingDot(2, ai1_rottingDot[1], ai1_rottingDot[2])
                        if rottingSpread_list[0] == 3:
                            self.apply_rottingDot(3, ai1_rottingDot[1], ai1_rottingDot[2])
                    if AI_SPAWNED == 4:
                        rottingSpread_list = []
                        if ai2_hp > 0:
                            rottingSpread_list.append(2)
                        if ai3_hp > 0:
                            rottingSpread_list.append(3)
                        if ai4_hp > 0:
                            rottingSpread_list.append(4)
                        random.shuffle(rottingSpread_list)
                        if rottingSpread_list[0] == 2:
                            self.apply_rottingDot(2, ai1_rottingDot[1], ai1_rottingDot[2])
                        if rottingSpread_list[0] == 3:
                            self.apply_rottingDot(3, ai1_rottingDot[1], ai1_rottingDot[2])
                        if rottingSpread_list[0] == 4:
                            self.apply_rottingDot(4, ai1_rottingDot[1], ai1_rottingDot[2])
                    if AI_SPAWNED == 5:
                        rottingSpread_list = []
                        if ai2_hp > 0:
                            rottingSpread_list.append(2)
                        if ai3_hp > 0:
                            rottingSpread_list.append(3)
                        if ai4_hp > 0:
                            rottingSpread_list.append(4)
                        if ai5_hp > 0:
                            rottingSpread_list.append(5)
                        random.shuffle(rottingSpread_list)
                        if rottingSpread_list[0] == 2:
                            self.apply_rottingDot(2, ai1_rottingDot[1], ai1_rottingDot[2])
                        if rottingSpread_list[0] == 3:
                            self.apply_rottingDot(3, ai1_rottingDot[1], ai1_rottingDot[2])
                        if rottingSpread_list[0] == 4:
                            self.apply_rottingDot(4, ai1_rottingDot[1], ai1_rottingDot[2])
                        if rottingSpread_list[0] == 5:
                            self.apply_rottingDot(5, ai1_rottingDot[1], ai1_rottingDot[2])
                if void_infusion_stacks > 0:
                    self.apply_rottingDot(1, 3, void_infusion_stacks)
            if 2 in target_list:
                ai2_hp = ai2_hp - (math.ceil(ability_data[3] * self.check_enemy_vunerability(2)))
                self.apply_toc(2)
                if ai2_rottingDot[1] > 0:
                    if AI_SPAWNED == 2:
                        rottingSpread_list = []
                        if ai1_hp > 0:
                            rottingSpread_list.append(1)
                        random.shuffle(rottingSpread_list)
                        if rottingSpread_list[0] == 1:
                            self.apply_rottingDot(1, ai2_rottingDot[1], ai2_rottingDot[2])
                    if AI_SPAWNED == 3:
                        rottingSpread_list = []
                        if ai1_hp > 0:
                            rottingSpread_list.append(1)
                        if ai3_hp > 0:
                            rottingSpread_list.append(3)
                        random.shuffle(rottingSpread_list)
                        if rottingSpread_list[0] == 1:
                            self.apply_rottingDot(1, ai2_rottingDot[1], ai2_rottingDot[2])
                        if rottingSpread_list[0] == 3:
                            self.apply_rottingDot(3, ai2_rottingDot[1], ai2_rottingDot[2])
                    if AI_SPAWNED == 4:
                        rottingSpread_list = []
                        if ai1_hp > 0:
                            rottingSpread_list.append(1)
                        if ai3_hp > 0:
                            rottingSpread_list.append(3)
                        if ai4_hp > 0:
                            rottingSpread_list.append(4)
                        random.shuffle(rottingSpread_list)
                        if rottingSpread_list[0] == 1:
                            self.apply_rottingDot(2, ai2_rottingDot[1], ai2_rottingDot[2])
                        if rottingSpread_list[0] == 3:
                            self.apply_rottingDot(3, ai2_rottingDot[1], ai2_rottingDot[2])
                        if rottingSpread_list[0] == 4:
                            self.apply_rottingDot(4, ai2_rottingDot[1], ai2_rottingDot[2])
                    if AI_SPAWNED == 5:
                        rottingSpread_list = []
                        if ai1_hp > 0:
                            rottingSpread_list.append(1)
                        if ai3_hp > 0:
                            rottingSpread_list.append(3)
                        if ai4_hp > 0:
                            rottingSpread_list.append(4)
                        if ai5_hp > 0:
                            rottingSpread_list.append(5)
                        random.shuffle(rottingSpread_list)
                        if rottingSpread_list[0] == 1:
                            self.apply_rottingDot(2, ai2_rottingDot[1], ai2_rottingDot[2])
                        if rottingSpread_list[0] == 3:
                            self.apply_rottingDot(3, ai2_rottingDot[1], ai2_rottingDot[2])
                        if rottingSpread_list[0] == 4:
                            self.apply_rottingDot(4, ai2_rottingDot[1], ai2_rottingDot[2])
                        if rottingSpread_list[0] == 5:
                            self.apply_rottingDot(5, ai2_rottingDot[1], ai2_rottingDot[2])
                if void_infusion_stacks > 0:
                    self.apply_rottingDot(2, 3, void_infusion_stacks)
            if 3 in target_list:
                ai3_hp = ai3_hp - (math.ceil(ability_data[3] * self.check_enemy_vunerability(3)))
                self.apply_toc(3)
                if ai3_rottingDot[1] > 0:
                    if AI_SPAWNED == 3:
                        rottingSpread_list = []
                        if ai1_hp > 0:
                            rottingSpread_list.append(1)
                        if ai2_hp > 0:
                            rottingSpread_list.append(2)
                        random.shuffle(rottingSpread_list)
                        if rottingSpread_list[0] == 1:
                            self.apply_rottingDot(1, ai3_rottingDot[1], ai3_rottingDot[2])
                        if rottingSpread_list[0] == 2:
                            self.apply_rottingDot(2, ai3_rottingDot[1], ai3_rottingDot[2])
                    if AI_SPAWNED == 4:
                        rottingSpread_list = []
                        if ai1_hp > 0:
                            rottingSpread_list.append(1)
                        if ai2_hp > 0:
                            rottingSpread_list.append(2)
                        if ai4_hp > 0:
                            rottingSpread_list.append(4)
                        random.shuffle(rottingSpread_list)
                        if rottingSpread_list[0] == 1:
                            self.apply_rottingDot(1, ai3_rottingDot[1], ai3_rottingDot[2])
                        if rottingSpread_list[0] == 2:
                            self.apply_rottingDot(2, ai3_rottingDot[1], ai3_rottingDot[2])
                        if rottingSpread_list[0] == 4:
                            self.apply_rottingDot(4, ai3_rottingDot[1], ai3_rottingDot[2])
                    if AI_SPAWNED == 5:
                        rottingSpread_list = []
                        if ai1_hp > 0:
                            rottingSpread_list.append(1)
                        if ai2_hp > 0:
                            rottingSpread_list.append(2)
                        if ai4_hp > 0:
                            rottingSpread_list.append(4)
                        if ai5_hp > 0:
                            rottingSpread_list.append(5)
                        random.shuffle(rottingSpread_list)
                        if rottingSpread_list[0] == 1:
                            self.apply_rottingDot(1, ai3_rottingDot[1], ai3_rottingDot[2])
                        if rottingSpread_list[0] == 2:
                            self.apply_rottingDot(2, ai3_rottingDot[1], ai3_rottingDot[2])
                        if rottingSpread_list[0] == 4:
                            self.apply_rottingDot(4, ai3_rottingDot[1], ai3_rottingDot[2])
                        if rottingSpread_list[0] == 5:
                            self.apply_rottingDot(5, ai3_rottingDot[1], ai3_rottingDot[2])
                if void_infusion_stacks > 0:
                    self.apply_rottingDot(3, 3, void_infusion_stacks)
            if 4 in target_list:
                ai4_hp = ai4_hp - (math.ceil(ability_data[3] * self.check_enemy_vunerability(4)))
                self.apply_toc(4)
                if ai4_rottingDot[1] > 0:
                    if AI_SPAWNED == 4:
                        rottingSpread_list = []
                        if ai1_hp > 0:
                            rottingSpread_list.append(1)
                        if ai2_hp > 0:
                            rottingSpread_list.append(2)
                        if ai3_hp > 0:
                            rottingSpread_list.append(3)
                        random.shuffle(rottingSpread_list)
                        if rottingSpread_list[0] == 1:
                            self.apply_rottingDot(1, ai4_rottingDot[1], ai4_rottingDot[2])
                        if rottingSpread_list[0] == 2:
                            self.apply_rottingDot(2, ai4_rottingDot[1], ai4_rottingDot[2])
                        if rottingSpread_list[0] == 3:
                            self.apply_rottingDot(3, ai4_rottingDot[1], ai4_rottingDot[2])
                    if AI_SPAWNED == 5:
                        rottingSpread_list = []
                        if ai1_hp > 0:
                            rottingSpread_list.append(1)
                        if ai2_hp > 0:
                            rottingSpread_list.append(2)
                        if ai3_hp > 0:
                            rottingSpread_list.append(3)
                        if ai5_hp > 0:
                            rottingSpread_list.append(5)
                        random.shuffle(rottingSpread_list)
                        if rottingSpread_list[0] == 1:
                            self.apply_rottingDot(1, ai4_rottingDot[1], ai4_rottingDot[2])
                        if rottingSpread_list[0] == 2:
                            self.apply_rottingDot(2, ai4_rottingDot[1], ai4_rottingDot[2])
                        if rottingSpread_list[0] == 3:
                            self.apply_rottingDot(3, ai4_rottingDot[1], ai4_rottingDot[2])
                        if rottingSpread_list[0] == 5:
                            self.apply_rottingDot(5, ai4_rottingDot[1], ai4_rottingDot[2])
                if void_infusion_stacks > 0:
                    self.apply_rottingDot(4, 3, void_infusion_stacks)
            if 5 in target_list:
                ai5_hp = ai5_hp - (math.ceil(ability_data[3] * self.check_enemy_vunerability(5)))
                self.apply_toc(5)
                if ai5_rottingDot[1] > 0:
                    if AI_SPAWNED == 5:
                        rottingSpread_list = []
                        if ai1_hp > 0:
                            rottingSpread_list.append(1)
                        if ai2_hp > 0:
                            rottingSpread_list.append(2)
                        if ai3_hp > 0:
                            rottingSpread_list.append(3)
                        if ai4_hp > 0:
                            rottingSpread_list.append(4)
                        random.shuffle(rottingSpread_list)
                        if rottingSpread_list[0] == 1:
                            self.apply_rottingDot(1, ai5_rottingDot[1], ai5_rottingDot[2])
                        if rottingSpread_list[0] == 2:
                            self.apply_rottingDot(2, ai5_rottingDot[1], ai5_rottingDot[2])
                        if rottingSpread_list[0] == 3:
                            self.apply_rottingDot(3, ai5_rottingDot[1], ai5_rottingDot[2])
                        if rottingSpread_list[0] == 4:
                            self.apply_rottingDot(4, ai5_rottingDot[1], ai5_rottingDot[2])
                if void_infusion_stacks > 0:
                    self.apply_rottingDot(5, 3, void_infusion_stacks)
            void_infusion_stacks = 0
        #Causes chosen enemy to reduce the duration of all damage over time effects by one, if a damage over time effect is still active then its duration is further reduced by one.
        #Damage over time effects that have their timers reduced to 0 are removed as normal
        #For each time the duration of a damage over time ability was reduced, the enemy take damage equal to one turn of damage from that effect
        #Example1 > Dot deals 360 damage with 3 turns left. Wound Fissure causes the dot to go down to 1 turn because it was reduced twice and the enemy then takes 360 damage twice
        #Example2 > Dot deals 150 damage with 1 turn left. Wound Fissure reduces the Dot to 0 immediately, because the DoT is no longer active, the enemy only takes one lot of 150 damage
        elif ability_data[0] == "Wound Fissure":
            global ai1_burnDot, ai2_burnDot, ai3_burnDot, ai4_burnDot, ai5_burnDot, \
                ai1_serraSlashDot, ai2_serraSlashDot, ai3_serraSlashDot, ai4_serraSlashDot, ai5_serraSlashDot, \
                ai1_eviscerDot, ai2_eviscerDot, ai3_eviscerDot, ai4_eviscerDot, ai5_eviscerDot, \
                ai1_garroteDot, ai2_garroteDot, ai3_garroteDot, ai4_garroteDot, ai5_garroteDot, \
                ai1_shimmerDot, ai2_shimmerDot, ai3_shimmerDot, ai4_shimmerDot, ai5_shimmerDot,\
                ai1_divineDot, ai2_divineDot, ai3_divineDot, ai4_divineDot, ai5_divineDot
            counter = 0
            if 1 in target_list:
                if ai1_burnDot[1] > 0:
                    while ai1_burnDot[1] > 0:
                        if ai1_hp <= 0:
                            break
                        if counter == 2:
                            break
                        ai1_hp = ai1_hp - ai1_burnDot[0]
                        ai1_burnDot[1] = ai1_burnDot[1] - 1
                        counter += 1
                    counter = 0
                if ai1_serraSlashDot[1] > 0:
                    while ai1_serraSlashDot[1] > 0:
                        if ai1_hp <= 0:
                            break
                        if counter == 2:
                            break
                        ai1_hp = ai1_hp - self.calculate_bleed_damage("Serrated", 1)
                        ai1_serraSlashDot[1] = ai1_serraSlashDot[1] - 1
                        counter += 1
                    counter = 0
                if ai1_eviscerDot[1] > 0:
                    while ai1_eviscerDot[1] > 0:
                        if ai1_hp <= 0:
                            break
                        if counter == 2:
                            break
                        ai1_hp = ai1_hp - self.calculate_bleed_damage("Eviscerated", 1)
                        ai1_eviscerDot[1] = ai1_eviscerDot[1] - 1
                        counter += 1
                    counter = 0
                if ai1_garroteDot[1] > 0:
                    while ai1_garroteDot[1] > 0:
                        if ai1_hp <= 0:
                            break
                        if counter == 2:
                            break
                        ai1_hp = ai1_hp - self.calculate_bleed_damage("Garroted", 1)
                        ai1_garroteDot[1] = ai1_garroteDot[1] - 1
                        counter += 1
                    counter = 0
                if ai1_rottingDot[1] > 0:
                    while ai1_rottingDot[1] > 0:
                        if ai1_hp <= 0:
                            break
                        if counter == 2:
                            break
                        ai1_hp = ai1_hp - ai1_rottingDot[0]
                        self.apply_toc(1)
                        ai1_rottingDot[1] = ai1_rottingDot[1] - 1
                        counter += 1
                    counter = 0 
                if ai1_shimmerDot[1] > 0:
                    while ai1_shimmerDot[1] > 0:
                        if ai1_hp <= 0:
                            break
                        if counter == 2:
                            break
                        ai1_hp = ai1_hp - ai1_shimmerDot[0]
                        ai1_shimmerDot[1] = ai1_shimmerDot[1] - 1
                        if champion1_hp > 0:
                            self.check_champion_blessing(1, ai1_shimmerDot[0])
                        if champion2_hp > 0:
                            self.check_champion_blessing(2, ai1_shimmerDot[0])
                        if champion3_hp > 0:
                            self.check_champion_blessing(3, ai1_shimmerDot[0])
                        if champion4_hp > 0:
                            self.check_champion_blessing(4, ai1_shimmerDot[0])
                        if champion5_hp > 0:
                            self.check_champion_blessing(5, ai1_shimmerDot[0])
                        counter += 1
                    counter = 0
                if ai1_divineDot[1] > 0:
                    while ai1_divineDot[1] > 0:
                        if ai1_hp <= 0:
                            break
                        if counter == 2:
                            break
                        ai1_hp = ai1_hp - ai1_divineDot[0]
                        ai1_divineDot[1] = ai1_divineDot[1] - 1
                        if champion1_hp > 0:
                            self.check_champion_blessing(1, ai1_divineDot[0])
                        if champion2_hp > 0:
                            self.check_champion_blessing(2, ai1_divineDot[0])
                        if champion3_hp > 0:
                            self.check_champion_blessing(3, ai1_divineDot[0])
                        if champion4_hp > 0:
                            self.check_champion_blessing(4, ai1_divineDot[0])
                        if champion5_hp > 0:
                            self.check_champion_blessing(5, ai1_divineDot[0])
                        counter += 1
                    counter = 0
                if ai1_barbedArrDot[1] > 0:
                    while ai1_barbedArrDot[1] > 0:
                        if ai1_hp <= 0:
                            break
                        if counter == 2:
                            break
                        ai1_hp = ai1_hp - ai1_barbedArrDot[0]
                        ai1_barbedArrDot[1] = ai1_barbedArrDot[1] - 1
                        counter += 1
                    counter = 0
            if 2 in target_list:
                if ai2_burnDot[1] > 0:
                    while ai2_burnDot[1] > 0:
                        if ai2_hp <= 0:
                            break
                        if counter == 2:
                            break
                        ai2_hp = ai2_hp - ai2_burnDot[0]
                        ai2_burnDot[1] = ai2_burnDot[1] - 1
                        counter += 1
                    counter = 0
                if ai2_serraSlashDot[1] > 0:
                    while ai2_serraSlashDot[1] > 0:
                        if ai2_hp <= 0:
                            break
                        if counter == 2:
                            break
                        ai2_hp = ai2_hp - self.calculate_bleed_damage("Serrated", 2)
                        ai2_serraSlashDot[1] = ai2_serraSlashDot[1] - 1
                        counter += 1
                    counter = 0
                if ai2_eviscerDot[1] > 0:
                    while ai2_eviscerDot[1] > 0:
                        if ai2_hp <= 0:
                            break
                        if counter == 2:
                            break
                        ai2_hp = ai2_hp - self.calculate_bleed_damage("Eviscerated", 2)
                        ai2_eviscerDot[1] = ai2_eviscerDot[1] - 1
                        counter += 1
                    counter = 0
                if ai2_garroteDot[1] > 0:
                    while ai2_garroteDot[1] > 0:
                        if ai2_hp <= 0:
                            break
                        if counter == 2:
                            break
                        ai2_hp = ai2_hp - self.calculate_bleed_damage("Garroted", 2)
                        ai2_garroteDot[1] = ai2_garroteDot[1] - 1
                        counter += 1
                    counter = 0
                if ai2_rottingDot[1] > 0:
                    while ai2_rottingDot[1] > 0:
                        if ai2_hp <= 0:
                            break
                        if counter == 2:
                            break
                        ai2_hp = ai2_hp - ai2_rottingDot[0]
                        self.apply_toc(2)
                        ai2_rottingDot[1] = ai2_rottingDot[1] - 1
                        counter += 1
                    counter = 0
                if ai2_shimmerDot[1] > 0:
                    while ai2_shimmerDot[1] > 0:
                        if ai2_hp <= 0:
                            break
                        if counter ==2:
                            break
                        ai2_hp = ai2_hp - ai2_shimmerDot[0]
                        ai2_shimmerDot[1] = ai2_shimmerDot[1] - 1
                        if champion1_hp > 0:
                            self.check_champion_blessing(1, ai2_shimmerDot[0])
                        if champion2_hp > 0:
                            self.check_champion_blessing(2, ai2_shimmerDot[0])
                        if champion3_hp > 0:
                            self.check_champion_blessing(3, ai2_shimmerDot[0])
                        if champion4_hp > 0:
                            self.check_champion_blessing(4, ai2_shimmerDot[0])
                        if champion5_hp > 0:
                            self.check_champion_blessing(5, ai2_shimmerDot[0])
                        counter += 1
                    counter = 0
                if ai2_divineDot[1] > 0:
                    while ai2_divineDot[1] > 0:
                        if ai2_hp <= 0:
                            break
                        if counter ==2:
                            break
                        ai2_hp = ai2_hp - ai2_divineDot[0]
                        ai2_divineDot[1] = ai2_divineDot[1] - 1
                        if champion1_hp > 0:
                            self.check_champion_blessing(1, ai2_divineDot[0])
                        if champion2_hp > 0:
                            self.check_champion_blessing(2, ai2_divineDot[0])
                        if champion3_hp > 0:
                            self.check_champion_blessing(3, ai2_divineDot[0])
                        if champion4_hp > 0:
                            self.check_champion_blessing(4, ai2_divineDot[0])
                        if champion5_hp > 0:
                            self.check_champion_blessing(5, ai2_divineDot[0])
                        counter += 1
                    counter = 0
                if ai2_barbedArrDot[1] > 0:
                    while ai2_barbedArrDot[1] > 0:
                        if ai2_hp <= 0:
                            break
                        if counter == 2:
                            break
                        ai2_hp = ai2_hp - ai2_barbedArrDot[0]
                        ai2_barbedArrDot[1] = ai2_barbedArrDot[1] - 1
                        counter += 1
                    counter = 0
            if 3 in target_list:
                if ai3_burnDot[1] > 0:
                    while ai3_burnDot[1] > 0:
                        if ai3_hp <= 0:
                            break
                        if counter == 2:
                            break
                        ai3_hp = ai3_hp - ai3_burnDot[0]
                        ai3_burnDot[1] = ai3_burnDot[1] - 1
                        counter += 1
                    counter = 0
                if ai3_serraSlashDot[1] > 0:
                    while ai3_serraSlashDot[1] > 0:
                        if ai3_hp <= 0:
                            break
                        if counter == 2:
                            break
                        ai3_hp = ai3_hp - self.calculate_bleed_damage("Serrated", 3)
                        ai3_serraSlashDot[1] = ai3_serraSlashDot[1] - 1
                        counter += 1
                    counter = 0
                if ai3_eviscerDot[1] > 0:
                    while ai3_eviscerDot[1] > 0:
                        if ai3_hp <= 0:
                            break
                        if counter == 2:
                            break
                        ai3_hp = ai3_hp - self.calculate_bleed_damage("Eviscerated", 3)
                        ai3_eviscerDot[1] = ai3_eviscerDot[1] - 1
                        counter += 1
                    counter = 0
                if ai3_garroteDot[1] > 0:
                    while ai3_garroteDot[1] > 0:
                        if ai3_hp <= 0:
                            break
                        if counter == 2:
                            break
                        ai3_hp = ai3_hp - self.calculate_bleed_damage("Garroted", 3)
                        ai3_garroteDot[1] = ai3_garroteDot[1] - 1
                        counter += 1
                    counter = 0
                if ai3_rottingDot[1] > 0:
                    while ai3_rottingDot[1] > 0:
                        if ai3_hp <= 0:
                            break
                        if counter == 2:
                            break
                        ai3_hp = ai3_hp - ai3_rottingDot[0]
                        self.apply_toc(3)
                        ai3_rottingDot[1] = ai3_rottingDot[1] - 1
                        counter += 1
                    counter = 0
                if ai3_shimmerDot[1] > 0:
                    while ai3_shimmerDot[1] > 0:
                        if ai3_hp <= 0:
                            break
                        if counter ==2:
                            break
                        ai3_hp = ai3_hp - ai3_shimmerDot[0]
                        ai3_shimmerDot[1] = ai3_shimmerDot[1] - 1
                        if champion1_hp > 0:
                            self.check_champion_blessing(1, ai3_shimmerDot[0])
                        if champion2_hp > 0:
                            self.check_champion_blessing(2, ai3_shimmerDot[0])
                        if champion3_hp > 0:
                            self.check_champion_blessing(3, ai3_shimmerDot[0])
                        if champion4_hp > 0:
                            self.check_champion_blessing(4, ai3_shimmerDot[0])
                        if champion5_hp > 0:
                            self.check_champion_blessing(5, ai3_shimmerDot[0])
                        counter += 1
                    counter = 0
                if ai3_divineDot[1] > 0:
                    while ai3_divineDot[1] > 0:
                        if ai3_hp <= 0:
                            break
                        if counter ==2:
                            break
                        ai3_hp = ai3_hp - ai3_divineDot[0]
                        ai3_divineDot[1] = ai3_divineDot[1] - 1
                        if champion1_hp > 0:
                            self.check_champion_blessing(1, ai3_divineDot[0])
                        if champion2_hp > 0:
                            self.check_champion_blessing(2, ai3_divineDot[0])
                        if champion3_hp > 0:
                            self.check_champion_blessing(3, ai3_divineDot[0])
                        if champion4_hp > 0:
                            self.check_champion_blessing(4, ai3_divineDot[0])
                        if champion5_hp > 0:
                            self.check_champion_blessing(5, ai3_divineDot[0])
                        counter += 1
                    counter = 0
                if ai3_barbedArrDot[1] > 0:
                    while ai3_barbedArrDot[1] > 0:
                        if ai3_hp <= 0:
                            break
                        if counter == 2:
                            break
                        ai3_hp = ai3_hp - ai3_barbedArrDot[0]
                        ai3_barbedArrDot[1] = ai3_barbedArrDot[1] - 1
                        counter += 1
                    counter = 0
            if 4 in target_list:
                if ai4_burnDot[1] > 0:
                    while ai4_burnDot[1] > 0:
                        if ai4_hp <= 0:
                            break
                        if counter == 2:
                            break
                        ai4_hp = ai4_hp - ai4_burnDot[0]
                        ai4_burnDot[1] = ai4_burnDot[1] - 1
                        counter += 1
                    counter = 0
                if ai4_serraSlashDot[1] > 0:
                    while ai4_serraSlashDot[1] > 0:
                        if ai4_hp <= 0:
                            break
                        if counter == 2:
                            break
                        ai4_hp = ai4_hp - self.calculate_bleed_damage("Serrated", 4)
                        ai4_serraSlashDot[1] = ai4_serraSlashDot[1] - 1
                        counter += 1
                    counter = 0
                if ai4_eviscerDot[1] > 0:
                    while ai4_eviscerDot[1] > 0:
                        if ai4_hp <= 0:
                            break
                        if counter == 2:
                            break
                        ai4_hp = ai4_hp - self.calculate_bleed_damage("Eviscerated", 4)
                        ai4_eviscerDot[1] = ai4_eviscerDot[1] - 1
                        counter += 1
                    counter = 0
                if ai4_garroteDot[1] > 0:
                    while ai4_garroteDot[1] > 0:
                        if ai4_hp <= 0:
                            break
                        if counter == 2:
                            break
                        ai4_hp = ai4_hp - self.calculate_bleed_damage("Garroted", 4)
                        ai4_garroteDot[1] = ai4_garroteDot[1] - 1
                        counter += 1
                    counter = 0
                if ai4_rottingDot[1] > 0:
                    while ai4_rottingDot[1] > 0:
                        if ai4_hp <= 0:
                            break
                        if counter == 2:
                            break
                        ai4_hp = ai4_hp - ai4_rottingDot[0]
                        self.apply_toc(4)
                        ai4_rottingDot[1] = ai4_rottingDot[1] - 1
                        counter += 1
                    counter = 0
                if ai4_shimmerDot[1] > 0:
                    while ai4_shimmerDot[1] > 0:
                        if ai4_hp <= 0:
                            break
                        if counter ==2:
                            break
                        ai4_hp = ai4_hp - ai4_shimmerDot[0]
                        ai4_shimmerDot[1] = ai4_shimmerDot[1] - 1
                        if champion1_hp > 0:
                            self.check_champion_blessing(1, ai4_shimmerDot[0])
                        if champion2_hp > 0:
                            self.check_champion_blessing(2, ai4_shimmerDot[0])
                        if champion3_hp > 0:
                            self.check_champion_blessing(3, ai4_shimmerDot[0])
                        if champion4_hp > 0:
                            self.check_champion_blessing(4, ai4_shimmerDot[0])
                        if champion5_hp > 0:
                            self.check_champion_blessing(5, ai4_shimmerDot[0])
                        counter += 1
                    counter = 0
                if ai4_divineDot[1] > 0:
                    while ai4_divineDot[1] > 0:
                        if ai4_hp <= 0:
                            break
                        if counter ==2:
                            break
                        ai4_hp = ai4_hp - ai4_divineDot[0]
                        ai4_divineDot[1] = ai4_divineDot[1] - 1
                        if champion1_hp > 0:
                            self.check_champion_blessing(1, ai4_divineDot[0])
                        if champion2_hp > 0:
                            self.check_champion_blessing(2, ai4_divineDot[0])
                        if champion3_hp > 0:
                            self.check_champion_blessing(3, ai4_divineDot[0])
                        if champion4_hp > 0:
                            self.check_champion_blessing(4, ai4_divineDot[0])
                        if champion5_hp > 0:
                            self.check_champion_blessing(5, ai4_divineDot[0])
                        counter += 1
                    counter = 0
                if ai4_barbedArrDot[1] > 0:
                    while ai4_barbedArrDot[1] > 0:
                        if ai4_hp <= 0:
                            break
                        if counter == 2:
                            break
                        ai4_hp = ai4_hp - ai4_barbedArrDot[0]
                        ai4_barbedArrDot[1] = ai4_barbedArrDot[1] - 1
                        counter += 1
                    counter = 0
            if 5 in target_list:
                if ai5_burnDot[1] > 0:
                    while ai5_burnDot[1] > 0:
                        if ai5_hp <= 0:
                            break
                        if counter == 2:
                            break
                        ai5_hp = ai5_hp - ai5_burnDot[0]
                        ai5_burnDot[1] = ai5_burnDot[1] - 1
                        counter += 1
                    counter = 0
                if ai5_serraSlashDot[1] > 0:
                    while ai5_serraSlashDot[1] > 0:
                        if ai5_hp <= 0:
                            break
                        if counter == 2:
                            break
                        ai5_hp = ai5_hp - self.calculate_bleed_damage("Serrated", 5)
                        ai5_serraSlashDot[1] = ai5_serraSlashDot[1] - 1
                        counter += 1
                    counter = 0
                if ai5_eviscerDot[1] > 0:
                    while ai5_eviscerDot[1] > 0:
                        if ai5_hp <= 0:
                            break
                        if counter == 2:
                            break
                        ai5_hp = ai5_hp - self.calculate_bleed_damage("Eviscerated", 5)
                        ai5_eviscerDot[1] = ai5_eviscerDot[1] - 1
                        counter += 1
                    counter = 0
                if ai5_garroteDot[1] > 0:
                    while ai5_garroteDot[1] > 0:
                        if ai5_hp <= 0:
                            break
                        if counter == 2:
                            break
                        ai5_hp = ai5_hp - self.calculate_bleed_damage("Garroted", 5)
                        ai5_garroteDot[1] = ai5_garroteDot[1] - 1
                        counter += 1
                    counter = 0 
                if ai5_rottingDot[1] > 0:
                    while ai5_rottingDot[1] > 0:
                        if ai5_hp <= 0:
                            break
                        if counter == 2:
                            break
                        ai5_hp = ai5_hp - ai5_rottingDot[0]
                        self.apply_toc(5)
                        ai5_rottingDot[1] = ai5_rottingDot[1] - 1
                        counter += 1
                    counter = 0
                if ai5_shimmerDot[1] > 0:
                    while ai5_shimmerDot[1] > 0:
                        if ai5_hp <= 0:
                            break
                        if counter ==2:
                            break
                        ai5_hp = ai5_hp - ai5_shimmerDot[0]
                        ai5_shimmerDot[1] = ai5_shimmerDot[1] - 1
                        if champion1_hp > 0:
                            self.check_champion_blessing(1, ai5_shimmerDot[0])
                        if champion2_hp > 0:
                            self.check_champion_blessing(2, ai5_shimmerDot[0])
                        if champion3_hp > 0:
                            self.check_champion_blessing(3, ai5_shimmerDot[0])
                        if champion4_hp > 0:
                            self.check_champion_blessing(4, ai5_shimmerDot[0])
                        if champion5_hp > 0:
                            self.check_champion_blessing(5, ai5_shimmerDot[0])
                        counter += 1
                    counter = 0
                if ai5_divineDot[1] > 0:
                    while ai5_divineDot[1] > 0:
                        if ai5_hp <= 0:
                            break
                        if counter ==2:
                            break
                        ai5_hp = ai5_hp - ai5_divineDot[0]
                        ai5_divineDot[1] = ai5_divineDot[1] - 1
                        if champion1_hp > 0:
                            self.check_champion_blessing(1, ai5_divineDot[0])
                        if champion2_hp > 0:
                            self.check_champion_blessing(2, ai5_divineDot[0])
                        if champion3_hp > 0:
                            self.check_champion_blessing(3, ai5_divineDot[0])
                        if champion4_hp > 0:
                            self.check_champion_blessing(4, ai5_divineDot[0])
                        if champion5_hp > 0:
                            self.check_champion_blessing(5, ai5_divineDot[0])
                        counter += 1
                    counter = 0
                if ai5_barbedArrDot[1] > 0:
                    while ai5_barbedArrDot[1] > 0:
                        if ai5_hp <= 0:
                            break
                        if counter == 2:
                            break
                        ai5_hp = ai5_hp - ai5_barbedArrDot[0]
                        ai5_barbedArrDot[1] = ai5_barbedArrDot[1] - 1
                        counter += 1
                    counter = 0
            if ai1_burnDot[1] <= 0:
                ai1_burnDot[1] = 0
                if "Burning" in ai1_statuses:
                    ai1_statuses.remove("Burning")
            if ai2_burnDot[1] <= 0:
                ai2_burnDot[1] = 0
                if "Burning" in ai2_statuses:
                    ai2_statuses.remove("Burning")
            if ai3_burnDot[1] <= 0:
                ai3_burnDot[1] = 0
                if "Burning" in ai3_statuses:
                    ai3_statuses.remove("Burning")
            if ai4_burnDot[1] <= 0:
                ai4_burnDot[1] = 0
                if "Burning" in ai4_statuses:
                    ai4_statuses.remove("Burning")
            if ai5_burnDot[1] <= 0:
                ai5_burnDot[1] = 0
                if "Burning" in ai5_statuses:
                    ai5_statuses.remove("Burning")
            if ai1_garroteDot[1] <= 0:
                ai1_garroteDot[1] = 0
                if "Garroted" in ai1_statuses:
                    ai1_statuses.remove("Garroted")
            if ai2_garroteDot[1] <= 0:
                ai2_garroteDot[1] = 0
                if "Garroted" in ai2_statuses:
                    ai2_statuses.remove("Garroted")
            if ai3_garroteDot[1] <= 0:
                ai3_garroteDot[1] = 0
                if "Garroted" in ai3_statuses:
                    ai3_statuses.remove("Garroted")
            if ai4_garroteDot[1] <= 0:
                ai4_garroteDot[1] = 0
                if "Garroted" in ai4_statuses:
                    ai4_statuses.remove("Garroted")
            if ai5_garroteDot[1] <= 0:
                ai5_garroteDot[1] = 0
                if "Garroted" in ai5_statuses:
                    ai5_statuses.remove("Garroted")
            if ai1_rottingDot[1] <= 0:
                ai1_rottingDot[1] = 0
                if "Rotting" in ai1_statuses:
                    ai1_statuses.remove("Rotting")
            if ai2_rottingDot[1] <= 0:
                ai2_rottingDot[1] = 0
                if "Rotting" in ai2_statuses:
                    ai2_statuses.remove("Rotting")
            if ai3_rottingDot[1] <= 0:
                ai3_rottingDot[1] = 0
                if "Rotting" in ai3_statuses:
                    ai3_statuses.remove("Rotting")
            if ai4_rottingDot[1] <= 0:
                ai4_rottingDot[1] = 0
                if "Rotting" in ai4_statuses:
                    ai4_statuses.remove("Rotting")
            if ai5_rottingDot[1] <= 0:
                ai5_rottingDot[1] = 0
                if "Rotting" in ai5_statuses:
                    ai5_statuses.remove("Rotting")
            if ai1_serraSlashDot[1] <= 0:
                ai1_serraSlashDot[1] = 0
                if "Serrated" in ai1_statuses:
                    ai1_statuses.remove("Serrated")
            if ai2_serraSlashDot[1] <= 0:
                ai2_serraSlashDot[1] = 0
                if "Serrated" in ai2_statuses:
                    ai2_statuses.remove("Serrated")
            if ai3_serraSlashDot[1] <= 0:
                ai3_serraSlashDot[1] = 0
                if "Serrated" in ai3_statuses:
                    ai3_statuses.remove("Serrated")
            if ai4_serraSlashDot[1] <= 0:
                ai4_serraSlashDot[1] = 0
                if "Serrated" in ai4_statuses:
                    ai4_statuses.remove("Serrated")
            if ai5_serraSlashDot[1] <= 0:
                ai5_serraSlashDot[1] = 0
                if "Serrated" in ai5_statuses:
                    ai5_statuses.remove("Serrated")
            if ai1_eviscerDot[1] <= 0:
                ai1_eviscerDot[1] = 0
                if "Eviscerated" in ai1_statuses:
                    ai1_statuses.remove("Eviscerated")
            if ai2_eviscerDot[1] <= 0:
                ai2_eviscerDot[1] = 0
                if "Eviscerated" in ai2_statuses:
                    ai2_statuses.remove("Eviscerated")
            if ai3_eviscerDot[1] <= 0:
                ai3_eviscerDot[1] = 0
                if "Eviscerated" in ai3_statuses:
                    ai3_statuses.remove("Eviscerated")
            if ai4_eviscerDot[1] <= 0:
                ai4_eviscerDot[1] = 0
                if "Eviscerated" in ai4_statuses:
                    ai4_statuses.remove("Eviscerated")
            if ai5_eviscerDot[1] <= 0:
                ai5_eviscerDot[1] = 0
                if "Eviscerated" in ai5_statuses:
                    ai5_statuses.remove("Eviscerated")
            if ai1_shimmerDot[1] <= 0:
                ai1_shimmerDot[1] = 0
                if "Sizzling Light" in ai1_statuses:
                    ai1_statuses.remove("Sizzling Light")
            if ai2_shimmerDot[1] <= 0:
                ai2_shimmerDot[1] = 0
                if "Sizzling Light" in ai2_statuses:
                    ai2_statuses.remove("Sizzling Light")
            if ai3_shimmerDot[1] <= 0:
                ai3_shimmerDot[1] = 0
                if "Sizzling Light" in ai3_statuses:
                    ai3_statuses.remove("Sizzling Light")
            if ai4_shimmerDot[1] <= 0:
                ai4_shimmerDot[1] = 0
                if "Sizzling Light" in ai4_statuses:
                    ai4_statuses.remove("Sizzling Light")
            if ai5_shimmerDot[1] <= 0:
                ai5_shimmerDot[1] = 0
                if "Sizzling Light" in ai5_statuses:
                    ai5_statuses.remove("Sizzling Light")
            if ai1_divineDot[1] <= 0:
                ai1_divineDot[1] = 0
                if "Searing Light" in ai1_statuses:
                    ai1_statuses.remove("Searing Light")
            if ai2_divineDot[1] <= 0:
                ai2_divineDot[1] = 0
                if "Searing Light" in ai2_statuses:
                    ai2_statuses.remove("Searing Light")
            if ai3_divineDot[1] <= 0:
                ai3_divineDot[1] = 0
                if "Searing Light" in ai3_statuses:
                    ai3_statuses.remove("Searing Light")
            if ai4_divineDot[1] <= 0:
                ai4_divineDot[1] = 0
                if "Searing Light" in ai4_statuses:
                    ai4_statuses.remove("Searing Light")
            if ai5_divineDot[1] <= 0:
                ai5_divineDot[1] = 0
                if "Searing Light" in ai5_statuses:
                    ai5_statuses.remove("Searing Light")
            if ai1_barbedArrDot[1] <= 0:
                ai1_barbedArrDot[1] = 0
                if "Barbed" in ai1_statuses:
                    ai1_statuses.remove("Barbed")
            if ai2_barbedArrDot[1] <= 0:
                ai2_barbedArrDot[1] = 0
                if "Barbed" in ai2_statuses:
                    ai2_statuses.remove("Barbed")
            if ai3_barbedArrDot[1] <= 0:
                ai3_barbedArrDot[1] = 0
                if "Barbed" in ai3_statuses:
                    ai3_statuses.remove("Barbed")
            if ai4_barbedArrDot[1] <= 0:
                ai4_barbedArrDot[1] = 0
                if "Barbed" in ai4_statuses:
                    ai4_statuses.remove("Barbed")
            if ai5_barbedArrDot[1] <= 0:
                ai5_barbedArrDot[1] = 0
                if "Barbed" in ai5_statuses:
                    ai5_statuses.remove("Barbed")
        #Deal damage to chosen enemy and heal the Bloodmancer equal to the damage done
        #If the Bloodmancer has the 'Blood Boil' buff, all other alive allies heal 30% of the damage done
        #Casting the empowered ability gives the Bloodmancer the 'Channeling Strength' buff which causes the next allies damaging or healing ability to be 50% effective
        elif ability_data[0] == "Drain Life":
            global blood_boil_buff
            if 1 in target_list:
                ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1))
                if blood_boil_buff == True:
                    champion1_hp = champion1_hp + math.ceil((ability_data[3] * self.check_enemy_vunerability(1))*0.3)
                    if champion1_hp > CHAMPION1_HP:
                        champion1_hp = CHAMPION1_HP
                    champion2_hp = champion2_hp + math.ceil((ability_data[3] * self.check_enemy_vunerability(1))*0.3)
                    if champion2_hp > CHAMPION2_HP:
                        champion2_hp = CHAMPION2_HP
                    champion3_hp = champion3_hp + math.ceil((ability_data[3] * self.check_enemy_vunerability(1))*0.3)
                    if champion3_hp > CHAMPION3_HP:
                        champion3_hp = CHAMPION3_HP
                    champion4_hp = champion4_hp + math.ceil((ability_data[3] * self.check_enemy_vunerability(1))*0.3)
                    if champion4_hp > CHAMPION4_HP:
                        champion4_hp = CHAMPION4_HP
                    champion5_hp = champion5_hp + math.ceil((ability_data[3] * self.check_enemy_vunerability(1))*0.3)
                    if champion5_hp > CHAMPION5_HP:
                        champion5_hp = CHAMPION5_HP
                    blood_boil_buff = False
                else:
                    for champions in CHAMPION_LIST:
                        counter += 1
                        if champions == BLOODMANCER.title:
                            if counter == 1:
                                champion1_hp = champion1_hp + math.ceil((ability_data[3] * self.check_enemy_vunerability(1)))
                                if champion1_hp > CHAMPION1_HP:
                                    champion1_hp = CHAMPION1_HP
                            elif counter == 2:
                                champion2_hp = champion2_hp + math.ceil((ability_data[3] * self.check_enemy_vunerability(1)))
                                if champion2_hp > CHAMPION2_HP:
                                    champion2_hp = CHAMPION2_HP
                            elif counter == 3:
                                champion3_hp = champion3_hp + math.ceil((ability_data[3] * self.check_enemy_vunerability(1)))
                                if champion3_hp > CHAMPION3_HP:
                                    champion3_hp = CHAMPION3_HP
                            elif counter == 4:
                                champion4_hp = champion4_hp + math.ceil((ability_data[3] * self.check_enemy_vunerability(1)))
                                if champion4_hp > CHAMPION4_HP:
                                    champion4_hp = CHAMPION4_HP
                            elif counter == 5:
                                champion5_hp = champion5_hp + math.ceil((ability_data[3] * self.check_enemy_vunerability(1)))
                                if champion5_hp > CHAMPION5_HP:
                                    champion5_hp = CHAMPION5_HP
            if 2 in target_list:
                ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2))
                if blood_boil_buff == True:
                    champion1_hp = champion1_hp + math.ceil((ability_data[3] * self.check_enemy_vunerability(2))*0.3)
                    if champion1_hp > CHAMPION1_HP:
                        champion1_hp = CHAMPION1_HP
                    champion2_hp = champion2_hp + math.ceil((ability_data[3] * self.check_enemy_vunerability(2))*0.3)
                    if champion2_hp > CHAMPION2_HP:
                        champion2_hp = CHAMPION2_HP
                    champion3_hp = champion3_hp + math.ceil((ability_data[3] * self.check_enemy_vunerability(2))*0.3)
                    if champion3_hp > CHAMPION3_HP:
                        champion3_hp = CHAMPION3_HP
                    champion4_hp = champion4_hp + math.ceil((ability_data[3] * self.check_enemy_vunerability(2))*0.3)
                    if champion4_hp > CHAMPION4_HP:
                        champion4_hp = CHAMPION4_HP
                    champion5_hp = champion5_hp + math.ceil((ability_data[3] * self.check_enemy_vunerability(2))*0.3)
                    if champion5_hp > CHAMPION5_HP:
                        champion5_hp = CHAMPION5_HP
                    blood_boil_buff = False
                else:
                    for champions in CHAMPION_LIST:
                        counter += 1
                        if champions == BLOODMANCER.title:
                            if counter == 1:
                                champion1_hp = champion1_hp + math.ceil((ability_data[3] * self.check_enemy_vunerability(2)))
                                if champion1_hp > CHAMPION1_HP:
                                    champion1_hp = CHAMPION1_HP
                            elif counter == 2:
                                champion2_hp = champion2_hp + math.ceil((ability_data[3] * self.check_enemy_vunerability(2)))
                                if champion2_hp > CHAMPION2_HP:
                                    champion2_hp = CHAMPION2_HP
                            elif counter == 3:
                                champion3_hp = champion3_hp + math.ceil((ability_data[3] * self.check_enemy_vunerability(2)))
                                if champion3_hp > CHAMPION3_HP:
                                    champion3_hp = CHAMPION3_HP
                            elif counter == 4:
                                champion4_hp = champion4_hp + math.ceil((ability_data[3] * self.check_enemy_vunerability(2)))
                                if champion4_hp > CHAMPION4_HP:
                                    champion4_hp = CHAMPION4_HP
                            elif counter == 5:
                                champion5_hp = champion5_hp + math.ceil((ability_data[3] * self.check_enemy_vunerability(2)))
                                if champion5_hp > CHAMPION5_HP:
                                    champion5_hp = CHAMPION5_HP
            if 3 in target_list:
                ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3))
                if blood_boil_buff == True:
                    champion1_hp = champion1_hp + math.ceil((ability_data[3] * self.check_enemy_vunerability(3))*0.3)
                    if champion1_hp > CHAMPION1_HP:
                        champion1_hp = CHAMPION1_HP
                    champion2_hp = champion2_hp + math.ceil((ability_data[3] * self.check_enemy_vunerability(3))*0.3)
                    if champion2_hp > CHAMPION2_HP:
                        champion2_hp = CHAMPION2_HP
                    champion3_hp = champion3_hp + math.ceil((ability_data[3] * self.check_enemy_vunerability(3))*0.3)
                    if champion3_hp > CHAMPION3_HP:
                        champion3_hp = CHAMPION3_HP
                    champion4_hp = champion4_hp + math.ceil((ability_data[3] * self.check_enemy_vunerability(3))*0.3)
                    if champion4_hp > CHAMPION4_HP:
                        champion4_hp = CHAMPION4_HP
                    champion5_hp = champion5_hp + math.ceil((ability_data[3] * self.check_enemy_vunerability(3))*0.3)
                    if champion5_hp > CHAMPION5_HP:
                        champion5_hp = CHAMPION5_HP
                    blood_boil_buff = False
                else:
                    for champions in CHAMPION_LIST:
                        counter += 1
                        if champions == BLOODMANCER.title:
                            if counter == 1:
                                champion1_hp = champion1_hp + math.ceil((ability_data[3] * self.check_enemy_vunerability(3)))
                                if champion1_hp > CHAMPION1_HP:
                                    champion1_hp = CHAMPION1_HP
                            elif counter == 2:
                                champion2_hp = champion2_hp + math.ceil((ability_data[3] * self.check_enemy_vunerability(3)))
                                if champion2_hp > CHAMPION2_HP:
                                    champion2_hp = CHAMPION2_HP
                            elif counter == 3:
                                champion3_hp = champion3_hp + math.ceil((ability_data[3] * self.check_enemy_vunerability(3)))
                                if champion3_hp > CHAMPION3_HP:
                                    champion3_hp = CHAMPION3_HP
                            elif counter == 4:
                                champion4_hp = champion4_hp + math.ceil((ability_data[3] * self.check_enemy_vunerability(3)))
                                if champion4_hp > CHAMPION4_HP:
                                    champion4_hp = CHAMPION4_HP
                            elif counter == 5:
                                champion5_hp = champion5_hp + math.ceil((ability_data[3] * self.check_enemy_vunerability(3)))
                                if champion5_hp > CHAMPION5_HP:
                                    champion5_hp = CHAMPION5_HP
            if 4 in target_list:
                ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4))
                if blood_boil_buff == True:
                    champion1_hp = champion1_hp + math.ceil((ability_data[3] * self.check_enemy_vunerability(4))*0.3)
                    if champion1_hp > CHAMPION1_HP:
                        champion1_hp = CHAMPION1_HP
                    champion2_hp = champion2_hp + math.ceil((ability_data[3] * self.check_enemy_vunerability(4))*0.3)
                    if champion2_hp > CHAMPION2_HP:
                        champion2_hp = CHAMPION2_HP
                    champion3_hp = champion3_hp + math.ceil((ability_data[3] * self.check_enemy_vunerability(4))*0.3)
                    if champion3_hp > CHAMPION3_HP:
                        champion3_hp = CHAMPION3_HP
                    champion4_hp = champion4_hp + math.ceil((ability_data[3] * self.check_enemy_vunerability(4))*0.3)
                    if champion4_hp > CHAMPION4_HP:
                        champion4_hp = CHAMPION4_HP
                    champion5_hp = champion5_hp + math.ceil((ability_data[3] * self.check_enemy_vunerability(4))*0.3)
                    if champion5_hp > CHAMPION5_HP:
                        champion5_hp = CHAMPION5_HP
                    blood_boil_buff = False
                else:
                    for champions in CHAMPION_LIST:
                        counter += 1
                        if champions == BLOODMANCER.title:
                            if counter == 1:
                                champion1_hp = champion1_hp + math.ceil((ability_data[3] * self.check_enemy_vunerability(4)))
                                if champion1_hp > CHAMPION1_HP:
                                    champion1_hp = CHAMPION1_HP
                            elif counter == 2:
                                champion2_hp = champion2_hp + math.ceil((ability_data[3] * self.check_enemy_vunerability(4)))
                                if champion2_hp > CHAMPION2_HP:
                                    champion2_hp = CHAMPION2_HP
                            elif counter == 3:
                                champion3_hp = champion3_hp + math.ceil((ability_data[3] * self.check_enemy_vunerability(4)))
                                if champion3_hp > CHAMPION3_HP:
                                    champion3_hp = CHAMPION3_HP
                            elif counter == 4:
                                champion4_hp = champion4_hp + math.ceil((ability_data[3] * self.check_enemy_vunerability(4)))
                                if champion4_hp > CHAMPION4_HP:
                                    champion4_hp = CHAMPION4_HP
                            elif counter == 5:
                                champion5_hp = champion5_hp + math.ceil((ability_data[3] * self.check_enemy_vunerability(4)))
                                if champion5_hp > CHAMPION5_HP:
                                    champion5_hp = CHAMPION5_HP
            if 5 in target_list:
                ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5))
                if blood_boil_buff == True:
                    champion1_hp = champion1_hp + math.ceil((ability_data[3] * self.check_enemy_vunerability(5))*0.3)
                    if champion1_hp > CHAMPION1_HP:
                        champion1_hp = CHAMPION1_HP
                    champion2_hp = champion2_hp + math.ceil((ability_data[3] * self.check_enemy_vunerability(5))*0.3)
                    if champion2_hp > CHAMPION2_HP:
                        champion2_hp = CHAMPION2_HP
                    champion3_hp = champion3_hp + math.ceil((ability_data[3] * self.check_enemy_vunerability(5))*0.3)
                    if champion3_hp > CHAMPION3_HP:
                        champion3_hp = CHAMPION3_HP
                    champion4_hp = champion4_hp + math.ceil((ability_data[3] * self.check_enemy_vunerability(5))*0.3)
                    if champion4_hp > CHAMPION4_HP:
                        champion4_hp = CHAMPION4_HP
                    champion5_hp = champion5_hp + math.ceil((ability_data[3] * self.check_enemy_vunerability(5))*0.3)
                    if champion5_hp > CHAMPION5_HP:
                        champion5_hp = CHAMPION5_HP
                    blood_boil_buff = False
                else:
                    for champions in CHAMPION_LIST:
                        counter += 1
                        if champions == BLOODMANCER.title:
                            if counter == 1:
                                champion1_hp = champion1_hp + math.ceil((ability_data[3] * self.check_enemy_vunerability(5)))
                                if champion1_hp > CHAMPION1_HP:
                                    champion1_hp = CHAMPION1_HP
                            elif counter == 2:
                                champion2_hp = champion2_hp + math.ceil((ability_data[3] * self.check_enemy_vunerability(5)))
                                if champion2_hp > CHAMPION2_HP:
                                    champion2_hp = CHAMPION2_HP
                            elif counter == 3:
                                champion3_hp = champion3_hp + math.ceil((ability_data[3] * self.check_enemy_vunerability(5)))
                                if champion3_hp > CHAMPION3_HP:
                                    champion3_hp = CHAMPION3_HP
                            elif counter == 4:
                                champion4_hp = champion4_hp + math.ceil((ability_data[3] * self.check_enemy_vunerability(5)))
                                if champion4_hp > CHAMPION4_HP:
                                    champion4_hp = CHAMPION4_HP
                            elif counter == 5:
                                champion5_hp = champion5_hp + math.ceil((ability_data[3] * self.check_enemy_vunerability(5)))
                                if champion5_hp > CHAMPION5_HP:
                                    champion5_hp = CHAMPION5_HP
        #Deal damage to chosen enemy and the Bloodmancer takes 20% of their maximum health points as damage
        #If the Bloodmancer has the 'Blood Boil' buff, all allies take 20% of their maximum health points, adding the damage taken into the damage of Blood Spike
        #Casting the empowered ability gives the Bloodmancer the 'Channeling Strength' buff which causes the next allies damaging or healing ability to be 50% effective
        elif ability_data[0] == "Blood Spike":
            total_drained = 0
            if blood_boil_buff == True:
                if champion1_hp < CHAMPION1_HP*0.2:
                    champion1_drained = champion1_hp
                    champion1_hp = 0
                    champion1_lastRoundDamageTaken_list.append(champion1_hp)
                else:
                    champion1_drained = CHAMPION1_HP*0.2
                    champion1_hp = champion1_hp - CHAMPION1_HP*0.2
                    champion1_lastRoundDamageTaken_list.append(CHAMPION1_HP*0.2)
                if champion2_hp < CHAMPION2_HP*0.2:
                    champion2_drained = champion2_hp
                    champion2_hp = 0
                    champion2_lastRoundDamageTaken_list.append(champion2_hp)
                else:
                    champion2_drained = CHAMPION2_HP*0.2
                    champion2_hp = champion2_hp - CHAMPION2_HP*0.2
                    champion2_lastRoundDamageTaken_list.append(CHAMPION2_HP*0.2)
                if champion3_hp < CHAMPION3_HP*0.2:
                    champion3_drained = champion3_hp
                    champion3_hp = 0
                    champion3_lastRoundDamageTaken_list.append(champion3_hp)
                else:
                    champion3_drained = CHAMPION3_HP*0.2
                    champion3_hp = champion3_hp - CHAMPION3_HP*0.2
                    champion3_lastRoundDamageTaken_list.append(CHAMPION3_HP*0.2)
                if champion4_hp < CHAMPION4_HP*0.2:
                    champion4_drained = champion4_hp
                    champion4_hp = 0
                    champion4_lastRoundDamageTaken_list.append(champion4_hp)
                else:
                    champion4_drained = CHAMPION4_HP*0.2
                    champion4_hp = champion4_hp - CHAMPION4_HP*0.2
                    champion4_lastRoundDamageTaken_list.append(CHAMPION4_HP*0.2)
                if champion5_hp < CHAMPION5_HP*0.2:
                    champion5_drained = champion5_hp
                    champion5_hp = 0
                    champion5_lastRoundDamageTaken_list.append(champion5_hp)
                else:
                    champion5_drained = CHAMPION5_HP*0.2
                    champion5_hp = champion5_hp - CHAMPION5_HP*0.2
                    champion5_lastRoundDamageTaken_list.append(CHAMPION5_HP*0.2)
                total_drained = champion1_drained+champion2_drained+champion3_drained+champion4_drained+champion5_drained
                channeling_strength = 1
            if 1 in target_list:
                ai1_hp = ai1_hp - ((math.ceil(ability_data[3] + total_drained) * self.check_enemy_vunerability(1)))
            if 2 in target_list:
                ai2_hp = ai2_hp - ((math.ceil(ability_data[3] + total_drained) * self.check_enemy_vunerability(2)))
            if 3 in target_list:
                ai3_hp = ai3_hp - ((math.ceil(ability_data[3] + total_drained) * self.check_enemy_vunerability(3)))
            if 4 in target_list:
                ai4_hp = ai4_hp - ((math.ceil(ability_data[3] + total_drained) * self.check_enemy_vunerability(4)))
            if 5 in target_list:
                ai5_hp = ai5_hp - ((math.ceil(ability_data[3] + total_drained) * self.check_enemy_vunerability(5)))
            if blood_boil_buff == True:
                blood_boil_buff = False
            else:
                for champions in CHAMPION_LIST:
                    counter += 1
                    if champions == BLOODMANCER.title:
                        if counter == 1:
                            champion1_hp = champion1_hp - CHAMPION1_HP*0.2
                            champion1_lastRoundDamageTaken_list.append(CHAMPION1_HP*0.2)
                            if champion1_hp < 0:
                                champion1_hp = CHAMPION1_HP
                        elif counter == 2:
                            champion2_hp = champion2_hp - CHAMPION2_HP*0.2
                            champion2_lastRoundDamageTaken_list.append(CHAMPION2_HP*0.2)
                            if champion2_hp < 0:
                                champion2_hp = CHAMPION2_HP
                        elif counter == 3:
                            champion3_hp = champion3_hp - CHAMPION3_HP*0.2
                            champion3_lastRoundDamageTaken_list.append(CHAMPION3_HP*0.2)
                            if champion3_hp < 0:
                                champion3_hp = 0
                        elif counter == 4:
                            champion4_hp = champion4_hp - CHAMPION4_HP*0.2
                            champion4_lastRoundDamageTaken_list.append(CHAMPION4_HP*0.2)
                            if champion4_hp < 0:
                                champion4_hp = 0
                        elif counter == 5:
                            champion5_hp = champion5_hp - CHAMPION5_HP*0.2
                            champion5_lastRoundDamageTaken_list.append(CHAMPION5_HP*0.2)
                            if champion5_hp < 0:
                                champion5_hp = 0
        #Deals damage to chosen enemy, giving the Paladin a stacking 20% permanent holywrath damage
        #stacks reset to 0% after gaining over 100% extra damage
        elif ability_data[0] == "Holy Wrath":
            global holywrath_multiplier
            if 1 in target_list:
                ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * (1 + (0.2 * holywrath_multiplier)))
                if holywrath_multiplier < 5:
                    holywrath_multiplier = holywrath_multiplier + 1
                else:
                    holywrath_multiplier = 1
            if 2 in target_list:
                ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * (1 + (0.2 * holywrath_multiplier)))
                if holywrath_multiplier < 5:
                    holywrath_multiplier = holywrath_multiplier + 1
                else:
                    holywrath_multiplier = 1
            if 3 in target_list:
                ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3) * (1 + (0.2 * holywrath_multiplier)))
                if holywrath_multiplier < 5:
                    holywrath_multiplier = holywrath_multiplier + 1
                else:
                    holywrath_multiplier = 1
            if 4 in target_list:
                ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4) * (1 + (0.2 * holywrath_multiplier)))
                if holywrath_multiplier < 5:
                    holywrath_multiplier = holywrath_multiplier + 1
                else:
                    holywrath_multiplier = 1
            if 5 in target_list:
                ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5) * (1 + (0.2 * holywrath_multiplier)))
                if holywrath_multiplier < 5:
                    holywrath_multiplier = holywrath_multiplier + 1
                else:
                    holywrath_multiplier = 1
        #Deals damage to chosen enemy and applies 'Stunned'
        elif ability_data[0] == "Righteous Blow":
            if 1 in target_list:
                ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1))
                self.apply_stun(1, 2)
            if 2 in target_list:
                ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2))
                self.apply_stun(2, 2)
            if 3 in target_list:
                ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3))
                self.apply_stun(3, 2)
            if 4 in target_list:
                ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4))
                self.apply_stun(4, 2)
            if 5 in target_list:
                ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5))
        #Deals damage to chosen enemy and low damage to all other alive enemies
        elif ability_data[0] == "Crusade":
            if 1 in target_list:
                ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1))
                if AI_SPAWNED == 2:
                    ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * 0.3)
                if AI_SPAWNED == 3:
                    ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * 0.3)
                    ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3) * 0.3)
                if AI_SPAWNED == 4:
                    ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * 0.3)
                    ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3) * 0.3)
                    ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4) * 0.3)
                if AI_SPAWNED == 5:
                    ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * 0.3)
                    ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3) * 0.3)
                    ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4) * 0.3)
                    ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5) * 0.3)
            if 2 in target_list:
                ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2))
                if AI_SPAWNED == 2:
                    ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * 0.3)
                if AI_SPAWNED == 3:
                    ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * 0.3)
                    ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3) * 0.3)
                if AI_SPAWNED == 4:
                    ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * 0.3)
                    ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3) * 0.3)
                    ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4) * 0.3)
                if AI_SPAWNED == 5:
                    ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * 0.3)
                    ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3) * 0.3)
                    ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4) * 0.3)
                    ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5) * 0.3)
            if 3 in target_list:
                ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3))
                if AI_SPAWNED == 3:
                    ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * 0.3)
                    ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * 0.3)
                if AI_SPAWNED == 4:
                    ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * 0.3)
                    ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * 0.3)
                    ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4) * 0.3)
                if AI_SPAWNED == 5:
                    ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * 0.3)
                    ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * 0.3)
                    ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4) * 0.3)
                    ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5) * 0.3)
            if 4 in target_list:
                ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4))
                if AI_SPAWNED == 4:
                    ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * 0.3)
                    ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * 0.3)
                    ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3) * 0.3)
                if AI_SPAWNED == 5:
                    ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * 0.3)
                    ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * 0.3)
                    ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3) * 0.3)
                    ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5) * 0.3)
            if 5 in target_list:
                ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * 0.3)
                ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * 0.3)
                ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3) * 0.3)
                ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4) * 0.3)
                ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5))
        #Applies the 'Exploding' to chosen enemy
        #Which explodes after a few turns for big damage
        elif ability_data[0] == "Damnation":
            global ai1_damnation, ai2_damnation, ai3_damnation, ai4_damnation, ai5_damnation
            damnation_damage = ability_data[3] * 3
            if 1 in target_list:
                ai1_damnation = [damnation_damage, 3]
                ai1_statuses.append("Exploding")
            if 2 in target_list:
                ai2_damnation = [damnation_damage, 3]
                ai2_statuses.append("Exploding")
            if 3 in target_list:
                ai3_damnation = [damnation_damage, 3]
                ai3_statuses.append("Exploding")
            if 4 in target_list:
                ai4_damnation = [damnation_damage, 3]
                ai4_statuses.append("Exploding")
            if 5 in target_list:
                ai5_damnation = [damnation_damage, 3]
                ai5_statuses.append("Exploding")
        #Deals damage chosen enemy, enemies hit are affected by the current arrow type
        #(Heavy Iron Tip > 1.5x damage)
        #(Barbed Tip > Applies Bleed damage over time effect)
        #(Shrapnel Tip > Deals low damage to enemies other than the one hit by the arrow)
        #(Venom Tip > Applies Weakness)
        #(Bola Tip > Applies Stun)
        #(Vein Sensitiser Tip > Applies Brittle)
        elif ability_data[0] == "Steady Aim":
            if current_arrow_type == "Heavy Iron Tip":
                if 1 in target_list:
                    ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * 1.5)
                    if ai1_hp < 0:
                        ai1_hp = 0
                if 2 in target_list:
                    ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * 1.5)
                    if ai2_hp < 0:
                        ai2_hp = 0
                if 3 in target_list:
                    ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3) * 1.5)
                    if ai3_hp < 0:
                        ai3_hp = 0
                if 4 in target_list:
                    ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4) * 1.5)
                    if ai4_hp < 0:
                        ai4_hp = 0
                if 5 in target_list:
                    ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5) * 1.5)
                    if ai5_hp < 0:
                        ai5_hp = 0
            if current_arrow_type == "Barbed Tip":
                if 1 in target_list:
                    ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1))
                    if ai1_hp < 0:
                        ai1_hp = 0
                    else:
                        self.apply_barbedArrowDot(1, 3)
                if 2 in target_list:
                    ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2))
                    if ai2_hp < 0:
                        ai2_hp = 0
                    else:
                        self.apply_barbedArrowDot(2, 3)
                if 3 in target_list:
                    ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3))
                    if ai3_hp < 0:
                        ai3_hp = 0
                    else:
                        self.apply_barbedArrowDot(3, 3)
                if 4 in target_list:
                    ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4))
                    if ai4_hp < 0:
                        ai4_hp = 0
                    else:
                        self.apply_barbedArrowDot(4, 3)
                if 5 in target_list:
                    ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5))
                    if ai5_hp < 0:
                        ai5_hp = 0
                    else:
                        self.apply_barbedArrowDot(5, 3)
            if current_arrow_type == "Shrapnel Tip":
                if 1 in target_list:
                    ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1))
                    if ai1_hp < 0:
                        ai1_hp = 0
                    if AI_SPAWNED == 2:
                        ai2_hp = ai2_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(2)) * 0.2)
                        if ai2_hp < 0:
                            ai2_hp = 0
                    if AI_SPAWNED == 3:
                        ai2_hp = ai2_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(2)) * 0.2)
                        ai3_hp = ai3_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(3)) * 0.2)
                        if ai2_hp < 0:
                            ai2_hp = 0
                        if ai3_hp < 0:
                            ai3_hp = 0
                    if AI_SPAWNED == 4:
                        ai2_hp = ai2_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(2)) * 0.2)
                        ai3_hp = ai3_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(3)) * 0.2)
                        ai4_hp = ai4_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(4)) * 0.2)
                        if ai2_hp < 0:
                            ai2_hp = 0
                        if ai3_hp < 0:
                            ai3_hp = 0
                        if ai4_hp < 0:
                            ai4_hp = 0
                    if AI_SPAWNED == 5:
                        ai2_hp = ai2_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(2)) * 0.2)
                        ai3_hp = ai3_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(3)) * 0.2)
                        ai4_hp = ai4_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(4)) * 0.2)
                        ai5_hp = ai5_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(5)) * 0.2)
                        if ai2_hp < 0:
                            ai2_hp = 0
                        if ai3_hp < 0:
                            ai3_hp = 0
                        if ai4_hp < 0:
                            ai4_hp = 0
                        if ai5_hp < 0:
                            ai5_hp = 0
                if 2 in target_list:
                    ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2))
                    if AI_SPAWNED == 2:
                        ai1_hp = ai1_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(1)) * 0.2)
                        if ai1_hp < 0:
                            ai1_hp = 0
                        if ai2_hp < 0:
                            ai2_hp = 0
                    if AI_SPAWNED == 3:
                        ai1_hp = ai1_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(1)) * 0.2)
                        ai3_hp = ai3_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(3)) * 0.2)
                        if ai1_hp < 0:
                            ai1_hp = 0
                        if ai2_hp < 0:
                            ai2_hp = 0
                        if ai3_hp < 0:
                            ai3_hp = 0
                    if AI_SPAWNED == 4:
                        ai1_hp = ai1_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(1)) * 0.2)
                        ai3_hp = ai3_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(3)) * 0.2)
                        ai4_hp = ai4_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(4)) * 0.2)
                        if ai1_hp < 0:
                            ai1_hp = 0
                        if ai2_hp < 0:
                            ai2_hp = 0
                        if ai3_hp < 0:
                            ai3_hp = 0
                        if ai4_hp < 0:
                            ai4_hp = 0
                    if AI_SPAWNED == 5:
                        ai1_hp = ai1_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(1)) * 0.2)
                        ai3_hp = ai3_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(3)) * 0.2)
                        ai4_hp = ai4_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(4)) * 0.2)
                        ai5_hp = ai5_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(5)) * 0.2)
                        if ai1_hp < 0:
                            ai1_hp = 0
                        if ai2_hp < 0:
                            ai2_hp = 0
                        if ai3_hp < 0:
                            ai3_hp = 0
                        if ai4_hp < 0:
                            ai4_hp = 0
                        if ai5_hp < 0:
                            ai5_hp = 0
                if 3 in target_list:
                    ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3))
                    if AI_SPAWNED == 3:
                        ai1_hp = ai1_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(1)) * 0.2)
                        ai2_hp = ai2_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(2)) * 0.2)
                        if ai1_hp < 0:
                            ai1_hp = 0
                        if ai2_hp < 0:
                            ai2_hp = 0
                        if ai3_hp < 0:
                            ai3_hp = 0
                    if AI_SPAWNED == 4:
                        ai1_hp = ai1_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(1)) * 0.2)
                        ai2_hp = ai2_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(2)) * 0.2)
                        ai4_hp = ai4_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(4)) * 0.2)
                        if ai1_hp < 0:
                            ai1_hp = 0
                        if ai2_hp < 0:
                            ai2_hp = 0
                        if ai3_hp < 0:
                            ai3_hp = 0
                        if ai4_hp < 0:
                            ai4_hp = 0
                    if AI_SPAWNED == 5:
                        ai1_hp = ai1_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(1)) * 0.2)
                        ai2_hp = ai2_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(2)) * 0.2)
                        ai4_hp = ai4_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(3)) * 0.2)
                        ai5_hp = ai5_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(5)) * 0.2)
                        if ai1_hp < 0:
                            ai1_hp = 0
                        if ai2_hp < 0:
                            ai2_hp = 0
                        if ai3_hp < 0:
                            ai3_hp = 0
                        if ai4_hp < 0:
                            ai4_hp = 0
                        if ai5_hp < 0:
                            ai5_hp = 0
                if 4 in target_list:
                    ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4))
                    if AI_SPAWNED == 4:
                        ai1_hp = ai1_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(1)) * 0.2)
                        ai2_hp = ai2_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(2)) * 0.2)
                        ai3_hp = ai3_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(4)) * 0.2)
                        if ai1_hp < 0:
                            ai1_hp = 0
                        if ai2_hp < 0:
                            ai2_hp = 0
                        if ai3_hp < 0:
                            ai3_hp = 0
                        if ai4_hp < 0:
                            ai4_hp = 0
                    if AI_SPAWNED == 5:
                        ai1_hp = ai1_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(1)) * 0.2)
                        ai2_hp = ai2_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(2)) * 0.2)
                        ai3_hp = ai3_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(3)) * 0.2)
                        ai5_hp = ai5_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(5)) * 0.2)
                        if ai1_hp < 0:
                            ai1_hp = 0
                        if ai2_hp < 0:
                            ai2_hp = 0
                        if ai3_hp < 0:
                            ai3_hp = 0
                        if ai4_hp < 0:
                            ai4_hp = 0
                        if ai5_hp < 0:
                            ai5_hp = 0
                if 5 in target_list:
                    ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5))
                    ai1_hp = ai1_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(1)) * 0.2)
                    ai2_hp = ai2_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(2)) * 0.2)
                    ai3_hp = ai3_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(3)) * 0.2)
                    ai4_hp = ai4_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(4)) * 0.2)
                    if ai1_hp < 0:
                        ai1_hp = 0
                    if ai2_hp < 0:
                        ai2_hp = 0
                    if ai3_hp < 0:
                        ai3_hp = 0
                    if ai4_hp < 0:
                        ai4_hp = 0
                    if ai5_hp < 0:
                        ai5_hp = 0
            if current_arrow_type == "Venom Tip":
                if 1 in target_list:
                    ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1))
                    if ai1_hp < 0:
                        ai1_hp = 0
                    else:
                        self.apply_weakness(1, 2)
                if 2 in target_list:
                    ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2))
                    if ai2_hp < 0:
                        ai2_hp = 0
                    else:
                        self.apply_weakness(2, 2)
                if 3 in target_list:
                    ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3))
                    if ai3_hp < 0:
                        ai3_hp = 0
                    else:
                        self.apply_weakness(3, 2)
                if 4 in target_list:
                    ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4))
                    if ai4_hp < 0:
                        ai4_hp = 0
                    else:
                        self.apply_weakness(4, 2)
                if 5 in target_list:
                    ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5))
                    if ai5_hp < 0:
                        ai5_hp = 0
                    else:
                        self.apply_weakness(5, 2)
            if current_arrow_type == "Bola Tip":
                if 1 in target_list:
                    ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1))
                    if ai1_hp < 0:
                        ai1_hp = 0
                    else:
                        self.apply_stun(1, 1)
                if 2 in target_list:
                    ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2))
                    if ai2_hp < 0:
                        ai2_hp = 0
                    else:
                        self.apply_stun(2, 1)
                if 3 in target_list:
                    ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3))
                    if ai3_hp < 0:
                        ai3_hp = 0
                    else:
                        self.apply_stun(3, 1)
                if 4 in target_list:
                    ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4))
                    if ai4_hp < 0:
                        ai4_hp = 0
                    else:
                        self.apply_stun(4, 1)
                if 5 in target_list:
                    ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5))
                    if ai5_hp < 0:
                        ai5_hp = 0
                    else:
                        self.apply_stun(5, 1)
            if current_arrow_type == "Vein Sensitizer Tip":
                if 1 in target_list:
                    ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1))
                    if ai1_hp < 0:
                        ai1_hp = 0
                    else:
                        self.apply_brittle(1, 2)
                if 2 in target_list:
                    ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2))
                    if ai2_hp < 0:
                        ai2_hp = 0
                    else:
                        self.apply_brittle(2, 2)
                if 3 in target_list:
                    ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3))
                    if ai3_hp < 0:
                        ai3_hp = 0
                    else:
                        self.apply_brittle(3, 2)
                if 4 in target_list:
                    ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4))
                    if ai4_hp < 0:
                        ai4_hp = 0
                    else:
                        self.apply_brittle(4, 2)
                if 5 in target_list:
                    ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5))
                    if ai5_hp < 0:
                        ai5_hp = 0
                    else:
                        self.apply_brittle(5, 2)
            if power_shot_requirements[3] != 0:
                power_shot_requirements[3] = power_shot_requirements[3] - 1
            if ricochet_shot_requirements[3] != 0:
                ricochet_shot_requirements[3] = ricochet_shot_requirements[3] - 1
        #Deals damage to chosen enemy, enemies hit are affected by the current arrow type with double the effect
        #(Heavy Iron Tip > 2x damage)
        #(Barbed Tip > Applies Bleed damage over time effect (double duration))
        #(Shrapnel Tip > Deals low damage to enemies other than the one hit by the arrow (double explosion damage))
        #(Venom Tip > Applies Weakness (double duration))
        #(Bola Tip > Applies Stun (double duration))
        #(Vein Sensitiser Tip > Applies Brittle (double duration))
        elif ability_data[0] == "Power Shot":
            if current_arrow_type == "Heavy Iron Tip":
                if 1 in target_list:
                    ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * 3)
                    if ai1_hp < 0:
                        ai1_hp = 0
                if 2 in target_list:
                    ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * 3)
                    if ai2_hp < 0:
                        ai2_hp = 0
                if 3 in target_list:
                    ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3) * 3)
                    if ai3_hp < 0:
                        ai3_hp = 0
                if 4 in target_list:
                    ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4) * 3)
                    if ai4_hp < 0:
                        ai4_hp = 0
                if 5 in target_list:
                    ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5) * 3)
                    if ai5_hp < 0:
                        ai5_hp = 0
            if current_arrow_type == "Barbed Tip":
                if 1 in target_list:
                    ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * 1.5)
                    if ai1_hp < 0:
                        ai1_hp = 0
                    else:
                        self.apply_barbedArrowDot(1, 6)
                if 2 in target_list:
                    ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * 1.5)
                    if ai2_hp < 0:
                        ai2_hp = 0
                    else:
                        self.apply_barbedArrowDot(2, 6)
                if 3 in target_list:
                    ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3) * 1.5)
                    if ai3_hp < 0:
                        ai3_hp = 0
                    else:
                        self.apply_barbedArrowDot(3, 6)
                if 4 in target_list:
                    ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4) * 1.5)
                    if ai4_hp < 0:
                        ai4_hp = 0
                    else:
                        self.apply_barbedArrowDot(4, 6)
                if 5 in target_list:
                    ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5) * 1.5)
                    if ai5_hp < 0:
                        ai5_hp = 0
                    else:
                        self.apply_barbedArrowDot(5, 6)
            if current_arrow_type == "Shrapnel Tip":
                if 1 in target_list:
                    ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * 1.5)
                    if ai1_hp < 0:
                        ai1_hp = 0
                    if AI_SPAWNED == 2:
                        ai2_hp = ai2_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(2)) * 0.75)
                        if ai2_hp < 0:
                            ai2_hp = 0
                    if AI_SPAWNED == 3:
                        ai2_hp = ai2_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(2)) * 0.75)
                        ai3_hp = ai3_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(3)) * 0.75)
                        if ai2_hp < 0:
                            ai2_hp = 0
                        if ai3_hp < 0:
                            ai3_hp = 0
                    if AI_SPAWNED == 4:
                        ai2_hp = ai2_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(2)) * 0.75)
                        ai3_hp = ai3_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(3)) * 0.75)
                        ai4_hp = ai4_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(4)) * 0.75)
                        if ai2_hp < 0:
                            ai2_hp = 0
                        if ai3_hp < 0:
                            ai3_hp = 0
                        if ai4_hp < 0:
                            ai4_hp = 0
                    if AI_SPAWNED == 5:
                        ai2_hp = ai2_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(2)) * 0.75)
                        ai3_hp = ai3_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(3)) * 0.75)
                        ai4_hp = ai4_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(4)) * 0.75)
                        ai5_hp = ai5_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(5)) * 0.75)
                        if ai2_hp < 0:
                            ai2_hp = 0
                        if ai3_hp < 0:
                            ai3_hp = 0
                        if ai4_hp < 0:
                            ai4_hp = 0
                        if ai5_hp < 0:
                            ai5_hp = 0
                if 2 in target_list:
                    ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * 1.5)
                    if AI_SPAWNED == 2:
                        ai1_hp = ai1_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(1)) * 0.75)
                        if ai1_hp < 0:
                            ai1_hp = 0
                        if ai2_hp < 0:
                            ai2_hp = 0
                    if AI_SPAWNED == 3:
                        ai1_hp = ai1_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(1)) * 0.75)
                        ai3_hp = ai3_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(3)) * 0.75)
                        if ai1_hp < 0:
                            ai1_hp = 0
                        if ai2_hp < 0:
                            ai2_hp = 0
                        if ai3_hp < 0:
                            ai3_hp = 0
                    if AI_SPAWNED == 4:
                        ai1_hp = ai1_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(1)) * 0.75)
                        ai3_hp = ai3_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(3)) * 0.75)
                        ai4_hp = ai4_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(4)) * 0.75)
                        if ai1_hp < 0:
                            ai1_hp = 0
                        if ai2_hp < 0:
                            ai2_hp = 0
                        if ai3_hp < 0:
                            ai3_hp = 0
                        if ai4_hp < 0:
                            ai4_hp = 0
                    if AI_SPAWNED == 5:
                        ai1_hp = ai1_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(1)) * 0.75)
                        ai3_hp = ai3_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(3)) * 0.75)
                        ai4_hp = ai4_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(4)) * 0.75)
                        ai5_hp = ai5_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(5)) * 0.75)
                        if ai1_hp < 0:
                            ai1_hp = 0
                        if ai2_hp < 0:
                            ai2_hp = 0
                        if ai3_hp < 0:
                            ai3_hp = 0
                        if ai4_hp < 0:
                            ai4_hp = 0
                        if ai5_hp < 0:
                            ai5_hp = 0
                if 3 in target_list:
                    ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3) * 1.5)
                    if AI_SPAWNED == 3:
                        ai1_hp = ai1_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(1)) * 0.75)
                        ai2_hp = ai2_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(2)) * 0.75)
                        if ai1_hp < 0:
                            ai1_hp = 0
                        if ai2_hp < 0:
                            ai2_hp = 0
                        if ai3_hp < 0:
                            ai3_hp = 0
                    if AI_SPAWNED == 4:
                        ai1_hp = ai1_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(1)) * 0.75)
                        ai2_hp = ai2_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(2)) * 0.75)
                        ai4_hp = ai4_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(4)) * 0.75)
                        if ai1_hp < 0:
                            ai1_hp = 0
                        if ai2_hp < 0:
                            ai2_hp = 0
                        if ai3_hp < 0:
                            ai3_hp = 0
                        if ai4_hp < 0:
                            ai4_hp = 0
                    if AI_SPAWNED == 5:
                        ai1_hp = ai1_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(1)) * 0.75)
                        ai2_hp = ai2_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(2)) * 0.75)
                        ai4_hp = ai4_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(3)) * 0.75)
                        ai5_hp = ai5_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(5)) * 0.75)
                        if ai1_hp < 0:
                            ai1_hp = 0
                        if ai2_hp < 0:
                            ai2_hp = 0
                        if ai3_hp < 0:
                            ai3_hp = 0
                        if ai4_hp < 0:
                            ai4_hp = 0
                        if ai5_hp < 0:
                            ai5_hp = 0
                if 4 in target_list:
                    ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4) * 1.5)
                    if AI_SPAWNED == 4:
                        ai1_hp = ai1_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(1)) * 0.75)
                        ai2_hp = ai2_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(2)) * 0.75)
                        ai3_hp = ai3_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(4)) * 0.75)
                        if ai1_hp < 0:
                            ai1_hp = 0
                        if ai2_hp < 0:
                            ai2_hp = 0
                        if ai3_hp < 0:
                            ai3_hp = 0
                        if ai4_hp < 0:
                            ai4_hp = 0
                    if AI_SPAWNED == 5:
                        ai1_hp = ai1_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(1)) * 0.75)
                        ai2_hp = ai2_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(2)) * 0.75)
                        ai3_hp = ai3_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(3)) * 0.75)
                        ai5_hp = ai5_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(5)) * 0.75)
                        if ai1_hp < 0:
                            ai1_hp = 0
                        if ai2_hp < 0:
                            ai2_hp = 0
                        if ai3_hp < 0:
                            ai3_hp = 0
                        if ai4_hp < 0:
                            ai4_hp = 0
                        if ai5_hp < 0:
                            ai5_hp = 0
                if 5 in target_list:
                    ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5) * 1.5)
                    ai1_hp = ai1_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(1)) * 0.75)
                    ai2_hp = ai2_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(2)) * 0.75)
                    ai3_hp = ai3_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(3)) * 0.75)
                    ai4_hp = ai4_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(4)) * 0.75)
                    if ai1_hp < 0:
                        ai1_hp = 0
                    if ai2_hp < 0:
                        ai2_hp = 0
                    if ai3_hp < 0:
                        ai3_hp = 0
                    if ai4_hp < 0:
                        ai4_hp = 0
                    if ai5_hp < 0:
                        ai5_hp = 0
            if current_arrow_type == "Venom Tip":
                if 1 in target_list:
                    ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * 1.5)
                    if ai1_hp < 0:
                        ai1_hp = 0
                    else:
                        self.apply_weakness(1, 4)
                if 2 in target_list:
                    ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * 1.5)
                    if ai2_hp < 0:
                        ai2_hp = 0
                    else:
                        self.apply_weakness(2, 4)
                if 3 in target_list:
                    ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3) * 1.5)
                    if ai3_hp < 0:
                        ai3_hp = 0
                    else:
                        self.apply_weakness(3, 4)
                if 4 in target_list:
                    ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4) * 1.5)
                    if ai4_hp < 0:
                        ai4_hp = 0
                    else:
                        self.apply_weakness(4, 4)
                if 5 in target_list:
                    ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5) * 1.5)
                    if ai5_hp < 0:
                        ai5_hp = 0
                    else:
                        self.apply_weakness(5, 4)
            if current_arrow_type == "Bola Tip":
                if 1 in target_list:
                    ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * 1.5)
                    if ai1_hp < 0:
                        ai1_hp = 0
                    else:
                        self.apply_stun(1, 2)
                if 2 in target_list:
                    ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * 1.5)
                    if ai2_hp < 0:
                        ai2_hp = 0
                    else:
                        self.apply_stun(2, 2)
                if 3 in target_list:
                    ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3) * 1.5)
                    if ai3_hp < 0:
                        ai3_hp = 0
                    else:
                        self.apply_stun(3, 2)
                if 4 in target_list:
                    ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4) * 1.5)
                    if ai4_hp < 0:
                        ai4_hp = 0
                    else:
                        self.apply_stun(4, 2)
                if 5 in target_list:
                    ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5) * 1.5)
                    if ai5_hp < 0:
                        ai5_hp = 0
                    else:
                        self.apply_stun(5, 2)
            if current_arrow_type == "Vein Sensitizer Tip":
                if 1 in target_list:
                    ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * 1.5)
                    if ai1_hp < 0:
                        ai1_hp = 0
                    else:
                        self.apply_brittle(1, 4)
                if 2 in target_list:
                    ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * 1.5)
                    if ai2_hp < 0:
                        ai2_hp = 0
                    else:
                        self.apply_brittle(2, 4)
                if 3 in target_list:
                    ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3) * 1.5)
                    if ai3_hp < 0:
                        ai3_hp = 0
                    else:
                        self.apply_brittle(3, 4)
                if 4 in target_list:
                    ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4) * 1.5)
                    if ai4_hp < 0:
                        ai4_hp = 0
                    else:
                        self.apply_brittle(4, 4)
                if 5 in target_list:
                    ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5) * 1.5)
                    if ai5_hp < 0:
                        ai5_hp = 0
                    else:
                        self.apply_brittle(5, 4)
            if multi_shot_requirements[3] != 0:
                multi_shot_requirements[3] = multi_shot_requirements[3] - 2
                if multi_shot_requirements[3] < 0:
                    multi_shot_requirements[3] = 0
        #Deals damage to chosen enemies, enemies hit are affected by the current arrow type
        #(Heavy Iron Tip > 1.5x damage)
        #(Barbed Tip > Applies Bleed damage over time effect)
        #(Shrapnel Tip > Deals low damage to enemies other than the one hit by the arrow)
        #(Venom Tip > Applies Weakness)
        #(Bola Tip > Applies Stun)
        #(Vein Sensitiser Tip > Applies Brittle)
        elif ability_data[0] == "Multi-shot":
            if current_arrow_type == "Heavy Iron Tip":
                if 1 in target_list:
                    ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * 1.5)
                    if ai1_hp < 0:
                        ai1_hp = 0
                if 2 in target_list:
                    ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * 1.5)
                    if ai2_hp < 0:
                        ai2_hp = 0
                if 3 in target_list:
                    ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3) * 1.5)
                    if ai3_hp < 0:
                        ai3_hp = 0
                if 4 in target_list:
                    ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4) * 1.5)
                    if ai4_hp < 0:
                        ai4_hp = 0
                if 5 in target_list:
                    ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5) * 1.5)
                    if ai5_hp < 0:
                        ai5_hp = 0
            if current_arrow_type == "Barbed Tip":
                if 1 in target_list:
                    ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1))
                    if ai1_hp < 0:
                        ai1_hp = 0
                    else:
                        self.apply_barbedArrowDot(1, 3)
                if 2 in target_list:
                    ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2))
                    if ai2_hp < 0:
                        ai2_hp = 0
                    else:
                        self.apply_barbedArrowDot(2, 3)
                if 3 in target_list:
                    ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3))
                    if ai3_hp < 0:
                        ai3_hp = 0
                    else:
                        self.apply_barbedArrowDot(3, 3)
                if 4 in target_list:
                    ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4))
                    if ai4_hp < 0:
                        ai4_hp = 0
                    else:
                        self.apply_barbedArrowDot(4, 3)
                if 5 in target_list:
                    ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5))
                    if ai5_hp < 0:
                        ai5_hp = 0
                    else:
                        self.apply_barbedArrowDot(5, 3)
            if current_arrow_type == "Shrapnel Tip":
                if 1 in target_list:
                    ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1))
                    if ai1_hp < 0:
                        ai1_hp = 0
                    if AI_SPAWNED == 2:
                        ai2_hp = ai2_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(2)) * 0.2)
                        if ai2_hp < 0:
                            ai2_hp = 0
                    if AI_SPAWNED == 3:
                        ai2_hp = ai2_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(2)) * 0.2)
                        ai3_hp = ai3_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(3)) * 0.2)
                        if ai2_hp < 0:
                            ai2_hp = 0
                        if ai3_hp < 0:
                            ai3_hp = 0
                    if AI_SPAWNED == 4:
                        ai2_hp = ai2_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(2)) * 0.2)
                        ai3_hp = ai3_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(3)) * 0.2)
                        ai4_hp = ai4_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(4)) * 0.2)
                        if ai2_hp < 0:
                            ai2_hp = 0
                        if ai3_hp < 0:
                            ai3_hp = 0
                        if ai4_hp < 0:
                            ai4_hp = 0
                    if AI_SPAWNED == 5:
                        ai2_hp = ai2_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(2)) * 0.2)
                        ai3_hp = ai3_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(3)) * 0.2)
                        ai4_hp = ai4_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(4)) * 0.2)
                        ai5_hp = ai5_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(5)) * 0.2)
                        if ai2_hp < 0:
                            ai2_hp = 0
                        if ai3_hp < 0:
                            ai3_hp = 0
                        if ai4_hp < 0:
                            ai4_hp = 0
                        if ai5_hp < 0:
                            ai5_hp = 0
                if 2 in target_list:
                    ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2))
                    if AI_SPAWNED == 2:
                        ai1_hp = ai1_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(1)) * 0.2)
                        if ai1_hp < 0:
                            ai1_hp = 0
                        if ai2_hp < 0:
                            ai2_hp = 0
                    if AI_SPAWNED == 3:
                        ai1_hp = ai1_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(1)) * 0.2)
                        ai3_hp = ai3_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(3)) * 0.2)
                        if ai1_hp < 0:
                            ai1_hp = 0
                        if ai2_hp < 0:
                            ai2_hp = 0
                        if ai3_hp < 0:
                            ai3_hp = 0
                    if AI_SPAWNED == 4:
                        ai1_hp = ai1_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(1)) * 0.2)
                        ai3_hp = ai3_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(3)) * 0.2)
                        ai4_hp = ai4_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(4)) * 0.2)
                        if ai1_hp < 0:
                            ai1_hp = 0
                        if ai2_hp < 0:
                            ai2_hp = 0
                        if ai3_hp < 0:
                            ai3_hp = 0
                        if ai4_hp < 0:
                            ai4_hp = 0
                    if AI_SPAWNED == 5:
                        ai1_hp = ai1_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(1)) * 0.2)
                        ai3_hp = ai3_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(3)) * 0.2)
                        ai4_hp = ai4_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(4)) * 0.2)
                        ai5_hp = ai5_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(5)) * 0.2)
                        if ai1_hp < 0:
                            ai1_hp = 0
                        if ai2_hp < 0:
                            ai2_hp = 0
                        if ai3_hp < 0:
                            ai3_hp = 0
                        if ai4_hp < 0:
                            ai4_hp = 0
                        if ai5_hp < 0:
                            ai5_hp = 0
                if 3 in target_list:
                    ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3))
                    if AI_SPAWNED == 3:
                        ai1_hp = ai1_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(1)) * 0.2)
                        ai2_hp = ai2_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(2)) * 0.2)
                        if ai1_hp < 0:
                            ai1_hp = 0
                        if ai2_hp < 0:
                            ai2_hp = 0
                        if ai3_hp < 0:
                            ai3_hp = 0
                    if AI_SPAWNED == 4:
                        ai1_hp = ai1_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(1)) * 0.2)
                        ai2_hp = ai2_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(2)) * 0.2)
                        ai4_hp = ai4_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(4)) * 0.2)
                        if ai1_hp < 0:
                            ai1_hp = 0
                        if ai2_hp < 0:
                            ai2_hp = 0
                        if ai3_hp < 0:
                            ai3_hp = 0
                        if ai4_hp < 0:
                            ai4_hp = 0
                    if AI_SPAWNED == 5:
                        ai1_hp = ai1_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(1)) * 0.2)
                        ai2_hp = ai2_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(2)) * 0.2)
                        ai4_hp = ai4_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(3)) * 0.2)
                        ai5_hp = ai5_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(5)) * 0.2)
                        if ai1_hp < 0:
                            ai1_hp = 0
                        if ai2_hp < 0:
                            ai2_hp = 0
                        if ai3_hp < 0:
                            ai3_hp = 0
                        if ai4_hp < 0:
                            ai4_hp = 0
                        if ai5_hp < 0:
                            ai5_hp = 0
                if 4 in target_list:
                    ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4))
                    if AI_SPAWNED == 4:
                        ai1_hp = ai1_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(1)) * 0.2)
                        ai2_hp = ai2_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(2)) * 0.2)
                        ai3_hp = ai3_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(4)) * 0.2)
                        if ai1_hp < 0:
                            ai1_hp = 0
                        if ai2_hp < 0:
                            ai2_hp = 0
                        if ai3_hp < 0:
                            ai3_hp = 0
                        if ai4_hp < 0:
                            ai4_hp = 0
                    if AI_SPAWNED == 5:
                        ai1_hp = ai1_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(1)) * 0.2)
                        ai2_hp = ai2_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(2)) * 0.2)
                        ai3_hp = ai3_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(3)) * 0.2)
                        ai5_hp = ai5_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(5)) * 0.2)
                        if ai1_hp < 0:
                            ai1_hp = 0
                        if ai2_hp < 0:
                            ai2_hp = 0
                        if ai3_hp < 0:
                            ai3_hp = 0
                        if ai4_hp < 0:
                            ai4_hp = 0
                        if ai5_hp < 0:
                            ai5_hp = 0
                if 5 in target_list:
                    ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5))
                    ai1_hp = ai1_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(1)) * 0.2)
                    ai2_hp = ai2_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(2)) * 0.2)
                    ai3_hp = ai3_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(3)) * 0.2)
                    ai4_hp = ai4_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(4)) * 0.2)
                    if ai1_hp < 0:
                        ai1_hp = 0
                    if ai2_hp < 0:
                        ai2_hp = 0
                    if ai3_hp < 0:
                        ai3_hp = 0
                    if ai4_hp < 0:
                        ai4_hp = 0
                    if ai5_hp < 0:
                        ai5_hp = 0
            if current_arrow_type == "Venom Tip":
                if 1 in target_list:
                    ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1))
                    if ai1_hp < 0:
                        ai1_hp = 0
                    else:
                        self.apply_weakness(1, 2)
                if 2 in target_list:
                    ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2))
                    if ai2_hp < 0:
                        ai2_hp = 0
                    else:
                        self.apply_weakness(2, 2)
                if 3 in target_list:
                    ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3))
                    if ai3_hp < 0:
                        ai3_hp = 0
                    else:
                        self.apply_weakness(3, 2)
                if 4 in target_list:
                    ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4))
                    if ai4_hp < 0:
                        ai4_hp = 0
                    else:
                        self.apply_weakness(4, 2)
                if 5 in target_list:
                    ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5))
                    if ai5_hp < 0:
                        ai5_hp = 0
                    else:
                        self.apply_weakness(5, 2)
            if current_arrow_type == "Bola Tip":
                if 1 in target_list:
                    ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1))
                    if ai1_hp < 0:
                        ai1_hp = 0
                    else:
                        self.apply_stun(1, 1)
                if 2 in target_list:
                    ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2))
                    if ai2_hp < 0:
                        ai2_hp = 0
                    else:
                        self.apply_stun(2, 1)
                if 3 in target_list:
                    ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3))
                    if ai3_hp < 0:
                        ai3_hp = 0
                    else:
                        self.apply_stun(3, 1)
                if 4 in target_list:
                    ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4))
                    if ai4_hp < 0:
                        ai4_hp = 0
                    else:
                        self.apply_stun(4, 1)
                if 5 in target_list:
                    ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5))
                    if ai5_hp < 0:
                        ai5_hp = 0
                    else:
                        self.apply_stun(5, 1)
            if current_arrow_type == "Vein Sensitizer Tip":
                if 1 in target_list:
                    ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1))
                    if ai1_hp < 0:
                        ai1_hp = 0
                    else:
                        self.apply_brittle(1, 2)
                if 2 in target_list:
                    ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2))
                    if ai2_hp < 0:
                        ai2_hp = 0
                    else:
                        self.apply_brittle(2, 2)
                if 3 in target_list:
                    ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3))
                    if ai3_hp < 0:
                        ai3_hp = 0
                    else:
                        self.apply_brittle(3, 2)
                if 4 in target_list:
                    ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4))
                    if ai4_hp < 0:
                        ai4_hp = 0
                    else:
                        self.apply_brittle(4, 2)
                if 5 in target_list:
                    ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5))
                    if ai5_hp < 0:
                        ai5_hp = 0
                    else:
                        self.apply_brittle(5, 2)
            if ricochet_shot_requirements[3] != 0:
                ricochet_shot_requirements[3] = ricochet_shot_requirements[3] - 3
                if ricochet_shot_requirements[3] < 0:
                    ricochet_shot_requirements[3] = 0
        #Deals damage to all alive enemies, enemies hit are affected by the current arrow type
        #(Heavy Iron Tip > 1.5x damage)
        #(Barbed Tip > Applies Bleed damage over time effect)
        #(Shrapnel Tip > Deals low damage to enemies other than the one hit by the arrow)
        #(Venom Tip > Applies Weakness)
        #(Bola Tip > Applies Stun)
        #(Vein Sensitiser Tip > Applies Brittle)
        elif ability_data[0] == "Ricochet Shot":
            if current_arrow_type == "Heavy Iron Tip":
                if AI_SPAWNED == 1:
                    ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * 1.5)
                if AI_SPAWNED == 2:
                    ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * 1.5)
                    ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * 1.5)
                if AI_SPAWNED == 3:
                    ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * 1.5)
                    ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * 1.5)
                    ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3) * 1.5)
                if AI_SPAWNED == 4:
                    ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * 1.5)
                    ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * 1.5)
                    ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3) * 1.5)
                    ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4) * 1.5)
                if AI_SPAWNED == 5:
                    ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * 1.5)
                    ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * 1.5)
                    ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3) * 1.5)
                    ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4) * 1.5)
                    ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5) * 1.5)
            if current_arrow_type == "Barbed Tip":
                if AI_SPAWNED == 1:
                    ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * 0.75)
                    if ai1_hp < 0:
                        ai1_hp = 0
                    else:
                        self.apply_barbedArrowDot(1, 3)
                if AI_SPAWNED == 2:
                    ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * 0.75)
                    ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * 0.75)
                    if ai1_hp < 0:
                        ai1_hp = 0
                    else:
                        self.apply_barbedArrowDot(1, 3)
                    if ai2_hp < 0:
                        ai2_hp = 0
                    else:
                        self.apply_barbedArrowDot(2, 3)
                if AI_SPAWNED == 3:
                    ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * 0.75)
                    ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * 0.75)
                    ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3) * 0.75)
                    if ai1_hp < 0:
                        ai1_hp = 0
                    else:
                        self.apply_barbedArrowDot(1, 3)
                    if ai2_hp < 0:
                        ai2_hp = 0
                    else:
                        self.apply_barbedArrowDot(2, 3)
                    if ai3_hp < 0:
                        ai3_hp = 0
                    else:
                        self.apply_barbedArrowDot(3, 3)
                if AI_SPAWNED == 4:
                    ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * 0.75)
                    ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * 0.75)
                    ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3) * 0.75)
                    ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4) * 0.75)
                    if ai1_hp < 0:
                        ai1_hp = 0
                    else:
                        self.apply_barbedArrowDot(1, 3)
                    if ai2_hp < 0:
                        ai2_hp = 0
                    else:
                        self.apply_barbedArrowDot(2, 3)
                    if ai3_hp < 0:
                        ai3_hp = 0
                    else:
                        self.apply_barbedArrowDot(3, 3)
                    if ai4_hp < 0:
                        ai4_hp = 0
                    else:
                        self.apply_barbedArrowDot(4, 3)
                if AI_SPAWNED == 5:
                    ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * 0.75)
                    ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * 0.75)
                    ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3) * 0.75)
                    ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4) * 0.75)
                    ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5) * 0.75)
                    if ai1_hp < 0:
                        ai1_hp = 0
                    else:
                        self.apply_barbedArrowDot(1, 3)
                    if ai2_hp < 0:
                        ai2_hp = 0
                    else:
                        self.apply_barbedArrowDot(2, 3)
                    if ai3_hp < 0:
                        ai3_hp = 0
                    else:
                        self.apply_barbedArrowDot(3, 3)
                    if ai4_hp < 0:
                        ai4_hp = 0
                    else:
                        self.apply_barbedArrowDot(4, 3)
                    if ai5_hp < 0:
                        ai5_hp = 0
                    else:
                        self.apply_barbedArrowDot(5, 3)
            if current_arrow_type == "Shrapnel Tip":
                if AI_SPAWNED == 1:
                    ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * 0.75)
                    if ai1_hp < 0:
                        ai1_hp = 0
                if AI_SPAWNED == 2:
                    ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * 0.75)
                    ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * 0.75)
                    if ai1_hp != 0:
                        ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * 0.15)
                    if ai2_hp != 0:
                        ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * 0.15)
                    if ai1_hp < 0:
                        ai1_hp = 0
                    if ai2_hp < 0:
                        ai2_hp = 0
                if AI_SPAWNED == 3:
                    ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * 0.75)
                    ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * 0.75)
                    ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3) * 0.75)
                    if ai1_hp != 0:
                        ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * 0.15)
                        ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3) * 0.15)
                    if ai2_hp != 0:
                        ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * 0.15)
                        ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3) * 0.15)
                    if ai3_hp != 0:
                        ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * 0.15)
                        ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * 0.15)
                    if ai1_hp < 0:
                        ai1_hp = 0
                    if ai2_hp < 0:
                        ai2_hp = 0
                    if ai3_hp < 0:
                        ai3_hp = 0
                if AI_SPAWNED == 4:
                    ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * 0.75)
                    ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * 0.75)
                    ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3) * 0.75)
                    ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4) * 0.75)
                    if ai1_hp != 0:
                        ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * 0.15)
                        ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3) * 0.15)
                        ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4) * 0.15)
                    if ai2_hp != 0:
                        ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * 0.15)
                        ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3) * 0.15)
                        ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4) * 0.15)
                    if ai3_hp != 0:
                        ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * 0.15)
                        ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * 0.15)
                        ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4) * 0.15)
                    if ai4_hp != 0:
                        ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * 0.15)
                        ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * 0.15)
                        ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3) * 0.15)
                    if ai1_hp < 0:
                        ai1_hp = 0
                    if ai2_hp < 0:
                        ai2_hp = 0
                    if ai3_hp < 0:
                        ai3_hp = 0
                    if ai4_hp < 0:
                        ai4_hp = 0
                if AI_SPAWNED == 5:
                    ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * 0.75)
                    ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * 0.75)
                    ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3) * 0.75)
                    ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4) * 0.75)
                    ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5) * 0.75)
                    if ai1_hp != 0:
                        ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * 0.15)
                        ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3) * 0.15)
                        ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4) * 0.15)
                        ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5) * 0.15)
                    if ai2_hp != 0:
                        ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * 0.15)
                        ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3) * 0.15)
                        ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4) * 0.15)
                        ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5) * 0.15)
                    if ai3_hp != 0:
                        ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * 0.15)
                        ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * 0.15)
                        ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4) * 0.15)
                        ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5) * 0.15)
                    if ai4_hp != 0:
                        ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * 0.15)
                        ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * 0.15)
                        ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3) * 0.15)
                        ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5) * 0.15)
                    if ai5_hp != 0:
                        ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * 0.15)
                        ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * 0.15)
                        ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3) * 0.15)
                        ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4) * 0.15)
                    if ai1_hp < 0:
                        ai1_hp = 0
                    if ai2_hp < 0:
                        ai2_hp = 0
                    if ai3_hp < 0:
                        ai3_hp = 0
                    if ai4_hp < 0:
                        ai4_hp = 0
                    if ai5_hp < 0:
                        ai5_hp = 0
            if current_arrow_type == "Venom Tip":
                if AI_SPAWNED == 1:
                    ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * 0.75)
                    if ai1_hp < 0:
                        ai1_hp = 0
                    else:
                        self.apply_weakness(1, 2)
                if AI_SPAWNED == 2:
                    ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * 0.75)
                    ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * 0.75)
                    if ai1_hp < 0:
                        ai1_hp = 0
                    else:
                        self.apply_weakness(1, 2)
                    if ai2_hp < 0:
                        ai2_hp = 0
                    else:
                        self.apply_weakness(2, 2)
                if AI_SPAWNED == 3:
                    ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * 0.75)
                    ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * 0.75)
                    ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3) * 0.75)
                    if ai1_hp < 0:
                        ai1_hp = 0
                    else:
                        self.apply_weakness(1, 2)
                    if ai2_hp < 0:
                        ai2_hp = 0
                    else:
                        self.apply_weakness(2, 2)
                    if ai3_hp < 0:
                        ai3_hp = 0
                    else:
                        self.apply_weakness(3, 2)
                if AI_SPAWNED == 4:
                    ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * 0.75)
                    ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * 0.75)
                    ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3) * 0.75)
                    ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4) * 0.75)
                    if ai1_hp < 0:
                        ai1_hp = 0
                    else:
                        self.apply_weakness(1, 2)
                    if ai2_hp < 0:
                        ai2_hp = 0
                    else:
                        self.apply_weakness(2, 2)
                    if ai3_hp < 0:
                        ai3_hp = 0
                    else:
                        self.apply_weakness(3, 2)
                    if ai4_hp < 0:
                        ai4_hp = 0
                    else:
                        self.apply_weakness(4, 2)
                if AI_SPAWNED == 5:
                    ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * 0.75)
                    ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * 0.75)
                    ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3) * 0.75)
                    ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4) * 0.75)
                    ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5) * 0.75)
                    if ai1_hp < 0:
                        ai1_hp = 0
                    else:
                        self.apply_weakness(1, 2)
                    if ai2_hp < 0:
                        ai2_hp = 0
                    else:
                        self.apply_weakness(2, 2)
                    if ai3_hp < 0:
                        ai3_hp = 0
                    else:
                        self.apply_weakness(3, 2)
                    if ai4_hp < 0:
                        ai4_hp = 0
                    else:
                        self.apply_weakness(4, 2)
                    if ai5_hp < 0:
                        ai5_hp = 0
                    else:
                        self.apply_weakness(5, 2)
            if current_arrow_type == "Bola Tip":
                if AI_SPAWNED == 1:
                    ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * 0.75)
                    if ai1_hp < 0:
                        ai1_hp = 0
                    else:
                        self.apply_stun(1, 1)
                if AI_SPAWNED == 2:
                    ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * 0.75)
                    ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * 0.75)
                    if ai1_hp < 0:
                        ai1_hp = 0
                    else:
                        self.apply_stun(1, 1)
                    if ai2_hp < 0:
                        ai2_hp = 0
                    else:
                        self.apply_stun(2, 1)
                if AI_SPAWNED == 3:
                    ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * 0.75)
                    ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * 0.75)
                    ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3) * 0.75)
                    if ai1_hp < 0:
                        ai1_hp = 0
                    else:
                        self.apply_stun(1, 1)
                    if ai2_hp < 0:
                        ai2_hp = 0
                    else:
                        self.apply_stun(2, 1)
                    if ai3_hp < 0:
                        ai3_hp = 0
                    else:
                        self.apply_stun(3, 1)
                if AI_SPAWNED == 4:
                    ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * 0.75)
                    ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * 0.75)
                    ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3) * 0.75)
                    ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4) * 0.75)
                    if ai1_hp < 0:
                        ai1_hp = 0
                    else:
                        self.apply_stun(1, 1)
                    if ai2_hp < 0:
                        ai2_hp = 0
                    else:
                        self.apply_stun(2, 1)
                    if ai3_hp < 0:
                        ai3_hp = 0
                    else:
                        self.apply_stun(3, 1)
                    if ai4_hp < 0:
                        ai4_hp = 0
                    else:
                        self.apply_stun(4, 1)
                if AI_SPAWNED == 5:
                    ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * 0.75)
                    ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * 0.75)
                    ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3) * 0.75)
                    ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4) * 0.75)
                    ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5) * 0.75)
                    if ai1_hp < 0:
                        ai1_hp = 0
                    else:
                        self.apply_stun(1, 1)
                    if ai2_hp < 0:
                        ai2_hp = 0
                    else:
                        self.apply_stun(2, 1)
                    if ai3_hp < 0:
                        ai3_hp = 0
                    else:
                        self.apply_stun(3, 1)
                    if ai4_hp < 0:
                        ai4_hp = 0
                    else:
                        self.apply_stun(4, 1)
                    if ai5_hp < 0:
                        ai5_hp = 0
                    else:
                        self.apply_stun(5, 1)
            if current_arrow_type == "Vein Sensitizer Tip":
                if AI_SPAWNED == 1:
                    ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * 0.75)
                    if ai1_hp < 0:
                        ai1_hp = 0
                    else:
                        self.apply_brittle(1, 2)
                if AI_SPAWNED == 2:
                    ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * 0.75)
                    ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * 0.75)
                    if ai1_hp < 0:
                        ai1_hp = 0
                    else:
                        self.apply_brittle(1, 2)
                    if ai2_hp < 0:
                        ai2_hp = 0
                    else:
                        self.apply_brittle(2, 2)
                if AI_SPAWNED == 3:
                    ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * 0.75)
                    ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * 0.75)
                    ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3) * 0.75)
                    if ai1_hp < 0:
                        ai1_hp = 0
                    else:
                        self.apply_brittle(1, 2)
                    if ai2_hp < 0:
                        ai2_hp = 0
                    else:
                        self.apply_brittle(2, 2)
                    if ai3_hp < 0:
                        ai3_hp = 0
                    else:
                        self.apply_brittle(3, 2)
                if AI_SPAWNED == 4:
                    ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * 0.75)
                    ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * 0.75)
                    ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3) * 0.75)
                    ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4) * 0.75)
                    if ai1_hp < 0:
                        ai1_hp = 0
                    else:
                        self.apply_brittle(1, 2)
                    if ai2_hp < 0:
                        ai2_hp = 0
                    else:
                        self.apply_brittle(2, 2)
                    if ai3_hp < 0:
                        ai3_hp = 0
                    else:
                        self.apply_brittle(3, 2)
                    if ai4_hp < 0:
                        ai4_hp = 0
                    else:
                        self.apply_brittle(4, 2)
                if AI_SPAWNED == 5:
                    ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1) * 0.75)
                    ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2) * 0.75)
                    ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3) * 0.75)
                    ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4) * 0.75)
                    ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5) * 0.75)
                    if ai1_hp < 0:
                        ai1_hp = 0
                    else:
                        self.apply_brittle(1, 2)
                    if ai2_hp < 0:
                        ai2_hp = 0
                    else:
                        self.apply_brittle(2, 2)
                    if ai3_hp < 0:
                        ai3_hp = 0
                    else:
                        self.apply_brittle(3, 2)
                    if ai4_hp < 0:
                        ai4_hp = 0
                    else:
                        self.apply_brittle(4, 2)
                    if ai5_hp < 0:
                        ai5_hp = 0
                    else:
                        self.apply_brittle(5, 2)
        #Deals damage to chosen enemies and gives them the 'Charged' debuff which can explode
        elif ability_data[0] == "Chain Bolts":
            if 1 in target_list:
                ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1)) * 1.2
                self.apply_charges(1)
            if 2 in target_list:
                ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2)) * 1.2
                self.apply_charges(2)
            if 3 in target_list:
                ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3)) * 1.2
                self.apply_charges(3)
            if 4 in target_list:
                ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4)) * 1.2
                self.apply_charges(4)
            if 5 in target_list:
                ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5)) * 1.2
                self.apply_charges(5)
        #Deals damage to all enemies and random spreads 10 charges if the Magnetimancer has the 'Energised' buff, or 5 charges if he doesn't
        elif ability_data[0] == "Electrical Expulsion":
            if AI_SPAWNED == 1:
                ai1_hp = ai1_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(1)) * 0.5)
                self.apply_charges(0)
            if AI_SPAWNED == 3:
                ai1_hp = ai1_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(1)) * 0.5)
                ai2_hp = ai2_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(2)) * 0.5)
                self.apply_charges(0)
            if AI_SPAWNED == 3:
                ai1_hp = ai1_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(1)) * 0.5)
                ai2_hp = ai2_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(2)) * 0.5)
                ai3_hp = ai3_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(3)) * 0.5)
                self.apply_charges(0)
            if AI_SPAWNED == 4:
                ai1_hp = ai1_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(1)) * 0.5)
                ai2_hp = ai2_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(2)) * 0.5)
                ai3_hp = ai3_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(3)) * 0.5)
                ai4_hp = ai4_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(4)) * 0.5)
                self.apply_charges(0)
            if AI_SPAWNED == 5:
                ai1_hp = ai1_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(1)) * 0.5)
                ai2_hp = ai2_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(2)) * 0.5)
                ai3_hp = ai3_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(3)) * 0.5)
                ai4_hp = ai4_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(4)) * 0.5)
                ai5_hp = ai5_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(5)) * 0.5)
                self.apply_charges(0)
        #Gives chosen enemy the 'Superconducted' debuff
        #Which causes them to take double damage from Charges exploding
        elif ability_data[0] == "Superconductor":
            global ai1_superconducted, ai2_superconducted, ai3_superconducted, ai4_superconducted, ai5_superconducted
            if 1 in target_list:
                ai1_superconducted = 2
            if 2 in target_list:
                ai2_superconducted = 2
            if 3 in target_list:
                ai3_superconducted = 2
            if 4 in target_list:
                ai4_superconducted = 2
            if 5 in target_list:
                ai5_superconducted = 2
        #Deals damage to all enemies and gives them the 'Weakened' debuff
        elif ability_data[0] == "Power Surge":
            if AI_SPAWNED == 1:
                ai1_hp = ai1_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(1))) * 1.4
                self.apply_weakness(1, 2)
            if AI_SPAWNED == 3:
                ai1_hp = ai1_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(1))) * 1.4
                ai2_hp = ai2_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(2))) * 1.4
                self.apply_weakness(1, 2)
                self.apply_weakness(2, 2)
            if AI_SPAWNED == 3:
                ai1_hp = ai1_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(1))) * 1.4
                ai2_hp = ai2_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(2))) * 1.4
                ai3_hp = ai3_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(3))) * 1.4
                self.apply_weakness(1, 2)
                self.apply_weakness(2, 2)
                self.apply_weakness(3, 2)
            if AI_SPAWNED == 4:
                ai1_hp = ai1_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(1))) * 1.4
                ai2_hp = ai2_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(2))) * 1.4
                ai3_hp = ai3_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(3))) * 1.4
                ai4_hp = ai4_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(4))) * 1.4
                self.apply_weakness(1, 2)
                self.apply_weakness(2, 2)
                self.apply_weakness(3, 2)
                self.apply_weakness(4, 2)
            if AI_SPAWNED == 5:
                ai1_hp = ai1_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(1))) * 1.4
                ai2_hp = ai2_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(2))) * 1.4
                ai3_hp = ai3_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(3))) * 1.4
                ai4_hp = ai4_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(4))) * 1.4
                ai5_hp = ai5_hp - math.ceil(math.ceil(ability_data[3] * self.check_enemy_vunerability(5))) * 1.4
                self.apply_weakness(1, 2)
                self.apply_weakness(2, 2)
                self.apply_weakness(3, 2)
                self.apply_weakness(4, 2)
                self.apply_weakness(5, 2)\
        #Deals damage to chosen enemy
        elif ability_data[0] == "Rock Barrage":
            if 1 in target_list:
                ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1)) * 1.6
            if 2 in target_list:
                ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2)) * 1.6
            if 3 in target_list:
                ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3)) * 1.6
            if 4 in target_list:
                ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4)) * 1.6
            if 5 in target_list:
                ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5)) * 1.6
        #Deals damage to chosen enemy, applies the 'Sizzling Light' damage over time effect to them, and heals allies with the 'Blessed' buff
        #Which converts all damage done by the Priest into healing for those affected by 'Blessed'
        elif ability_data[0] == "Shimmering Bolt":
            shimmer_damage1 = math.ceil(ability_data[3] * self.check_enemy_vunerability(1)) * 1.8
            shimmer_damage2 = math.ceil(ability_data[3] * self.check_enemy_vunerability(2)) * 1.8
            shimmer_damage3 = math.ceil(ability_data[3] * self.check_enemy_vunerability(3)) * 1.8
            shimmer_damage4 = math.ceil(ability_data[3] * self.check_enemy_vunerability(4)) * 1.8
            shimmer_damage5 = math.ceil(ability_data[3] * self.check_enemy_vunerability(5)) * 1.8
            if 1 in target_list:
                ai1_hp = ai1_hp - shimmer_damage1
                self.apply_shimmerDot(1,2)
                if champion1_hp != 0:
                    self.check_champion_blessing(1, shimmer_damage1)
                if champion2_hp != 0:
                    self.check_champion_blessing(2, shimmer_damage1)
                if champion3_hp != 0:
                    self.check_champion_blessing(3, shimmer_damage1)
                if champion4_hp != 0:
                    self.check_champion_blessing(4, shimmer_damage1)
                if champion5_hp != 0:
                    self.check_champion_blessing(5, shimmer_damage1)
            if 2 in target_list:
                ai2_hp = ai2_hp - shimmer_damage2
                self.apply_shimmerDot(2,2)
                if champion1_hp != 0:
                    self.check_champion_blessing(1, shimmer_damage2)
                if champion2_hp != 0:
                    self.check_champion_blessing(2, shimmer_damage2)
                if champion3_hp != 0:
                    self.check_champion_blessing(3, shimmer_damage2)
                if champion4_hp != 0:
                    self.check_champion_blessing(4, shimmer_damage2)
                if champion5_hp != 0:
                    self.check_champion_blessing(5, shimmer_damage2)
            if 3 in target_list:
                ai3_hp = ai3_hp - shimmer_damage3
                self.apply_shimmerDot(3,2)
                if champion1_hp != 0:
                    self.check_champion_blessing(1, shimmer_damage3)
                if champion2_hp != 0:
                    self.check_champion_blessing(2, shimmer_damage3)
                if champion3_hp != 0:
                    self.check_champion_blessing(3, shimmer_damage3)
                if champion4_hp != 0:
                    self.check_champion_blessing(4, shimmer_damage3)
                if champion5_hp != 0:
                    self.check_champion_blessing(5, shimmer_damage3)
            if 4 in target_list:
                ai4_hp = ai4_hp - shimmer_damage4
                self.apply_shimmerDot(4,2)
                if champion1_hp != 0:
                    self.check_champion_blessing(1, shimmer_damage4)
                if champion2_hp != 0:
                    self.check_champion_blessing(2, shimmer_damage4)
                if champion3_hp != 0:
                    self.check_champion_blessing(3, shimmer_damage4)
                if champion4_hp != 0:
                    self.check_champion_blessing(4, shimmer_damage4)
                if champion5_hp != 0:
                    self.check_champion_blessing(5, shimmer_damage4)
            if 5 in target_list:
                ai5_hp = ai5_hp - shimmer_damage5
                self.apply_shimmerDot(5,2)
                if champion1_hp != 0:
                    self.check_champion_blessing(1, shimmer_damage5)
                if champion2_hp != 0:
                    self.check_champion_blessing(2, shimmer_damage5)
                if champion3_hp != 0:
                    self.check_champion_blessing(3, shimmer_damage5)
                if champion4_hp != 0:
                    self.check_champion_blessing(4, shimmer_damage5)
                if champion5_hp != 0:
                    self.check_champion_blessing(5, shimmer_damage5)
        #Deals damage to chosen enemy, applies the 'Searing Light' damage over time effect to them, and heals allies with the 'Blessed' buff
        #Which converts all damage done by the Priest into healing for those affected by 'Blessed'
        elif ability_data[0] == "Divine Smite":
            divine_damage1 = math.ceil(ability_data[3] * self.check_enemy_vunerability(1)) * 2.8
            divine_damage2 = math.ceil(ability_data[3] * self.check_enemy_vunerability(2)) * 2.8
            divine_damage3 = math.ceil(ability_data[3] * self.check_enemy_vunerability(3)) * 2.8
            divine_damage4 = math.ceil(ability_data[3] * self.check_enemy_vunerability(4)) * 2.8
            divine_damage5 = math.ceil(ability_data[3] * self.check_enemy_vunerability(5)) * 2.8
            if 1 in target_list:
                ai1_hp = ai1_hp - divine_damage1
                self.apply_divineDot(1,2)
                if champion1_hp != 0:
                    self.check_champion_blessing(1, divine_damage1)
                if champion2_hp != 0:
                    self.check_champion_blessing(2, divine_damage1)
                if champion3_hp != 0:
                    self.check_champion_blessing(3, divine_damage1)
                if champion4_hp != 0:
                    self.check_champion_blessing(4, divine_damage1)
                if champion5_hp != 0:
                    self.check_champion_blessing(5, divine_damage1)
            if 2 in target_list:
                ai2_hp = ai2_hp - divine_damage2
                self.apply_divineDot(2,2)
                if champion1_hp != 0:
                    self.check_champion_blessing(1, divine_damage2)
                if champion2_hp != 0:
                    self.check_champion_blessing(2, divine_damage2)
                if champion3_hp != 0:
                    self.check_champion_blessing(3, divine_damage2)
                if champion4_hp != 0:
                    self.check_champion_blessing(4, divine_damage2)
                if champion5_hp != 0:
                    self.check_champion_blessing(5, divine_damage2)
            if 3 in target_list:
                ai3_hp = ai3_hp - divine_damage3
                self.apply_divineDot(3,2)
                if champion1_hp != 0:
                    self.check_champion_blessing(1, divine_damage3)
                if champion2_hp != 0:
                    self.check_champion_blessing(2, divine_damage3)
                if champion3_hp != 0:
                    self.check_champion_blessing(3, divine_damage3)
                if champion4_hp != 0:
                    self.check_champion_blessing(4, divine_damage3)
                if champion5_hp != 0:
                    self.check_champion_blessing(5, divine_damage3)
            if 4 in target_list:
                ai4_hp = ai4_hp - divine_damage4
                self.apply_divineDot(4,2)
                if champion1_hp != 0:
                    self.check_champion_blessing(1, divine_damage4)
                if champion2_hp != 0:
                    self.check_champion_blessing(2, divine_damage4)
                if champion3_hp != 0:
                    self.check_champion_blessing(3, divine_damage4)
                if champion4_hp != 0:
                    self.check_champion_blessing(4, divine_damage4)
                if champion5_hp != 0:
                    self.check_champion_blessing(5, divine_damage4)
            if 5 in target_list:
                ai5_hp = ai5_hp - divine_damage5
                self.apply_divineDot(5,2)
                if champion1_hp != 0:
                    self.check_champion_blessing(1, divine_damage5)
                if champion2_hp != 0:
                    self.check_champion_blessing(2, divine_damage5)
                if champion3_hp != 0:
                    self.check_champion_blessing(3, divine_damage5)
                if champion4_hp != 0:
                    self.check_champion_blessing(4, divine_damage5)
                if champion5_hp != 0:
                    self.check_champion_blessing(5, divine_damage5)
        #Deals damage to all alive enemies and heals allies with the 'Blessed' buff
        #Then grants all alive allies with the 'Blessed' buff
        #Which converts all damage done by the Priest into healing for those affected by 'Blessed'
        elif ability_data[0] == "Diffracting Nova":
            nova_damage1 = math.ceil(ability_data[3] * self.check_enemy_vunerability(1))
            nova_damage2 = math.ceil(ability_data[3] * self.check_enemy_vunerability(2))
            nova_damage3 = math.ceil(ability_data[3] * self.check_enemy_vunerability(3))
            nova_damage4 = math.ceil(ability_data[3] * self.check_enemy_vunerability(4))
            nova_damage5 = math.ceil(ability_data[3] * self.check_enemy_vunerability(5))
            if AI_SPAWNED == 1:
                ai1_hp = ai1_hp - nova_damage1
                if champion1_hp != 0:
                    self.check_champion_blessing(1, nova_damage1)
                if champion2_hp != 0:
                    self.check_champion_blessing(2, nova_damage1)
                if champion3_hp != 0:
                    self.check_champion_blessing(3, nova_damage1)
                if champion4_hp != 0:
                    self.check_champion_blessing(4, nova_damage1)
                if champion5_hp != 0:
                    self.check_champion_blessing(5, nova_damage1)
            if AI_SPAWNED == 2:
                if ai1_hp > 0:
                    ai1_hp = ai1_hp - nova_damage1
                else:
                    nova_damage1 = 0
                if ai2_hp > 0:
                    ai2_hp = ai2_hp - nova_damage2
                else:
                    nova_damage2 = 0
                total_nova_damage = nova_damage1 + nova_damage2
                if champion1_hp != 0:
                    self.check_champion_blessing(1, total_nova_damage)
                if champion2_hp != 0:
                    self.check_champion_blessing(2, total_nova_damage)
                if champion3_hp != 0:
                    self.check_champion_blessing(3, total_nova_damage)
                if champion4_hp != 0:
                    self.check_champion_blessing(4, total_nova_damage)
                if champion5_hp != 0:
                    self.check_champion_blessing(5, total_nova_damage)
            if AI_SPAWNED == 3:
                if ai1_hp > 0:
                    ai1_hp = ai1_hp - nova_damage1
                else:
                    nova_damage1 = 0
                if ai2_hp > 0:
                    ai2_hp = ai2_hp - nova_damage2
                else:
                    nova_damage2 = 0
                if ai3_hp > 0:
                    ai3_hp = ai3_hp - nova_damage3
                else:
                    nova_damage3 = 0
                total_nova_damage = nova_damage1 + nova_damage2 + nova_damage3
                if champion1_hp != 0:
                    self.check_champion_blessing(1, total_nova_damage)
                if champion2_hp != 0:
                    self.check_champion_blessing(2, total_nova_damage)
                if champion3_hp != 0:
                    self.check_champion_blessing(3, total_nova_damage)
                if champion4_hp != 0:
                    self.check_champion_blessing(4, total_nova_damage)
                if champion5_hp != 0:
                    self.check_champion_blessing(5, total_nova_damage)
            if AI_SPAWNED == 4:
                if ai1_hp > 0:
                    ai1_hp = ai1_hp - nova_damage1
                else:
                    nova_damage1 = 0
                if ai2_hp > 0:
                    ai2_hp = ai2_hp - nova_damage2
                else:
                    nova_damage2 = 0
                if ai3_hp > 0:
                    ai3_hp = ai3_hp - nova_damage3
                else:
                    nova_damage3 = 0
                if ai4_hp > 0:
                    ai4_hp = ai4_hp - nova_damage4
                else:
                    nova_damage4 = 0
                total_nova_damage = nova_damage1 + nova_damage2 + nova_damage3 + nova_damage4
                if champion1_hp != 0:
                    self.check_champion_blessing(1, total_nova_damage)
                if champion2_hp != 0:
                    self.check_champion_blessing(2, total_nova_damage)
                if champion3_hp != 0:
                    self.check_champion_blessing(3, total_nova_damage)
                if champion4_hp != 0:
                    self.check_champion_blessing(4, total_nova_damage)
                if champion5_hp != 0:
                    self.check_champion_blessing(5, total_nova_damage)
            if AI_SPAWNED == 5:
                if ai1_hp > 0:
                    ai1_hp = ai1_hp - nova_damage1
                else:
                    nova_damage1 = 0
                if ai2_hp > 0:
                    ai2_hp = ai2_hp - nova_damage2
                else:
                    nova_damage2 = 0
                if ai3_hp > 0:
                    ai3_hp = ai3_hp - nova_damage3
                else:
                    nova_damage3 = 0
                if ai4_hp > 0:
                    ai4_hp = ai4_hp - nova_damage4
                else:
                    nova_damage4 = 0
                if ai5_hp > 0:
                    ai5_hp = ai5_hp - nova_damage5
                else:
                    nova_damage5 = 0
                total_nova_damage = nova_damage1 + nova_damage2 + nova_damage3 + nova_damage4 + nova_damage5
                if champion1_hp != 0:
                    self.check_champion_blessing(1, total_nova_damage)
                if champion2_hp != 0:
                    self.check_champion_blessing(2, total_nova_damage)
                if champion3_hp != 0:
                    self.check_champion_blessing(3, total_nova_damage)
                if champion4_hp != 0:
                    self.check_champion_blessing(4, total_nova_damage)
                if champion5_hp != 0:
                    self.check_champion_blessing(5, total_nova_damage)
            if champion1_hp != 0:
                self.grant_champion_blessing(1)
            if champion2_hp != 0:
                self.grant_champion_blessing(2)
            if champion3_hp != 0:
                self.grant_champion_blessing(3)
            if champion4_hp != 0:
                self.grant_champion_blessing(4)
            if champion5_hp != 0:
                self.grant_champion_blessing(5)
        #Deals damage to chosen enemy
        elif ability_data[0] == "Cybernetic Blast":
            if 1 in target_list:
                ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1)) * 1.4
            if 2 in target_list:
                ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2)) * 1.4
            if 3 in target_list:
                ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3)) * 1.4
            if 4 in target_list:
                ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4)) * 1.4
            if 5 in target_list:
                ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5)) * 1.4
        #Deals damage to chosen enemy
        elif ability_data[0] == "Snip Snip":
            if 1 in target_list:
                ai1_hp = ai1_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(1)) * 2.2
            if 2 in target_list:
                ai2_hp = ai2_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(2)) * 2.2
            if 3 in target_list:
                ai3_hp = ai3_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(3)) * 2.2
            if 4 in target_list:
                ai4_hp = ai4_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(4)) * 2.2
            if 5 in target_list:
                ai5_hp = ai5_hp - math.ceil(ability_data[3] * self.check_enemy_vunerability(5)) * 2.2
        ai1_hp = math.ceil(ai1_hp)
        ai2_hp = math.ceil(ai2_hp)
        ai3_hp = math.ceil(ai3_hp)
        ai4_hp = math.ceil(ai4_hp)
        ai5_hp = math.ceil(ai5_hp)
#Function that activates the chosen abilities effect
#Globals that are referenced in more than one ability are globaled at the beginning of the function, whereas ability specific ones are globaled inside their ability effect
    def finalise_healing_done(self, target_list):
        global champion1_hp, champion2_hp, champion3_hp, champion4_hp, champion5_hp, channeling_strength, \
            champion1_immunity, champion2_immunity, champion3_immunity, champion4_immunity, champion5_immunity, \
            champion1_statuses, champion2_statuses, champion3_statuses, champion4_statuses, champion5_statuses, nanobot_overclock, ability_data
        counter = 0
        #Checks for the Bloodmancers 'Channeling Strength' buff
        #If he has it and the ability has a healing or damage value (ability_data[3]), the buff is consumed and it increases ability_data[3] by 50%
        if channeling_strength != 0:
            if len(ability_data) == 4:
                ability_data[3] = ability_data[3] * 1.5
                channeling_strength = 0
        #Gives all alive allies the 'Fortified' buff, which reduces damage taken by 15%
        if ability_data[0] == "Fortification":
            global champion1_fortification, champion2_fortification, champion3_fortification, \
                champion4_fortification, champion5_fortification
            if champion1_hp != 0:
                champion1_fortification = 2
                champion1_statuses.append("Fortified")
            if champion2_hp != 0:
                champion2_fortification = 2
                champion2_statuses.append("Fortified")
            if champion3_hp != 0:
                champion3_fortification = 2
                champion3_statuses.append("Fortified")
            if champion4_hp != 0:
                champion4_fortification = 2
                champion4_statuses.append("Fortified")
            if champion5_hp != 0:
                champion5_fortification = 2
                champion5_statuses.append("Fortified")
        #Give the chosen ally the 'Block' buff
        #Whenever they are to take damage, the Kings-Guard takes it instead
        #If the Kings-Guard is given the buff, they instead take 50% less damage
        elif ability_data[0] == "Block":
            if 1 in target_list:
                champion1_immunity.append("Block")
                champion1_statuses.append("Immunity: Block")
            if 2 in target_list:
                champion2_immunity.append("Block")
                champion2_statuses.append("Immunity: Block")
            if 3 in target_list:
                champion3_immunity.append("Block")
                champion3_statuses.append("Immunity: Block")
            if 4 in target_list:
                champion4_immunity.append("Block")
                champion4_statuses.append("Immunity: Block")
            if 5 in target_list:
                champion5_immunity.append("Block")
                champion5_statuses.append("Immunity: Block")
        #Gives the chosen ally the 'Bush Armour' buff, causing attackers that hit them to take 200 damage and become embedded by one thorn
        elif ability_data[0] == "Barbed Bush Armour":
            global champion1_bush_armour, champion2_bush_armour, champion3_bush_armour, champion4_bush_armour, champion5_bush_armour
            if 1 in target_list:
                champion1_bush_armour = 5
                if "Bush Armour" not in champion1_statuses:
                    champion1_statuses.append("Bush Armour")
            if 2 in target_list:
                champion2_bush_armour = 5
                if "Bush Armour" not in champion2_statuses:
                    champion2_statuses.append("Bush Armour")
            if 3 in target_list:
                champion3_bush_armour = 5
                if "Bush Armour" not in champion3_statuses:
                    champion3_statuses.append("Bush Armour")
            if 4 in target_list:
                champion4_bush_armour = 5
                if "Bush Armour" not in champion4_statuses:
                    champion4_statuses.append("Bush Armour")
            if 5 in target_list:
                champion5_bush_armour = 5
                if "Bush Armour" not in champion5_statuses:
                    champion5_statuses.append("Bush Armour")
        #Gives the chosen ally the 'Enlarged Muscles' buff, increasing their damage done by 60%
        elif ability_data[0] == "Muscle Enlarger":
            global champion1_muscleEnlarger, champion2_muscleEnlarger, champion3_muscleEnlarger, \
                champion4_muscleEnlarger, champion5_muscleEnlarger
            if 1 in target_list:
                champion1_muscleEnlarger = 3
                if "Enlarged Muscles" not in champion1_statuses:
                    champion1_statuses.append("Enlarged Muscles")
            if 2 in target_list:
                champion2_muscleEnlarger = 3
                if "Enlarged Muscles" not in champion2_statuses:
                    champion2_statuses.append("Enlarged Muscles")
            if 3 in target_list:
                champion3_muscleEnlarger = 3
                if "Enlarged Muscles" not in champion3_statuses:
                    champion3_statuses.append("Enlarged Muscles")
            if 4 in target_list:
                champion4_muscleEnlarger = 3
                if "Enlarged Muscles" not in champion4_statuses:
                    champion4_statuses.append("Enlarged Muscles")
            if 5 in target_list:
                champion5_muscleEnlarger = 3
                if "Enlarged Muscles" not in champion5_statuses:
                    champion5_statuses.append("Enlarged Muscles")
        #Heals the chosen ally
        elif ability_data[0] == "Mistic Bloom":
            if 1 in target_list:
                champion1_hp = champion1_hp + ability_data[3]
                if champion1_hp > CHAMPION1_HP:
                    champion1_hp = CHAMPION1_HP
            if 2 in target_list:
                champion2_hp = champion2_hp + ability_data[3]
                if champion2_hp > CHAMPION2_HP:
                    champion2_hp = CHAMPION2_HP
            if 3 in target_list:
                champion3_hp = champion3_hp + ability_data[3]
                if champion3_hp > CHAMPION3_HP:
                    champion3_hp = CHAMPION3_HP
            if 4 in target_list:
                champion4_hp = champion4_hp + ability_data[3]
                if champion4_hp > CHAMPION4_HP:
                    champion4_hp = CHAMPION4_HP
            if 5 in target_list:
                champion5_hp = champion5_hp + ability_data[3]
                if champion5_hp > CHAMPION5_HP:
                    champion5_hp = CHAMPION5_HP
        #Gives the chosen ally the 'Fullest Potential' buff, increasing their damage done by 200%
        elif ability_data[0] == "Full Potential":
            global champion1_fullPotential, champion2_fullPotential, champion3_fullPotential, \
                champion4_fullPotential, champion5_fullPotential
            if 1 in target_list:
                champion1_fullPotential = 3
                champion1_statuses.append("Fullest Potential")
            if 2 in target_list:
                champion2_fullPotential = 3
                champion2_statuses.append("Fullest Potential")
            if 3 in target_list:
                champion3_fullPotential = 3
                champion3_statuses.append("Fullest Potential")
            if 4 in target_list:
                champion4_fullPotential = 3
                champion4_statuses.append("Fullest Potential")
            if 5 in target_list:
                champion5_fullPotential = 3
                champion5_statuses.append("Fullest Potential")
        #Heals chosen allies and applies 'Flowing Waters' to them (healing them over time)
        elif ability_data[0] == "Spring Waters":
            if 1 in target_list:
                champion1_hp = champion1_hp + ability_data[3]
                if champion1_hp > CHAMPION1_HP:
                    champion1_hp = CHAMPION1_HP
                self.apply_spring_waters(1, 3)
            if 2 in target_list:
                champion2_hp = champion2_hp + ability_data[3]
                if champion2_hp > CHAMPION2_HP:
                    champion2_hp = CHAMPION2_HP
                self.apply_spring_waters(2, 3)
            if 3 in target_list:
                champion3_hp = champion3_hp + ability_data[3]
                if champion3_hp > CHAMPION3_HP:
                    champion3_hp = CHAMPION3_HP
                self.apply_spring_waters(3, 3)
            if 4 in target_list:
                champion4_hp = champion4_hp + ability_data[3]
                if champion4_hp > CHAMPION4_HP:
                    champion4_hp = CHAMPION4_HP
                self.apply_spring_waters(4, 3)
            if 5 in target_list:
                champion5_hp = champion5_hp + ability_data[3]
                if champion5_hp > CHAMPION5_HP:
                    champion5_hp = CHAMPION5_HP
                self.apply_spring_waters(5, 3)
        #Heals all alive allies, extends all active 'Flowing Waters' buffs by 1 turn, and applies 'Crashing Waters' to all allies (healing them over time)
        elif ability_data[0] == "Ocean Tides":
            if champion1_hp != 0:
                champion1_hp = champion1_hp + ability_data[3] * 1.5
                if champion1_hp > CHAMPION1_HP:
                    champion1_hp = CHAMPION1_HP
            if champion2_hp != 0:
                champion2_hp = champion2_hp + ability_data[3] * 1.5
                if champion2_hp > CHAMPION2_HP:
                    champion2_hp = CHAMPION2_HP
            if champion3_hp != 0:
                champion3_hp = champion3_hp + ability_data[3] * 1.5
                if champion3_hp > CHAMPION3_HP:
                    champion3_hp = CHAMPION3_HP
            if champion4_hp != 0:
                champion4_hp = champion4_hp + ability_data[3] * 1.5
                if champion4_hp > CHAMPION4_HP:
                    champion4_hp = CHAMPION4_HP
            if champion5_hp != 0:
                champion5_hp = champion5_hp + ability_data[3] * 1.5
                if champion5_hp > CHAMPION5_HP:
                    champion5_hp = CHAMPION5_HP
            self.apply_ocean_tide(1)
        #Makes the chosen ally immune to damage until next turn
        elif ability_data[0] == "Boulder Cocoon":
            if 1 in target_list:
                champion1_immunity.append("Cocoon")
                champion1_statuses.append("Immunity: Cocoon")
            if 2 in target_list:
                champion2_immunity.append("Cocoon")
                champion2_statuses.append("Immunity: Cocoon")
            if 3 in target_list:
                champion3_immunity.append("Cocoon")
                champion3_statuses.append("Immunity: Cocoon")
            if 4 in target_list:
                champion4_immunity.append("Cocoon")
                champion4_statuses.append("Immunity: Cocoon")
            if 5 in target_list:
                champion5_immunity.append("Cocoon")
                champion5_statuses.append("Immunity: Cocoon")
        #Heals chosen allies and gives them the 'Blessed' buff
        #Which converts all damage done by the Priest into healing for those affected by 'Blessed'
        elif ability_data[0] == "Healing Light":
            if 1 in target_list:
                champion1_hp = champion1_hp + ability_data[3]
                if champion1_hp > CHAMPION1_HP:
                    champion1_hp = CHAMPION1_HP
                self.grant_champion_blessing(1)
            if 2 in target_list:
                champion2_hp = champion2_hp + ability_data[3]
                if champion2_hp > CHAMPION2_HP:
                    champion2_hp = CHAMPION2_HP
                self.grant_champion_blessing(2)
            if 3 in target_list:
                champion3_hp = champion3_hp + ability_data[3]
                if champion3_hp > CHAMPION3_HP:
                    champion3_hp = CHAMPION3_HP
                self.grant_champion_blessing(3)
            if 4 in target_list:
                champion4_hp = champion4_hp + ability_data[3]
                if champion4_hp > CHAMPION4_HP:
                    champion4_hp = CHAMPION4_HP
                self.grant_champion_blessing(4)
            if 5 in target_list:
                champion5_hp = champion5_hp + ability_data[3]
                if champion5_hp > CHAMPION5_HP:
                    champion5_hp = CHAMPION5_HP
                self.grant_champion_blessing(5)
        #Give the Time Walker the 'Overclock Nanobots' buff
        #This causes the Time Walkers passive to heal for double per turn (10% > 20%)
        elif ability_data[0] == "Overclock Nanobots":
            nanobot_overclock = 2
        #Heals all damage taken from chosen ally through the last rounds monsters turn to this turn before monsters turn (:Last Rounds monsters_turn > This Rounds champion_turn:)
        elif ability_data[0] == "Reverse Wounds":
            if 1 in target_list:
                for damage in champion1_lastRoundDamageTaken_list:
                    champion1_hp = champion1_hp + int(damage)
                    if champion1_hp > CHAMPION1_HP:
                        champion1_hp = CHAMPION1_HP
            if 2 in target_list:
                for damage in champion2_lastRoundDamageTaken_list:
                    champion2_hp = champion2_hp + int(damage)
                    if champion2_hp > CHAMPION2_HP:
                        champion2_hp = CHAMPION2_HP
            if 3 in target_list:
                for damage in champion3_lastRoundDamageTaken_list:
                    champion3_hp = champion3_hp + int(damage)
                    if champion3_hp > CHAMPION3_HP:
                        champion3_hp = CHAMPION3_HP
            if 4 in target_list:
                for damage in champion4_lastRoundDamageTaken_list:
                    champion4_hp = champion4_hp + int(damage)
                    if champion4_hp > CHAMPION4_HP:
                        champion4_hp = CHAMPION4_HP
            if 5 in target_list:
                for damage in champion5_lastRoundDamageTaken_list:
                    champion5_hp = champion5_hp + int(damage)
                    if champion5_hp > CHAMPION5_HP:
                        champion5_hp = CHAMPION5_HP
        #Heals chosen ally to full health points
        elif ability_data[0] == "Alter Time":
            if champion1_hp != 0:
                champion1_hp = CHAMPION1_HP
            if champion2_hp != 0:
                champion2_hp = CHAMPION2_HP
            if champion3_hp != 0:
                champion3_hp = CHAMPION3_HP
            if champion4_hp != 0:
                champion4_hp = CHAMPION4_HP
            if champion5_hp != 0:
                champion5_hp = CHAMPION5_HP
        #Heals and gives the 'Bandaged' buff to chosen ally
        elif ability_data[0] == "Bandages":
            if 1 in target_list:
                champion1_hp = champion1_hp + ability_data[3]
                if champion1_hp > CHAMPION1_HP:
                    champion1_hp = CHAMPION1_HP
                self.apply_bandages(1, 2)
            if 2 in target_list:
                champion2_hp = champion2_hp + ability_data[3]
                if champion2_hp > CHAMPION2_HP:
                    champion2_hp = CHAMPION2_HP
                self.apply_bandages(2, 2)
            if 3 in target_list:
                champion3_hp = champion3_hp + ability_data[3]
                if champion3_hp > CHAMPION3_HP:
                    champion3_hp = CHAMPION3_HP
                self.apply_bandages(3, 2)
            if 4 in target_list:
                champion4_hp = champion4_hp + ability_data[3]
                if champion4_hp > CHAMPION4_HP:
                    champion4_hp = CHAMPION4_HP
                self.apply_bandages(4, 2)
            if 5 in target_list:
                champion5_hp = champion5_hp + ability_data[3]
                if champion5_hp > CHAMPION5_HP:
                    champion5_hp = CHAMPION5_HP
                self.apply_bandages(5, 2)
        #Gives the 'Tight Tourniquet' buff to chosen ally
        #Reduces damage taken by 20%
        elif ability_data[0] == "Tight Tourniquet":
            global champion1_tighttourniquet, champion2_tighttourniquet, champion3_tighttourniquet, \
                champion4_tighttourniquet, champion5_tighttourniquet
            if 1 in target_list:
                champion1_tighttourniquet = 1
                if "Tight Tourniquet" not in champion1_statuses:
                    champion1_statuses.append("Tight Tourniquet")
            if 2 in target_list:
                champion2_tighttourniquet = 1
                if "Tight Tourniquet" not in champion2_statuses:
                    champion2_statuses.append("Tight Tourniquet")
            if 3 in target_list:
                champion3_tighttourniquet = 1
                if "Tight Tourniquet" not in champion3_statuses:
                    champion3_statuses.append("Tight Tourniquet")
            if 4 in target_list:
                champion4_tighttourniquet = 1
                if "Tight Tourniquet" not in champion4_statuses:
                    champion4_statuses.append("Tight Tourniquet")
            if 5 in target_list:
                champion5_tighttourniquet = 1
                if "Tight Tourniquet" not in champion5_statuses:
                    champion5_statuses.append("Tight Tourniquet")
        #Gives the 'Strong Remedy' buff to chosen ally
        #Increases damage done by 50%
        elif ability_data[0] == "Secret Remedy":
            global champion1_strongremedy, champion2_strongremedy, champion3_strongremedy, \
                champion4_strongremedy, champion5_strongremedy
            if 1 in target_list:
                champion1_strongremedy = 1
                if "Strong Remedy" not in champion1_statuses:
                    champion1_statuses.append("Strong Remedy")
            if 2 in target_list:
                champion2_strongremedy = 1
                if "Strong Remedy" not in champion2_statuses:
                    champion2_statuses.append("Strong Remedy")
            if 3 in target_list:
                champion3_strongremedy = 1
                if "Strong Remedy" not in champion3_statuses:
                    champion3_statuses.append("Strong Remedy")
            if 4 in target_list:
                champion4_strongremedy = 1
                if "Strong Remedy" not in champion4_statuses:
                    champion4_statuses.append("Strong Remedy")
            if 5 in target_list:
                champion5_strongremedy = 1
                if "Strong Remedy" not in champion5_statuses:
                    champion5_statuses.append("Strong Remedy")
#Function that activates the chosen abilities effect
#Globals that are referenced in more than one ability are globaled at the beginning of the function, whereas ability specific ones are globaled inside their ability effect
    def finalise_self_buff(self):
        global ai1_hp, ai2_hp,ai3_hp,ai4_hp,ai5_hp, champion1_hp, champion2_hp, champion3_hp, champion4_hp, champion5_hp, \
            champion1_immunity, champion2_immunity, champion3_immunity, champion4_immunity, champion5_immunity
        counter = 0
        #Removes one charge from all baubles that have charges and halves the damage of each charge
        if ability_data[0] == "Harmonize":
            global monk_bauble_damage_list1, monk_bauble_damage_list2, monk_bauble_damage_list3
            if monk_bauble_damage_list1[1] != 0:
                monk_bauble_damage_list1[1] = monk_bauble_damage_list1[1] - 1
                monk_bauble_damage_list1[0] = monk_bauble_damage_list1[0] / 2
            if monk_bauble_damage_list2[1] != 0:
                monk_bauble_damage_list2[1] = monk_bauble_damage_list2[1] - 1
                monk_bauble_damage_list2[0] = monk_bauble_damage_list2[0] / 2
            if monk_bauble_damage_list3[1] != 0:
                monk_bauble_damage_list3[1] = monk_bauble_damage_list3[1] - 1
                monk_bauble_damage_list3[0] = monk_bauble_damage_list3[0] / 2
        #Applies the 'Taunted' debuff to all alive enemies for two turns
        elif ability_data[0] == "Challenging Shout":
            if AI_SPAWNED == 1:
                self.apply_taunt(1, BARBARIAN.title, 2)
            if AI_SPAWNED == 2:
                if ai1_hp != 0:
                    self.apply_taunt(1, BARBARIAN.title, 2)
                if ai2_hp != 0:
                    self.apply_taunt(2, BARBARIAN.title, 2)
            if AI_SPAWNED == 3:
                if ai1_hp != 0:
                    self.apply_taunt(1, BARBARIAN.title, 2)
                if ai2_hp != 0:
                    self.apply_taunt(2, BARBARIAN.title, 2)
                if ai3_hp != 0:
                    self.apply_taunt(3, BARBARIAN.title, 2)
            if AI_SPAWNED == 4:
                if ai1_hp != 0:
                    self.apply_taunt(1, BARBARIAN.title, 2)
                if ai2_hp != 0:
                    self.apply_taunt(2, BARBARIAN.title, 2)
                if ai3_hp != 0:
                    self.apply_taunt(3, BARBARIAN.title, 2)
                if ai4_hp != 0:
                    self.apply_taunt(4, BARBARIAN.title, 2)
            if AI_SPAWNED == 5:
                if ai1_hp != 0:
                    self.apply_taunt(1, BARBARIAN.title, 2)
                if ai2_hp != 0:
                    self.apply_taunt(2, BARBARIAN.title, 2)
                if ai3_hp != 0:
                    self.apply_taunt(3, BARBARIAN.title, 2)
                if ai4_hp != 0:
                    self.apply_taunt(4, BARBARIAN.title, 2)
                if ai5_hp != 0:
                    self.apply_taunt(5, BARBARIAN.title, 2)
        #Heals the Barbarian for 300 health points for each enemy attacking him
        #Cannot heal over his maximum hit points
        elif ability_data[0] == "Impactful Boast":
            point = 0
            if AI_SPAWNED == 1:
                if BARBARIAN.title in ai1_attack_intention:
                    point += 1
            if AI_SPAWNED == 2:
                if BARBARIAN.title in ai1_attack_intention:
                    point += 1
                if BARBARIAN.title in ai2_attack_intention:
                    point += 1
            if AI_SPAWNED == 3:
                if BARBARIAN.title in ai1_attack_intention:
                    point += 1
                if BARBARIAN.title in ai2_attack_intention:
                    point += 1
                if BARBARIAN.title in ai3_attack_intention:
                    point += 1
            if AI_SPAWNED == 4:
                if BARBARIAN.title in ai1_attack_intention:
                    point += 1
                if BARBARIAN.title in ai2_attack_intention:
                    point += 1
                if BARBARIAN.title in ai3_attack_intention:
                    point += 1
                if BARBARIAN.title in ai4_attack_intention:
                    point += 1
            if AI_SPAWNED == 5:
                if BARBARIAN.title in ai1_attack_intention:
                    point += 1
                if BARBARIAN.title in ai2_attack_intention:
                    point += 1
                if BARBARIAN.title in ai3_attack_intention:
                    point += 1
                if BARBARIAN.title in ai4_attack_intention:
                    point += 1
                if BARBARIAN.title in ai5_attack_intention:
                    point += 1
            for character in CHAMPION_LIST:
                counter += 1
                if character == BARBARIAN.title:
                    if counter == 1:
                        champion1_hp = champion1_hp + (300 * point)
                        if champion1_hp > CHAMPION1_HP:
                            champion1_hp = CHAMPION1_HP
                        break
                    if counter == 2:
                        champion2_hp = champion2_hp + (300 * point)
                        if champion2_hp > CHAMPION2_HP:
                            champion2_hp = CHAMPION2_HP
                        break
                    if counter == 3:
                        champion3_hp = champion3_hp + (300 * point)
                        if champion3_hp > CHAMPION3_HP:
                            champion3_hp = CHAMPION3_HP
                        break
                    if counter == 4:
                        champion4_hp = champion4_hp + (300 * point)
                        if champion4_hp > CHAMPION4_HP:
                            champion4_hp = CHAMPION4_HP
                        break
                    if counter == 5:
                        champion5_hp = champion5_hp + (300 * point)
                        if champion5_hp > CHAMPION5_HP:
                            champion5_hp = CHAMPION5_HP
                        break
        #Gives the Fencer the 'Evasive Manoeuvres' buff
        #While this buff is active, she has a 100% chance to dodge all attacks and the damage reduced by dodging is increased to 100% regardless of enemy size class
        elif ability_data[0] == "Evasive Manoeuvres":
            for character in CHAMPION_LIST:
                counter += 1
                if character == MASTER_FENCER.title:
                    if counter == 1:
                        champion1_immunity.append("Evasive Manoeuvres")
                        champion1_statuses.append("Immunity: Evasion")
                        break
                    if counter == 2:
                        champion2_immunity.append("Evasive Manoeuvres")
                        champion2_statuses.append("Immunity: Evasion")
                        break
                    if counter == 3:
                        champion3_immunity.append("Evasive Manoeuvres")
                        champion3_statuses.append("Immunity: Evasion")
                        break
                    if counter == 4:
                        champion4_immunity.append("Evasive Manoeuvres")
                        champion4_statuses.append("Immunity: Evasion")
                        break
                    if counter == 5:
                        champion5_immunity.append("Evasive Manoeuvres")
                        champion5_statuses.append("Immunity: Evasion")
                        break
        #Gives the Berserker the 'Pure Rage' buff
        #While this buff is active, the Berserker deals 50% more damage but takes an increased 30% damage from enemies
        elif ability_data[0] == "Pure Rage":
            global champion1_pure_rage, champion2_pure_rage, champion3_pure_rage, champion4_pure_rage, champion5_pure_rage
            for character in CHAMPION_LIST:
                counter += 1
                if character == BERSERKER.title:
                    if counter == 1:
                        champion1_pure_rage = 3
                        if "Pure Rage" not in champion1_statuses:
                            champion1_statuses.append("Pure Rage")
                        break
                    if counter == 2:
                        champion2_pure_rage = 3
                        if "Pure Rage" not in champion2_statuses:
                            champion2_statuses.append("Pure Rage")
                        break
                    if counter == 3:
                        champion3_pure_rage = 3
                        if "Pure Rage" not in champion3_statuses:
                            champion3_statuses.append("Pure Rage")
                        break
                    if counter == 4:
                        champion4_pure_rage = 3
                        if "Pure Rage" not in champion4_statuses:
                            champion4_statuses.append("Pure Rage")
                        break
                    if counter == 5:
                        champion5_pure_rage = 3
                        if "Pure Rage" not in champion5_statuses:
                            champion5_statuses.append("Pure Rage")
                        break
        #Gives the Berserker the 'Reckless Flurry' buff
        #Any combonation of the next two 'Angering Strike' or 'Unbridled Rampage' hit all enemies alive instead of just one
        elif ability_data[0] == "Reckless Flurry":
            global reckless_flurry_buff
            reckless_flurry_buff = 2
        #Gives the Survivalist the 'Playing Dead' buff
        #Any enemies that were attacking the Survivalist when he obtains this buff are forced to switch to another target
        elif ability_data[0] == "Play Dead":
            global champion1_play_dead, champion2_play_dead, champion3_play_dead , \
                champion4_play_dead, champion5_play_dead, prepare_buff
            for character in CHAMPION_LIST:
                counter += 1
                if character == SURVIVALIST.title:
                    if counter == 1:
                        champion1_play_dead = 1
                        break
                    if counter == 2:
                        champion2_play_dead = 1
                        break
                    if counter == 3:
                        champion3_play_dead = 1
                        break
                    if counter == 4:
                        champion4_play_dead = 1
                        break
                    if counter == 5:
                        champion5_play_dead = 1
                        break
                    prepare_buff = 1
        #Heals the Survivalist for 60% of their maximum health points and gives them the 'Prepared' buff
        elif ability_data[0] == "Survival Kit":
            for character in CHAMPION_LIST:
                counter += 1
                if character == SURVIVALIST.title:
                    if counter == 1:
                        champion1_hp = champion1_hp + (CHAMPION1_HP * 0.6)
                        if champion1_hp > CHAMPION1_HP:
                            champion1_hp = CHAMPION1_HP
                        break
                    if counter == 2:
                        champion2_hp = champion2_hp + (CHAMPION2_HP * 0.6)
                        if champion2_hp > CHAMPION2_HP:
                            champion2_hp = CHAMPION2_HP
                        break
                    if counter == 3:
                        champion3_hp = champion3_hp + (CHAMPION3_HP * 0.6)
                        if champion3_hp > CHAMPION3_HP:
                            champion3_hp = CHAMPION3_HP
                        break
                    if counter == 4:
                        champion4_hp = champion4_hp + (CHAMPION4_HP * 0.6)
                        if champion4_hp > CHAMPION4_HP:
                            champion4_hp = CHAMPION4_HP
                        break
                    if counter == 5:
                        champion5_hp = champion5_hp + (CHAMPION5_HP * 0.6)
                        if champion5_hp > CHAMPION5_HP:
                            champion5_hp = CHAMPION5_HP
                        break
                    prepare_buff = 1
        #Gives the Mage a shield that prevents the next 500 damage they would've taken
        elif ability_data[0] == "Magical Barrier":
            global champion1_magical_barrier, champion2_magical_barrier, champion3_magical_barrier, champion4_magical_barrier, champion5_magical_barrier
            for character in CHAMPION_LIST:
                counter += 1
                if character == ACADEMIC_MAGE.title:
                    if counter == 1:
                        champion1_magical_barrier = 500
                        break
                    if counter == 2:
                        champion2_magical_barrier = 500
                        break
                    if counter == 3:
                        champion3_magical_barrier = 500
                        break
                    if counter == 4:
                        champion4_magical_barrier = 500
                        break
                    if counter == 5:
                        champion5_magical_barrier = 500
                        break
        #Gives the Warlock the 'Void Infused' buff
        #Causes 'Black Bolt' to apply the 'Rotting' damage over time effect
        elif ability_data[0] == "Void Infusion":
            global void_infusion_stacks
            void_infusion_stacks += 1
        #Converts 1 point of health for 1 point of mana until the Warlock has reached his max resource amount (200)
        #If the amount of health that needs to be converted would kill the Warlock, nothing happens
        elif ability_data[0] == "Soul Tap":
            global champion1_rp, champion2_rp, champion3_rp, champion4_rp, champion5_rp
            for character in CHAMPION_LIST:
                counter += 1
                if character == WARLOCK.title:
                    if counter == 1:
                        hp_sacrifice_amount = CHAMPION1_RP - champion1_rp
                        if hp_sacrifice_amount < champion1_hp:
                            champion1_hp = champion1_hp - hp_sacrifice_amount
                            champion1_lastRoundDamageTaken_list.append(hp_sacrifice_amount)
                            champion1_rp = CHAMPION1_RP
                        break
                    elif counter == 2:
                        hp_sacrifice_amount = CHAMPION2_RP - champion2_rp
                        if hp_sacrifice_amount < champion2_hp:
                            champion2_hp = champion2_hp - hp_sacrifice_amount
                            champion2_lastRoundDamageTaken_list.append(hp_sacrifice_amount)
                            champion2_rp = CHAMPION2_RP
                        break
                    elif counter == 3:
                        hp_sacrifice_amount = CHAMPION3_RP - champion3_rp
                        if hp_sacrifice_amount < champion3_hp:
                            champion3_hp = champion3_hp - hp_sacrifice_amount
                            champion3_lastRoundDamageTaken_list.append(hp_sacrifice_amount)
                            champion3_rp = CHAMPION3_RP
                        break
                    elif counter == 4:
                        hp_sacrifice_amount = CHAMPION4_RP - champion4_rp
                        if hp_sacrifice_amount < champion4_hp:
                            champion4_hp = champion4_hp - hp_sacrifice_amount
                            champion4_lastRoundDamageTaken_list.append(hp_sacrifice_amount)
                            champion4_rp = CHAMPION4_RP
                        break
                    elif counter == 5:
                        hp_sacrifice_amount = CHAMPION5_RP - champion5_rp
                        if hp_sacrifice_amount < champion5_hp:
                            champion5_hp = champion5_hp - hp_sacrifice_amount
                            champion5_lastRoundDamageTaken_list.append(hp_sacrifice_amount)
                            champion5_rp = CHAMPION5_RP
                        break
        #Gives the Bloodmancer the 'Blood Boil' buff
        #Empowers the next ability the Bloodmancer uses
        elif ability_data[0] == "Blood Boil":
            global blood_boil_buff
            blood_boil_buff = True
        #If the Bloodmancer doesn't have the 'Blood Boil' buff , he gives himself the 'Enharden Nerves' buff (damage taken reduced by 40%)
        #If he does have 'Blood Boil', he gives all his allies the 'Enharden Nerves' buff
        #Casting the empowered ability gives the Bloodmancer the 'Channeling Strength' buff which causes the next allies damaging or healing ability to be 50% effective
        elif ability_data[0] == "Enharden Nerves":
            global champion1_enhardened_nerves, champion2_enhardened_nerves, champion3_enhardened_nerves, \
                champion4_enhardened_nerves, champion5_enhardened_nerves, channeling_strength
            if blood_boil_buff == True:
                champion1_statuses.append("Enharden Nerves")
                champion1_enhardened_nerves = 1
                champion2_statuses.append("Enharden Nerves")
                champion2_enhardened_nerves = 1
                champion3_statuses.append("Enharden Nerves")
                champion3_enhardened_nerves = 1
                champion4_statuses.append("Enharden Nerves")
                champion4_enhardened_nerves = 1
                champion5_statuses.append("Enharden Nerves")
                champion5_enhardened_nerves = 1
                channeling_strength = 1
                blood_boil_buff = False
            else:
                for character in CHAMPION_LIST:
                    counter += 1
                    if character == BLOODMANCER.title:
                        if counter == 1:
                            champion1_statuses.append("Enharden Nerves")
                            break
                        if counter == 2:
                            champion2_statuses.append("Enharden Nerves")
                            break
                        if counter == 3:
                            champion3_statuses.append("Enharden Nerves")
                            break
                        if counter == 4:
                            champion4_statuses.append("Enharden Nerves")
                            break
                        if counter == 5:
                            champion5_statuses.append("Enharden Nerves")
                            break
        #Sets the remaining cooldown of 'Electrical Expulsion to 0 and gives the Magnetimancer the 'Energised' buff
        #Which causes the next Electrical Expulsion to release 10 random charges instead of 5
        elif ability_data[0] == "Energise":
            global energised, electrical_expulsion_requirements
            if electrical_expulsion_requirements[3] != 0:
                electrical_expulsion_requirements[3] = 0
            energised = 1
#Applies the 'Blessed' effect to the ally specificed from the 'target' parameter
#Blessed is applied by the Priests 'Healing Light' and 'Diffracting Nova'
#Blessed heals the affected ally equal to the amount of damage the Priest deals (including Dot ticks)
    def grant_champion_blessing(self, target):
        global champion1_blessing, champion2_blessing, champion3_blessing, champion4_blessing, champion5_blessing, \
            champion1_statuses, champion2_statuses, champion3_statuses, champion4_statuses, champion5_statuses
        if target == 1:
            champion1_blessing = 3
            if "Blessed" not in champion1_statuses:
                champion1_statuses.append("Blessed")
        if target == 2:
            champion2_blessing = 3
            if "Blessed" not in champion2_statuses:
                champion2_statuses.append("Blessed")
        if target == 3:
            champion3_blessing = 3
            if "Blessed" not in champion3_statuses:
                champion3_statuses.append("Blessed")
        if target == 4:
            champion4_blessing = 3
            if "Blessed" not in champion4_statuses:
                champion4_statuses.append("Blessed")
        if target == 5:
            champion5_blessing = 3
            if "Blessed" not in champion5_statuses:
                champion5_statuses.append("Blessed")
#Function runs whenever the Priest deals damage (including DoT ticks)
#Checks each champion to see if they're affected by the 'Blessed' buff
#If they are, they are healed equal to the damage the Priest dealt
    def check_champion_blessing(self, target, damage_done):
        global champion1_hp, champion2_hp, champion3_hp, champion4_hp, champion5_hp
        if target == 1:
            if champion1_blessing != 0:
                champion1_hp = champion1_hp + damage_done
                if champion1_hp > CHAMPION1_HP:
                    champion1_hp = CHAMPION1_HP
        if target == 2:
            if champion2_blessing != 0:
                champion2_hp = champion2_hp + damage_done
                if champion2_hp > CHAMPION2_HP:
                    champion2_hp = CHAMPION2_HP
        if target == 3:
            if champion3_blessing != 0:
                champion3_hp = champion3_hp + damage_done
                if champion3_hp > CHAMPION3_HP:
                    champion3_hp = CHAMPION3_HP
        if target == 4:
            if champion4_blessing != 0:
                champion4_hp = champion4_hp + damage_done
                if champion4_hp > CHAMPION4_HP:
                    champion4_hp = CHAMPION4_HP
        if target == 5:
            if champion5_blessing != 0:
                champion5_hp = champion5_hp + damage_done
                if champion5_hp > CHAMPION5_HP:
                    champion5_hp = CHAMPION5_HP
#Applies the 'Bandaged' heal over time effect to the ally specificed from the 'target' parameter
#Bandaged is applied by the Field Medics 'Bandages'
#Bandaged heals the ally each turn until the timer expires, then the effect is removed
    def apply_bandages(self, target, length):
        global champion1_bandaged, champion2_bandaged, champion3_bandaged, champion4_bandaged, champion5_bandaged, \
            champion1_statuses, champion2_statuses, champion3_statuses, champion4_statuses, champion5_statuses
        bandaged_HealHOT = ability_data[3]
        if target == 1:
            champion1_bandaged = [bandaged_HealHOT, length]
            if "Bandaged" not in champion1_statuses:
                champion1_statuses.append("Bandaged")
        if target == 2:
            champion2_bandaged = [bandaged_HealHOT, length]
            if "Bandaged" not in champion2_statuses:
                champion2_statuses.append("Bandaged")
        if target == 3:
            champion3_bandaged = [bandaged_HealHOT, length]
            if "Bandaged" not in champion3_statuses:
                champion3_statuses.append("Bandaged")
        if target == 4:
            champion4_bandaged = [bandaged_HealHOT, length]
            if "Bandaged" not in champion4_statuses:
                champion4_statuses.append("Bandaged")
        if target == 5:
            champion5_bandaged = [bandaged_HealHOT, length]
            if "Bandaged" not in champion5_statuses:
                champion5_statuses.append("Bandaged")
#Applies the 'Weak Tourniquet' reduced damage taken effect to the ally specificed from the 'target' parameter
#Weak Tourniquet is applied by the Field Medics 'Experienced Healing'
#Weak Tourniquet reduces the allies damage taken by 10% each turn until the timer expires, then the effect is removed
#Weak Tourniquet is the reduced effect that takes place after Tight Tourniquet has expired
    def apply_weak_tourniquet(self, target, length):
        global champion1_weaktourniquet, champion2_weaktourniquet, champion3_weaktourniquet, champion4_weaktourniquet, champion5_weaktourniquet, \
            champion1_statuses, champion2_statuses, champion3_statuses, champion4_statuses, champion5_statuses
        if target == 1:
            champion1_weaktourniquet = length
            if "Weak Tourniquet" not in champion1_statuses:
                champion1_statuses.append("Weak Tourniquet")
        if target == 2:
            champion2_weaktourniquet = length
            if "Weak Tourniquet" not in champion2_statuses:
                champion2_statuses.append("Weak Tourniquet")
        if target == 3:
            champion3_weaktourniquet = length
            if "Weak Tourniquet" not in champion3_statuses:
                champion3_statuses.append("Weak Tourniquet")
        if target == 4:
            champion4_weaktourniquet = length
            if "Weak Tourniquet" not in champion4_statuses:
                champion4_statuses.append("Weak Tourniquet")
        if target == 5:
            champion5_weaktourniquet = length
            if "Weak Tourniquet" not in champion5_statuses:
                champion5_statuses.append("Weak Tourniquet")
#Applies the 'Weak Remedy' damage increase effect to the ally specificed from the 'target' parameter
#Weak Remedy is applied by the Field Medics 'Experienced Healing'
#Weak Remedy increass the allies damage by 25% each turn until the timer expires, then the effect is removed
#Weak Remedy is the reduced effect that takes place after Strong Remedy has expired
    def apply_weak_remedy(self, target, length):
        global champion1_weakremedy, champion2_weakremedy, champion3_weakremedy, champion4_weakremedy, champion5_weakremedy, \
            champion1_statuses, champion2_statuses, champion3_statuses, champion4_statuses, champion5_statuses
        if target == 1:
            champion1_weakremedy = length
            if "Weak Remedy" not in champion1_statuses:
                champion1_statuses.append("Weak Remedy")
        if target == 2:
            champion2_weakremedy = length
            if "Weak Remedy" not in champion2_statuses:
                champion2_statuses.append("Weak Remedy")
        if target == 3:
            champion3_weakremedy = length
            if "Weak Remedy" not in champion3_statuses:
                champion3_statuses.append("Weak Remedy")
        if target == 4:
            champion4_weakremedy = length
            if "Weak Remedy" not in champion4_statuses:
                champion4_statuses.append("Weak Remedy")
        if target == 5:
            champion5_weakremedy = length
            if "Weak Remedy" not in champion5_statuses:
                champion5_statuses.append("Weak Remedy")
#Applies the 'Flowing Waters' heal over time effect to the ally specificed from the 'target' parameter
#Flowing Waters is applied by the Earth Speakers 'Spring Waters'
#Flowing Waters heals the ally each turn until the timer expires, then the effect is removed
#While Flowing Waters or Crashing Waters are active, the ally is also affected by Toughened Mud 
#which gives them a 15% reduction in damage taken
    def apply_spring_waters(self, target, length):
        global champion1_springwaters, champion2_springwaters, champion3_springwaters, champion4_springwaters, \
            champion5_springwaters, champion1_statuses, champion2_statuses, champion3_statuses, champion4_statuses, \
            champion5_statuses
        springwaters_HealHOT = ability_data[3]
        if target == 1:
            champion1_springwaters = [springwaters_HealHOT, length]
            if "Flowing Waters" not in champion1_statuses:
                champion1_statuses.append("Flowing Waters")
            if "Toughened Mud" not in champion1_statuses:
                champion1_statuses.append("Toughened Mud")
        if target == 2:
            champion2_springwaters = [springwaters_HealHOT, length]
            if "Flowing Waters" not in champion2_statuses:
                champion2_statuses.append("Flowing Waters")
            if "Toughened Mud" not in champion2_statuses:
                champion2_statuses.append("Toughened Mud")
        if target == 3:
            champion3_springwaters = [springwaters_HealHOT, length]
            if "Flowing Waters" not in champion3_statuses:
                champion3_statuses.append("Flowing Waters")
            if "Toughened Mud" not in champion3_statuses:
                champion3_statuses.append("Toughened Mud")
        if target == 4:
            champion4_springwaters = [springwaters_HealHOT, length]
            if "Flowing Waters" not in champion4_statuses:
                champion4_statuses.append("Flowing Waters")
            if "Toughened Mud" not in champion4_statuses:
                champion4_statuses.append("Toughened Mud")
        if target == 5:
            champion5_springwaters = [springwaters_HealHOT, length]
            if "Flowing Waters" not in champion5_statuses:
                champion5_statuses.append("Flowing Waters")
            if "Toughened Mud" not in champion5_statuses:
                champion5_statuses.append("Toughened Mud")
#Applies the 'Crashing Waters' heal over time effect to the ally specificed from the 'target' parameter
#Crashing Waters is applied by the Earth Speakers 'Ocean Tides'
#Crashing Waters heals the ally each turn until the timer expires, then the effect is removed
#While Crashing Waters or Flowing Waters are active, the ally is also affected by Toughened Mud 
#which gives them a 15% reduction in damage taken
    def apply_ocean_tide(self, length):
        global champion1_oceantide, champion2_oceantide, champion3_oceantide, champion4_oceantide, \
            champion5_oceantide, champion1_statuses, champion2_statuses, champion3_statuses, champion4_statuses, \
            champion5_statuses
        crashingwaters_HealHOT = ability_data[3] * 1.5
        champion1_oceantide = [crashingwaters_HealHOT, length]
        if "Crashing Waters" not in champion1_statuses:
            champion1_statuses.append("Crashing Waters")
        if "Toughened Mud" not in champion1_statuses:
                champion1_statuses.append("Toughened Mud")
        champion2_oceantide = [crashingwaters_HealHOT, length]
        if "Crashing Waters" not in champion2_statuses:
            champion2_statuses.append("Crashing Waters")
        if "Toughened Mud" not in champion2_statuses:
                champion2_statuses.append("Toughened Mud")
        champion3_oceantide = [crashingwaters_HealHOT, length]
        if "Crashing Waters" not in champion3_statuses:
            champion3_statuses.append("Crashing Waters")
        if "Toughened Mud" not in champion3_statuses:
                champion3_statuses.append("Toughened Mud")
        champion4_oceantide = [crashingwaters_HealHOT, length]
        if "Crashing Waters" not in champion4_statuses:
            champion4_statuses.append("Crashing Waters")
        if "Toughened Mud" not in champion4_statuses:
                champion4_statuses.append("Toughened Mud")
        champion5_oceantide = [crashingwaters_HealHOT, length]
        if "Crashing Waters" not in champion5_statuses:
            champion5_statuses.append("Crashing Waters")
        if "Toughened Mud" not in champion5_statuses:
                champion5_statuses.append("Toughened Mud")
        if "Flowing Waters" in champion1_statuses:
            champion1_springwaters[1] = champion1_springwaters[1] + 1
        if "Flowing Waters" in champion2_statuses:
            champion2_springwaters[1] = champion2_springwaters[1] + 1
        if "Flowing Waters" in champion3_statuses:
            champion3_springwaters[1] = champion3_springwaters[1] + 1
        if "Flowing Waters" in champion4_statuses:
            champion4_springwaters[1] = champion4_springwaters[1] + 1
        if "Flowing Waters" in champion5_statuses:
            champion5_springwaters[1] = champion5_springwaters[1] + 1
#Applies the 'Charged' debuff to the enemy specificed from the 'target' parameter
#The 'Electrical Expulsion' ability (represented by target = 0) releases 5 charges randomly to random targets, if 'Energised' it releases 10 charges instead
#Charged is applied by the Magnetimancers 'Chain Bolts' and 'Electrical Expulsion'
#Charged causes the affected enemy to be randomly become positively or negaitively charged, one type of charge can stack up to a maximum of two
#when the affected enemy has one of each, both debuffs are removed and that enemy takes high damage and all other enemies take half damage
    def apply_charges(self, target):
        global ai1_charged, ai2_charged, ai3_charged, ai4_charged, ai5_charged, ai1_hp, ai2_hp, ai3_hp, ai4_hp, ai5_hp, energised
        charges2apply = 0
        CHARGELIST = ["POSITIVE", "NEGATIVE"]
        if ai1_superconducted != 0:
            conducted1 = 2
        else:
            conducted1 = 1
        if ai2_superconducted != 0:
            conducted2 = 2
        else:
            conducted2 = 1
        if ai3_superconducted != 0:
            conducted3 = 2
        else:
            conducted3 = 1
        if ai4_superconducted != 0:
            conducted4 = 2
        else:
            conducted4 = 1
        if ai5_superconducted != 0:
            conducted5 = 2
        else:
            conducted5 = 1
        if target == 0:
            if energised == 1:
                charges2apply = 10
                energised = 0
            else:
                charges2apply = 5
            if AI_SPAWNED == 1:
                while charges2apply != 0:
                    appliedcharge = random.choice(CHARGELIST)
                    if appliedcharge == "POSITIVE":
                        if ai1_charged[0] == 2:
                            ai1_charged[1] = ai1_charged[1] + 1
                        else:
                            ai1_charged[0] = ai1_charged[0] + 1
                    if appliedcharge == "NEGATIVE":
                        if ai1_charged[1] == 2:
                            ai1_charged[0] = ai1_charged[1] + 1
                        else:
                            ai1_charged[1] = ai1_charged[1] + 1
                    if ai1_charged[0] and ai1_charged[1] != 0:
                        ai1_charged[0] = ai1_charged[0] - 1
                        ai1_charged[1] = ai1_charged[1] - 1
                        ai1_hp = ai1_hp - ability_data[3] * conducted1
                    charges2apply = charges2apply - 1
            if AI_SPAWNED == 2:
                    ai_list = [1, 2]
                    while charges2apply != 0:
                        chargetarget = random.choice(ai_list)
                        appliedcharge = random.choice(CHARGELIST)
                        if chargetarget == 1:
                            if appliedcharge == "POSITIVE":
                                if ai1_charged[0] == 2:
                                    ai1_charged[1] = ai1_charged[1] + 1
                                else:
                                    ai1_charged[0] = ai1_charged[0] + 1
                            if appliedcharge == "NEGATIVE":
                                if ai1_charged[1] == 2:
                                    ai1_charged[0] = ai1_charged[1] + 1
                                else:
                                    ai1_charged[1] = ai1_charged[1] + 1
                            if ai1_charged[0] and ai1_charged[1] != 0:
                                ai1_charged[0] = ai1_charged[0] - 1
                                ai1_charged[1] = ai1_charged[1] - 1
                                ai1_hp = ai1_hp - ability_data[3] * conducted1
                                ai2_hp = ai2_hp - ability_data[3] * conducted2 * 0.5
                        if chargetarget == 2:
                            if appliedcharge == "POSITIVE":
                                if ai2_charged[0] == 2:
                                    ai2_charged[1] = ai2_charged[1] + 1
                                else:
                                    ai2_charged[0] = ai2_charged[0] + 1
                            if appliedcharge == "NEGATIVE":
                                if ai2_charged[1] == 2:
                                    ai2_charged[0] = ai2_charged[1] + 1
                                else:
                                    ai2_charged[1] = ai2_charged[1] + 1
                            if ai2_charged[0] and ai2_charged[1] != 0:
                                ai2_charged[0] = ai2_charged[0] - 1
                                ai2_charged[1] = ai2_charged[1] - 1
                                ai1_hp = ai1_hp - ability_data[3] * conducted1 * 0.5
                                ai2_hp = ai2_hp - ability_data[3] * conducted2
                        charges2apply = charges2apply - 1
            if AI_SPAWNED == 3:
                    ai_list = [1, 2, 3]
                    while charges2apply != 0:
                        chargetarget = random.choice(ai_list)
                        appliedcharge = random.choice(CHARGELIST)
                        if chargetarget == 1:
                            if appliedcharge == "POSITIVE":
                                if ai1_charged[0] == 2:
                                    ai1_charged[1] = ai1_charged[1] + 1
                                else:
                                    ai1_charged[0] = ai1_charged[0] + 1
                            if appliedcharge == "NEGATIVE":
                                if ai1_charged[1] == 2:
                                    ai1_charged[0] = ai1_charged[1] + 1
                                else:
                                    ai1_charged[1] = ai1_charged[1] + 1
                            if ai1_charged[0] and ai1_charged[1] != 0:
                                ai1_charged[0] = ai1_charged[0] - 1
                                ai1_charged[1] = ai1_charged[1] - 1
                                ai1_hp = ai1_hp - ability_data[3] * conducted1
                                ai2_hp = ai2_hp - ability_data[3] * conducted2 * 0.5
                                ai3_hp = ai3_hp - ability_data[3] * conducted3 * 0.5
                        if chargetarget == 2:
                            if appliedcharge == "POSITIVE":
                                if ai2_charged[0] == 2:
                                    ai2_charged[1] = ai2_charged[1] + 1
                                else:
                                    ai2_charged[0] = ai2_charged[0] + 1
                            if appliedcharge == "NEGATIVE":
                                if ai2_charged[1] == 2:
                                    ai2_charged[0] = ai2_charged[1] + 1
                                else:
                                    ai2_charged[1] = ai2_charged[1] + 1
                            if ai2_charged[0] and ai2_charged[1] != 0:
                                ai2_charged[0] = ai2_charged[0] - 1
                                ai2_charged[1] = ai2_charged[1] - 1
                                ai1_hp = ai1_hp - ability_data[3] * conducted1 * 0.5
                                ai2_hp = ai2_hp - ability_data[3] * conducted2
                                ai3_hp = ai3_hp - ability_data[3] * conducted3 * 0.5
                        if chargetarget == 3:
                            if appliedcharge == "POSITIVE":
                                if ai3_charged[0] == 2:
                                    ai3_charged[1] = ai3_charged[1] + 1
                                else:
                                    ai3_charged[0] = ai3_charged[0] + 1
                            if appliedcharge == "NEGATIVE":
                                if ai3_charged[1] == 2:
                                    ai3_charged[0] = ai3_charged[1] + 1
                                else:
                                    ai3_charged[1] = ai3_charged[1] + 1
                            if ai3_charged[0] and ai3_charged[1] != 0:
                                ai3_charged[0] = ai3_charged[0] - 1
                                ai3_charged[1] = ai3_charged[1] - 1
                                ai1_hp = ai1_hp - ability_data[3] * conducted1 * 0.5
                                ai2_hp = ai2_hp - ability_data[3] * conducted2 * 0.5
                                ai3_hp = ai3_hp - ability_data[3] * conducted3
                        charges2apply = charges2apply - 1
            if AI_SPAWNED == 4:
                    ai_list = [1, 2, 3, 4]
                    while charges2apply != 0:
                        chargetarget = random.choice(ai_list)
                        appliedcharge = random.choice(CHARGELIST)
                        if chargetarget == 1:
                            if appliedcharge == "POSITIVE":
                                if ai1_charged[0] == 2:
                                    ai1_charged[1] = ai1_charged[1] + 1
                                else:
                                    ai1_charged[0] = ai1_charged[0] + 1
                            if appliedcharge == "NEGATIVE":
                                if ai1_charged[1] == 2:
                                    ai1_charged[0] = ai1_charged[1] + 1
                                else:
                                    ai1_charged[1] = ai1_charged[1] + 1
                            if ai1_charged[0] and ai1_charged[1] != 0:
                                ai1_charged[0] = ai1_charged[0] - 1
                                ai1_charged[1] = ai1_charged[1] - 1
                                ai1_hp = ai1_hp - ability_data[3] * conducted1
                                ai2_hp = ai2_hp - ability_data[3] * conducted2 * 0.5
                                ai3_hp = ai3_hp - ability_data[3] * conducted3 * 0.5
                                ai4_hp = ai4_hp - ability_data[3] * conducted4 * 0.5
                        if chargetarget == 2:
                            if appliedcharge == "POSITIVE":
                                if ai2_charged[0] == 2:
                                    ai2_charged[1] = ai2_charged[1] + 1
                                else:
                                    ai2_charged[0] = ai2_charged[0] + 1
                            if appliedcharge == "NEGATIVE":
                                if ai2_charged[1] == 2:
                                    ai2_charged[0] = ai2_charged[1] + 1
                                else:
                                    ai2_charged[1] = ai2_charged[1] + 1
                            if ai2_charged[0] and ai2_charged[1] != 0:
                                ai2_charged[0] = ai2_charged[0] - 1
                                ai2_charged[1] = ai2_charged[1] - 1
                                ai1_hp = ai1_hp - ability_data[3] * conducted1 * 0.5
                                ai2_hp = ai2_hp - ability_data[3] * conducted2
                                ai3_hp = ai3_hp - ability_data[3] * conducted3 * 0.5
                                ai4_hp = ai4_hp - ability_data[3] * conducted4 * 0.5
                        if chargetarget == 3:
                            if appliedcharge == "POSITIVE":
                                if ai3_charged[0] == 2:
                                    ai3_charged[1] = ai3_charged[1] + 1
                                else:
                                    ai3_charged[0] = ai3_charged[0] + 1
                            if appliedcharge == "NEGATIVE":
                                if ai3_charged[1] == 2:
                                    ai3_charged[0] = ai3_charged[1] + 1
                                else:
                                    ai3_charged[1] = ai3_charged[1] + 1
                            if ai3_charged[0] and ai3_charged[1] != 0:
                                ai3_charged[0] = ai3_charged[0] - 1
                                ai3_charged[1] = ai3_charged[1] - 1
                                ai1_hp = ai1_hp - ability_data[3] * conducted1 * 0.5
                                ai2_hp = ai2_hp - ability_data[3] * conducted2 * 0.5
                                ai3_hp = ai3_hp - ability_data[3] * conducted3
                                ai4_hp = ai4_hp - ability_data[3] * conducted4 * 0.5
                        if chargetarget == 4:
                            if appliedcharge == "POSITIVE":
                                if ai4_charged[0] == 2:
                                    ai4_charged[1] = ai4_charged[1] + 1
                                else:
                                    ai4_charged[0] = ai4_charged[0] + 1
                            if appliedcharge == "NEGATIVE":
                                if ai4_charged[1] == 2:
                                    ai4_charged[0] = ai4_charged[1] + 1
                                else:
                                    ai4_charged[1] = ai4_charged[1] + 1
                            if ai4_charged[0] and ai4_charged[1] != 0:
                                ai4_charged[0] = ai4_charged[0] - 1
                                ai4_charged[1] = ai4_charged[1] - 1
                                ai1_hp = ai1_hp - ability_data[3] * conducted1 * 0.5
                                ai2_hp = ai2_hp - ability_data[3] * conducted2 * 0.5
                                ai3_hp = ai3_hp - ability_data[3] * conducted3 * 0.5
                                ai4_hp = ai4_hp - ability_data[3] * conducted4
                        charges2apply = charges2apply - 1
            if AI_SPAWNED == 5:
                    ai_list = [1, 2, 3, 4, 5]
                    while charges2apply != 0:
                        chargetarget = random.choice(ai_list)
                        appliedcharge = random.choice(CHARGELIST)
                        if chargetarget == 1:
                            if appliedcharge == "POSITIVE":
                                if ai1_charged[0] == 2:
                                    ai1_charged[1] = ai1_charged[1] + 1
                                else:
                                    ai1_charged[0] = ai1_charged[0] + 1
                            if appliedcharge == "NEGATIVE":
                                if ai1_charged[1] == 2:
                                    ai1_charged[0] = ai1_charged[1] + 1
                                else:
                                    ai1_charged[1] = ai1_charged[1] + 1
                            if ai1_charged[0] and ai1_charged[1] != 0:
                                ai1_charged[0] = ai1_charged[0] - 1
                                ai1_charged[1] = ai1_charged[1] - 1
                                ai1_hp = ai1_hp - ability_data[3] * conducted1
                                ai2_hp = ai2_hp - ability_data[3] * conducted2 * 0.5
                                ai3_hp = ai3_hp - ability_data[3] * conducted3 * 0.5
                                ai4_hp = ai4_hp - ability_data[3] * conducted4 * 0.5
                                ai5_hp = ai5_hp - ability_data[3] * conducted5 * 0.5
                        if chargetarget == 2:
                            if appliedcharge == "POSITIVE":
                                if ai2_charged[0] == 2:
                                    ai2_charged[1] = ai2_charged[1] + 1
                                else:
                                    ai2_charged[0] = ai2_charged[0] + 1
                            if appliedcharge == "NEGATIVE":
                                if ai2_charged[1] == 2:
                                    ai2_charged[0] = ai2_charged[1] + 1
                                else:
                                    ai2_charged[1] = ai2_charged[1] + 1
                            if ai2_charged[0] and ai2_charged[1] != 0:
                                ai2_charged[0] = ai2_charged[0] - 1
                                ai2_charged[1] = ai2_charged[1] - 1
                                ai1_hp = ai1_hp - ability_data[3] * conducted1 * 0.5
                                ai2_hp = ai2_hp - ability_data[3] * conducted2
                                ai3_hp = ai3_hp - ability_data[3] * conducted3 * 0.5
                                ai4_hp = ai4_hp - ability_data[3] * conducted4 * 0.5
                                ai5_hp = ai5_hp - ability_data[3] * conducted5 * 0.5
                        if chargetarget == 3:
                            if appliedcharge == "POSITIVE":
                                if ai3_charged[0] == 2:
                                    ai3_charged[1] = ai3_charged[1] + 1
                                else:
                                    ai3_charged[0] = ai3_charged[0] + 1
                            if appliedcharge == "NEGATIVE":
                                if ai3_charged[1] == 2:
                                    ai3_charged[0] = ai3_charged[1] + 1
                                else:
                                    ai3_charged[1] = ai3_charged[1] + 1
                            if ai3_charged[0] and ai3_charged[1] != 0:
                                ai3_charged[0] = ai3_charged[0] - 1
                                ai3_charged[1] = ai3_charged[1] - 1
                                ai1_hp = ai1_hp - ability_data[3] * conducted1 * 0.5
                                ai2_hp = ai2_hp - ability_data[3] * conducted2 * 0.5
                                ai3_hp = ai3_hp - ability_data[3] * conducted3
                                ai4_hp = ai4_hp - ability_data[3] * conducted4 * 0.5
                                ai5_hp = ai5_hp - ability_data[3] * conducted5 * 0.5
                        if chargetarget == 4:
                            if appliedcharge == "POSITIVE":
                                if ai4_charged[0] == 2:
                                    ai4_charged[1] = ai4_charged[1] + 1
                                else:
                                    ai4_charged[0] = ai4_charged[0] + 1
                            if appliedcharge == "NEGATIVE":
                                if ai4_charged[1] == 2:
                                    ai4_charged[0] = ai4_charged[1] + 1
                                else:
                                    ai4_charged[1] = ai4_charged[1] + 1
                            if ai4_charged[0] and ai4_charged[1] != 0:
                                ai4_charged[0] = ai4_charged[0] - 1
                                ai4_charged[1] = ai4_charged[1] - 1
                                ai1_hp = ai1_hp - ability_data[3] * conducted1 * 0.5
                                ai2_hp = ai2_hp - ability_data[3] * conducted2 * 0.5
                                ai3_hp = ai3_hp - ability_data[3] * conducted3 * 0.5
                                ai4_hp = ai4_hp - ability_data[3] * conducted4
                                ai5_hp = ai5_hp - ability_data[3] * conducted5 * 0.5
                        if chargetarget == 5:
                            if appliedcharge == "POSITIVE":
                                if ai5_charged[0] == 2:
                                    ai5_charged[1] = ai5_charged[1] + 1
                                else:
                                    ai5_charged[0] = ai5_charged[0] + 1
                            if appliedcharge == "NEGATIVE":
                                if ai5_charged[1] == 2:
                                    ai5_charged[0] = ai5_charged[1] + 1
                                else:
                                    ai4_charged[1] = ai5_charged[1] + 1
                            if ai5_charged[0] and ai5_charged[1] != 0:
                                ai5_charged[0] = ai5_charged[0] - 1
                                ai5_charged[1] = ai5_charged[1] - 1
                                ai1_hp = ai1_hp - ability_data[3] * conducted1 * 0.5
                                ai2_hp = ai2_hp - ability_data[3] * conducted2 * 0.5
                                ai3_hp = ai3_hp - ability_data[3] * conducted3 * 0.5
                                ai4_hp = ai4_hp - ability_data[3] * conducted4 * 0.5
                                ai5_hp = ai5_hp - ability_data[3] * conducted5
                        charges2apply = charges2apply - 1
        if target == 1:
            appliedcharge = random.choice(CHARGELIST)
            if appliedcharge == "POSITIVE":
                if ai1_charged[0] == 2:
                    ai1_charged[1] = ai1_charged[1] + 1
                else:
                    ai1_charged[0] = ai1_charged[0] + 1
            if appliedcharge == "NEGATIVE":
                if ai1_charged[1] == 2:
                    ai1_charged[0] = ai1_charged[1] + 1
                else:
                    ai1_charged[1] = ai1_charged[1] + 1
            if ai1_charged[0] and ai1_charged[1] != 0:
                ai1_charged[0] = ai1_charged[0] - 1
                ai1_charged[1] = ai1_charged[1] - 1
                ai1_hp = ai1_hp - ability_data[3] * conducted1
                if AI_SPAWNED == 2:
                    ai2_hp = ai2_hp - ability_data[3] * conducted2 * 0.5
                if AI_SPAWNED == 3:
                    ai2_hp = ai2_hp - ability_data[3] * conducted2 * 0.5
                    ai3_hp = ai3_hp - ability_data[3] * conducted3 * 0.5
                if AI_SPAWNED == 4:
                    ai2_hp = ai2_hp - ability_data[3] * conducted2 * 0.5
                    ai3_hp = ai3_hp - ability_data[3] * conducted3 * 0.5
                    ai4_hp = ai4_hp - ability_data[3] * conducted4 * 0.5
                if AI_SPAWNED == 5:
                    ai2_hp = ai2_hp - ability_data[3] * conducted2 * 0.5
                    ai3_hp = ai3_hp - ability_data[3] * conducted3 * 0.5
                    ai4_hp = ai4_hp - ability_data[3] * conducted4 * 0.5
                    ai5_hp = ai5_hp - ability_data[3] * conducted5 * 0.5
        if target == 2:
            appliedcharge = random.choice(CHARGELIST)
            if appliedcharge == "POSITIVE":
                if ai2_charged[0] == 2:
                    ai2_charged[1] = ai2_charged[1] + 1
                else:
                    ai2_charged[0] = ai2_charged[0] + 1
            if appliedcharge == "NEGATIVE":
                if ai2_charged[1] == 2:
                    ai2_charged[0] = ai2_charged[1] + 1
                else:
                    ai2_charged[1] = ai2_charged[1] + 1
            if ai2_charged[0] and ai2_charged[1] != 0:
                ai2_charged[0] = ai2_charged[0] - 1
                ai2_charged[1] = ai2_charged[1] - 1
                ai2_hp = ai2_hp - ability_data[3] * conducted2
                if AI_SPAWNED == 2:
                    ai1_hp = ai1_hp - ability_data[3] * conducted1 * 0.5
                if AI_SPAWNED == 3:
                    ai1_hp = ai1_hp - ability_data[3] * conducted1 * 0.5
                    ai3_hp = ai3_hp - ability_data[3] * conducted3 * 0.5
                if AI_SPAWNED == 4:
                    ai1_hp = ai1_hp - ability_data[3] * conducted1 * 0.5
                    ai3_hp = ai3_hp - ability_data[3] * conducted3 * 0.5
                    ai4_hp = ai4_hp - ability_data[3] * conducted4 * 0.5
                if AI_SPAWNED == 5:
                    ai1_hp = ai1_hp - ability_data[3] * conducted1 * 0.5
                    ai3_hp = ai3_hp - ability_data[3] * conducted3 * 0.5
                    ai4_hp = ai4_hp - ability_data[3] * conducted4 * 0.5
                    ai5_hp = ai5_hp - ability_data[3] * conducted5 * 0.5
        if target == 3:
            appliedcharge = random.choice(CHARGELIST)
            if appliedcharge == "POSITIVE":
                if ai3_charged[0] == 2:
                    ai3_charged[1] = ai3_charged[1] + 1
                else:
                    ai3_charged[0] = ai3_charged[0] + 1
            if appliedcharge == "NEGATIVE":
                if ai3_charged[1] == 2:
                    ai3_charged[0] = ai3_charged[1] + 1
                else:
                    ai3_charged[1] = ai3_charged[1] + 1
            if ai3_charged[0] and ai3_charged[1] != 0:
                ai3_charged[0] = ai3_charged[0] - 1
                ai3_charged[1] = ai3_charged[1] - 1
                ai3_hp = ai3_hp - ability_data[3] * conducted3
                if AI_SPAWNED == 3:
                    ai1_hp = ai1_hp - ability_data[3] * conducted1 * 0.5
                    ai2_hp = ai2_hp - ability_data[3] * conducted2 * 0.5
                if AI_SPAWNED == 4:
                    ai1_hp = ai1_hp - ability_data[3] * conducted1 * 0.5
                    ai2_hp = ai2_hp - ability_data[3] * conducted2 * 0.5
                    ai4_hp = ai4_hp - ability_data[3] * conducted4 * 0.5
                if AI_SPAWNED == 5:
                    ai1_hp = ai1_hp - ability_data[3] * conducted1 * 0.5
                    ai2_hp = ai2_hp - ability_data[3] * conducted2 * 0.5
                    ai4_hp = ai4_hp - ability_data[3] * conducted4 * 0.5
                    ai5_hp = ai5_hp - ability_data[3] * conducted5 * 0.5
        if target == 4:
            appliedcharge = random.choice(CHARGELIST)
            if appliedcharge == "POSITIVE":
                if ai4_charged[0] == 2:
                    ai4_charged[1] = ai4_charged[1] + 1
                else:
                    ai4_charged[0] = ai4_charged[0] + 1
            if appliedcharge == "NEGATIVE":
                if ai4_charged[1] == 2:
                    ai4_charged[0] = ai4_charged[1] + 1
                else:
                    ai4_charged[1] = ai4_charged[1] + 1
            if ai4_charged[0] and ai4_charged[1] != 0:
                ai4_charged[0] = ai4_charged[0] - 1
                ai4_charged[1] = ai4_charged[1] - 1
                ai4_hp = ai4_hp - ability_data[3] * conducted4
                if AI_SPAWNED == 4:
                    ai1_hp = ai1_hp - ability_data[3] * conducted1 * 0.5
                    ai2_hp = ai2_hp - ability_data[3] * conducted2 * 0.5
                    ai3_hp = ai3_hp - ability_data[3] * conducted3 * 0.5
                if AI_SPAWNED == 5:
                    ai1_hp = ai1_hp - ability_data[3] * conducted1 * 0.5
                    ai2_hp = ai2_hp - ability_data[3] * conducted2 * 0.5
                    ai3_hp = ai3_hp - ability_data[3] * conducted3 * 0.5
                    ai5_hp = ai5_hp - ability_data[3] * conducted5 * 0.5
        if target == 5:
            appliedcharge = random.choice(CHARGELIST)
            if appliedcharge == "POSITIVE":
                if ai5_charged[0] == 2:
                    ai5_charged[1] = ai5_charged[1] + 1
                else:
                    ai5_charged[0] = ai5_charged[0] + 1
            if appliedcharge == "NEGATIVE":
                if ai5_charged[1] == 2:
                    ai5_charged[0] = ai5_charged[1] + 1
                else:
                    ai5_charged[1] = ai5_charged[1] + 1
            if ai5_charged[0] and ai5_charged[1] != 0:
                ai5_charged[0] = ai5_charged[0] - 1
                ai5_charged[1] = ai5_charged[1] - 1
                ai5_hp = ai5_hp - ability_data[3] * conducted5
                ai1_hp = ai1_hp - ability_data[3] * conducted1 * 0.5
                ai2_hp = ai2_hp - ability_data[3] * conducted2 * 0.5
                ai3_hp = ai3_hp - ability_data[3] * conducted3 * 0.5
                ai4_hp = ai4_hp - ability_data[3] * conducted4 * 0.5
        if AI_SPAWNED == 1:
            if ai1_hp < 0:
                ai1_hp = 0
        if AI_SPAWNED == 2:
            if ai1_hp < 0:
                ai1_hp = 0
            if ai2_hp < 0:
                ai2_hp = 0
        if AI_SPAWNED == 3:
            if ai1_hp < 0:
                ai1_hp = 0
            if ai2_hp < 0:
                ai2_hp = 0
            if ai3_hp < 0:
                ai3_hp = 0
        if AI_SPAWNED == 4:
            if ai1_hp < 0:
                ai1_hp = 0
            if ai2_hp < 0:
                ai2_hp = 0
            if ai3_hp < 0:
                ai3_hp = 0
            if ai4_hp < 0:
                ai4_hp = 0
        if AI_SPAWNED == 5:
            if ai1_hp < 0:
                ai1_hp = 0
            if ai2_hp < 0:
                ai2_hp = 0
            if ai3_hp < 0:
                ai3_hp = 0
            if ai4_hp < 0:
                ai4_hp = 0
            if ai5_hp < 0:
                ai5_hp = 0
#Applies the 'Weakened' debuff to the enemy specificed from the 'target' parameter
#Weakened is applied by the Kings-Guards ('Shield Bash'), the Survivalists ('Scrap Bomb'), the Power Conduits ('Power Surge'), and the Rangers ('Steady Aim', 'Power Shot', 'Multi-shot', and 'Ricochet Shot' when they have 'Venom Tip')
#Weakened causes the affected enemy to deal less damage until the timer expires, which will remove the effect
    def apply_weakness(self, target, length):
        global ai1_weakness, ai2_weakness, ai3_weakness, ai4_weakness, ai5_weakness, \
            ai1_statuses, ai2_statuses, ai3_statuses, ai4_statuses, ai5_statuses
        if target == 1:
            if length > ai1_weakness:
                ai1_weakness = length
                if "Weakened" not in ai1_statuses:
                    ai1_statuses.append("Weakened")
            else:
                return
        if target == 2:
            if length > ai2_weakness:
                ai2_weakness = length
                if "Weakened" not in ai2_statuses:
                    ai2_statuses.append("Weakened")
            else:
                return
        if target == 3:
            if length > ai3_weakness:
                ai3_weakness = length
                if "Weakened" not in ai3_statuses:
                    ai3_statuses.append("Weakened")
            else:
                return
        if target == 4:
            if length > ai4_weakness:
                ai4_weakness = length
                if "Weakened" not in ai4_statuses:
                    ai4_statuses.append("Weakened")
            else:
                return
        if target == 5:
            if length > ai5_weakness:
                ai5_weakness = length
                if "Weakened" not in ai5_statuses:
                    ai5_statuses.append("Weakened")
            else:
                return
#Applies the 'Taunted' debuff to the enemy specificed from the 'target' parameter
#Taunted is applied by the Monks ('Palm Strike'), the Barbarians ('Pulverize', and 'Challenging Shout'), and the Fencers ('Keen Reflexes')
#Taunted causes the affected enemy to forcibly attack the champion that applied the effect each turn until the timer expires, which will remove the effect
    def apply_taunt(self, target, tauntie, length):
        global ai1_taunt, ai2_taunt, ai3_taunt, ai4_taunt, ai5_taunt, \
            ai1_statuses, ai2_statuses, ai3_statuses, ai4_statuses, ai5_statuses
        if target == 1:
            if length >= ai1_taunt[1]:
                ai1_taunt = [tauntie, length]
                if "Taunted" not in ai1_statuses:
                    ai1_statuses.append("Taunted")
            else:
                return
        if target == 2:
            if length >= ai2_taunt[1]:
                ai2_taunt = [tauntie, length]
                if "Taunted" not in ai2_statuses:
                    ai2_statuses.append("Taunted")
            else:
                return
        if target == 3:
            if length >= ai3_taunt[1]:
                ai3_taunt = [tauntie, length]
                if "Taunted" not in ai3_statuses:
                    ai3_statuses.append("Taunted")
            else:
                return
        if target == 4:
            if length >= ai4_taunt[1]:
                ai4_taunt = [tauntie, length]
                if "Taunted" not in ai4_statuses:
                    ai4_statuses.append("Taunted")
            else:
                return
        if target == 5:
            if length >= ai5_taunt[1]:
                ai5_taunt = [tauntie, length]
                if "Taunted" not in ai5_statuses:
                    ai5_statuses.append("Taunted")
            else:
                return
#Applies the 'Stunned' debuff to the enemy specificed from the 'target' parameter
#Stunned is applied by the Monks ('Leg Sweep', and 'Pressure Points'), the Fencers ('Riposte', and 'Magic Reflection'), and the Rangers ('Steady Aim', 'Power Shot', 'Multi-shot', and 'Ricochet Shot' when they have 'Bola Tip')
#Stunned causes the affected enemy not be able to make any attacks until the timer expires, which will remove the effect
    def apply_stun(self, target, length):
        global ai1_stun, ai2_stun, ai3_stun, ai4_stun, ai5_stun, \
            ai1_statuses, ai2_statuses, ai3_statuses, ai4_statuses, ai5_statuses
        if target == 1:
            if length > ai1_stun:
                ai1_stun = length
                if "Stunned" not in ai1_statuses:
                    ai1_statuses.append("Stunned")
            else:
                return
        if target == 2:
            if length > ai2_stun:
                ai2_stun = length
                if "Stunned" not in ai2_statuses:
                    ai2_statuses.append("Stunned")
            else:
                return
        if target == 3:
            if length > ai3_stun:
                ai3_stun = length
                if "Stunned" not in ai3_statuses:
                    ai3_statuses.append("Stunned")
            else:
                return
        if target == 4:
            if length > ai4_stun:
                ai4_stun = length
                if "Stunned" not in ai4_statuses:
                    ai4_statuses.append("Stunned")
            else:
                return
        if target == 5:
            if length > ai5_stun:
                ai5_stun = length
                if "Stunned" not in ai5_statuses:
                    ai5_statuses.append("Stunned")
            else:
                return
#Applies the 'Brittle' debuff to the enemy specificed from the 'target' parameter
#Brittle is applied by the Mages ('Frost Bolt') and the Rangers ('Steady Aim', 'Power Shot', 'Multi-shot', and 'Ricochet Shot' when they have 'Vein Sensitizer Tip')
#Brittle causes the enemy to take extra damage until the timer expires, which will remove the effect
    def apply_brittle(self, target, length):
        global ai1_brittle, ai2_brittle, ai3_brittle, ai4_brittle, ai5_brittle, \
            ai1_statuses, ai2_statuses, ai3_statuses, ai4_statuses, ai5_statuses
        if target == 1:
            if length > ai1_brittle:
                ai1_brittle = length
                if "Brittle" not in ai1_statuses:
                    ai1_statuses.append("Brittle")
            else:
                return
        if target == 2:
            if length > ai2_brittle:
                ai2_brittle = length
                if "Brittle" not in ai2_statuses:
                    ai2_statuses.append("Brittle")
            else:
                return
        if target == 3:
            if length > ai3_brittle:
                ai3_brittle = length
                if "Brittle" not in ai3_statuses:
                    ai3_statuses.append("Brittle")
            else:
                return
        if target == 4:
            if length > ai4_brittle:
                ai4_brittle = length
                if "Brittle" not in ai4_statuses:
                    ai4_statuses.append("Brittle")
            else:
                return
        if target == 5:
            if length > ai5_brittle:
                ai5_brittle = length
                if "Brittle" not in ai5_statuses:
                    ai5_statuses.append("Brittle")
            else:
                return
#Calculates the extra damage enemies take from the debuff that cause them to take extra damage
#Extra damage is calculated by checking if the enemy defined by the 'target' parameter has the debuffs and 
#adding it to the 'vunerability_modifier' interget which is then returned
    def check_enemy_vunerability(self, target):
        vunerability_modifier = 1
        if target == 1:
            if ai1_brittle != 0:
                vunerability_modifier = vunerability_modifier + 0.3
            if ai1_thornsDot[1] != 0:
                vunerability_modifier = vunerability_modifier + (0.02 * ai1_thornsDot[1])
        if target == 2:
            if ai2_brittle != 0:
                vunerability_modifier = vunerability_modifier + 0.3
            if ai2_thornsDot[1] != 0:
                vunerability_modifier = vunerability_modifier + (0.02 * ai2_thornsDot[1])
        if target == 3:
            if ai3_brittle != 0:
                vunerability_modifier = vunerability_modifier + 0.3
            if ai3_thornsDot[1] != 0:
                vunerability_modifier = vunerability_modifier + (0.02 * ai3_thornsDot[1])
        if target == 4:
            if ai4_brittle != 0:
                vunerability_modifier = vunerability_modifier + 0.3
            if ai4_thornsDot[1] != 0:
                vunerability_modifier = vunerability_modifier + (0.02 * ai4_thornsDot[1])
        if target == 5:
            if ai5_brittle != 0:
                vunerability_modifier = vunerability_modifier + 0.3
            if ai5_thornsDot[1] != 0:
                vunerability_modifier = vunerability_modifier + (0.02 * ai5_thornsDot[1])
        return vunerability_modifier
#Applies the 'Sizzling Light' damage over time effect to the enemy specificed from the 'target' parameter
#Sizzling Light is applied by the Priests 'Shimmering Bolt'
#Sizzling Light deals damage each turn until the timer expires, then the effect is removed
    def apply_shimmerDot(self, target, length):
        global ai1_shimmerDot, ai2_shimmerDot, ai3_shimmerDot, ai4_shimmerDot, ai5_shimmerDot, \
            ai1_statuses, ai2_statuses, ai3_statuses, ai4_statuses, ai5_statuses
        shimmerDotTick = math.ceil(ability_data[3])
        if target == 1:
            if length > ai1_shimmerDot[1]:
                ai1_shimmerDot = [shimmerDotTick, length]
                if "Sizzling Light" not in ai1_statuses:
                    ai1_statuses.append("Sizzling Light")
            else:
                return
        if target == 2:
            if length > ai2_shimmerDot[1]:
                ai2_shimmerDot = [shimmerDotTick, length]
                if "Sizzling Light" not in ai2_statuses:
                    ai2_statuses.append("Sizzling Light")
            else:
                return
        if target == 3:
            if length > ai3_shimmerDot[1]:
                ai3_shimmerDot = [shimmerDotTick, length]
                if "Sizzling Light" not in ai3_statuses:
                    ai3_statuses.append("Sizzling Light")
            else:
                return
        if target == 4:
            if length > ai4_shimmerDot[1]:
                ai4_shimmerDot = [shimmerDotTick, length]
                if "Sizzling Light" not in ai4_statuses:
                    ai4_statuses.append("Sizzling Light")
            else:
                return
        if target == 5:
            if length > ai5_shimmerDot[1]:
                ai5_shimmerDot = [shimmerDotTick, length]
                if "Sizzling Light" not in ai5_statuses:
                    ai5_statuses.append("Sizzling Light")
            else:
                return
#Applies the 'Searing Light' damage over time effect to the enemy specificed from the 'target' parameter
#Searing Light is applied by the Priests 'Divine Smite'
#Searing Light deals damage each turn until the timer expires, then the effect is removed
    def apply_divineDot(self, target, length):
        global ai1_divineDot, ai2_divineDot, ai3_divineDot, ai4_divineDot, ai5_divineDot, \
            ai1_statuses, ai2_statuses, ai3_statuses, ai4_statuses, ai5_statuses
        divineDotTick = math.ceil(ability_data[3]*2)
        if target == 1:
            if length > ai1_divineDot[1]:
                ai1_divineDot = [divineDotTick, length]
                if "Searing Light" not in ai1_statuses:
                    ai1_statuses.append("Searing Light")
            else:
                return
        if target == 2:
            if length > ai2_divineDot[1]:
                ai2_divineDot = [divineDotTick, length]
                if "Searing Light" not in ai2_statuses:
                    ai2_statuses.append("Searing Light")
            else:
                return
        if target == 3:
            if length > ai3_divineDot[1]:
                ai3_divineDot = [divineDotTick, length]
                if "Searing Light" not in ai3_statuses:
                    ai3_statuses.append("Searing Light")
            else:
                return
        if target == 4:
            if length > ai4_divineDot[1]:
                ai4_divineDot = [divineDotTick, length]
                if "Searing Light" not in ai4_statuses:
                    ai4_statuses.append("Searing Light")
            else:
                return
        if target == 5:
            if length > ai5_divineDot[1]:
                ai5_divineDot = [divineDotTick, length]
                if "Searing Light" not in ai5_statuses:
                    ai5_statuses.append("Searing Light")
            else:
                return
#Applies the 'Barbed Arrow' damage over time effect to the enemy specificed from the 'target' parameter
#Barbed Arrow is applied by the Rangers 'Steady Aim', 'Power Shot', 'Multi-shot', and 'Ricochet Shot' when the Ranger has 'Barbed Tip'
#Barbed Arrow deals damage each turn until the timer expires, then the effect is removed
    def apply_barbedArrowDot(self, target, length):
        global ai1_barbedArrDot, ai2_barbedArrDot, ai3_barbedArrDot, ai4_barbedArrDot, ai5barbedArrDot, \
            ai1_statuses, ai2_statuses, ai3_statuses, ai4_statuses, ai5_statuses
        barbedArrDotTick = math.ceil(ability_data[3] * 0.75)
        if target == 1:
            if length > ai1_barbedArrDot[1]:
                ai1_barbedArrDot = [barbedArrDotTick, length]
                if "Barbed Arrow" not in ai1_statuses:
                    ai1_statuses.append("Barbed Arrow")
            else:
                return
        if target == 2:
            if length > ai2_barbedArrDot[1]:
                ai2_barbedArrDot = [barbedArrDotTick, length]
                if "Barbed Arrow" not in ai2_statuses:
                    ai2_statuses.append("Barbed Arrow")
            else:
                return
        if target == 3:
            if length > ai3_barbedArrDot[1]:
                ai3_barbedArrDot = [barbedArrDotTick, length]
                if "Barbed Arrow" not in ai3_statuses:
                    ai3_statuses.append("Barbed Arrow")
            else:
                return
        if target == 4:
            if length > ai4_barbedArrDot[1]:
                ai4_barbedArrDot = [barbedArrDotTick, length]
                if "Barbed Arrow" not in ai4_statuses:
                    ai4_statuses.append("Barbed Arrow")
            else:
                return
        if target == 5:
            if length > ai5_barbedArrDot[1]:
                ai5_barbedArrDot = [barbedArrDotTick, length]
                if "Barbed Arrow" not in ai5_statuses:
                    ai5_statuses.append("Barbed Arrow")
            else:
                return
#Applies the 'Burning' damage over time effect to the enemy specificed from the 'target' parameter
#Burning is applied by the Mages 'Fireball'
#Burning deals damage each turn until the timer expires, then the effect is removed
    def apply_burnDot(self, target, length):
        global ai1_burnDot, ai2_burnDot, ai3_burnDot, ai4_burnDot, ai5_burnDot, \
            ai1_statuses, ai2_statuses, ai3_statuses, ai4_statuses, ai5_statuses
        burnDotTick = math.ceil(ability_data[3] * 0.5)
        if target == 1:
            if length > ai1_burnDot[1]:
                ai1_burnDot = [burnDotTick, length]
                if "Burning" not in ai1_statuses:
                    ai1_statuses.append("Burning")
            else:
                return
        if target == 2:
            if length > ai2_burnDot[1]:
                ai2_burnDot = [burnDotTick, length]
                if "Burning" not in ai2_statuses:
                    ai2_statuses.append("Burning")
            else:
                return
        if target == 3:
            if length > ai3_burnDot[1]:
                ai3_burnDot = [burnDotTick, length]
                if "Burning" not in ai3_statuses:
                    ai3_statuses.append("Burning")
            else:
                return
        if target == 4:
            if length > ai4_burnDot[1]:
                ai4_burnDot = [burnDotTick, length]
                if "Burning" not in ai4_statuses:
                    ai4_statuses.append("Burning")
            else:
                return
        if target == 5:
            if length > ai5_burnDot[1]:
                ai5_burnDot = [burnDotTick, length]
                if "Burning" not in ai5_statuses:
                    ai5_statuses.append("Burning")
            else:
                return
#Applies the 'Thorns' damage over time effect to the enemy specificed from the 'target' parameter
#Thorns is applied by the Druids 'Vine-swipe', 'Invigorate Thorns', and 'Barbed Bush Armour'
#Thorns deals damage each turn and is a permanent effect on the enemy, only being removed when the enemy either dies or the Druid casts 'Burst n Bloom'
#Thorns also causes the enemy to take 2% extra damage from all damage per stack
    def apply_thornsDot(self, target, stack_count):
        global ai1_thornsDot, ai2_thornsDot, ai3_thornsDot, ai4_thornsDot, ai5_thornsDot, \
            ai1_statuses, ai2_statuses, ai3_statuses, ai4_statuses, ai5_statuses
        ThornDotTick = math.ceil(ability_data[3] * 0.25)
        if target == 1:
            if ai1_thornsDot[1] != 0:
                ai1_thornsDot[1] = ai1_thornsDot[1] + stack_count
            else:
                ai1_thornsDot = [ThornDotTick, stack_count]
            if "Thorns" not in ai1_statuses:
                ai1_statuses.append("Thorns")
        if target == 2:
            if ai2_thornsDot[1] != 0:
                ai2_thornsDot[1] = ai2_thornsDot[1] + stack_count
            else:
                ai2_thornsDot = [ThornDotTick, stack_count]
            if "Thorns" not in ai2_statuses:
                ai2_statuses.append("Thorns")
        if target == 3:
            if ai3_thornsDot[1] != 0:
                ai3_thornsDot[1] = ai3_thornsDot[1] + stack_count
            else:
                ai3_thornsDot = [ThornDotTick, stack_count]
            if "Thorns" not in ai3_statuses:
                ai3_statuses.append("Thorns")
        if target == 4:
            if ai4_thornsDot[1] != 0:
                ai4_thornsDot[1] = ai4_thornsDot[1] + stack_count
            else:
                ai4_thornsDot = [ThornDotTick, stack_count]
            if "Thorns" not in ai4_statuses:
                ai4_statuses.append("Thorns")
        if target == 5:
            if ai5_thornsDot[1] != 0:
                ai5_thornsDot[1] = ai5_thornsDot[1] + stack_count
            else:
                ai5_thornsDot = [ThornDotTick, stack_count]
            if "Thorns" not in ai5_statuses:
                ai5_statuses.append("Thorns")
#Applies the 'Serrated' damage over time effect to the enemy specificed from the 'target' parameter
#Serrated is applied by the Rogues 'Serrated Slash'
#Serrated deals damage each turn until the timer expires, then the effect is removed
    def apply_serratedSlashDot(self, target, length):
        global ai1_serraSlashDot, ai2_serraSlashDot, ai3_serraSlashDot, ai4_serraSlashDot, ai5_serraSlashDot, \
            ai1_statuses, ai2_statuses, ai3_statuses, ai4_statuses, ai5_statuses
        SerraSlashDotTick = math.ceil(ability_data[3] * 0.5)
        if target == 1:
            if length > ai1_serraSlashDot[1]:
                ai1_serraSlashDot = [SerraSlashDotTick, length]
                if "Serrated" not in ai1_statuses:
                    ai1_statuses.append("Serrated")
            else:
                return
        if target == 2:
            if length > ai2_serraSlashDot[1]:
                ai2_serraSlashDot = [SerraSlashDotTick, length]
                if "Serrated" not in ai2_statuses:
                    ai2_statuses.append("Serrated")
            else:
                return
        if target == 3:
            if length > ai3_serraSlashDot[1]:
                ai3_serraSlashDot = [SerraSlashDotTick, length]
                if "Serrated" not in ai3_statuses:
                    ai3_statuses.append("Serrated")
            else:
                return
        if target == 4:
            if length > ai4_serraSlashDot[1]:
                ai4_serraSlashDot = [SerraSlashDotTick, length]
                if "Serrated" not in ai4_statuses:
                    ai4_statuses.append("Serrated")
            else:
                return
        if target == 5:
            if length > ai5_serraSlashDot[1]:
                ai5_serraSlashDot = [SerraSlashDotTick, length]
                if "Serrated" not in ai5_statuses:
                    ai5_statuses.append("Serrated")
            else:
                return
#Applies the 'Eviscerated' damage over time effect to the enemy specificed from the 'target' parameter
#Eviscerated is applied by the Rogues 'Eviscerate'
#Eviscerated deals damage each turn until the timer expires, then the effect is removed
    def apply_eviscerateDot(self, target, length):
        global ai1_eviscerDot, ai2_eviscerDot, ai3_eviscerDot, ai4_eviscerDot, ai5_eviscerDot, \
            ai1_statuses, ai2_statuses, ai3_statuses, ai4_statuses, ai5_statuses
        EviscerDotTick = math.ceil(ability_data[3])
        if target == 1:
            if length > ai1_eviscerDot[1]:
                ai1_eviscerDot = [EviscerDotTick, length]
                if "Eviscerated" not in ai1_statuses:
                    ai1_statuses.append("Eviscerated")
            else:
                return
        if target == 2:
            if length > ai2_eviscerDot[1]:
                ai2_eviscerDot = [EviscerDotTick, length]
                if "Eviscerated" not in ai2_statuses:
                    ai2_statuses.append("Eviscerated")
            else:
                return
        if target == 3:
            if length > ai3_eviscerDot[1]:
                ai3_eviscerDot = [EviscerDotTick, length]
                if "Eviscerated" not in ai3_statuses:
                    ai3_statuses.append("Eviscerated")
            else:
                return
        if target == 4:
            if length > ai4_eviscerDot[1]:
                ai4_eviscerDot = [EviscerDotTick, length]
                if "Eviscerated" not in ai4_statuses:
                    ai4_statuses.append("Eviscerated")
            else:
                return
        if target == 5:
            if length > ai5_eviscerDot[1]:
                ai5_eviscerDot = [EviscerDotTick, length]
                if "Eviscerated" not in ai5_statuses:
                    ai5_statuses.append("Eviscerated")
            else:
                return
#Applies the 'Garroted' damage over time effect to the enemy specificed from the 'target' parameter
#Garroted is applied by the Rogues 'Garrote'
#Garroted deals damage each turn until the timer expires, then the effect is removed
    def apply_garroteDot(self, target, length):
        global ai1_garroteDot, ai2_garroteDot, ai3_garroteDot, ai4_garroteDot, ai5_garroteDot, \
            ai1_statuses, ai2_statuses, ai3_statuses, ai4_statuses, ai5_statuses
        garroteDotTick = math.ceil(ability_data[3] * 0.75)
        if target == 1:
            if length > ai1_garroteDot[1]:
                ai1_garroteDot = [garroteDotTick, length]
                if "Garroted" not in ai1_statuses:
                    ai1_statuses.append("Garroted")
            else:
                return
        if target == 2:
            if length > ai2_garroteDot[1]:
                ai2_garroteDot = [garroteDotTick, length]
                if "Garroted" not in ai2_statuses:
                    ai2_statuses.append("Garroted")
            else:
                return
        if target == 3:
            if length > ai3_garroteDot[1]:
                ai3_garroteDot = [garroteDotTick, length]
                if "Garroted" not in ai3_statuses:
                    ai3_statuses.append("Garroted")
            else:
                return
        if target == 4:
            if length > ai4_garroteDot[1]:
                ai4_garroteDot = [garroteDotTick, length]
                if "Garroted" not in ai4_statuses:
                    ai4_statuses.append("Garroted")
            else:
                return
        if target == 5:
            if length > ai5_garroteDot[1]:
                ai5_garroteDot = [garroteDotTick, length]
                if "Garroted" not in ai5_statuses:
                    ai5_statuses.append("Garroted")
            else:
                return
#Applies the 'Rotting' damage over time effect to the enemy specificed from the 'target' parameter
#Rotting is applied by the Warlocks 'Black Bolt' when he has at least one 'Void Infused' stack
#Rotting deals damage each turn until the timer expires, then the effect is removed
    def apply_rottingDot(self, target, length, stacks_level):
        global ai1_rottingDot, ai2_rottingDot, ai3_rottingDot, ai4_rottingDot, ai5_rottingDot, \
            ai1_statuses, ai2_statuses, ai3_statuses, ai4_statuses, ai5_statuses
        rottingDotTick = math.ceil(600 * stacks_level)
        if target == 1:
            if stacks_level > ai1_rottingDot[2]:
                ai1_rottingDot = [rottingDotTick, length, stacks_level]
                if "Rotting" not in ai1_statuses:
                    ai1_statuses.append("Rotting")
            else:
                return
        if target == 2:
            if stacks_level > ai2_rottingDot[2]:
                ai2_rottingDot = [rottingDotTick, length, stacks_level]
                if "Rotting" not in ai2_statuses:
                    ai2_statuses.append("Rotting")
            else:
                return
        if target == 3:
            if stacks_level > ai3_rottingDot[2]:
                ai3_rottingDot = [rottingDotTick, length, stacks_level]
                if "Rotting" not in ai3_statuses:
                    ai3_statuses.append("Rotting")
            else:
                return
        if target == 4:
            if stacks_level > ai4_rottingDot[2]:
                ai4_rottingDot = [rottingDotTick, length, stacks_level]
                if "Rotting" not in ai4_statuses:
                    ai4_statuses.append("Rotting")
            else:
                return
        if target == 5:
            if stacks_level > ai5_rottingDot[2]:
                ai5_rottingDot = [rottingDotTick, length, stacks_level]
                if "Rotting" not in ai5_statuses:
                    ai5_statuses.append("Rotting")
            else:
                return
#Applies the 'Touch of Corruption' debuff to the enemy specificed from the 'target' parameter
#Touch of Corruption is applied by the Warlocks passive and reduces the enemies damage dealt by 1% up to a maximum of 10%
#Touch of Corruption is a permanent effect on the enemy, only going away when they die
    def apply_toc(self, target):
        global ai1_toc, ai2_toc, ai3_toc, ai4_toc, ai5_toc, \
            ai1_statuses, ai2_statuses, ai3_statuses, ai4_statuses, ai5_statuses
        if target == 1:
            if ai1_toc != 0:
                if ai1_toc != 10:
                    ai1_toc = ai1_toc + 1
            else: 
                ai1_toc = 1
                ai1_statuses.append("Touch of Corruption")
        if target == 2:
            if ai2_toc != 0:
                if ai2_toc != 10:
                    ai2_toc = ai2_toc + 1
            else: 
                ai2_toc = 1
                ai2_statuses.append("Touch of Corruption")
        if target == 3:
            if ai3_toc != 0:
                if ai3_toc != 10:
                    ai3_toc = ai3_toc + 1
            else: 
                ai3_toc = 1
                ai3_statuses.append("Touch of Corruption")
        if target == 4:
            if ai4_toc != 0:
                if ai4_toc != 10:
                    ai4_toc = ai4_toc + 1
            else: 
                ai4_toc = 1
                ai4_statuses.append("Touch of Corruption")
        if target == 5:
            if ai5_toc != 0:
                if ai5_toc != 10:
                    ai5_toc = ai5_toc + 1
            else: 
                ai5_toc = 1
                ai5_statuses.append("Touch of Corruption")
#Function to calculate the extra damage the Rogues bleeds receive from his passive
#Each unique bleed adds 10% to the damage
    def calculate_bleed_damage(self, bleed_name, enemy_number):
        if enemy_number == 1:
            if bleed_name == "Serrated":
                updated_damage = ai1_serraSlashDot[0]
                unique_bleed = 0
                if ai1_garroteDot[1] != 0:
                    unique_bleed = unique_bleed + 1
                if ai1_eviscerDot[1] != 0:
                    unique_bleed = unique_bleed + 1
                if ai1_barbedArrDot[1] != 0:
                    unique_bleed = unique_bleed + 1
                if ai1_thornsDot[1] != 0:
                    unique_bleed = unique_bleed + 1
                updated_damaged = updated_damage * (1 + (0.1 * unique_bleed))
                return updated_damage
            if bleed_name == "Garroted":
                updated_damage = ai1_garroteDot[0]
                unique_bleed = 0
                if ai1_serraSlashDot[1] != 0:
                    unique_bleed = unique_bleed + 1
                if ai1_eviscerDot[1] != 0:
                    unique_bleed = unique_bleed + 1
                if ai1_barbedArrDot[1] != 0:
                    unique_bleed = unique_bleed + 1
                if ai1_thornsDot[1] != 0:
                    unique_bleed = unique_bleed + 1
                updated_damaged = updated_damage * (1 + (0.1 * unique_bleed))
                return updated_damage
            if bleed_name == "Eviscerated":
                updated_damage = ai1_eviscerDot[0]
                unique_bleed = 0
                if ai1_garroteDot[1] != 0:
                    unique_bleed = unique_bleed + 1
                if ai1_serraSlashDot[1] != 0:
                    unique_bleed = unique_bleed + 1
                if ai1_barbedArrDot[1] != 0:
                    unique_bleed = unique_bleed + 1
                if ai1_thornsDot[1] != 0:
                    unique_bleed = unique_bleed + 1
                updated_damaged = updated_damage * (1 + (0.1 * unique_bleed))
                return updated_damage
        if enemy_number == 2:
            if bleed_name == "Serrated":
                updated_damage = ai2_serraSlashDot[0]
                unique_bleed = 0
                if ai2_garroteDot[1] != 0:
                    unique_bleed = unique_bleed + 1
                if ai2_eviscerDot[1] != 0:
                    unique_bleed = unique_bleed + 1
                if ai2_barbedArrDot[1] != 0:
                    unique_bleed = unique_bleed + 1
                if ai2_thornsDot[1] != 0:
                    unique_bleed = unique_bleed + 1
                updated_damaged = updated_damage * (1 + (0.1 * unique_bleed))
                return updated_damage
            if bleed_name == "Garroted":
                updated_damage = ai2_garroteDot[0]
                unique_bleed = 0
                if ai2_serraSlashDot[1] != 0:
                    unique_bleed = unique_bleed + 1
                if ai2_eviscerDot[1] != 0:
                    unique_bleed = unique_bleed + 1
                if ai2_barbedArrDot[1] != 0:
                    unique_bleed = unique_bleed + 1
                if ai2_thornsDot[1] != 0:
                    unique_bleed = unique_bleed + 1
                updated_damaged = updated_damage * (1 + (0.1 * unique_bleed))
                return updated_damage
            if bleed_name == "Eviscerated":
                updated_damage = ai2_eviscerDot[0]
                unique_bleed = 0
                if ai2_garroteDot[1] != 0:
                    unique_bleed = unique_bleed + 1
                if ai2_serraSlashDot[1] != 0:
                    unique_bleed = unique_bleed + 1
                if ai2_barbedArrDot[1] != 0:
                    unique_bleed = unique_bleed + 1
                if ai2_thornsDot[1] != 0:
                    unique_bleed = unique_bleed + 1
                updated_damaged = updated_damage * (1 + (0.1 * unique_bleed))
                return updated_damage
        if enemy_number == 3:
            if bleed_name == "Serrated":
                updated_damage = ai3_serraSlashDot[0]
                unique_bleed = 0
                if ai3_garroteDot[1] != 0:
                    unique_bleed = unique_bleed + 1
                if ai3_eviscerDot[1] != 0:
                    unique_bleed = unique_bleed + 1
                if ai3_barbedArrDot[1] != 0:
                    unique_bleed = unique_bleed + 1
                if ai3_thornsDot[1] != 0:
                    unique_bleed = unique_bleed + 1
                updated_damaged = updated_damage * (1 + (0.1 * unique_bleed))
                return updated_damage
            if bleed_name == "Garroted":
                updated_damage = ai3_garroteDot[0]
                unique_bleed = 0
                if ai3_serraSlashDot[1] != 0:
                    unique_bleed = unique_bleed + 1
                if ai3_eviscerDot[1] != 0:
                    unique_bleed = unique_bleed + 1
                if ai3_barbedArrDot[1] != 0:
                    unique_bleed = unique_bleed + 1
                if ai3_thornsDot[1] != 0:
                    unique_bleed = unique_bleed + 1
                updated_damaged = updated_damage * (1 + (0.1 * unique_bleed))
                return updated_damage
            if bleed_name == "Eviscerated":
                updated_damage = ai3_eviscerDot[0]
                unique_bleed = 0
                if ai3_garroteDot[1] != 0:
                    unique_bleed = unique_bleed + 1
                if ai3_serraSlashDot[1] != 0:
                    unique_bleed = unique_bleed + 1
                if ai3_barbedArrDot[1] != 0:
                    unique_bleed = unique_bleed + 1
                if ai3_thornsDot[1] != 0:
                    unique_bleed = unique_bleed + 1
                updated_damaged = updated_damage * (1 + (0.1 * unique_bleed))
                return updated_damage
        if enemy_number == 4:
            if bleed_name == "Serrated":
                updated_damage = ai4_serraSlashDot[0]
                unique_bleed = 0
                if ai4_garroteDot[1] != 0:
                    unique_bleed = unique_bleed + 1
                if ai4_eviscerDot[1] != 0:
                    unique_bleed = unique_bleed + 1
                if ai4_barbedArrDot[1] != 0:
                    unique_bleed = unique_bleed + 1
                if ai4_thornsDot[1] != 0:
                    unique_bleed = unique_bleed + 1
                updated_damaged = updated_damage * (1 + (0.1 * unique_bleed))
                return updated_damage
            if bleed_name == "Garroted":
                updated_damage = ai4_garroteDot[0]
                unique_bleed = 0
                if ai4_serraSlashDot[1] != 0:
                    unique_bleed = unique_bleed + 1
                if ai4_eviscerDot[1] != 0:
                    unique_bleed = unique_bleed + 1
                if ai4_barbedArrDot[1] != 0:
                    unique_bleed = unique_bleed + 1
                if ai4_thornsDot[1] != 0:
                    unique_bleed = unique_bleed + 1
                updated_damaged = updated_damage * (1 + (0.1 * unique_bleed))
                return updated_damage
            if bleed_name == "Eviscerated":
                updated_damage = ai4_eviscerDot[0]
                unique_bleed = 0
                if ai4_garroteDot[1] != 0:
                    unique_bleed = unique_bleed + 1
                if ai4_serraSlashDot[1] != 0:
                    unique_bleed = unique_bleed + 1
                if ai4_barbedArrDot[1] != 0:
                    unique_bleed = unique_bleed + 1
                if ai4_thornsDot[1] != 0:
                    unique_bleed = unique_bleed + 1
                updated_damaged = updated_damage * (1 + (0.1 * unique_bleed))
                return updated_damage
        if enemy_number == 5:
            if bleed_name == "Serrated":
                updated_damage = ai5_serraSlashDot[0]
                unique_bleed = 0
                if ai5_garroteDot[1] != 0:
                    unique_bleed = unique_bleed + 1
                if ai5_eviscerDot[1] != 0:
                    unique_bleed = unique_bleed + 1
                if ai5_barbedArrDot[1] != 0:
                    unique_bleed = unique_bleed + 1
                if ai5_thornsDot[1] != 0:
                    unique_bleed = unique_bleed + 1
                updated_damaged = updated_damage * (1 + (0.1 * unique_bleed))
                return updated_damage
            if bleed_name == "Garroted":
                updated_damage = ai5_garroteDot[0]
                unique_bleed = 0
                if ai5_serraSlashDot[1] != 0:
                    unique_bleed = unique_bleed + 1
                if ai5_eviscerDot[1] != 0:
                    unique_bleed = unique_bleed + 1
                if ai5_barbedArrDot[1] != 0:
                    unique_bleed = unique_bleed + 1
                if ai5_thornsDot[1] != 0:
                    unique_bleed = unique_bleed + 1
                updated_damaged = updated_damage * (1 + (0.1 * unique_bleed))
                return updated_damage
            if bleed_name == "Eviscerated":
                updated_damage = ai5_eviscerDot[0]
                unique_bleed = 0
                if ai5_garroteDot[1] != 0:
                    unique_bleed = unique_bleed + 1
                if ai5_serraSlashDot[1] != 0:
                    unique_bleed = unique_bleed + 1
                if ai5_barbedArrDot[1] != 0:
                    unique_bleed = unique_bleed + 1
                if ai5_thornsDot[1] != 0:
                    unique_bleed = unique_bleed + 1
                updated_damaged = updated_damage * (1 + (0.1 * unique_bleed))
                return updated_damage
#Deletes leftover target chosing widgets
    def clean_up(self):
        if ability_data[1] == "ally":
            if ability_data[2] != "AOE":
                champion1_supporttarget_frame.destroy()
                champion2_supporttarget_frame.destroy()
                champion3_supporttarget_frame.destroy()
                champion4_supporttarget_frame.destroy()
                champion5_supporttarget_frame.destroy()
        if ability_data[1] == "enemy":
            if ability_data[2] != "AOE":
                if AI_SPAWNED == 1:
                    ai1_attacktarget_frame.destroy()
                if AI_SPAWNED == 2:
                    ai1_attacktarget_frame.destroy()
                    ai2_attacktarget_frame.destroy()
                if AI_SPAWNED == 3:
                    ai1_attacktarget_frame.destroy()
                    ai2_attacktarget_frame.destroy()
                    ai3_attacktarget_frame.destroy()
                if AI_SPAWNED == 4:
                    ai1_attacktarget_frame.destroy()
                    ai2_attacktarget_frame.destroy()
                    ai3_attacktarget_frame.destroy()
                    ai4_attacktarget_frame.destroy()
                if AI_SPAWNED == 5:
                    ai1_attacktarget_frame.destroy()
                    ai2_attacktarget_frame.destroy()
                    ai3_attacktarget_frame.destroy()
                    ai4_attacktarget_frame.destroy()
                    ai5_attacktarget_frame.destroy()
#Sets the text of button for when the user is targeting
#Shows their current health points and if its equal to 0
#it'll also show '*DEAD*' next to their name
#Sets the text depending on 'enemy_or_champion' parameter
    def target_frame_ai_champion_text(self, enemy_or_champion, character_position):
        if enemy_or_champion == "champion":
            if character_position == 1:
                if champion1_hp == 0:
                    status_text = "{}\n*DEAD*\nHealth Points: {}/{}".format(CHAMPION_LIST[0], champion1_hp,
                                                                            CHAMPION1_HP)
                    return status_text
                else:
                    status_text = "{}\nHealth Points: {}/{}".format(CHAMPION_LIST[0], champion1_hp, CHAMPION1_HP)
                    return status_text
            if character_position == 2:
                if champion2_hp == 0:
                    status_text = "{}\n*DEAD*\nHealth Points: {}/{}".format(CHAMPION_LIST[1], champion2_hp,
                                                                            CHAMPION2_HP)
                    return status_text
                else:
                    status_text = "{}\nHealth Points: {}/{}".format(CHAMPION_LIST[1], champion2_hp, CHAMPION2_HP)
                    return status_text
            if character_position == 3:
                if champion3_hp == 0:
                    status_text = "{}\n*DEAD*\nHealth Points: {}/{}".format(CHAMPION_LIST[2], champion3_hp,
                                                                            CHAMPION3_HP)
                    return status_text
                else:
                    status_text = "{}\nHealth Points: {}/{}".format(CHAMPION_LIST[2], champion3_hp, CHAMPION3_HP)
                    return status_text
            if character_position == 4:
                if champion4_hp == 0:
                    status_text = "{}\n*DEAD*\nHealth Points: {}/{}".format(CHAMPION_LIST[3], champion4_hp,
                                                                            CHAMPION4_HP)
                    return status_text
                else:
                    status_text = "{}\nHealth Points: {}/{}".format(CHAMPION_LIST[3], champion4_hp, CHAMPION4_HP)
                    return status_text
            if character_position == 5:
                if champion5_hp == 0:
                    status_text = "{}\n*DEAD*\nHealth Points: {}/{}".format(CHAMPION_LIST[4], champion5_hp,
                                                                            CHAMPION5_HP)
                    return status_text
                else:
                    status_text = "{}\nHealth Points: {}/{}".format(CHAMPION_LIST[4], champion5_hp, CHAMPION5_HP)
                    return status_text
        if enemy_or_champion == "ai":
            if character_position == 1:
                if AI_SPAWNED == 1:
                    status_text = "{}\nHealth Points: {}/{}".format(AI_NAME, ai1_hp, ai1_max_hp)
                    return status_text
                if ai1_hp == 0:
                    status_text = "{}#1\n*DEAD*\nHealth Points: {}/{}".format(AI_NAME, ai1_hp,
                                                                              ai1_max_hp)
                    return status_text
                else:
                    status_text = "{}#1\nHealth Points: {}/{}".format(AI_NAME, ai1_hp, ai1_max_hp)
                    return status_text
            if character_position == 2:
                if ai2_hp == 0:
                    status_text = "{}#2\n*DEAD*\nHealth Points: {}/{}".format(AI_NAME, ai2_hp,
                                                                              ai2_max_hp)
                    return status_text
                else:
                    status_text = "{}#2\nHealth Points: {}/{}".format(AI_NAME, ai2_hp, ai2_max_hp)
                    return status_text
            if character_position == 3:
                if ai3_hp == 0:
                    status_text = "{}#3\n*DEAD*\nHealth Points: {}/{}".format(AI_NAME, ai3_hp,
                                                                              ai3_max_hp)
                    return status_text
                else:
                    status_text = "{}#3\nHealth Points: {}/{}".format(AI_NAME, ai3_hp, ai3_max_hp)
                    return status_text
            if character_position == 4:
                if ai4_hp == 0:
                    status_text = "{}#4\n*DEAD*\nHealth Points: {}/{}".format(AI_NAME, ai4_hp,
                                                                              ai4_max_hp)
                    return status_text
                else:
                    status_text = "{}#4\nHealth Points: {}/{}".format(AI_NAME, ai4_hp, ai4_max_hp)
                    return status_text
            if character_position == 5:
                if ai5_hp == 0:
                    status_text = "{}#5\n*DEAD*\nHealth Points: {}/{}".format(AI_NAME, ai5_hp,
                                                                              ai5_max_hp)
                    return status_text
                else:
                    status_text = "{}#5\nHealth Points: {}/{}".format(AI_NAME, ai5_hp, ai5_max_hp)
                    return status_text
#Calculates all of the champions extra damage from the buffs that are on themselves
#Adds all them all together in the 'damage_done_multipler' interger based on the 'champion_position' parameter
#Buffs are additive not multiplicative
    def calculate_champion_damage(self, champion_position):
        damage_done_multipler = 1
        if champion_position == 1:
            if champion1_pure_rage != 0:
                damage_done_multipler = damage_done_multipler + 0.5
            if champion1_muscleEnlarger != 0:
                damage_done_multipler = damage_done_multipler + 0.6
            if champion1_strongremedy != 0:
                damage_done_multipler = damage_done_multipler + 0.5
            if champion1_weakremedy != 0:
                damage_done_multipler = damage_done_multipler + 0.25
            if champion1_fullPotential != 0:
                damage_done_multipler = damage_done_multipler + 1
            if paladin_aura == 1:
                damage_done_multipler = damage_done_multipler + 0.2
        if champion_position == 2:
            if champion2_pure_rage != 0:
                damage_done_multipler = damage_done_multipler + 0.5
            if champion2_muscleEnlarger != 0:
                damage_done_multipler = damage_done_multipler + 0.6
            if champion2_strongremedy != 0:
                damage_done_multipler = damage_done_multipler + 0.5
            if champion2_weakremedy != 0:
                damage_done_multipler = damage_done_multipler + 0.25
            if champion2_fullPotential != 0:
                damage_done_multipler = damage_done_multipler + 1
            if paladin_aura == 1:
                damage_done_multipler = damage_done_multipler + 0.2
        if champion_position == 3:
            if champion3_pure_rage != 0:
                damage_done_multipler = damage_done_multipler + 0.5
            if champion3_muscleEnlarger != 0:
                damage_done_multipler = damage_done_multipler + 0.6
            if champion3_strongremedy != 0:
                damage_done_multipler = damage_done_multipler + 0.5
            if champion3_weakremedy != 0:
                damage_done_multipler = damage_done_multipler + 0.25
            if champion3_fullPotential != 0:
                damage_done_multipler = damage_done_multipler + 1
            if paladin_aura == 1:
                damage_done_multipler = damage_done_multipler + 0.2
        if champion_position == 4:
            if champion4_pure_rage != 0:
                damage_done_multipler = damage_done_multipler + 0.5
            if champion4_muscleEnlarger != 0:
                damage_done_multipler = damage_done_multipler + -.6
            if champion4_strongremedy != 0:
                damage_done_multipler = damage_done_multipler + 0.5
            if champion4_weakremedy != 0:
                damage_done_multipler = damage_done_multipler + 0.25
            if champion4_fullPotential != 0:
                damage_done_multipler = damage_done_multipler + 1
            if paladin_aura == 1:
                damage_done_multipler = damage_done_multipler + 0.2
        if champion_position == 5:
            if champion5_pure_rage != 0:
                damage_done_multipler = damage_done_multipler + 0.5
            if champion5_muscleEnlarger != 0:
                damage_done_multipler = damage_done_multipler + 0.6
            if champion5_strongremedy != 0:
                damage_done_multipler = damage_done_multipler + 0.5
            if champion5_weakremedy != 0:
                damage_done_multipler = damage_done_multipler + 0.25
            if champion5_fullPotential != 0:
                damage_done_multipler = damage_done_multipler + 1
            if paladin_aura == 1:
                damage_done_multipler = damage_done_multipler + 0.2
        return damage_done_multipler
#Function that preforms the enemy ai's turn.
#All damage over time effects deal damage before the enemies attack
#For each enemy it checks whether its alive before making its attack
#Checks whether its stunned or taunted to change its attack
#Choosing its target with all the different targeting options (1T, 2T, AOE)
#All the special cases take place happen with damage that include immunities, damage redirects, damage reductions
#Enemy damage is calculated by the calculate_ai_damage function
#After each enemy attacks, all damage over time effects and debuffs with durations are reduced by 1
#Some champion buffs like the Monks baubles charges are reduced by one and Fencers additional dodge chance is reset
    def monsters_turn(self):
            global combat_results, current_turn, ai1_stun, ai2_stun, ai3_stun, ai4_stun, ai5_stun, ai1_taunt, ai2_taunt, ai3_taunt, ai4_taunt, ai5_taunt, \
                ai1_brittle, ai2_brittle, ai3_brittle, ai4_brittle, ai5_brittle, ai1_weakness, ai2_weakness, ai3_weakness, ai4_weakness, ai5_weakness, \
                ai1_burnDot, ai2_burnDot, ai3_burnDot, ai4_burnDot, ai5_burnDot, ai1_serraSlashDot, ai2_serraSlashDot, ai3_serraSlashDot, \
                ai4_serraSlashDot, ai5_serraSlashDot, ai1_garroteDot, ai2_garroteDot, ai3_garroteDot, ai4_garroteDot, ai5_garroteDot, \
                ai1_eviscerDot, ai2_eviscerDot, ai3_eviscerDot, ai4_eviscerDot, ai5_eviscerDot, \
                ai1_shimmerDot, ai2_shimmerDot, ai3_shimmerDot, ai4_shimmerDot, ai5_shimmerDot, \
                ai1_divineDot, ai2_divineDot, ai3_divineDot, ai4_divineDot, ai1_divineDot, \
                ai1_damnation, ai2_damnation, ai3_damnation, ai4_damnation, ai5_damnation, \
                ai1_rottingDot, ai2_rottingDot, ai3_rottingDot, ai4_rottingDot, ai5_rottingDot, \
                ai1_barbedArrDot, ai2_barbedArrDot, ai3_barbedArrDot, ai4_barbedArrDot, ai5_barbedArrDot, \
                ai1_thornsDot, ai2_thornsDot, ai3_thornsDot, ai4_thornsDot, ai5_thornsDot, \
                ai1_statuses, ai2_statuses, ai3_statuses, ai4_statuses, ai5_statuses, \
                champion1_statuses, champion2_statuses, champion3_statuses, champion4_statuses, champion5_statuses, \
                ai1_hp, ai2_hp, ai3_hp, ai4_hp, ai5_hp, \
                champion1_hp, champion2_hp, champion3_hp,champion4_hp, champion5_hp, \
                champion1_lastRoundDamageTaken_list, champion2_lastRoundDamageTaken_list, champion3_lastRoundDamageTaken_list, champion4_lastRoundDamageTaken_list, champion5_lastRoundDamageTaken_list, \
                champion1_immunity, champion2_immunity, champion3_immunity, champion4_immunity, champion5_immunity, \
                monk_bauble_damage_list1, monk_bauble_damage_list2, monk_bauble_damage_list3, \
                champion1_bush_armour, champion2_bush_armour, champion3_bush_armour, champion4_bush_armour, champion5_bush_armour, \
                champion1_magical_barrier, champion2_magical_barrier, champion3_magical_barrier, champion4_magical_barrier, champion5_magical_barrier,\
                ai1_fencer_dodgechance, ai2_fencer_dodgechance, ai3_fencer_dodgechance, ai4_fencer_dodgechance, ai5_fencer_dodgechance
            champion1_lastRoundDamageTaken_list = []
            champion2_lastRoundDamageTaken_list = []
            champion3_lastRoundDamageTaken_list = []
            champion4_lastRoundDamageTaken_list = []
            champion5_lastRoundDamageTaken_list = []
            if AI_SPAWNED == 1:
                monster_list = [1]
            elif AI_SPAWNED == 2:
                monster_list = [1, 2]
            elif AI_SPAWNED == 3:
                monster_list = [1, 2, 3]
            elif AI_SPAWNED == 4:
                monster_list = [1, 2, 3, 4]
            elif AI_SPAWNED == 5:
                monster_list = [1, 2, 3, 4, 5]
            for monster_var in monster_list:
                if monster_var == 1:
                    if ai1_hp == 0:
                        continue
                    if ai1_thornsDot[1] != 0:
                        ai1_hp = ai1_hp - ai1_thornsDot[0] * ai1_thornsDot[1]
                        if ai1_hp < 0:
                            ai1_hp = 0
                            continue
                    if ai1_burnDot[1] != 0:
                        ai1_hp = ai1_hp - ai1_burnDot[0]
                        ai1_burnDot[1] = ai1_burnDot[1] - 1
                        if ai1_hp < 0:
                            ai1_hp = 0
                            continue
                    if ai1_serraSlashDot[1] != 0:
                        ai1_hp = ai1_hp - self.calculate_bleed_damage("Serrated", 1)
                        ai1_serraSlashDot[1] = ai1_serraSlashDot[1] - 1
                        if ai1_hp < 0:
                            ai1_hp = 0
                            continue
                    if ai1_eviscerDot[1] != 0:
                        ai1_hp = ai1_hp - self.calculate_bleed_damage("Eviscerated", 1)
                        ai1_eviscerDot[1] = ai1_eviscerDot[1] - 1
                        if ai1_hp < 0:
                            ai1_hp = 0
                            continue
                    if ai1_garroteDot[1] != 0:
                        ai1_hp = ai1_hp - self.calculate_bleed_damage("Garroted", 1)
                        ai1_garroteDot[1] = ai1_garroteDot[1] - 1
                        if ai1_hp < 0:
                            ai1_hp = 0
                            continue
                    if ai1_rottingDot[1] != 0:
                        ai1_hp = ai1_hp - ai1_rottingDot[0]
                        self.apply_toc(1)
                        ai1_rottingDot[1] = ai1_rottingDot[1] - 1
                        if ai1_hp < 0:
                            ai1_hp = 0
                            continue
                    if ai1_shimmerDot[1] != 0:
                        ai1_hp = ai1_hp - ai1_shimmerDot[0]
                        ai1_shimmerDot[1] = ai1_shimmerDot[1] - 1
                        if champion1_hp > 0:
                            self.check_champion_blessing(1, ai1_shimmerDot[0])
                        if champion2_hp > 0:
                            self.check_champion_blessing(2, ai1_shimmerDot[0])
                        if champion3_hp > 0:
                            self.check_champion_blessing(3, ai1_shimmerDot[0])
                        if champion4_hp > 0:
                            self.check_champion_blessing(4, ai1_shimmerDot[0])
                        if champion5_hp > 0:
                            self.check_champion_blessing(5, ai1_shimmerDot[0])
                        if ai1_hp < 0:
                            ai1_hp = 0
                            continue
                    if ai1_divineDot[1] != 0:
                        ai1_hp = ai1_hp - ai1_divineDot[0]
                        ai1_divineDot[1] = ai1_divineDot[1] - 1
                        if champion1_hp > 0:
                            self.check_champion_blessing(1, ai1_divineDot[0])
                        if champion2_hp > 0:
                            self.check_champion_blessing(2, ai1_divineDot[0])
                        if champion3_hp > 0:
                            self.check_champion_blessing(3, ai1_divineDot[0])
                        if champion4_hp > 0:
                            self.check_champion_blessing(4, ai1_divineDot[0])
                        if champion5_hp > 0:
                            self.check_champion_blessing(5, ai1_divineDot[0])
                        if ai1_hp < 0:
                            ai1_hp = 0
                            continue
                    if ai1_barbedArrDot[1] != 0:
                        ai1_hp = ai1_hp - ai1_barbedArrDot[0]
                        ai1_barbedArrDot[1] = ai1_barbedArrDot[1] - 1
                        if ai1_hp < 0:
                            ai1_hp = 0
                            continue
                    if ai1_damnation[1] != 0:
                        ai1_damnation[1] = ai1_damnation[1] - 1
                        if ai1_damnation[1] == 0:
                            ai1_hp = ai1_hp - ai1_damnation[0]
                            if ai1_hp < 0:
                                ai1_hp = 0
                    if ai1_hp == 0:
                        continue
                    if ai1_stun != 0:
                        continue
                    if ai1_taunt[1] != 0:
                        if ai1_taunt[0] in CHAMPION_LIST[0]:
                            if len(champion1_immunity) != 0:
                                immune_list = []
                                for immune in champion1_immunity:
                                    if immune == "Cocoon":
                                        champion1_hp = champion1_hp
                                    elif immune == "Block":
                                        if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                            champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 1, 0) * 0.5)
                                            champion1_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(1, 1, 1) * 0.5))
                                            if champion1_hp < 0:
                                                champion1_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                            champion2_hp = champion2_hp - self.calculate_ai_damage(2, 1, 0)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 1, 1))
                                            if champion2_hp < 0:
                                                champion2_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                            champion3_hp = champion3_hp - self.calculate_ai_damage(3, 1, 0)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 1, 1))
                                            if champion3_hp < 0:
                                                champion3_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                            champion4_hp = champion4_hp - self.calculate_ai_damage(4, 1, 0)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 1, 1))
                                            if champion4_hp < 0:
                                                champion4_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                            champion5_hp = champion5_hp - self.calculate_ai_damage(5, 1, 0)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 1, 1))
                                            if champion5_hp < 0:
                                                champion5_hp = 0
                                    elif immune == "Evasive Manoeuvres":
                                        self.apply_taunt(1, MASTER_FENCER.title, 1)
                            elif CHAMPION_LIST[0] == MONK.title:
                                bauble_damage = self.calculate_ai_damage(1, 1, 0)
                                bauble_unavailable_check = 0
                                if monk_bauble_damage_list1[1] == 0:
                                    monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                else:
                                    if monk_bauble_damage_list2[1] == 0:
                                        monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list3[1] == 0:
                                            monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            bauble_unavailable_check = 1
                                monk_damage_taken = 0
                                if monk_bauble_damage_list1[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                if monk_bauble_damage_list2[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                if monk_bauble_damage_list3[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                if bauble_unavailable_check == 1:
                                    monk_damage_taken = monk_damage_taken + bauble_damage
                                champion1_hp = champion1_hp - math.ceil(monk_damage_taken)
                                champion1_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                if champion1_hp < 0:
                                    champion1_hp = 0
                            elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                ai_hit_fencer_range = random.randint(1, 100)
                                if ai_hit_fencer_range <= ai1_fencer_dodgechance:
                                    if AI_SIZE == "Tiny":
                                        champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 1, 0) * 0.5)
                                        champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 1, 1) * 0.5)
                                        self.apply_taunt(1, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Small":
                                        champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 1, 0) * 0.6)
                                        champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 1, 1) * 0.6)
                                        self.apply_taunt(1, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Medium":
                                        champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 1, 0) * 0.7)
                                        champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 1, 1) * 0.7)
                                        self.apply_taunt(1, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Large":
                                        champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 1, 0) * 0.8)
                                        champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 1, 1) * 0.8)
                                        self.apply_taunt(1, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Huge":
                                        champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 1, 0) * 0.9)
                                        champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 1, 1) * 0.9)
                                        self.apply_taunt(1, MASTER_FENCER.title, 1)
                                else:
                                    champion1_hp = champion1_hp - self.calculate_ai_damage(1, 1, 0)
                                    champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 1, 1))
                                    if champion1_hp < 0:
                                        champion1_hp = 0
                            else:
                                champion1_hp = champion1_hp - self.calculate_ai_damage(1, 1, 0)
                                champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 1, 1))
                                if champion1_hp < 0:
                                    champion1_hp = 0
                            if champion1_bush_armour != 0:
                                ai1_hp = ai1_hp - 200
                                self.apply_thornsDot(1, 1)
                            if ai1_hp < 0:
                                ai1_hp = 0
                        elif ai1_taunt[0] in CHAMPION_LIST[1]:
                            if len(champion2_immunity) != 0:
                                immune_list = []
                                for immune in champion2_immunity:
                                    if immune == "Cocoon":
                                        champion2_hp = champion2_hp
                                    elif immune == "Block":
                                        if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                            champion1_hp = champion1_hp - self.calculate_ai_damage(1, 1, 0)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 1, 1))
                                            if champion1_hp < 0:
                                                champion1_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                            champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 1, 0) * 0.5)
                                            champion2_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(2, 1, 1) * 0.5))
                                            if champion2_hp < 0:
                                                champion2_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                            champion3_hp = champion3_hp - self.calculate_ai_damage(3, 1, 0)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 1, 1))
                                            if champion3_hp < 0:
                                                champion3_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                            champion4_hp = champion4_hp - self.calculate_ai_damage(4, 1, 0)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 1, 1))
                                            if champion4_hp < 0:
                                                champion4_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                            champion5_hp = champion5_hp - self.calculate_ai_damage(5, 1, 0)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 1, 1))
                                            if champion5_hp < 0:
                                                champion5_hp = 0
                                    elif immune == "Evasive Manoeuvres":
                                        self.apply_taunt(1, MASTER_FENCER.title, 1)
                            elif CHAMPION_LIST[0] == MONK.title:
                                bauble_damage = self.calculate_ai_damage(2, 1, 0)
                                bauble_unavailable_check = 0
                                if monk_bauble_damage_list1[1] == 0:
                                    monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                else:
                                    if monk_bauble_damage_list2[1] == 0:
                                        monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list3[1] == 0:
                                            monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            bauble_unavailable_check = 1
                                monk_damage_taken = 0
                                if monk_bauble_damage_list1[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                if monk_bauble_damage_list2[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                if monk_bauble_damage_list3[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                if bauble_unavailable_check == 1:
                                    monk_damage_taken = monk_damage_taken + bauble_damage
                                champion2_hp = champion2_hp - math.ceil(monk_damage_taken)
                                champion2_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                if champion2_hp < 0:
                                    champion2_hp = 0
                            elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                ai_hit_fencer_range = random.randint(1, 100)
                                if ai_hit_fencer_range <= ai1_fencer_dodgechance:
                                    if AI_SIZE == "Tiny":
                                        champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 1, 0) * 0.5)
                                        champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 1, 1) * 0.5)
                                        self.apply_taunt(1, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Small":
                                        champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 1, 0) * 0.6)
                                        champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 1, 1) * 0.6)
                                        self.apply_taunt(1, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Medium":
                                        champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 1, 0) * 0.7)
                                        champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 1, 1) * 0.7)
                                        self.apply_taunt(1, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Large":
                                        champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 1, 0) * 0.8)
                                        champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 1, 1) * 0.8)
                                        self.apply_taunt(1, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Huge":
                                        champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 1, 0) * 0.9)
                                        champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 1, 1) * 0.9)
                                        self.apply_taunt(1, MASTER_FENCER.title, 1)
                                else:
                                    champion2_hp = champion2_hp - self.calculate_ai_damage(2, 1, 0)
                                    champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 1, 1))
                                    if champion2_hp < 0:
                                        champion2_hp = 0
                            else:
                                champion2_hp = champion2_hp - self.calculate_ai_damage(2, 1, 0)
                                champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 1, 1))
                                if champion2_hp < 0:
                                    champion2_hp = 0
                            if champion2_bush_armour != 0:
                                ai1_hp = ai1_hp - 200
                                self.apply_thornsDot(1, 1)
                            if ai1_hp < 0:
                                ai1_hp = 0
                        elif ai1_taunt[0] in CHAMPION_LIST[2]:
                            if len(champion3_immunity) != 0:
                                immune_list = []
                                for immune in champion3_immunity:
                                    if immune == "Cocoon":
                                        champion3_hp = champion3_hp
                                    elif immune == "Block":
                                        if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                            champion1_hp = champion1_hp - self.calculate_ai_damage(1, 1, 0)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 1, 1))
                                            if champion1_hp < 0:
                                                champion1_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                            champion2_hp = champion2_hp - self.calculate_ai_damage(2, 1, 0)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 1, 1))
                                            if champion2_hp < 0:
                                                champion2_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                            champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 1, 0) * 0.5)
                                            champion3_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(3, 1, 1) * 0.5))
                                            if champion3_hp < 0:
                                                champion3_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                            champion4_hp = champion4_hp - self.calculate_ai_damage(4, 1, 0)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 1, 1))
                                            if champion4_hp < 0:
                                                champion4_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                            champion5_hp = champion5_hp - self.calculate_ai_damage(5, 1, 0)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 1, 1))
                                            if champion5_hp < 0:
                                                champion5_hp = 0
                                    elif immune == "Evasive Manoeuvres":
                                        self.apply_taunt(1, MASTER_FENCER.title, 1)
                            elif CHAMPION_LIST[0] == MONK.title:
                                bauble_damage = self.calculate_ai_damage(3, 1)
                                bauble_unavailable_check = 0
                                if monk_bauble_damage_list1[1] == 0:
                                    monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                else:
                                    if monk_bauble_damage_list2[1] == 0:
                                        monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list3[1] == 0:
                                            monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            bauble_unavailable_check = 1
                                monk_damage_taken = 0
                                if monk_bauble_damage_list1[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                if monk_bauble_damage_list2[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                if monk_bauble_damage_list3[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                if bauble_unavailable_check == 1:
                                    monk_damage_taken = monk_damage_taken + bauble_damage
                                champion3_hp = champion3_hp - math.ceil(monk_damage_taken)
                                champion3_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                if champion3_hp < 0:
                                    champion3_hp = 0
                            elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                ai_hit_fencer_range = random.randint(1, 100)
                                if ai_hit_fencer_range <= ai1_fencer_dodgechance:
                                    if AI_SIZE == "Tiny":
                                        champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 1, 0) * 0.5)
                                        champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 1, 1) * 0.5)
                                        self.apply_taunt(1, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Small":
                                        champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 1, 0) * 0.6)
                                        champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 1, 1) * 0.6)
                                        self.apply_taunt(1, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Medium":
                                        champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 1, 0) * 0.7)
                                        champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 1, 1) * 0.7)
                                        self.apply_taunt(1, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Large":
                                        champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 1, 0) * 0.8)
                                        champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 1, 1) * 0.8)
                                        self.apply_taunt(1, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Huge":
                                        champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 1, 0) * 0.9)
                                        champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 1, 1) * 0.9)
                                        self.apply_taunt(1, MASTER_FENCER.title, 1)
                                else:
                                    champion3_hp = champion3_hp - self.calculate_ai_damage(3, 1, 0)
                                    champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 1, 1))
                                    if champion3_hp < 0:
                                        champion3_hp = 0
                            else:
                                champion3_hp = champion3_hp - self.calculate_ai_damage(3, 1, 0)
                                champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 1, 1))
                                if champion3_hp < 0:
                                    champion3_hp = 0
                            if champion3_bush_armour != 0:
                                ai1_hp = ai1_hp - 200
                                self.apply_thornsDot(1, 1)
                            if ai1_hp < 0:
                                ai1_hp = 0
                        elif ai1_taunt[0] in CHAMPION_LIST[3]:
                            if len(champion4_immunity) != 0:
                                immune_list = []
                                for immune in champion4_immunity:
                                    if immune == "Cocoon":
                                        champion4_hp = champion4_hp
                                    elif immune == "Block":
                                        if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                            champion1_hp = champion1_hp - self.calculate_ai_damage(1, 1, 0)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 1, 1))
                                            if champion1_hp < 0:
                                                champion1_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                            champion2_hp = champion2_hp - self.calculate_ai_damage(2, 1, 0)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 1, 1))
                                            if champion2_hp < 0:
                                                champion2_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                            champion3_hp = champion3_hp - self.calculate_ai_damage(3, 1, 0)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 1, 1))
                                            if champion3_hp < 0:
                                                champion3_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                            champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 1, 0) * 0.5)
                                            champion4_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(4, 1, 1) * 0.5))
                                            if champion4_hp < 0:
                                                champion4_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                            champion5_hp = champion5_hp - self.calculate_ai_damage(5, 1, 0)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 1, 1))
                                            if champion5_hp < 0:
                                                champion5_hp = 0
                                    elif immune == "Evasive Manoeuvres":
                                        self.apply_taunt(1, MASTER_FENCER.title, 1)
                            elif CHAMPION_LIST[0] == MONK.title:
                                bauble_damage = self.calculate_ai_damage(4, 1, 0)
                                bauble_unavailable_check = 0
                                if monk_bauble_damage_list1[1] == 0:
                                    monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                else:
                                    if monk_bauble_damage_list2[1] == 0:
                                        monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list3[1] == 0:
                                            monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            bauble_unavailable_check = 1
                                monk_damage_taken = 0
                                if monk_bauble_damage_list1[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                if monk_bauble_damage_list2[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                if monk_bauble_damage_list3[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                if bauble_unavailable_check == 1:
                                    monk_damage_taken = monk_damage_taken + bauble_damage
                                champion4_hp = champion4_hp - math.ceil(monk_damage_taken)
                                champion4_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                if champion4_hp < 0:
                                    champion4_hp = 0
                            elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                ai_hit_fencer_range = random.randint(1, 100)
                                if ai_hit_fencer_range <= ai1_fencer_dodgechance:
                                    if AI_SIZE == "Tiny":
                                        champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 1, 0) * 0.5)
                                        champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 1, 1) * 0.5)
                                        self.apply_taunt(1, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Small":
                                        champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 1, 0) * 0.6)
                                        champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 1, 1) * 0.6)
                                        self.apply_taunt(1, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Medium":
                                        champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 1, 0) * 0.7)
                                        champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 1, 1) * 0.7)
                                        self.apply_taunt(1, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Large":
                                        champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 1, 0) * 0.8)
                                        champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 1, 1) * 0.8)
                                        self.apply_taunt(1, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Huge":
                                        champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 1, 0) * 0.9)
                                        champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 1, 1) * 0.9)
                                        self.apply_taunt(1, MASTER_FENCER.title, 1)
                                else:
                                    champion4_hp = champion4_hp - self.calculate_ai_damage(4, 1, 0)
                                    champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 1, 1))
                                    if champion4_hp < 0:
                                        champion4_hp = 0
                            else:
                                champion4_hp = champion4_hp - self.calculate_ai_damage(4, 1, 0)
                                champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 1, 1))
                                if champion4_hp < 0:
                                    champion4_hp = 0
                            if champion4_bush_armour != 0:
                                ai1_hp = ai1_hp - 200
                                self.apply_thornsDot(1, 1)
                            if ai1_hp < 0:
                                ai1_hp = 0
                        elif ai1_taunt[0] in CHAMPION_LIST[4]:
                            if len(champion5_immunity) != 0:
                                immune_list = []
                                for immune in champion5_immunity:
                                    if immune == "Cocoon":
                                        champion5_hp = champion5_hp
                                    elif immune == "Block":
                                        if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                            champion1_hp = champion1_hp - self.calculate_ai_damage(1, 1, 0)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 1, 1))
                                            if champion1_hp < 0:
                                                champion1_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                            champion2_hp = champion2_hp - self.calculate_ai_damage(2, 1, 0)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 1, 1))
                                            if champion2_hp < 0:
                                                champion2_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                            champion3_hp = champion3_hp - self.calculate_ai_damage(3, 1, 0)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 1, 1))
                                            if champion3_hp < 0:
                                                champion3_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                            champion4_hp = champion4_hp - self.calculate_ai_damage(4, 1, 0)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 1, 1))
                                            if champion4_hp < 0:
                                                champion4_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                            champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 1, 0) * 0.5)
                                            champion5_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(5, 1, 0) * 0.5))
                                            if champion5_hp < 0:
                                                champion5_hp = 0
                                    elif immune == "Evasive Manoeuvres":
                                        self.apply_taunt(1, MASTER_FENCER.title, 1)
                            elif CHAMPION_LIST[0] == MONK.title:
                                bauble_damage = self.calculate_ai_damage(5, 1, 0)
                                bauble_unavailable_check = 0
                                if monk_bauble_damage_list1[1] == 0:
                                    monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                else:
                                    if monk_bauble_damage_list2[1] == 0:
                                        monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list3[1] == 0:
                                            monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            bauble_unavailable_check = 1
                                monk_damage_taken = 0
                                if monk_bauble_damage_list1[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                if monk_bauble_damage_list2[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                if monk_bauble_damage_list3[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                if bauble_unavailable_check == 1:
                                    monk_damage_taken = monk_damage_taken + bauble_damage
                                champion5_hp = champion5_hp - math.ceil(monk_damage_taken)
                                champion5_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                if champion5_hp < 0:
                                    champion5_hp = 0
                            elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                ai_hit_fencer_range = random.randint(1, 100)
                                if ai_hit_fencer_range <= ai1_fencer_dodgechance:
                                    if AI_SIZE == "Tiny":
                                        champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 1, 0) * 0.5)
                                        champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 1, 1) * 0.5)
                                        self.apply_taunt(1, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Small":
                                        champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 1, 0) * 0.6)
                                        champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 1, 1) * 0.6)
                                        self.apply_taunt(1, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Medium":
                                        champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 1, 0) * 0.7)
                                        champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 1, 1) * 0.7)
                                        self.apply_taunt(1, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Large":
                                        champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 1, 0) * 0.8)
                                        champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 1, 1) * 0.8)
                                        self.apply_taunt(1, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Huge":
                                        champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 1, 0) * 0.9)
                                        champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 1, 1) * 0.9)
                                        self.apply_taunt(1, MASTER_FENCER.title, 1)
                                else:
                                    champion5_hp = champion5_hp - self.calculate_ai_damage(5, 1, 0)
                                    champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 1, 1))
                                    if champion5_hp < 0:
                                        champion5_hp = 0
                            else:
                                champion5_hp = champion5_hp - self.calculate_ai_damage(5, 1, 0)
                                champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 1, 1))
                                if champion5_hp < 0:
                                    champion5_hp = 0
                            if champion5_bush_armour != 0:
                                ai1_hp = ai1_hp - 200
                                self.apply_thornsDot(1, 1)
                            if ai1_hp < 0:
                                ai1_hp = 0
                    else:
                        if "Everyone" in ai1_attack_intention:
                            if champion1_hp != 0:
                                if len(champion1_immunity) != 0:
                                    immune_list = []
                                    for immune in champion1_immunity:
                                        if immune == "Cocoon":
                                            champion1_hp = champion1_hp
                                        elif immune == "Block":
                                            if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                                champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 1, 0) * 0.5)
                                                champion1_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(1, 1, 1) * 0.5))
                                                if champion1_hp < 0:
                                                    champion1_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                                champion2_hp = champion2_hp - self.calculate_ai_damage(2, 1, 0)
                                                champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 1, 1))
                                                if champion2_hp < 0:
                                                    champion2_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                                champion3_hp = champion3_hp - self.calculate_ai_damage(3, 1, 0)
                                                champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 1, 1))
                                                if champion3_hp < 0:
                                                    champion3_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                                champion4_hp = champion4_hp - self.calculate_ai_damage(4, 1, 0)
                                                champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 1, 1))
                                                if champion4_hp < 0:
                                                    champion4_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                                champion5_hp = champion5_hp - self.calculate_ai_damage(5, 1, 0)
                                                champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 1, 1))
                                                if champion5_hp < 0:
                                                    champion5_hp = 0
                                        elif immune == "Evasive Manoeuvres":
                                            self.apply_taunt(1, MASTER_FENCER.title, 1)
                                elif CHAMPION_LIST[0] == MONK.title:
                                    bauble_damage = self.calculate_ai_damage(1, 1, 0)
                                    bauble_unavailable_check = 0
                                    if monk_bauble_damage_list1[1] == 0:
                                        monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list2[1] == 0:
                                            monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            if monk_bauble_damage_list3[1] == 0:
                                                monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                            else:
                                                bauble_unavailable_check = 1
                                    monk_damage_taken = 0
                                    if monk_bauble_damage_list1[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                    if monk_bauble_damage_list2[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                    if monk_bauble_damage_list3[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                    if bauble_unavailable_check == 1:
                                        monk_damage_taken = monk_damage_taken + bauble_damage
                                    champion1_hp = champion1_hp - math.ceil(monk_damage_taken)
                                    champion1_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                    if champion1_hp < 0:
                                        champion1_hp = 0
                                elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                    ai_hit_fencer_range = random.randint(1, 100)
                                    if ai_hit_fencer_range <= ai1_fencer_dodgechance:
                                        if AI_SIZE == "Tiny":
                                            champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 1, 0) * 0.5)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 1, 1) * 0.5)
                                            self.apply_taunt(1, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Small":
                                            champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 1, 0) * 0.6)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 1, 1) * 0.6)
                                            self.apply_taunt(1, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Medium":
                                            champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 1, 0) * 0.7)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 1, 1) * 0.7)
                                            self.apply_taunt(1, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Large":
                                            champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 1, 0) * 0.8)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 1, 1) * 0.8)
                                            self.apply_taunt(1, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Huge":
                                            champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 1, 0) * 0.9)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 1, 1) * 0.9)
                                            self.apply_taunt(1, MASTER_FENCER.title, 1)
                                    else:
                                        champion1_hp = champion1_hp - self.calculate_ai_damage(1, 1, 0)
                                        champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 1, 1))
                                        if champion1_hp < 0:
                                            champion1_hp = 0
                                elif CHAMPION_LIST[0] == POWER_CONDUIT.title:
                                    champion1_hp = champion1_hp - self.calculate_ai_damage(1, 1, 0)
                                    champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 1, 1))
                                    if champion1_hp < 0:
                                        champion1_hp = 0
                                    ai1_hp = ai1_hp - 750
                                    if ai1_hp < 0:
                                        ai1_hp = 0
                                elif CHAMPION_LIST[0] == ACADEMIC_MAGE.title:
                                    mage_damage_taken = math.ceil(self.calculate_ai_damage(1, 1, 0) - champion1_magical_barrier)
                                    if mage_damage_taken < 0:
                                        champion1_magical_barrier = mage_damage_taken * -1
                                    else:
                                        champion1_magical_barrier = 0
                                        champion1_hp = champion1_hp - mage_damage_taken
                                        champion1_lastRoundDamageTaken_list.append(mage_damage_taken)
                                        if champion1_hp < 0:
                                            champion1_hp = 0
                                else:
                                    champion1_hp = champion1_hp - self.calculate_ai_damage(1, 1, 0)
                                    champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 1, 1))
                                    if champion1_hp < 0:
                                        champion1_hp = 0
                                if champion1_bush_armour != 0:
                                    ai1_hp = ai1_hp - 200
                                    self.apply_thornsDot(1, 1)
                                if ai1_hp < 0:
                                    ai1_hp = 0
                            if champion2_hp != 0:
                                if len(champion2_immunity) != 0:
                                    immune_list = []
                                    for immune in champion2_immunity:
                                        if immune == "Cocoon":
                                            champion2_hp = champion2_hp
                                        elif immune == "Block":
                                            if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                                champion1_hp = champion1_hp - self.calculate_ai_damage(1, 1, 0)
                                                champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 1, 1))
                                                if champion1_hp < 0:
                                                    champion1_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                                champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 1, 0) * 0.5)
                                                champion2_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(2, 1, 1) * 0.5))
                                                if champion2_hp < 0:
                                                    champion2_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                                champion3_hp = champion3_hp - self.calculate_ai_damage(3, 1, 0)
                                                champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 1, 1))
                                                if champion3_hp < 0:
                                                    champion3_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                                champion4_hp = champion4_hp - self.calculate_ai_damage(4, 1, 0)
                                                champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 1, 1))
                                                if champion4_hp < 0:
                                                    champion4_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                                champion5_hp = champion5_hp - self.calculate_ai_damage(5, 1, 0)
                                                champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 1, 1))
                                                if champion5_hp < 0:
                                                    champion5_hp = 0
                                        elif immune == "Evasive Manoeuvres":
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                elif CHAMPION_LIST[0] == MONK.title:
                                    bauble_damage = self.calculate_ai_damage(2, 1, 0)
                                    bauble_unavailable_check = 0
                                    if monk_bauble_damage_list1[1] == 0:
                                        monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list2[1] == 0:
                                            monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            if monk_bauble_damage_list3[1] == 0:
                                                monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                            else:
                                                bauble_unavailable_check = 1
                                    monk_damage_taken = 0
                                    if monk_bauble_damage_list1[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                    if monk_bauble_damage_list2[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                    if monk_bauble_damage_list3[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                    if bauble_unavailable_check == 1:
                                        monk_damage_taken = monk_damage_taken + bauble_damage
                                    champion2_hp = champion2_hp - math.ceil(monk_damage_taken)
                                    champion2_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                    if champion2_hp < 0:
                                        champion2_hp = 0
                                elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                    ai_hit_fencer_range = random.randint(1, 100)
                                    if ai_hit_fencer_range <= ai1_fencer_dodgechance:
                                        if AI_SIZE == "Tiny":
                                            champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 1, 0) * 0.5)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 1, 1) * 0.5)
                                            self.apply_taunt(1, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Small":
                                            champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 1, 0) * 0.6)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 1, 1) * 0.6)
                                            self.apply_taunt(1, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Medium":
                                            champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 1, 0) * 0.7)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 1, 1) * 0.7)
                                            self.apply_taunt(1, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Large":
                                            champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 1, 0) * 0.8)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 1, 1) * 0.8)
                                            self.apply_taunt(1, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Huge":
                                            champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 1, 0) * 0.9)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 1, 1) * 0.9)
                                            self.apply_taunt(1, MASTER_FENCER.title, 1)
                                    else:
                                        champion2_hp = champion2_hp - self.calculate_ai_damage(2, 1, 0)
                                        champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 1, 1))
                                        if champion2_hp < 0:
                                            champion2_hp = 0
                                elif CHAMPION_LIST[0] == POWER_CONDUIT.title:
                                    champion2_hp = champion2_hp - self.calculate_ai_damage(2, 1, 0)
                                    champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 1, 1))
                                    if champion2_hp < 0:
                                        champion2_hp = 0
                                    ai1_hp = ai1_hp - 750
                                    if ai1_hp < 0:
                                        ai1_hp = 0
                                elif CHAMPION_LIST[0] == ACADEMIC_MAGE.title:
                                    mage_damage_taken = math.ceil(self.calculate_ai_damage(2, 1, 0) - champion2_magical_barrier)
                                    if mage_damage_taken < 0:
                                        champion2_magical_barrier = mage_damage_taken * -1
                                    else:
                                        champion2_magical_barrier = 0
                                        champion2_hp = champion2_hp - mage_damage_taken
                                        champion2_lastRoundDamageTaken_list.append(mage_damage_taken)
                                        if champion2_hp < 0:
                                            champion2_hp = 0
                                else:
                                    champion2_hp = champion2_hp - self.calculate_ai_damage(2, 1, 0)
                                    champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 1, 1))
                                    if champion2_hp < 0:
                                        champion2_hp = 0
                                if champion2_bush_armour != 0:
                                    ai1_hp = ai1_hp - 200
                                    self.apply_thornsDot(1, 1)
                                if ai1_hp < 0:
                                    ai1_hp = 0
                            if champion3_hp != 0:
                                if len(champion3_immunity) != 0:
                                    immune_list = []
                                    for immune in champion3_immunity:
                                        if immune == "Cocoon":
                                            champion3_hp = champion3_hp
                                        elif immune == "Block":
                                            if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                                champion1_hp = champion1_hp - self.calculate_ai_damage(1, 1, 0)
                                                champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 1, 1))
                                                if champion1_hp < 0:
                                                    champion1_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                                champion2_hp = champion2_hp - self.calculate_ai_damage(2, 1, 0)
                                                champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 1, 1))
                                                if champion2_hp < 0:
                                                    champion2_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                                champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 1, 0) * 0.5)
                                                champion3_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(3, 1, 1) * 0.5))
                                                if champion3_hp < 0:
                                                    champion3_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                                champion4_hp = champion4_hp - self.calculate_ai_damage(4, 1, 0)
                                                champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 1, 1))
                                                if champion4_hp < 0:
                                                    champion4_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                                champion5_hp = champion5_hp - self.calculate_ai_damage(5, 1, 0)
                                                champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 1, 1))
                                                if champion5_hp < 0:
                                                    champion5_hp = 0
                                        elif immune == "Evasive Manoeuvres":
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                elif CHAMPION_LIST[0] == MONK.title:
                                    bauble_damage = self.calculate_ai_damage(3, 1, 0)
                                    bauble_unavailable_check = 0
                                    if monk_bauble_damage_list1[1] == 0:
                                        monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list2[1] == 0:
                                            monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            if monk_bauble_damage_list3[1] == 0:
                                                monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                            else:
                                                bauble_unavailable_check = 1
                                    monk_damage_taken = 0
                                    if monk_bauble_damage_list1[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                    if monk_bauble_damage_list2[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                    if monk_bauble_damage_list3[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                    if bauble_unavailable_check == 1:
                                        monk_damage_taken = monk_damage_taken + bauble_damage
                                    champion3_hp = champion3_hp - math.ceil(monk_damage_taken)
                                    champion3_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                    if champion3_hp < 0:
                                        champion3_hp = 0
                                elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                    ai_hit_fencer_range = random.randint(1, 100)
                                    if ai_hit_fencer_range <= ai1_fencer_dodgechance:
                                        if AI_SIZE == "Tiny":
                                            champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 1, 0) * 0.5)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 1, 1) * 0.5)
                                            self.apply_taunt(1, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Small":
                                            champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 1, 0) * 0.6)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 1, 1) * 0.6)
                                            self.apply_taunt(1, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Medium":
                                            champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 1, 0) * 0.7)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 1, 1) * 0.7)
                                            self.apply_taunt(1, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Large":
                                            champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 1, 0) * 0.8)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 1, 1) * 0.8)
                                            self.apply_taunt(1, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Huge":
                                            champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 1, 0) * 0.9)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 1, 1) * 0.9)
                                            self.apply_taunt(1, MASTER_FENCER.title, 1)
                                    else:
                                        champion3_hp = champion3_hp - self.calculate_ai_damage(3, 1, 0)
                                        champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 1, 1))
                                        if champion3_hp < 0:
                                            champion3_hp = 0
                                elif CHAMPION_LIST[0] == POWER_CONDUIT.title:
                                    champion3_hp = champion3_hp - self.calculate_ai_damage(3, 1, 0)
                                    champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 1, 1))
                                    if champion3_hp < 0:
                                        champion3_hp = 0
                                    ai1_hp = ai1_hp - 750
                                    if ai1_hp < 0:
                                        ai1_hp = 0
                                elif CHAMPION_LIST[0] == ACADEMIC_MAGE.title:
                                    mage_damage_taken = math.ceil(self.calculate_ai_damage(3, 1, 0) - champion3_magical_barrier)
                                    if mage_damage_taken < 0:
                                        champion3_magical_barrier = mage_damage_taken * -1
                                    else:
                                        champion3_magical_barrier = 0
                                        champion3_hp = champion3_hp - mage_damage_taken
                                        champion3_lastRoundDamageTaken_list.append(mage_damage_taken)
                                        if champion3_hp < 0:
                                            champion3_hp = 0
                                else:
                                    champion3_hp = champion3_hp - self.calculate_ai_damage(3, 1, 0)
                                    champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 1, 1))
                                    if champion3_hp < 0:
                                        champion3_hp = 0
                                if champion3_bush_armour != 0:
                                    ai1_hp = ai1_hp - 200
                                    self.apply_thornsDot(1, 1)
                                if ai1_hp < 0:
                                    ai1_hp = 0
                            if champion4_hp != 0:
                                if len(champion4_immunity) != 0:
                                    immune_list = []
                                    for immune in champion4_immunity:
                                        if immune == "Cocoon":
                                            champion4_hp = champion4_hp
                                        elif immune == "Block":
                                            if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                                champion1_hp = champion1_hp - self.calculate_ai_damage(1, 1, 0)
                                                champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 1, 1))
                                                if champion1_hp < 0:
                                                    champion1_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                                champion2_hp = champion2_hp - self.calculate_ai_damage(2, 1, 0)
                                                champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 1, 1))
                                                if champion2_hp < 0:
                                                    champion2_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                                champion3_hp = champion3_hp - self.calculate_ai_damage(3, 1, 0)
                                                champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 1, 1))
                                                if champion3_hp < 0:
                                                    champion3_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                                champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 1, 0) * 0.5)
                                                champion4_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(4, 1, 1) * 0.5))
                                                if champion4_hp < 0:
                                                    champion4_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                                champion5_hp = champion5_hp - self.calculate_ai_damage(5, 1, 0)
                                                champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 1, 1))
                                                if champion5_hp < 0:
                                                    champion5_hp = 0
                                        elif immune == "Evasive Manoeuvres":
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                elif CHAMPION_LIST[0] == MONK.title:
                                    bauble_damage = self.calculate_ai_damage(4, 1, 0)
                                    bauble_unavailable_check = 0
                                    if monk_bauble_damage_list1[1] == 0:
                                        monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list2[1] == 0:
                                            monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            if monk_bauble_damage_list3[1] == 0:
                                                monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                            else:
                                                bauble_unavailable_check = 1
                                    monk_damage_taken = 0
                                    if monk_bauble_damage_list1[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                    if monk_bauble_damage_list2[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                    if monk_bauble_damage_list3[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                    if bauble_unavailable_check == 1:
                                        monk_damage_taken = monk_damage_taken + bauble_damage
                                    champion4_hp = champion4_hp - math.ceil(monk_damage_taken)
                                    champion4_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                    if champion4_hp < 0:
                                        champion4_hp = 0
                                elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                    ai_hit_fencer_range = random.randint(1, 100)
                                    if ai_hit_fencer_range <= ai1_fencer_dodgechance:
                                        if AI_SIZE == "Tiny":
                                            champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 1, 0) * 0.5)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 1, 1) * 0.5)
                                            self.apply_taunt(1, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Small":
                                            champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 1, 0) * 0.6)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 1, 1) * 0.6)
                                            self.apply_taunt(1, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Medium":
                                            champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 1, 0) * 0.7)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 1, 1) * 0.7)
                                            self.apply_taunt(1, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Large":
                                            champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 1, 0) * 0.8)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 1, 1) * 0.8)
                                            self.apply_taunt(1, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Huge":
                                            champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 1, 0) * 0.9)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 1, 1) * 0.9)
                                            self.apply_taunt(1, MASTER_FENCER.title, 1)
                                    else:
                                        champion4_hp = champion4_hp - self.calculate_ai_damage(4, 1, 0)
                                        champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 1, 1))
                                        if champion4_hp < 0:
                                            champion4_hp = 0
                                elif CHAMPION_LIST[0] == POWER_CONDUIT.title:
                                    champion4_hp = champion4_hp - self.calculate_ai_damage(4, 1, 0)
                                    champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 1, 1))
                                    if champion4_hp < 0:
                                        champion4_hp = 0
                                    ai1_hp = ai1_hp - 750
                                    if ai1_hp < 0:
                                        ai1_hp = 0
                                elif CHAMPION_LIST[0] == ACADEMIC_MAGE.title:
                                    mage_damage_taken = math.ceil(self.calculate_ai_damage(4, 1, 0) - champion4_magical_barrier)
                                    if mage_damage_taken < 0:
                                        champion4_magical_barrier = mage_damage_taken * -1
                                    else:
                                        champion4_magical_barrier = 0
                                        champion4_hp = champion4_hp - mage_damage_taken
                                        champion4_lastRoundDamageTaken_list.append(mage_damage_taken)
                                        if champion4_hp < 0:
                                            champion4_hp = 0
                                else:
                                    champion4_hp = champion4_hp - self.calculate_ai_damage(4, 1, 0)
                                    champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 1, 1))
                                    if champion4_hp < 0:
                                        champion4_hp = 0
                                if champion4_bush_armour != 0:
                                    ai1_hp = ai1_hp - 200
                                    self.apply_thornsDot(1, 1)
                                if ai1_hp < 0:
                                    ai1_hp = 0
                            if champion5_hp != 0:
                                if len(champion5_immunity) != 0:
                                    immune_list = []
                                    for immune in champion5_immunity:
                                        if immune == "Cocoon":
                                            champion5_hp = champion5_hp
                                        elif immune == "Block":
                                            if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                                champion1_hp = champion1_hp - self.calculate_ai_damage(1, 1, 0)
                                                champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 1, 1))
                                                if champion1_hp < 0:
                                                    champion1_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                                champion2_hp = champion2_hp - self.calculate_ai_damage(2, 1, 0)
                                                champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 1, 1))
                                                if champion2_hp < 0:
                                                    champion2_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                                champion3_hp = champion3_hp - self.calculate_ai_damage(3, 1, 0)
                                                champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 1, 1))
                                                if champion3_hp < 0:
                                                    champion3_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                                champion4_hp = champion4_hp - self.calculate_ai_damage(4, 1, 0)
                                                champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 1, 1))
                                                if champion4_hp < 0:
                                                    champion4_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                                champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 1, 0) * 0.5)
                                                champion5_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(5, 1, 1) * 0.5))
                                                if champion5_hp < 0:
                                                    champion5_hp = 0
                                        elif immune == "Evasive Manoeuvres":
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                elif CHAMPION_LIST[0] == MONK.title:
                                    bauble_damage = self.calculate_ai_damage(5, 1, 0)
                                    bauble_unavailable_check = 0
                                    if monk_bauble_damage_list1[1] == 0:
                                        monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list2[1] == 0:
                                            monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            if monk_bauble_damage_list3[1] == 0:
                                                monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                            else:
                                                bauble_unavailable_check = 1
                                    monk_damage_taken = 0
                                    if monk_bauble_damage_list1[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                    if monk_bauble_damage_list2[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                    if monk_bauble_damage_list3[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                    if bauble_unavailable_check == 1:
                                        monk_damage_taken = monk_damage_taken + bauble_damage
                                    champion5_hp = champion5_hp - math.ceil(monk_damage_taken)
                                    champion5_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                    if champion5_hp < 0:
                                        champion5_hp = 0
                                elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                    ai_hit_fencer_range = random.randint(1, 100)
                                    if ai_hit_fencer_range <= ai1_fencer_dodgechance:
                                        if AI_SIZE == "Tiny":
                                            champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 1, 0) * 0.5)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 1, 1) * 0.5)
                                            self.apply_taunt(1, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Small":
                                            champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 1, 0) * 0.6)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 1, 1) * 0.6)
                                            self.apply_taunt(1, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Medium":
                                            champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 1, 0) * 0.7)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 1, 1) * 0.7)
                                            self.apply_taunt(1, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Large":
                                            champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 1, 0) * 0.8)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 1, 1) * 0.8)
                                            self.apply_taunt(1, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Huge":
                                            champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 1, 0) * 0.9)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 1, 1) * 0.9)
                                            self.apply_taunt(1, MASTER_FENCER.title, 1)
                                    else:
                                        champion5_hp = champion5_hp - self.calculate_ai_damage(5, 1, 0)
                                        champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 1, 1))
                                        if champion5_hp < 0:
                                            champion5_hp = 0
                                elif CHAMPION_LIST[0] == POWER_CONDUIT.title:
                                    champion5_hp = champion5_hp - self.calculate_ai_damage(5, 1, 0)
                                    champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 1, 1))
                                    if champion5_hp < 0:
                                        champion5_hp = 0
                                    ai1_hp = ai1_hp - 750
                                    if ai1_hp < 0:
                                        ai1_hp = 0
                                elif CHAMPION_LIST[0] == ACADEMIC_MAGE.title:
                                    mage_damage_taken = math.ceil(self.calculate_ai_damage(5, 1, 0) - champion5_magical_barrier)
                                    if mage_damage_taken < 0:
                                        champion5_magical_barrier = mage_damage_taken * -1
                                    else:
                                        champion5_magical_barrier = 0
                                        champion5_hp = champion5_hp - mage_damage_taken
                                        champion5_lastRoundDamageTaken_list.append(mage_damage_taken)
                                        if champion5_hp < 0:
                                            champion5_hp = 0
                                else:
                                    champion5_hp = champion5_hp - self.calculate_ai_damage(5, 1, 0)
                                    champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 1, 1))
                                    if champion5_hp < 0:
                                        champion5_hp = 0
                                if champion5_bush_armour != 0:
                                    ai1_hp = ai1_hp - 200
                                    self.apply_thornsDot(1, 1)
                                if ai1_hp < 0:
                                    ai1_hp = 0
                        else:
                            if CHAMPION_LIST[0] in ai1_attack_intention:
                                if len(champion1_immunity) != 0:
                                    immune_list = []
                                    for immune in champion1_immunity:
                                        if immune == "Cocoon":
                                            champion1_hp = champion1_hp
                                        elif immune == "Block":
                                            if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                                champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 1, 0) * 0.5)
                                                champion1_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(1, 1, 1) * 0.5))
                                                if champion1_hp < 0:
                                                    champion1_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                                champion2_hp = champion2_hp - self.calculate_ai_damage(2, 1, 0)
                                                champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 1, 1))
                                                if champion2_hp < 0:
                                                    champion2_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                                champion3_hp = champion3_hp - self.calculate_ai_damage(3, 1, 0)
                                                champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 1, 1))
                                                if champion3_hp < 0:
                                                    champion3_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                                champion4_hp = champion4_hp - self.calculate_ai_damage(4, 1, 0)
                                                champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 1, 1))
                                                if champion4_hp < 0:
                                                    champion4_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                                champion5_hp = champion5_hp - self.calculate_ai_damage(5, 1, 0)
                                                champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 1, 1))
                                                if champion5_hp < 0:
                                                    champion5_hp = 0
                                        elif immune == "Evasive Manoeuvres":
                                            self.apply_taunt(1, MASTER_FENCER.title, 1)
                                elif CHAMPION_LIST[0] == MONK.title:
                                    bauble_damage = self.calculate_ai_damage(1, 1, 0)
                                    bauble_unavailable_check = 0
                                    if monk_bauble_damage_list1[1] == 0:
                                        monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list2[1] == 0:
                                            monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            if monk_bauble_damage_list3[1] == 0:
                                                monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                            else:
                                                bauble_unavailable_check = 1
                                    monk_damage_taken = 0
                                    if monk_bauble_damage_list1[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                    if monk_bauble_damage_list2[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                    if monk_bauble_damage_list3[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                    if bauble_unavailable_check == 1:
                                        monk_damage_taken = monk_damage_taken + bauble_damage
                                    champion1_hp = champion1_hp - math.ceil(monk_damage_taken)
                                    champion1_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                    if champion1_hp < 0:
                                        champion1_hp = 0
                                elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                    ai_hit_fencer_range = random.randint(1, 100)
                                    if ai_hit_fencer_range <= ai1_fencer_dodgechance:
                                        if AI_SIZE == "Tiny":
                                            champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 1, 0) * 0.5)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 1, 1) * 0.5)
                                            self.apply_taunt(1, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Small":
                                            champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 1, 0) * 0.6)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 1, 1) * 0.6)
                                            self.apply_taunt(1, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Medium":
                                            champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 1, 0) * 0.7)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 1, 1) * 0.7)
                                            self.apply_taunt(1, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Large":
                                            champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 1, 0) * 0.8)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 1, 1) * 0.8)
                                            self.apply_taunt(1, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Huge":
                                            champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 1, 0) * 0.9)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 1, 1) * 0.9)
                                            self.apply_taunt(1, MASTER_FENCER.title, 1)
                                    else:
                                        champion1_hp = champion1_hp - self.calculate_ai_damage(1, 1, 0)
                                        champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 1, 1))
                                        if champion1_hp < 0:
                                            champion1_hp = 0
                                elif CHAMPION_LIST[0] == POWER_CONDUIT.title:
                                    champion1_hp = champion1_hp - self.calculate_ai_damage(1, 1, 0)
                                    champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 1, 1))
                                    if champion1_hp < 0:
                                        champion1_hp = 0
                                    ai1_hp = ai1_hp - 750
                                    if ai1_hp < 0:
                                        ai1_hp = 0
                                elif CHAMPION_LIST[0] == ACADEMIC_MAGE.title:
                                    mage_damage_taken = math.ceil(self.calculate_ai_damage(1, 1, 0) - champion1_magical_barrier)
                                    if mage_damage_taken < 0:
                                        champion1_magical_barrier = mage_damage_taken * -1
                                    else:
                                        champion1_magical_barrier = 0
                                        champion1_hp = champion1_hp - mage_damage_taken
                                        champion1_lastRoundDamageTaken_list.append(mage_damage_taken)
                                        if champion1_hp < 0:
                                            champion1_hp = 0
                                else:
                                    champion1_hp = champion1_hp - self.calculate_ai_damage(1, 1, 0)
                                    champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 1, 1))
                                    if champion1_hp < 0:
                                        champion1_hp = 0
                                if champion1_bush_armour != 0:
                                    ai1_hp = ai1_hp - 200
                                    self.apply_thornsDot(1, 1)
                                if ai1_hp < 0:
                                    ai1_hp = 0
                            if CHAMPION_LIST[1] in ai1_attack_intention:
                                if len(champion2_immunity) != 0:
                                    immune_list = []
                                    for immune in champion2_immunity:
                                        if immune == "Cocoon":
                                            champion2_hp = champion2_hp
                                        elif immune == "Block":
                                            if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                                champion1_hp = champion1_hp - self.calculate_ai_damage(1, 1, 0)
                                                champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 1, 1))
                                                if champion1_hp < 0:
                                                    champion1_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                                champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 1, 0) * 0.5)
                                                champion2_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(2, 1, 1) * 0.5))
                                                if champion2_hp < 0:
                                                    champion2_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                                champion3_hp = champion3_hp - self.calculate_ai_damage(3, 1, 0)
                                                champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 1, 1))
                                                if champion3_hp < 0:
                                                    champion3_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                                champion4_hp = champion4_hp - self.calculate_ai_damage(4, 1, 0)
                                                champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 1, 1))
                                                if champion4_hp < 0:
                                                    champion4_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                                champion5_hp = champion5_hp - self.calculate_ai_damage(5, 1, 0)
                                                champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 1, 1))
                                                if champion5_hp < 0:
                                                    champion5_hp = 0
                                        elif immune == "Evasive Manoeuvres":
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                elif CHAMPION_LIST[0] == MONK.title:
                                    bauble_damage = self.calculate_ai_damage(2, 1, 0)
                                    bauble_unavailable_check = 0
                                    if monk_bauble_damage_list1[1] == 0:
                                        monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list2[1] == 0:
                                            monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            if monk_bauble_damage_list3[1] == 0:
                                                monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                            else:
                                                bauble_unavailable_check = 1
                                    monk_damage_taken = 0
                                    if monk_bauble_damage_list1[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                    if monk_bauble_damage_list2[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                    if monk_bauble_damage_list3[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                    if bauble_unavailable_check == 1:
                                        monk_damage_taken = monk_damage_taken + bauble_damage
                                    champion2_hp = champion2_hp - math.ceil(monk_damage_taken)
                                    champion2_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                    if champion2_hp < 0:
                                        champion2_hp = 0
                                elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                    ai_hit_fencer_range = random.randint(1, 100)
                                    if ai_hit_fencer_range <= ai1_fencer_dodgechance:
                                        if AI_SIZE == "Tiny":
                                            champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 1, 0) * 0.5)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 1, 1) * 0.5)
                                            self.apply_taunt(1, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Small":
                                            champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 1, 0) * 0.6)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 1, 1) * 0.6)
                                            self.apply_taunt(1, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Medium":
                                            champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 1, 0) * 0.7)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 1, 1) * 0.7)
                                            self.apply_taunt(1, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Large":
                                            champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 1, 0) * 0.8)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 1, 1) * 0.8)
                                            self.apply_taunt(1, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Huge":
                                            champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 1, 0) * 0.9)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 1, 1) * 0.9)
                                            self.apply_taunt(1, MASTER_FENCER.title, 1)
                                    else:
                                        champion2_hp = champion2_hp - self.calculate_ai_damage(2, 1, 0)
                                        champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 1, 1))
                                        if champion2_hp < 0:
                                            champion2_hp = 0
                                elif CHAMPION_LIST[0] == POWER_CONDUIT.title:
                                    champion2_hp = champion2_hp - self.calculate_ai_damage(2, 1, 0)
                                    champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 1, 1))
                                    if champion2_hp < 0:
                                        champion2_hp = 0
                                    ai1_hp = ai1_hp - 750
                                    if ai1_hp < 0:
                                        ai1_hp = 0
                                elif CHAMPION_LIST[0] == ACADEMIC_MAGE.title:
                                    mage_damage_taken = math.ceil(self.calculate_ai_damage(2, 1, 0) - champion2_magical_barrier)
                                    if mage_damage_taken < 0:
                                        champion2_magical_barrier = mage_damage_taken * -1
                                    else:
                                        champion2_magical_barrier = 0
                                        champion2_hp = champion2_hp - mage_damage_taken
                                        champion2_lastRoundDamageTaken_list.append(mage_damage_taken)
                                        if champion2_hp < 0:
                                            champion2_hp = 0
                                else:
                                    champion2_hp = champion2_hp - self.calculate_ai_damage(2, 1, 0)
                                    champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 1, 1))
                                    if champion2_hp < 0:
                                        champion2_hp = 0
                                if champion2_bush_armour != 0:
                                    ai1_hp = ai1_hp - 200
                                    self.apply_thornsDot(1, 1)
                                if ai1_hp < 0:
                                    ai1_hp = 0
                            if CHAMPION_LIST[2] in ai1_attack_intention:
                                if len(champion3_immunity) != 0:
                                    immune_list = []
                                    for immune in champion3_immunity:
                                        if immune == "Cocoon":
                                            champion3_hp = champion3_hp
                                        elif immune == "Block":
                                            if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                                champion1_hp = champion1_hp - self.calculate_ai_damage(1, 1, 0)
                                                champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 1, 1))
                                                if champion1_hp < 0:
                                                    champion1_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                                champion2_hp = champion2_hp - self.calculate_ai_damage(2, 1, 0)
                                                champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 1, 1))
                                                if champion2_hp < 0:
                                                    champion2_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                                champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 1, 0) * 0.5)
                                                champion3_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(3, 1, 1) * 0.5))
                                                if champion3_hp < 0:
                                                    champion3_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                                champion4_hp = champion4_hp - self.calculate_ai_damage(4, 1, 0)
                                                champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 1, 1))
                                                if champion4_hp < 0:
                                                    champion4_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                                champion5_hp = champion5_hp - self.calculate_ai_damage(5, 1, 0)
                                                champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 1, 1))
                                                if champion5_hp < 0:
                                                    champion5_hp = 0
                                        elif immune == "Evasive Manoeuvres":
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                elif CHAMPION_LIST[0] == MONK.title:
                                    bauble_damage = self.calculate_ai_damage(3, 1, 0)
                                    bauble_unavailable_check = 0
                                    if monk_bauble_damage_list1[1] == 0:
                                        monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list2[1] == 0:
                                            monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            if monk_bauble_damage_list3[1] == 0:
                                                monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                            else:
                                                bauble_unavailable_check = 1
                                    monk_damage_taken = 0
                                    if monk_bauble_damage_list1[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                    if monk_bauble_damage_list2[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                    if monk_bauble_damage_list3[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                    if bauble_unavailable_check == 1:
                                        monk_damage_taken = monk_damage_taken + bauble_damage
                                    champion3_hp = champion3_hp - math.ceil(monk_damage_taken)
                                    champion3_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                    if champion3_hp < 0:
                                        champion3_hp = 0
                                elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                    ai_hit_fencer_range = random.randint(1, 100)
                                    if ai_hit_fencer_range <= ai1_fencer_dodgechance:
                                        if AI_SIZE == "Tiny":
                                            champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 1, 0) * 0.5)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 1, 1) * 0.5)
                                            self.apply_taunt(1, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Small":
                                            champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 1, 0) * 0.6)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 1, 1) * 0.6)
                                            self.apply_taunt(1, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Medium":
                                            champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 1, 0) * 0.7)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 1, 1) * 0.7)
                                            self.apply_taunt(1, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Large":
                                            champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 1, 0) * 0.8)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 1, 1) * 0.8)
                                            self.apply_taunt(1, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Huge":
                                            champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 1, 0) * 0.9)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 1, 1) * 0.9)
                                            self.apply_taunt(1, MASTER_FENCER.title, 1)
                                    else:
                                        champion3_hp = champion3_hp - self.calculate_ai_damage(3, 1, 0)
                                        champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 1, 1))
                                        if champion3_hp < 0:
                                            champion3_hp = 0
                                elif CHAMPION_LIST[0] == POWER_CONDUIT.title:
                                    champion3_hp = champion3_hp - self.calculate_ai_damage(3, 1, 0)
                                    champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 1, 1))
                                    if champion3_hp < 0:
                                        champion3_hp = 0
                                    ai1_hp = ai1_hp - 750
                                    if ai1_hp < 0:
                                        ai1_hp = 0
                                elif CHAMPION_LIST[0] == ACADEMIC_MAGE.title:
                                    mage_damage_taken = math.ceil(self.calculate_ai_damage(3, 1, 0) - champion3_magical_barrier)
                                    if mage_damage_taken < 0:
                                        champion3_magical_barrier = mage_damage_taken * -1
                                    else:
                                        champion3_magical_barrier = 0
                                        champion3_hp = champion3_hp - mage_damage_taken
                                        champion3_lastRoundDamageTaken_list.append(mage_damage_taken)
                                        if champion3_hp < 0:
                                            champion3_hp = 0
                                else:
                                    champion3_hp = champion3_hp - self.calculate_ai_damage(3, 1, 0)
                                    champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 1, 1))
                                    if champion3_hp < 0:
                                        champion3_hp = 0
                                if champion3_bush_armour != 0:
                                    ai1_hp = ai1_hp - 200
                                    self.apply_thornsDot(1, 1)
                                if ai1_hp < 0:
                                    ai1_hp = 0
                            if CHAMPION_LIST[3] in ai1_attack_intention:
                                if len(champion4_immunity) != 0:
                                    immune_list = []
                                    for immune in champion4_immunity:
                                        if immune == "Cocoon":
                                            champion4_hp = champion4_hp
                                        elif immune == "Block":
                                            if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                                champion1_hp = champion1_hp - self.calculate_ai_damage(1, 1, 0)
                                                champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 1, 1))
                                                if champion1_hp < 0:
                                                    champion1_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                                champion2_hp = champion2_hp - self.calculate_ai_damage(2, 1, 0)
                                                champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 1, 1))
                                                if champion2_hp < 0:
                                                    champion2_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                                champion3_hp = champion3_hp - self.calculate_ai_damage(3, 1, 0)
                                                champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 1, 1))
                                                if champion3_hp < 0:
                                                    champion3_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                                champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 1, 0) * 0.5)
                                                champion4_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(4, 1, 1) * 0.5))
                                                if champion4_hp < 0:
                                                    champion4_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                                champion5_hp = champion5_hp - self.calculate_ai_damage(5, 1, 0)
                                                champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 1, 1))
                                                if champion5_hp < 0:
                                                    champion5_hp = 0
                                        elif immune == "Evasive Manoeuvres":
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                elif CHAMPION_LIST[0] == MONK.title:
                                    bauble_damage = self.calculate_ai_damage(4, 1, 0)
                                    bauble_unavailable_check = 0
                                    if monk_bauble_damage_list1[1] == 0:
                                        monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list2[1] == 0:
                                            monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            if monk_bauble_damage_list3[1] == 0:
                                                monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                            else:
                                                bauble_unavailable_check = 1
                                    monk_damage_taken = 0
                                    if monk_bauble_damage_list1[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                    if monk_bauble_damage_list2[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                    if monk_bauble_damage_list3[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                    if bauble_unavailable_check == 1:
                                        monk_damage_taken = monk_damage_taken + bauble_damage
                                    champion4_hp = champion4_hp - math.ceil(monk_damage_taken)
                                    champion4_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                    if champion4_hp < 0:
                                        champion4_hp = 0
                                elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                    ai_hit_fencer_range = random.randint(1, 100)
                                    if ai_hit_fencer_range <= ai1_fencer_dodgechance:
                                        if AI_SIZE == "Tiny":
                                            champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 1, 0) * 0.5)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 1, 1) * 0.5)
                                            self.apply_taunt(1, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Small":
                                            champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 1, 0) * 0.6)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 1, 1) * 0.6)
                                            self.apply_taunt(1, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Medium":
                                            champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 1, 0) * 0.7)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 1, 1) * 0.7)
                                            self.apply_taunt(1, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Large":
                                            champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 1, 0) * 0.8)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 1, 1) * 0.8)
                                            self.apply_taunt(1, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Huge":
                                            champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 1, 0) * 0.9)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 1, 1) * 0.9)
                                            self.apply_taunt(1, MASTER_FENCER.title, 1)
                                    else:
                                        champion4_hp = champion4_hp - self.calculate_ai_damage(4, 1, 0)
                                        champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 1, 1))
                                        if champion4_hp < 0:
                                            champion4_hp = 0
                                elif CHAMPION_LIST[0] == POWER_CONDUIT.title:
                                    champion4_hp = champion4_hp - self.calculate_ai_damage(4, 1, 0)
                                    champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 1, 1))
                                    if champion4_hp < 0:
                                        champion4_hp = 0
                                    ai1_hp = ai1_hp - 750
                                    if ai1_hp < 0:
                                        ai1_hp = 0
                                elif CHAMPION_LIST[0] == ACADEMIC_MAGE.title:
                                    mage_damage_taken = math.ceil(self.calculate_ai_damage(4, 1, 0) - champion4_magical_barrier)
                                    if mage_damage_taken < 0:
                                        champion4_magical_barrier = mage_damage_taken * -1
                                    else:
                                        champion4_magical_barrier = 0
                                        champion4_hp = champion4_hp - mage_damage_taken
                                        champion4_lastRoundDamageTaken_list.append(mage_damage_taken)
                                        if champion4_hp < 0:
                                            champion4_hp = 0
                                else:
                                    champion4_hp = champion4_hp - self.calculate_ai_damage(4, 1, 0)
                                    champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 1, 1))
                                    if champion4_hp < 0:
                                        champion4_hp = 0
                                if champion4_bush_armour != 0:
                                    ai1_hp = ai1_hp - 200
                                    self.apply_thornsDot(1, 1)
                                if ai1_hp < 0:
                                    ai1_hp = 0
                            if CHAMPION_LIST[4] in ai1_attack_intention:
                                if len(champion5_immunity) != 0:
                                    immune_list = []
                                    for immune in champion5_immunity:
                                        if immune == "Cocoon":
                                            champion5_hp = champion5_hp
                                        elif immune == "Block":
                                            if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                                champion1_hp = champion1_hp - self.calculate_ai_damage(1, 1, 0)
                                                champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 1, 1))
                                                if champion1_hp < 0:
                                                    champion1_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                                champion2_hp = champion2_hp - self.calculate_ai_damage(2, 1, 0)
                                                champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 1, 1))
                                                if champion2_hp < 0:
                                                    champion2_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                                champion3_hp = champion3_hp - self.calculate_ai_damage(3, 1, 0)
                                                champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 1, 1))
                                                if champion3_hp < 0:
                                                    champion3_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                                champion4_hp = champion4_hp - self.calculate_ai_damage(4, 1, 0)
                                                champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 1, 1))
                                                if champion4_hp < 0:
                                                    champion4_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                                champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 1, 0) * 0.5)
                                                champion5_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(5, 1, 1) * 0.5))
                                                if champion5_hp < 0:
                                                    champion5_hp = 0
                                        elif immune == "Evasive Manoeuvres":
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                elif CHAMPION_LIST[0] == MONK.title:
                                    bauble_damage = self.calculate_ai_damage(5, 1, 0)
                                    bauble_unavailable_check = 0
                                    if monk_bauble_damage_list1[1] == 0:
                                        monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list2[1] == 0:
                                            monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            if monk_bauble_damage_list3[1] == 0:
                                                monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                            else:
                                                bauble_unavailable_check = 1
                                    monk_damage_taken = 0
                                    if monk_bauble_damage_list1[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                    if monk_bauble_damage_list2[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                    if monk_bauble_damage_list3[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                    if bauble_unavailable_check == 1:
                                        monk_damage_taken = monk_damage_taken + bauble_damage
                                    champion5_hp = champion5_hp - math.ceil(monk_damage_taken)
                                    champion5_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                    if champion5_hp < 0:
                                        champion5_hp = 0
                                elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                    ai_hit_fencer_range = random.randint(1, 100)
                                    if ai_hit_fencer_range <= ai1_fencer_dodgechance:
                                        if AI_SIZE == "Tiny":
                                            champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 1, 0) * 0.5)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 1, 1) * 0.5)
                                            self.apply_taunt(1, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Small":
                                            champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 1, 0) * 0.6)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 1, 1) * 0.6)
                                            self.apply_taunt(1, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Medium":
                                            champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 1, 0) * 0.7)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 1, 1) * 0.7)
                                            self.apply_taunt(1, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Large":
                                            champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 1, 0) * 0.8)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 1, 1) * 0.8)
                                            self.apply_taunt(1, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Huge":
                                            champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 1, 0) * 0.9)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 1, 1) * 0.9)
                                            self.apply_taunt(1, MASTER_FENCER.title, 1)
                                    else:
                                        champion5_hp = champion5_hp - self.calculate_ai_damage(5, 1, 0)
                                        champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 1, 1))
                                        if champion5_hp < 0:
                                            champion5_hp = 0
                                elif CHAMPION_LIST[0] == POWER_CONDUIT.title:
                                    champion5_hp = champion5_hp - self.calculate_ai_damage(5, 1, 0)
                                    champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 1, 1))
                                    if champion5_hp < 0:
                                        champion5_hp = 0
                                    ai1_hp = ai1_hp - 750
                                    if ai1_hp < 0:
                                        ai1_hp = 0
                                elif CHAMPION_LIST[0] == ACADEMIC_MAGE.title:
                                    mage_damage_taken = math.ceil(self.calculate_ai_damage(5, 1, 0) - champion5_magical_barrier)
                                    if mage_damage_taken < 0:
                                        champion5_magical_barrier = mage_damage_taken * -1
                                    else:
                                        champion5_magical_barrier = 0
                                        champion5_hp = champion5_hp - mage_damage_taken
                                        champion5_lastRoundDamageTaken_list.append(mage_damage_taken)
                                        if champion5_hp < 0:
                                            champion5_hp = 0
                                else:
                                    champion5_hp = champion5_hp - self.calculate_ai_damage(5, 1, 0)
                                    champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 1, 1))
                                    if champion5_hp < 0:
                                        champion5_hp = 0
                                if champion5_bush_armour != 0:
                                    ai1_hp = ai1_hp - 200
                                    self.apply_thornsDot(1, 1)
                                if ai1_hp < 0:
                                    ai1_hp = 0
                if monster_var == 2:
                    if ai2_hp == 0:
                        continue
                    if ai2_thornsDot[1] != 0:
                        ai2_hp = ai2_hp - ai2_thornsDot[0] * ai2_thornsDot[1]
                        if ai2_hp < 0:
                            ai2_hp = 0
                            continue
                    if ai2_burnDot[1] != 0:
                        ai2_hp = ai2_hp - ai2_burnDot[0]
                        ai2_burnDot[1] = ai2_burnDot[1] - 1
                        if ai2_hp < 0:
                            ai2_hp = 0
                            continue
                    if ai2_serraSlashDot[1] != 0:
                        ai2_hp = ai2_hp - self.calculate_bleed_damage("Serrated", 2)
                        ai2_serraSlashDot[1] = ai2_serraSlashDot[1] - 1
                        if ai2_hp < 0:
                            ai2_hp = 0
                            continue
                    if ai2_eviscerDot[1] != 0:
                        ai2_hp = ai2_hp - self.calculate_bleed_damage("Eviscerated", 2)
                        ai2_eviscerDot[1] = ai2_eviscerDot[1] - 1
                        if ai2_hp < 0:
                            ai2_hp = 0
                            continue
                    if ai2_garroteDot[1] != 0:
                        ai2_hp = ai2_hp - self.calculate_bleed_damage("Garroted", 2)
                        ai2_garroteDot[1] = ai2_garroteDot[1] - 1
                        if ai2_hp < 0:
                            ai2_hp = 0
                            continue
                    if ai2_rottingDot[1] != 0:
                        ai2_hp = ai2_hp - ai2_rottingDot[0]
                        self.apply_toc(2)
                        ai2_rottingDot[1] = ai2_rottingDot[1] - 1
                        if ai2_hp < 0:
                            ai2_hp = 0
                            continue
                    if ai2_shimmerDot[1] != 0:
                        ai2_hp = ai2_hp - ai2_shimmerDot[0]
                        ai2_shimmerDot[1] = ai2_shimmerDot[1] - 1
                        if champion1_hp > 0:
                            self.check_champion_blessing(1, ai2_shimmerDot[0])
                        if champion2_hp > 0:
                            self.check_champion_blessing(2, ai2_shimmerDot[0])
                        if champion3_hp > 0:
                            self.check_champion_blessing(3, ai2_shimmerDot[0])
                        if champion4_hp > 0:
                            self.check_champion_blessing(4, ai2_shimmerDot[0])
                        if champion5_hp > 0:
                            self.check_champion_blessing(5, ai2_shimmerDot[0])
                        if ai2_hp < 0:
                            ai2_hp = 0
                            continue
                    if ai2_divineDot[1] != 0:
                        ai2_hp = ai2_hp - ai2_divineDot[0]
                        ai2_divineDot[1] = ai2_divineDot[1] - 1
                        if champion1_hp > 0:
                            self.check_champion_blessing(1, ai2_divineDot[0])
                        if champion2_hp > 0:
                            self.check_champion_blessing(2, ai2_divineDot[0])
                        if champion3_hp > 0:
                            self.check_champion_blessing(3, ai2_divineDot[0])
                        if champion4_hp > 0:
                            self.check_champion_blessing(4, ai2_divineDot[0])
                        if champion5_hp > 0:
                            self.check_champion_blessing(5, ai2_divineDot[0])
                        if ai2_hp < 0:
                            ai2_hp = 0
                            continue
                    if ai2_barbedArrDot[1] != 0:
                        ai2_hp = ai2_hp - ai2_barbedArrDot[0]
                        ai2_barbedArrDot[1] = ai2_barbedArrDot[1] - 1
                        if ai2_hp < 0:
                            ai2_hp = 0
                            continue
                    if ai2_damnation[1] != 0:
                        ai2_damnation[1] = ai2_damnation[1] - 1
                        if ai2_damnation[1] == 0:
                            ai2_hp = ai2_hp - ai2_damnation[0]
                            if ai2_hp < 0:
                                ai2_hp = 0
                    if ai2_hp == 0:
                        continue
                    if ai2_stun != 0:
                        continue
                    if ai2_taunt[1] != 0:
                        if ai2_taunt[0] in CHAMPION_LIST[0]:
                            if len(champion1_immunity) != 0:
                                immune_list = []
                                for immune in champion1_immunity:
                                    if immune == "Cocoon":
                                        champion1_hp = champion1_hp
                                    elif immune == "Block":
                                        if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                            champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 2, 0) * 0.5)
                                            champion1_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(1, 2, 1) * 0.5))
                                            if champion1_hp < 0:
                                                champion1_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                            champion2_hp = champion2_hp - self.calculate_ai_damage(2, 2, 0)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 2, 1))
                                            if champion2_hp < 0:
                                                champion2_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                            champion3_hp = champion3_hp - self.calculate_ai_damage(3, 2, 0)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 2, 1))
                                            if champion3_hp < 0:
                                                champion3_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                            champion4_hp = champion4_hp - self.calculate_ai_damage(4, 2, 0)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 2, 1))
                                            if champion4_hp < 0:
                                                champion4_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                            champion5_hp = champion5_hp - self.calculate_ai_damage(5, 2, 0)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 2, 1))
                                            if champion5_hp < 0:
                                                champion5_hp = 0
                                    elif immune == "Evasive Manoeuvres":
                                        self.apply_taunt(2, MASTER_FENCER.title, 1)
                            elif CHAMPION_LIST[0] == MONK.title:
                                bauble_damage = self.calculate_ai_damage(1, 2, 0)
                                bauble_unavailable_check = 0
                                if monk_bauble_damage_list1[1] == 0:
                                    monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                else:
                                    if monk_bauble_damage_list2[1] == 0:
                                        monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list3[1] == 0:
                                            monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            bauble_unavailable_check = 1
                                monk_damage_taken = 0
                                if monk_bauble_damage_list1[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                if monk_bauble_damage_list2[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                if monk_bauble_damage_list3[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                if bauble_unavailable_check == 1:
                                    monk_damage_taken = monk_damage_taken + bauble_damage
                                champion1_hp = champion1_hp - math.ceil(monk_damage_taken)
                                champion1_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                if champion1_hp < 0:
                                    champion1_hp = 0
                            elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                ai_hit_fencer_range = random.randint(1, 100)
                                if ai_hit_fencer_range <= ai2_fencer_dodgechance:
                                    if AI_SIZE == "Tiny":
                                        champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 2, 0) * 0.5)
                                        champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 2, 1) * 0.5)
                                        self.apply_taunt(2, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Small":
                                        champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 2, 0) * 0.6)
                                        champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 2, 1) * 0.6)
                                        self.apply_taunt(2, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Medium":
                                        champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 2, 0) * 0.7)
                                        champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 2, 1) * 0.7)
                                        self.apply_taunt(2, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Large":
                                        champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 2, 0) * 0.8)
                                        champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 2, 1) * 0.8)
                                        self.apply_taunt(2, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Huge":
                                        champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 2, 0) * 0.9)
                                        champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 2, 1) * 0.9)
                                        self.apply_taunt(2, MASTER_FENCER.title, 1)
                                else:
                                    champion1_hp = champion1_hp - self.calculate_ai_damage(1, 2, 0)
                                    champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 2, 1))
                                    if champion1_hp < 0:
                                        champion1_hp = 0
                            else:
                                champion1_hp = champion1_hp - self.calculate_ai_damage(1, 2, 0)
                                champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 2, 1))
                                if champion1_hp < 0:
                                    champion1_hp = 0
                            if champion1_bush_armour != 0:
                                ai2_hp = ai2_hp - 200
                                self.apply_thornsDot(1, 2)
                            if ai2_hp < 0:
                                ai2_hp = 0
                        elif ai2_taunt[0] in CHAMPION_LIST[1]:
                            if len(champion2_immunity) != 0:
                                immune_list = []
                                for immune in champion2_immunity:
                                    if immune == "Cocoon":
                                        champion2_hp = champion2_hp
                                    elif immune == "Block":
                                        if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                            champion1_hp = champion1_hp - self.calculate_ai_damage(1, 2, 0)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 2, 1))
                                            if champion1_hp < 0:
                                                champion1_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                            champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 2, 0) * 0.5)
                                            champion2_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(2, 2, 1) * 0.5))
                                            if champion2_hp < 0:
                                                champion2_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                            champion3_hp = champion3_hp - self.calculate_ai_damage(3, 2, 0)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 2, 1))
                                            if champion3_hp < 0:
                                                champion3_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                            champion4_hp = champion4_hp - self.calculate_ai_damage(4, 2, 0)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 2, 1))
                                            if champion4_hp < 0:
                                                champion4_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                            champion5_hp = champion5_hp - self.calculate_ai_damage(5, 2, 0)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 2, 1))
                                            if champion5_hp < 0:
                                                champion5_hp = 0
                                    elif immune == "Evasive Manoeuvres":
                                        self.apply_taunt(2, MASTER_FENCER.title, 1)
                            elif CHAMPION_LIST[0] == MONK.title:
                                bauble_damage = self.calculate_ai_damage(2, 2, 0)
                                bauble_unavailable_check = 0
                                if monk_bauble_damage_list1[1] == 0:
                                    monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                else:
                                    if monk_bauble_damage_list2[1] == 0:
                                        monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list3[1] == 0:
                                            monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            bauble_unavailable_check = 1
                                monk_damage_taken = 0
                                if monk_bauble_damage_list1[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                if monk_bauble_damage_list2[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                if monk_bauble_damage_list3[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                if bauble_unavailable_check == 1:
                                    monk_damage_taken = monk_damage_taken + bauble_damage
                                champion2_hp = champion2_hp - math.ceil(monk_damage_taken)
                                champion2_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                if champion2_hp < 0:
                                    champion2_hp = 0
                            elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                ai_hit_fencer_range = random.randint(1, 100)
                                if ai_hit_fencer_range <= ai2_fencer_dodgechance:
                                    if AI_SIZE == "Tiny":
                                        champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 2, 0) * 0.5)
                                        champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 2, 1) * 0.5)
                                        self.apply_taunt(2, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Small":
                                        champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 2, 0) * 0.6)
                                        champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 2, 1) * 0.6)
                                        self.apply_taunt(2, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Medium":
                                        champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 2, 0) * 0.7)
                                        champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 2, 1) * 0.7)
                                        self.apply_taunt(2, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Large":
                                        champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 2, 0) * 0.8)
                                        champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 2, 1) * 0.8)
                                        self.apply_taunt(2, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Huge":
                                        champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 2, 0) * 0.9)
                                        champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 2, 1) * 0.9)
                                        self.apply_taunt(2, MASTER_FENCER.title, 1)
                                else:
                                    champion2_hp = champion2_hp - self.calculate_ai_damage(2, 2, 0)
                                    champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 2, 1))
                                    if champion2_hp < 0:
                                        champion2_hp = 0
                            else:
                                champion2_hp = champion2_hp - self.calculate_ai_damage(2, 2, 0)
                                champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 2, 1))
                                if champion2_hp < 0:
                                    champion2_hp = 0
                            if champion2_bush_armour != 0:
                                ai2_hp = ai2_hp - 200
                                self.apply_thornsDot(1, 2)
                            if ai2_hp < 0:
                                ai2_hp = 0
                        elif ai2_taunt[0] in CHAMPION_LIST[2]:
                            if len(champion3_immunity) != 0:
                                immune_list = []
                                for immune in champion3_immunity:
                                    if immune == "Cocoon":
                                        champion3_hp = champion3_hp
                                    elif immune == "Block":
                                        if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                            champion1_hp = champion1_hp - self.calculate_ai_damage(1, 2, 0)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 2, 1))
                                            if champion1_hp < 0:
                                                champion1_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                            champion2_hp = champion2_hp - self.calculate_ai_damage(2, 2, 0)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 2, 1))
                                            if champion2_hp < 0:
                                                champion2_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                            champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 2, 0) * 0.5)
                                            champion3_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(3, 2, 1) * 0.5))
                                            if champion3_hp < 0:
                                                champion3_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                            champion4_hp = champion4_hp - self.calculate_ai_damage(4, 2, 0)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 2, 1))
                                            if champion4_hp < 0:
                                                champion4_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                            champion5_hp = champion5_hp - self.calculate_ai_damage(5, 2, 0)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 2, 1))
                                            if champion5_hp < 0:
                                                champion5_hp = 0
                                    elif immune == "Evasive Manoeuvres":
                                        self.apply_taunt(2, MASTER_FENCER.title, 1)
                            elif CHAMPION_LIST[0] == MONK.title:
                                bauble_damage = self.calculate_ai_damage(3, 2)
                                bauble_unavailable_check = 0
                                if monk_bauble_damage_list1[1] == 0:
                                    monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                else:
                                    if monk_bauble_damage_list2[1] == 0:
                                        monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list3[1] == 0:
                                            monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            bauble_unavailable_check = 1
                                monk_damage_taken = 0
                                if monk_bauble_damage_list1[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                if monk_bauble_damage_list2[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                if monk_bauble_damage_list3[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                if bauble_unavailable_check == 1:
                                    monk_damage_taken = monk_damage_taken + bauble_damage
                                champion3_hp = champion3_hp - math.ceil(monk_damage_taken)
                                champion3_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                if champion3_hp < 0:
                                    champion3_hp = 0
                            elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                ai_hit_fencer_range = random.randint(1, 100)
                                if ai_hit_fencer_range <= ai2_fencer_dodgechance:
                                    if AI_SIZE == "Tiny":
                                        champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 2, 0) * 0.5)
                                        champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 2, 1) * 0.5)
                                        self.apply_taunt(2, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Small":
                                        champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 2, 0) * 0.6)
                                        champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 2, 1) * 0.6)
                                        self.apply_taunt(2, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Medium":
                                        champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 2, 0) * 0.7)
                                        champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 2, 1) * 0.7)
                                        self.apply_taunt(2, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Large":
                                        champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 2, 0) * 0.8)
                                        champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 2, 1) * 0.8)
                                        self.apply_taunt(2, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Huge":
                                        champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 2, 0) * 0.9)
                                        champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 2, 1) * 0.9)
                                        self.apply_taunt(2, MASTER_FENCER.title, 1)
                                else:
                                    champion3_hp = champion3_hp - self.calculate_ai_damage(3, 2, 0)
                                    champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 2, 1))
                                    if champion3_hp < 0:
                                        champion3_hp = 0
                            else:
                                champion3_hp = champion3_hp - self.calculate_ai_damage(3, 2, 0)
                                champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 2, 1))
                                if champion3_hp < 0:
                                    champion3_hp = 0
                            if champion3_bush_armour != 0:
                                ai2_hp = ai2_hp - 200
                                self.apply_thornsDot(1, 2)
                            if ai2_hp < 0:
                                ai2_hp = 0
                        elif ai2_taunt[0] in CHAMPION_LIST[3]:
                            if len(champion4_immunity) != 0:
                                immune_list = []
                                for immune in champion4_immunity:
                                    if immune == "Cocoon":
                                        champion4_hp = champion4_hp
                                    elif immune == "Block":
                                        if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                            champion1_hp = champion1_hp - self.calculate_ai_damage(1, 2, 0)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 2, 1))
                                            if champion1_hp < 0:
                                                champion1_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                            champion2_hp = champion2_hp - self.calculate_ai_damage(2, 2, 0)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 2, 1))
                                            if champion2_hp < 0:
                                                champion2_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                            champion3_hp = champion3_hp - self.calculate_ai_damage(3, 2, 0)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 2, 1))
                                            if champion3_hp < 0:
                                                champion3_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                            champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 2, 0) * 0.5)
                                            champion4_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(4, 2, 1) * 0.5))
                                            if champion4_hp < 0:
                                                champion4_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                            champion5_hp = champion5_hp - self.calculate_ai_damage(5, 2, 0)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 2, 1))
                                            if champion5_hp < 0:
                                                champion5_hp = 0
                                    elif immune == "Evasive Manoeuvres":
                                        self.apply_taunt(2, MASTER_FENCER.title, 1)
                            elif CHAMPION_LIST[0] == MONK.title:
                                bauble_damage = self.calculate_ai_damage(4, 2, 0)
                                bauble_unavailable_check = 0
                                if monk_bauble_damage_list1[1] == 0:
                                    monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                else:
                                    if monk_bauble_damage_list2[1] == 0:
                                        monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list3[1] == 0:
                                            monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            bauble_unavailable_check = 1
                                monk_damage_taken = 0
                                if monk_bauble_damage_list1[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                if monk_bauble_damage_list2[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                if monk_bauble_damage_list3[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                if bauble_unavailable_check == 1:
                                    monk_damage_taken = monk_damage_taken + bauble_damage
                                champion4_hp = champion4_hp - math.ceil(monk_damage_taken)
                                champion4_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                if champion4_hp < 0:
                                    champion4_hp = 0
                            elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                ai_hit_fencer_range = random.randint(1, 100)
                                if ai_hit_fencer_range <= ai2_fencer_dodgechance:
                                    if AI_SIZE == "Tiny":
                                        champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 2, 0) * 0.5)
                                        champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 2, 1) * 0.5)
                                        self.apply_taunt(2, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Small":
                                        champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 2, 0) * 0.6)
                                        champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 2, 1) * 0.6)
                                        self.apply_taunt(2, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Medium":
                                        champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 2, 0) * 0.7)
                                        champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 2, 1) * 0.7)
                                        self.apply_taunt(2, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Large":
                                        champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 2, 0) * 0.8)
                                        champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 2, 1) * 0.8)
                                        self.apply_taunt(2, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Huge":
                                        champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 2, 0) * 0.9)
                                        champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 2, 1) * 0.9)
                                        self.apply_taunt(2, MASTER_FENCER.title, 1)
                                else:
                                    champion4_hp = champion4_hp - self.calculate_ai_damage(4, 2, 0)
                                    champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 2, 1))
                                    if champion4_hp < 0:
                                        champion4_hp = 0
                            else:
                                champion4_hp = champion4_hp - self.calculate_ai_damage(4, 2, 0)
                                champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 2, 1))
                                if champion4_hp < 0:
                                    champion4_hp = 0
                            if champion4_bush_armour != 0:
                                ai2_hp = ai2_hp - 200
                                self.apply_thornsDot(1, 2)
                            if ai2_hp < 0:
                                ai2_hp = 0
                        elif ai2_taunt[0] in CHAMPION_LIST[4]:
                            if len(champion5_immunity) != 0:
                                immune_list = []
                                for immune in champion5_immunity:
                                    if immune == "Cocoon":
                                        champion5_hp = champion5_hp
                                    elif immune == "Block":
                                        if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                            champion1_hp = champion1_hp - self.calculate_ai_damage(1, 2, 0)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 2, 1))
                                            if champion1_hp < 0:
                                                champion1_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                            champion2_hp = champion2_hp - self.calculate_ai_damage(2, 2, 0)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 2, 1))
                                            if champion2_hp < 0:
                                                champion2_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                            champion3_hp = champion3_hp - self.calculate_ai_damage(3, 2, 0)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 2, 1))
                                            if champion3_hp < 0:
                                                champion3_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                            champion4_hp = champion4_hp - self.calculate_ai_damage(4, 2, 0)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 2, 1))
                                            if champion4_hp < 0:
                                                champion4_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                            champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 2, 0) * 0.5)
                                            champion5_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(5, 2, 0) * 0.5))
                                            if champion5_hp < 0:
                                                champion5_hp = 0
                                    elif immune == "Evasive Manoeuvres":
                                        self.apply_taunt(2, MASTER_FENCER.title, 1)
                            elif CHAMPION_LIST[0] == MONK.title:
                                bauble_damage = self.calculate_ai_damage(5, 2, 0)
                                bauble_unavailable_check = 0
                                if monk_bauble_damage_list1[1] == 0:
                                    monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                else:
                                    if monk_bauble_damage_list2[1] == 0:
                                        monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list3[1] == 0:
                                            monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            bauble_unavailable_check = 1
                                monk_damage_taken = 0
                                if monk_bauble_damage_list1[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                if monk_bauble_damage_list2[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                if monk_bauble_damage_list3[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                if bauble_unavailable_check == 1:
                                    monk_damage_taken = monk_damage_taken + bauble_damage
                                champion5_hp = champion5_hp - math.ceil(monk_damage_taken)
                                champion5_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                if champion5_hp < 0:
                                    champion5_hp = 0
                            elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                ai_hit_fencer_range = random.randint(1, 100)
                                if ai_hit_fencer_range <= ai2_fencer_dodgechance:
                                    if AI_SIZE == "Tiny":
                                        champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 2, 0) * 0.5)
                                        champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 2, 1) * 0.5)
                                        self.apply_taunt(2, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Small":
                                        champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 2, 0) * 0.6)
                                        champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 2, 1) * 0.6)
                                        self.apply_taunt(2, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Medium":
                                        champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 2, 0) * 0.7)
                                        champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 2, 1) * 0.7)
                                        self.apply_taunt(2, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Large":
                                        champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 2, 0) * 0.8)
                                        champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 2, 1) * 0.8)
                                        self.apply_taunt(2, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Huge":
                                        champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 2, 0) * 0.9)
                                        champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 2, 1) * 0.9)
                                        self.apply_taunt(2, MASTER_FENCER.title, 1)
                                else:
                                    champion5_hp = champion5_hp - self.calculate_ai_damage(5, 2, 0)
                                    champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 2, 1))
                                    if champion5_hp < 0:
                                        champion5_hp = 0
                            else:
                                champion5_hp = champion5_hp - self.calculate_ai_damage(5, 2, 0)
                                champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 2, 1))
                                if champion5_hp < 0:
                                    champion5_hp = 0
                            if champion5_bush_armour != 0:
                                ai2_hp = ai2_hp - 200
                                self.apply_thornsDot(1, 2)
                            if ai2_hp < 0:
                                ai2_hp = 0
                    else:
                        if "Everyone" in ai2_attack_intention:
                            if champion1_hp != 0:
                                if len(champion1_immunity) != 0:
                                    immune_list = []
                                    for immune in champion1_immunity:
                                        if immune == "Cocoon":
                                            champion1_hp = champion1_hp
                                        elif immune == "Block":
                                            if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                                champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 2, 0) * 0.5)
                                                champion1_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(1, 2, 1) * 0.5))
                                                if champion1_hp < 0:
                                                    champion1_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                                champion2_hp = champion2_hp - self.calculate_ai_damage(2, 2, 0)
                                                champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 2, 1))
                                                if champion2_hp < 0:
                                                    champion2_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                                champion3_hp = champion3_hp - self.calculate_ai_damage(3, 2, 0)
                                                champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 2, 1))
                                                if champion3_hp < 0:
                                                    champion3_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                                champion4_hp = champion4_hp - self.calculate_ai_damage(4, 2, 0)
                                                champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 2, 1))
                                                if champion4_hp < 0:
                                                    champion4_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                                champion5_hp = champion5_hp - self.calculate_ai_damage(5, 2, 0)
                                                champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 2, 1))
                                                if champion5_hp < 0:
                                                    champion5_hp = 0
                                        elif immune == "Evasive Manoeuvres":
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                elif CHAMPION_LIST[0] == MONK.title:
                                    bauble_damage = self.calculate_ai_damage(1, 2, 0)
                                    bauble_unavailable_check = 0
                                    if monk_bauble_damage_list1[1] == 0:
                                        monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list2[1] == 0:
                                            monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            if monk_bauble_damage_list3[1] == 0:
                                                monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                            else:
                                                bauble_unavailable_check = 1
                                    monk_damage_taken = 0
                                    if monk_bauble_damage_list1[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                    if monk_bauble_damage_list2[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                    if monk_bauble_damage_list3[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                    if bauble_unavailable_check == 1:
                                        monk_damage_taken = monk_damage_taken + bauble_damage
                                    champion1_hp = champion1_hp - math.ceil(monk_damage_taken)
                                    champion1_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                    if champion1_hp < 0:
                                        champion1_hp = 0
                                elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                    ai_hit_fencer_range = random.randint(1, 100)
                                    if ai_hit_fencer_range <= ai2_fencer_dodgechance:
                                        if AI_SIZE == "Tiny":
                                            champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 2, 0) * 0.5)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 2, 1) * 0.5)
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Small":
                                            champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 2, 0) * 0.6)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 2, 1) * 0.6)
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Medium":
                                            champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 2, 0) * 0.7)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 2, 1) * 0.7)
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Large":
                                            champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 2, 0) * 0.8)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 2, 1) * 0.8)
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Huge":
                                            champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 2, 0) * 0.9)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 2, 1) * 0.9)
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                    else:
                                        champion1_hp = champion1_hp - self.calculate_ai_damage(1, 2, 0)
                                        champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 2, 1))
                                        if champion1_hp < 0:
                                            champion1_hp = 0
                                elif CHAMPION_LIST[0] == POWER_CONDUIT.title:
                                    champion1_hp = champion1_hp - self.calculate_ai_damage(1, 2, 0)
                                    champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 2, 1))
                                    if champion1_hp < 0:
                                        champion1_hp = 0
                                    ai2_hp = ai2_hp - 750
                                    if ai2_hp < 0:
                                        ai2_hp = 0
                                elif CHAMPION_LIST[0] == ACADEMIC_MAGE.title:
                                    mage_damage_taken = math.ceil(self.calculate_ai_damage(1, 2, 0) - champion1_magical_barrier)
                                    if mage_damage_taken < 0:
                                        champion1_magical_barrier = mage_damage_taken * -1
                                    else:
                                        champion1_magical_barrier = 0
                                        champion1_hp = champion1_hp - mage_damage_taken
                                        champion1_lastRoundDamageTaken_list.append(mage_damage_taken)
                                        if champion1_hp < 0:
                                            champion1_hp = 0
                                else:
                                    champion1_hp = champion1_hp - self.calculate_ai_damage(1, 2, 0)
                                    champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 2, 1))
                                    if champion1_hp < 0:
                                        champion1_hp = 0
                                if champion1_bush_armour != 0:
                                    ai2_hp = ai2_hp - 200
                                    self.apply_thornsDot(2, 1)
                                if ai2_hp < 0:
                                    ai2_hp = 0
                            if champion2_hp != 0:
                                if len(champion2_immunity) != 0:
                                    immune_list = []
                                    for immune in champion2_immunity:
                                        if immune == "Cocoon":
                                            champion2_hp = champion2_hp
                                        elif immune == "Block":
                                            if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                                champion1_hp = champion1_hp - self.calculate_ai_damage(1, 2, 0)
                                                champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 2, 1))
                                                if champion1_hp < 0:
                                                    champion1_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                                champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 2, 0) * 0.5)
                                                champion2_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(2, 2, 1) * 0.5))
                                                if champion2_hp < 0:
                                                    champion2_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                                champion3_hp = champion3_hp - self.calculate_ai_damage(3, 2, 0)
                                                champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 2, 1))
                                                if champion3_hp < 0:
                                                    champion3_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                                champion4_hp = champion4_hp - self.calculate_ai_damage(4, 2, 0)
                                                champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 2, 1))
                                                if champion4_hp < 0:
                                                    champion4_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                                champion5_hp = champion5_hp - self.calculate_ai_damage(5, 2, 0)
                                                champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 2, 1))
                                                if champion5_hp < 0:
                                                    champion5_hp = 0
                                        elif immune == "Evasive Manoeuvres":
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                elif CHAMPION_LIST[0] == MONK.title:
                                    bauble_damage = self.calculate_ai_damage(2, 2, 0)
                                    bauble_unavailable_check = 0
                                    if monk_bauble_damage_list1[1] == 0:
                                        monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list2[1] == 0:
                                            monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            if monk_bauble_damage_list3[1] == 0:
                                                monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                            else:
                                                bauble_unavailable_check = 1
                                    monk_damage_taken = 0
                                    if monk_bauble_damage_list1[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                    if monk_bauble_damage_list2[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                    if monk_bauble_damage_list3[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                    if bauble_unavailable_check == 1:
                                        monk_damage_taken = monk_damage_taken + bauble_damage
                                    champion2_hp = champion2_hp - math.ceil(monk_damage_taken)
                                    champion2_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                    if champion2_hp < 0:
                                        champion2_hp = 0
                                elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                    ai_hit_fencer_range = random.randint(1, 100)
                                    if ai_hit_fencer_range <= ai2_fencer_dodgechance:
                                        if AI_SIZE == "Tiny":
                                            champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 2, 0) * 0.5)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 2, 1) * 0.5)
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Small":
                                            champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 2, 0) * 0.6)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 2, 1) * 0.6)
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Medium":
                                            champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 2, 0) * 0.7)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 2, 1) * 0.7)
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Large":
                                            champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 2, 0) * 0.8)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 2, 1) * 0.8)
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Huge":
                                            champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 2, 0) * 0.9)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 2, 1) * 0.9)
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                    else:
                                        champion2_hp = champion2_hp - self.calculate_ai_damage(2, 2, 0)
                                        champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 2, 1))
                                        if champion2_hp < 0:
                                            champion2_hp = 0
                                elif CHAMPION_LIST[0] == POWER_CONDUIT.title:
                                    champion2_hp = champion2_hp - self.calculate_ai_damage(2, 2, 0)
                                    champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 2, 1))
                                    if champion2_hp < 0:
                                        champion2_hp = 0
                                    ai2_hp = ai2_hp - 750
                                    if ai2_hp < 0:
                                        ai2_hp = 0
                                elif CHAMPION_LIST[0] == ACADEMIC_MAGE.title:
                                    mage_damage_taken = math.ceil(self.calculate_ai_damage(2, 2, 0) - champion2_magical_barrier)
                                    if mage_damage_taken < 0:
                                        champion2_magical_barrier = mage_damage_taken * -1
                                    else:
                                        champion2_magical_barrier = 0
                                        champion2_hp = champion2_hp - mage_damage_taken
                                        champion2_lastRoundDamageTaken_list.append(mage_damage_taken)
                                        if champion2_hp < 0:
                                            champion2_hp = 0
                                else:
                                    champion2_hp = champion2_hp - self.calculate_ai_damage(2, 2, 0)
                                    champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 2, 1))
                                    if champion2_hp < 0:
                                        champion2_hp = 0
                                if champion2_bush_armour != 0:
                                    ai2_hp = ai2_hp - 200
                                    self.apply_thornsDot(2, 1)
                                if ai2_hp < 0:
                                    ai2_hp = 0
                            if champion3_hp != 0:
                                if len(champion3_immunity) != 0:
                                    immune_list = []
                                    for immune in champion3_immunity:
                                        if immune == "Cocoon":
                                            champion3_hp = champion3_hp
                                        elif immune == "Block":
                                            if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                                champion1_hp = champion1_hp - self.calculate_ai_damage(1, 2, 0)
                                                champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 2, 1))
                                                if champion1_hp < 0:
                                                    champion1_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                                champion2_hp = champion2_hp - self.calculate_ai_damage(2, 2, 0)
                                                champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 2, 1))
                                                if champion2_hp < 0:
                                                    champion2_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                                champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 2, 0) * 0.5)
                                                champion3_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(3, 2, 1) * 0.5))
                                                if champion3_hp < 0:
                                                    champion3_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                                champion4_hp = champion4_hp - self.calculate_ai_damage(4, 2, 0)
                                                champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 2, 1))
                                                if champion4_hp < 0:
                                                    champion4_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                                champion5_hp = champion5_hp - self.calculate_ai_damage(5, 2, 0)
                                                champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 2, 1))
                                                if champion5_hp < 0:
                                                    champion5_hp = 0
                                        elif immune == "Evasive Manoeuvres":
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                elif CHAMPION_LIST[0] == MONK.title:
                                    bauble_damage = self.calculate_ai_damage(3, 2, 0)
                                    bauble_unavailable_check = 0
                                    if monk_bauble_damage_list1[1] == 0:
                                        monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list2[1] == 0:
                                            monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            if monk_bauble_damage_list3[1] == 0:
                                                monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                            else:
                                                bauble_unavailable_check = 1
                                    monk_damage_taken = 0
                                    if monk_bauble_damage_list1[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                    if monk_bauble_damage_list2[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                    if monk_bauble_damage_list3[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                    if bauble_unavailable_check == 1:
                                        monk_damage_taken = monk_damage_taken + bauble_damage
                                    champion3_hp = champion3_hp - math.ceil(monk_damage_taken)
                                    champion3_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                    if champion3_hp < 0:
                                        champion3_hp = 0
                                elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                    ai_hit_fencer_range = random.randint(1, 100)
                                    if ai_hit_fencer_range <= ai2_fencer_dodgechance:
                                        if AI_SIZE == "Tiny":
                                            champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 2, 0) * 0.5)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 2, 1) * 0.5)
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Small":
                                            champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 2, 0) * 0.6)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 2, 1) * 0.6)
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Medium":
                                            champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 2, 0) * 0.7)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 2, 1) * 0.7)
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Large":
                                            champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 2, 0) * 0.8)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 2, 1) * 0.8)
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Huge":
                                            champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 2, 0) * 0.9)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 2, 1) * 0.9)
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                    else:
                                        champion3_hp = champion3_hp - self.calculate_ai_damage(3, 2, 0)
                                        champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 2, 1))
                                        if champion3_hp < 0:
                                            champion3_hp = 0
                                elif CHAMPION_LIST[0] == POWER_CONDUIT.title:
                                    champion3_hp = champion3_hp - self.calculate_ai_damage(3, 2, 0)
                                    champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 2, 1))
                                    if champion3_hp < 0:
                                        champion3_hp = 0
                                    ai2_hp = ai2_hp - 750
                                    if ai2_hp < 0:
                                        ai2_hp = 0
                                elif CHAMPION_LIST[0] == ACADEMIC_MAGE.title:
                                    mage_damage_taken = math.ceil(self.calculate_ai_damage(3, 2, 0) - champion3_magical_barrier)
                                    if mage_damage_taken < 0:
                                        champion3_magical_barrier = mage_damage_taken * -1
                                    else:
                                        champion3_magical_barrier = 0
                                        champion3_hp = champion3_hp - mage_damage_taken
                                        champion3_lastRoundDamageTaken_list.append(mage_damage_taken)
                                        if champion3_hp < 0:
                                            champion3_hp = 0
                                else:
                                    champion3_hp = champion3_hp - self.calculate_ai_damage(3, 2, 0)
                                    champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 2, 1))
                                    if champion3_hp < 0:
                                        champion3_hp = 0
                                if champion3_bush_armour != 0:
                                    ai2_hp = ai2_hp - 200
                                    self.apply_thornsDot(2, 1)
                                if ai2_hp < 0:
                                    ai2_hp = 0
                            if champion4_hp != 0:
                                if len(champion4_immunity) != 0:
                                    immune_list = []
                                    for immune in champion4_immunity:
                                        if immune == "Cocoon":
                                            champion4_hp = champion4_hp
                                        elif immune == "Block":
                                            if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                                champion1_hp = champion1_hp - self.calculate_ai_damage(1, 2, 0)
                                                champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 2, 1))
                                                if champion1_hp < 0:
                                                    champion1_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                                champion2_hp = champion2_hp - self.calculate_ai_damage(2, 2, 0)
                                                champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 2, 1))
                                                if champion2_hp < 0:
                                                    champion2_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                                champion3_hp = champion3_hp - self.calculate_ai_damage(3, 2, 0)
                                                champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 2, 1))
                                                if champion3_hp < 0:
                                                    champion3_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                                champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 2, 0) * 0.5)
                                                champion4_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(4, 2, 1) * 0.5))
                                                if champion4_hp < 0:
                                                    champion4_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                                champion5_hp = champion5_hp - self.calculate_ai_damage(5, 2, 0)
                                                champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 2, 1))
                                                if champion5_hp < 0:
                                                    champion5_hp = 0
                                        elif immune == "Evasive Manoeuvres":
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                elif CHAMPION_LIST[0] == MONK.title:
                                    bauble_damage = self.calculate_ai_damage(4, 2, 0)
                                    bauble_unavailable_check = 0
                                    if monk_bauble_damage_list1[1] == 0:
                                        monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list2[1] == 0:
                                            monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            if monk_bauble_damage_list3[1] == 0:
                                                monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                            else:
                                                bauble_unavailable_check = 1
                                    monk_damage_taken = 0
                                    if monk_bauble_damage_list1[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                    if monk_bauble_damage_list2[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                    if monk_bauble_damage_list3[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                    if bauble_unavailable_check == 1:
                                        monk_damage_taken = monk_damage_taken + bauble_damage
                                    champion4_hp = champion4_hp - math.ceil(monk_damage_taken)
                                    champion4_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                    if champion4_hp < 0:
                                        champion4_hp = 0
                                elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                    ai_hit_fencer_range = random.randint(1, 100)
                                    if ai_hit_fencer_range <= ai2_fencer_dodgechance:
                                        if AI_SIZE == "Tiny":
                                            champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 2, 0) * 0.5)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 2, 1) * 0.5)
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Small":
                                            champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 2, 0) * 0.6)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 2, 1) * 0.6)
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Medium":
                                            champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 2, 0) * 0.7)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 2, 1) * 0.7)
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Large":
                                            champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 2, 0) * 0.8)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 2, 1) * 0.8)
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Huge":
                                            champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 2, 0) * 0.9)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 2, 1) * 0.9)
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                    else:
                                        champion4_hp = champion4_hp - self.calculate_ai_damage(4, 2, 0)
                                        champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 2, 1))
                                        if champion4_hp < 0:
                                            champion4_hp = 0
                                elif CHAMPION_LIST[0] == POWER_CONDUIT.title:
                                    champion4_hp = champion4_hp - self.calculate_ai_damage(4, 2, 0)
                                    champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 2, 1))
                                    if champion4_hp < 0:
                                        champion4_hp = 0
                                    ai2_hp = ai2_hp - 750
                                    if ai2_hp < 0:
                                        ai2_hp = 0
                                elif CHAMPION_LIST[0] == ACADEMIC_MAGE.title:
                                    mage_damage_taken = math.ceil(self.calculate_ai_damage(4, 2, 0) - champion4_magical_barrier)
                                    if mage_damage_taken < 0:
                                        champion4_magical_barrier = mage_damage_taken * -1
                                    else:
                                        champion4_magical_barrier = 0
                                        champion4_hp = champion4_hp - mage_damage_taken
                                        champion4_lastRoundDamageTaken_list.append(mage_damage_taken)
                                        if champion4_hp < 0:
                                            champion4_hp = 0
                                else:
                                    champion4_hp = champion4_hp - self.calculate_ai_damage(4, 2, 0)
                                    champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 2, 1))
                                    if champion4_hp < 0:
                                        champion4_hp = 0
                                if champion4_bush_armour != 0:
                                    ai2_hp = ai2_hp - 200
                                    self.apply_thornsDot(2, 1)
                                if ai2_hp < 0:
                                    ai2_hp = 0
                            if champion5_hp != 0:
                                if len(champion5_immunity) != 0:
                                    immune_list = []
                                    for immune in champion5_immunity:
                                        if immune == "Cocoon":
                                            champion5_hp = champion5_hp
                                        elif immune == "Block":
                                            if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                                champion1_hp = champion1_hp - self.calculate_ai_damage(1, 2, 0)
                                                champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 2, 1))
                                                if champion1_hp < 0:
                                                    champion1_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                                champion2_hp = champion2_hp - self.calculate_ai_damage(2, 2, 0)
                                                champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 2, 1))
                                                if champion2_hp < 0:
                                                    champion2_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                                champion3_hp = champion3_hp - self.calculate_ai_damage(3, 2, 0)
                                                champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 2, 1))
                                                if champion3_hp < 0:
                                                    champion3_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                                champion4_hp = champion4_hp - self.calculate_ai_damage(4, 2, 0)
                                                champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 2, 1))
                                                if champion4_hp < 0:
                                                    champion4_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                                champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 2, 0) * 0.5)
                                                champion5_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(5, 2, 1) * 0.5))
                                                if champion5_hp < 0:
                                                    champion5_hp = 0
                                        elif immune == "Evasive Manoeuvres":
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                elif CHAMPION_LIST[0] == MONK.title:
                                    bauble_damage = self.calculate_ai_damage(5, 2, 0)
                                    bauble_unavailable_check = 0
                                    if monk_bauble_damage_list1[1] == 0:
                                        monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list2[1] == 0:
                                            monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            if monk_bauble_damage_list3[1] == 0:
                                                monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                            else:
                                                bauble_unavailable_check = 1
                                    monk_damage_taken = 0
                                    if monk_bauble_damage_list1[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                    if monk_bauble_damage_list2[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                    if monk_bauble_damage_list3[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                    if bauble_unavailable_check == 1:
                                        monk_damage_taken = monk_damage_taken + bauble_damage
                                    champion5_hp = champion5_hp - math.ceil(monk_damage_taken)
                                    champion5_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                    if champion5_hp < 0:
                                        champion5_hp = 0
                                elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                    ai_hit_fencer_range = random.randint(1, 100)
                                    if ai_hit_fencer_range <= ai2_fencer_dodgechance:
                                        if AI_SIZE == "Tiny":
                                            champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 2, 0) * 0.5)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 2, 1) * 0.5)
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Small":
                                            champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 2, 0) * 0.6)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 2, 1) * 0.6)
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Medium":
                                            champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 2, 0) * 0.7)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 2, 1) * 0.7)
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Large":
                                            champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 2, 0) * 0.8)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 2, 1) * 0.8)
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Huge":
                                            champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 2, 0) * 0.9)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 2, 1) * 0.9)
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                    else:
                                        champion5_hp = champion5_hp - self.calculate_ai_damage(5, 2, 0)
                                        champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 2, 1))
                                        if champion5_hp < 0:
                                            champion5_hp = 0
                                elif CHAMPION_LIST[0] == POWER_CONDUIT.title:
                                    champion5_hp = champion5_hp - self.calculate_ai_damage(5, 2, 0)
                                    champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 2, 1))
                                    if champion5_hp < 0:
                                        champion5_hp = 0
                                    ai2_hp = ai2_hp - 750
                                    if ai2_hp < 0:
                                        ai2_hp = 0
                                elif CHAMPION_LIST[0] == ACADEMIC_MAGE.title:
                                    mage_damage_taken = math.ceil(self.calculate_ai_damage(5, 2, 0) - champion5_magical_barrier)
                                    if mage_damage_taken < 0:
                                        champion5_magical_barrier = mage_damage_taken * -1
                                    else:
                                        champion5_magical_barrier = 0
                                        champion5_hp = champion5_hp - mage_damage_taken
                                        champion5_lastRoundDamageTaken_list.append(mage_damage_taken)
                                        if champion5_hp < 0:
                                            champion5_hp = 0
                                else:
                                    champion5_hp = champion5_hp - self.calculate_ai_damage(5, 2, 0)
                                    champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 2, 1))
                                    if champion5_hp < 0:
                                        champion5_hp = 0
                                if champion5_bush_armour != 0:
                                    ai2_hp = ai2_hp - 200
                                    self.apply_thornsDot(2, 1)
                                if ai2_hp < 0:
                                    ai2_hp = 0
                        else:
                            if CHAMPION_LIST[0] in ai2_attack_intention:
                                if len(champion1_immunity) != 0:
                                    immune_list = []
                                    for immune in champion1_immunity:
                                        if immune == "Cocoon":
                                            champion1_hp = champion1_hp
                                        elif immune == "Block":
                                            if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                                champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 2, 0) * 0.5)
                                                champion1_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(1, 2, 1) * 0.5))
                                                if champion1_hp < 0:
                                                    champion1_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                                champion2_hp = champion2_hp - self.calculate_ai_damage(2, 2, 0)
                                                champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 2, 1))
                                                if champion2_hp < 0:
                                                    champion2_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                                champion3_hp = champion3_hp - self.calculate_ai_damage(3, 2, 0)
                                                champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 2, 1))
                                                if champion3_hp < 0:
                                                    champion3_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                                champion4_hp = champion4_hp - self.calculate_ai_damage(4, 2, 0)
                                                champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 2, 1))
                                                if champion4_hp < 0:
                                                    champion4_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                                champion5_hp = champion5_hp - self.calculate_ai_damage(5, 2, 0)
                                                champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 2, 1))
                                                if champion5_hp < 0:
                                                    champion5_hp = 0
                                        elif immune == "Evasive Manoeuvres":
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                elif CHAMPION_LIST[0] == MONK.title:
                                    bauble_damage = self.calculate_ai_damage(1, 2, 0)
                                    bauble_unavailable_check = 0
                                    if monk_bauble_damage_list1[1] == 0:
                                        monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list2[1] == 0:
                                            monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            if monk_bauble_damage_list3[1] == 0:
                                                monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                            else:
                                                bauble_unavailable_check = 1
                                    monk_damage_taken = 0
                                    if monk_bauble_damage_list1[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                    if monk_bauble_damage_list2[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                    if monk_bauble_damage_list3[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                    if bauble_unavailable_check == 1:
                                        monk_damage_taken = monk_damage_taken + bauble_damage
                                    champion1_hp = champion1_hp - math.ceil(monk_damage_taken)
                                    champion1_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                    if champion1_hp < 0:
                                        champion1_hp = 0
                                elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                    ai_hit_fencer_range = random.randint(1, 100)
                                    if ai_hit_fencer_range <= ai2_fencer_dodgechance:
                                        if AI_SIZE == "Tiny":
                                            champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 2, 0) * 0.5)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 2, 1) * 0.5)
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Small":
                                            champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 2, 0) * 0.6)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 2, 1) * 0.6)
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Medium":
                                            champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 2, 0) * 0.7)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 2, 1) * 0.7)
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Large":
                                            champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 2, 0) * 0.8)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 2, 1) * 0.8)
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Huge":
                                            champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 2, 0) * 0.9)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 2, 1) * 0.9)
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                    else:
                                        champion1_hp = champion1_hp - self.calculate_ai_damage(1, 2, 0)
                                        champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 2, 1))
                                        if champion1_hp < 0:
                                            champion1_hp = 0
                                elif CHAMPION_LIST[0] == POWER_CONDUIT.title:
                                    champion1_hp = champion1_hp - self.calculate_ai_damage(1, 2, 0)
                                    champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 2, 1))
                                    if champion1_hp < 0:
                                        champion1_hp = 0
                                    ai2_hp = ai2_hp - 750
                                    if ai2_hp < 0:
                                        ai2_hp = 0
                                elif CHAMPION_LIST[0] == ACADEMIC_MAGE.title:
                                    mage_damage_taken = math.ceil(self.calculate_ai_damage(1, 2, 0) - champion1_magical_barrier)
                                    if mage_damage_taken < 0:
                                        champion1_magical_barrier = mage_damage_taken * -1
                                    else:
                                        champion1_magical_barrier = 0
                                        champion1_hp = champion1_hp - mage_damage_taken
                                        champion1_lastRoundDamageTaken_list.append(mage_damage_taken)
                                        if champion1_hp < 0:
                                            champion1_hp = 0
                                else:
                                    champion1_hp = champion1_hp - self.calculate_ai_damage(1, 2, 0)
                                    champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 2, 1))
                                    if champion1_hp < 0:
                                        champion1_hp = 0
                                if champion1_bush_armour != 0:
                                    ai2_hp = ai2_hp - 200
                                    self.apply_thornsDot(2, 1)
                                if ai2_hp < 0:
                                    ai2_hp = 0
                            if CHAMPION_LIST[1] in ai2_attack_intention:
                                if len(champion2_immunity) != 0:
                                    immune_list = []
                                    for immune in champion2_immunity:
                                        if immune == "Cocoon":
                                            champion2_hp = champion2_hp
                                        elif immune == "Block":
                                            if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                                champion1_hp = champion1_hp - self.calculate_ai_damage(1, 2, 0)
                                                champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 2, 1))
                                                if champion1_hp < 0:
                                                    champion1_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                                champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 2, 0) * 0.5)
                                                champion2_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(2, 2, 1) * 0.5))
                                                if champion2_hp < 0:
                                                    champion2_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                                champion3_hp = champion3_hp - self.calculate_ai_damage(3, 2, 0)
                                                champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 2, 1))
                                                if champion3_hp < 0:
                                                    champion3_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                                champion4_hp = champion4_hp - self.calculate_ai_damage(4, 2, 0)
                                                champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 2, 1))
                                                if champion4_hp < 0:
                                                    champion4_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                                champion5_hp = champion5_hp - self.calculate_ai_damage(5, 2, 0)
                                                champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 2, 1))
                                                if champion5_hp < 0:
                                                    champion5_hp = 0
                                        elif immune == "Evasive Manoeuvres":
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                elif CHAMPION_LIST[0] == MONK.title:
                                    bauble_damage = self.calculate_ai_damage(2, 2, 0)
                                    bauble_unavailable_check = 0
                                    if monk_bauble_damage_list1[1] == 0:
                                        monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list2[1] == 0:
                                            monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            if monk_bauble_damage_list3[1] == 0:
                                                monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                            else:
                                                bauble_unavailable_check = 1
                                    monk_damage_taken = 0
                                    if monk_bauble_damage_list1[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                    if monk_bauble_damage_list2[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                    if monk_bauble_damage_list3[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                    if bauble_unavailable_check == 1:
                                        monk_damage_taken = monk_damage_taken + bauble_damage
                                    champion2_hp = champion2_hp - math.ceil(monk_damage_taken)
                                    champion2_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                    if champion2_hp < 0:
                                        champion2_hp = 0
                                elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                    ai_hit_fencer_range = random.randint(1, 100)
                                    if ai_hit_fencer_range <= ai2_fencer_dodgechance:
                                        if AI_SIZE == "Tiny":
                                            champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 2, 0) * 0.5)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 2, 1) * 0.5)
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Small":
                                            champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 2, 0) * 0.6)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 2, 1) * 0.6)
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Medium":
                                            champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 2, 0) * 0.7)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 2, 1) * 0.7)
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Large":
                                            champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 2, 0) * 0.8)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 2, 1) * 0.8)
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Huge":
                                            champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 2, 0) * 0.9)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 2, 1) * 0.9)
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                    else:
                                        champion2_hp = champion2_hp - self.calculate_ai_damage(2, 2, 0)
                                        champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 2, 1))
                                        if champion2_hp < 0:
                                            champion2_hp = 0
                                elif CHAMPION_LIST[0] == POWER_CONDUIT.title:
                                    champion2_hp = champion2_hp - self.calculate_ai_damage(2, 2, 0)
                                    champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 2, 1))
                                    if champion2_hp < 0:
                                        champion2_hp = 0
                                    ai2_hp = ai2_hp - 750
                                    if ai2_hp < 0:
                                        ai2_hp = 0
                                elif CHAMPION_LIST[0] == ACADEMIC_MAGE.title:
                                    mage_damage_taken = math.ceil(self.calculate_ai_damage(2, 2, 0) - champion2_magical_barrier)
                                    if mage_damage_taken < 0:
                                        champion2_magical_barrier = mage_damage_taken * -1
                                    else:
                                        champion2_magical_barrier = 0
                                        champion2_hp = champion2_hp - mage_damage_taken
                                        champion2_lastRoundDamageTaken_list.append(mage_damage_taken)
                                        if champion2_hp < 0:
                                            champion2_hp = 0
                                else:
                                    champion2_hp = champion2_hp - self.calculate_ai_damage(2, 2, 0)
                                    champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 2, 1))
                                    if champion2_hp < 0:
                                        champion2_hp = 0
                                if champion2_bush_armour != 0:
                                    ai2_hp = ai2_hp - 200
                                    self.apply_thornsDot(2, 1)
                                if ai2_hp < 0:
                                    ai2_hp = 0
                            if CHAMPION_LIST[2] in ai2_attack_intention:
                                if len(champion3_immunity) != 0:
                                    immune_list = []
                                    for immune in champion3_immunity:
                                        if immune == "Cocoon":
                                            champion3_hp = champion3_hp
                                        elif immune == "Block":
                                            if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                                champion1_hp = champion1_hp - self.calculate_ai_damage(1, 2, 0)
                                                champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 2, 1))
                                                if champion1_hp < 0:
                                                    champion1_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                                champion2_hp = champion2_hp - self.calculate_ai_damage(2, 2, 0)
                                                champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 2, 1))
                                                if champion2_hp < 0:
                                                    champion2_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                                champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 2, 0) * 0.5)
                                                champion3_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(3, 2, 1) * 0.5))
                                                if champion3_hp < 0:
                                                    champion3_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                                champion4_hp = champion4_hp - self.calculate_ai_damage(4, 2, 0)
                                                champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 2, 1))
                                                if champion4_hp < 0:
                                                    champion4_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                                champion5_hp = champion5_hp - self.calculate_ai_damage(5, 2, 0)
                                                champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 2, 1))
                                                if champion5_hp < 0:
                                                    champion5_hp = 0
                                        elif immune == "Evasive Manoeuvres":
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                elif CHAMPION_LIST[0] == MONK.title:
                                    bauble_damage = self.calculate_ai_damage(3, 2, 0)
                                    bauble_unavailable_check = 0
                                    if monk_bauble_damage_list1[1] == 0:
                                        monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list2[1] == 0:
                                            monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            if monk_bauble_damage_list3[1] == 0:
                                                monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                            else:
                                                bauble_unavailable_check = 1
                                    monk_damage_taken = 0
                                    if monk_bauble_damage_list1[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                    if monk_bauble_damage_list2[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                    if monk_bauble_damage_list3[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                    if bauble_unavailable_check == 1:
                                        monk_damage_taken = monk_damage_taken + bauble_damage
                                    champion3_hp = champion3_hp - math.ceil(monk_damage_taken)
                                    champion3_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                    if champion3_hp < 0:
                                        champion3_hp = 0
                                elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                    ai_hit_fencer_range = random.randint(1, 100)
                                    if ai_hit_fencer_range <= ai2_fencer_dodgechance:
                                        if AI_SIZE == "Tiny":
                                            champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 2, 0) * 0.5)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 2, 1) * 0.5)
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Small":
                                            champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 2, 0) * 0.6)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 2, 1) * 0.6)
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Medium":
                                            champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 2, 0) * 0.7)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 2, 1) * 0.7)
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Large":
                                            champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 2, 0) * 0.8)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 2, 1) * 0.8)
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Huge":
                                            champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 2, 0) * 0.9)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 2, 1) * 0.9)
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                    else:
                                        champion3_hp = champion3_hp - self.calculate_ai_damage(3, 2, 0)
                                        champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 2, 1))
                                        if champion3_hp < 0:
                                            champion3_hp = 0
                                elif CHAMPION_LIST[0] == POWER_CONDUIT.title:
                                    champion3_hp = champion3_hp - self.calculate_ai_damage(3, 2, 0)
                                    champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 2, 1))
                                    if champion3_hp < 0:
                                        champion3_hp = 0
                                    ai2_hp = ai2_hp - 750
                                    if ai2_hp < 0:
                                        ai2_hp = 0
                                elif CHAMPION_LIST[0] == ACADEMIC_MAGE.title:
                                    mage_damage_taken = math.ceil(self.calculate_ai_damage(3, 2, 0) - champion3_magical_barrier)
                                    if mage_damage_taken < 0:
                                        champion3_magical_barrier = mage_damage_taken * -1
                                    else:
                                        champion3_magical_barrier = 0
                                        champion3_hp = champion3_hp - mage_damage_taken
                                        champion3_lastRoundDamageTaken_list.append(mage_damage_taken)
                                        if champion3_hp < 0:
                                            champion3_hp = 0
                                else:
                                    champion3_hp = champion3_hp - self.calculate_ai_damage(3, 2, 0)
                                    champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 2, 1))
                                    if champion3_hp < 0:
                                        champion3_hp = 0
                                if champion3_bush_armour != 0:
                                    ai2_hp = ai2_hp - 200
                                    self.apply_thornsDot(2, 1)
                                if ai2_hp < 0:
                                    ai2_hp = 0
                            if CHAMPION_LIST[3] in ai2_attack_intention:
                                if len(champion4_immunity) != 0:
                                    immune_list = []
                                    for immune in champion4_immunity:
                                        if immune == "Cocoon":
                                            champion4_hp = champion4_hp
                                        elif immune == "Block":
                                            if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                                champion1_hp = champion1_hp - self.calculate_ai_damage(1, 2, 0)
                                                champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 2, 1))
                                                if champion1_hp < 0:
                                                    champion1_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                                champion2_hp = champion2_hp - self.calculate_ai_damage(2, 2, 0)
                                                champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 2, 1))
                                                if champion2_hp < 0:
                                                    champion2_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                                champion3_hp = champion3_hp - self.calculate_ai_damage(3, 2, 0)
                                                champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 2, 1))
                                                if champion3_hp < 0:
                                                    champion3_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                                champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 2, 0) * 0.5)
                                                champion4_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(4, 2, 1) * 0.5))
                                                if champion4_hp < 0:
                                                    champion4_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                                champion5_hp = champion5_hp - self.calculate_ai_damage(5, 2, 0)
                                                champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 2, 1))
                                                if champion5_hp < 0:
                                                    champion5_hp = 0
                                        elif immune == "Evasive Manoeuvres":
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                elif CHAMPION_LIST[0] == MONK.title:
                                    bauble_damage = self.calculate_ai_damage(4, 2, 0)
                                    bauble_unavailable_check = 0
                                    if monk_bauble_damage_list1[1] == 0:
                                        monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list2[1] == 0:
                                            monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            if monk_bauble_damage_list3[1] == 0:
                                                monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                            else:
                                                bauble_unavailable_check = 1
                                    monk_damage_taken = 0
                                    if monk_bauble_damage_list1[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                    if monk_bauble_damage_list2[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                    if monk_bauble_damage_list3[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                    if bauble_unavailable_check == 1:
                                        monk_damage_taken = monk_damage_taken + bauble_damage
                                    champion4_hp = champion4_hp - math.ceil(monk_damage_taken)
                                    champion4_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                    if champion4_hp < 0:
                                        champion4_hp = 0
                                elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                    ai_hit_fencer_range = random.randint(1, 100)
                                    if ai_hit_fencer_range <= ai2_fencer_dodgechance:
                                        if AI_SIZE == "Tiny":
                                            champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 2, 0) * 0.5)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 2, 1) * 0.5)
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Small":
                                            champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 2, 0) * 0.6)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 2, 1) * 0.6)
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Medium":
                                            champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 2, 0) * 0.7)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 2, 1) * 0.7)
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Large":
                                            champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 2, 0) * 0.8)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 2, 1) * 0.8)
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Huge":
                                            champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 2, 0) * 0.9)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 2, 1) * 0.9)
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                    else:
                                        champion4_hp = champion4_hp - self.calculate_ai_damage(4, 2, 0)
                                        champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 2, 1))
                                        if champion4_hp < 0:
                                            champion4_hp = 0
                                elif CHAMPION_LIST[0] == POWER_CONDUIT.title:
                                    champion4_hp = champion4_hp - self.calculate_ai_damage(4, 2, 0)
                                    champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 2, 1))
                                    if champion4_hp < 0:
                                        champion4_hp = 0
                                    ai2_hp = ai2_hp - 750
                                    if ai2_hp < 0:
                                        ai2_hp = 0
                                elif CHAMPION_LIST[0] == ACADEMIC_MAGE.title:
                                    mage_damage_taken = math.ceil(self.calculate_ai_damage(4, 2, 0) - champion4_magical_barrier)
                                    if mage_damage_taken < 0:
                                        champion4_magical_barrier = mage_damage_taken * -1
                                    else:
                                        champion4_magical_barrier = 0
                                        champion4_hp = champion4_hp - mage_damage_taken
                                        champion4_lastRoundDamageTaken_list.append(mage_damage_taken)
                                        if champion4_hp < 0:
                                            champion4_hp = 0
                                else:
                                    champion4_hp = champion4_hp - self.calculate_ai_damage(4, 2, 0)
                                    champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 2, 1))
                                    if champion4_hp < 0:
                                        champion4_hp = 0
                                if champion4_bush_armour != 0:
                                    ai2_hp = ai2_hp - 200
                                    self.apply_thornsDot(2, 1)
                                if ai2_hp < 0:
                                    ai2_hp = 0
                            if CHAMPION_LIST[4] in ai2_attack_intention:
                                if len(champion5_immunity) != 0:
                                    immune_list = []
                                    for immune in champion5_immunity:
                                        if immune == "Cocoon":
                                            champion5_hp = champion5_hp
                                        elif immune == "Block":
                                            if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                                champion1_hp = champion1_hp - self.calculate_ai_damage(1, 2, 0)
                                                champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 2, 1))
                                                if champion1_hp < 0:
                                                    champion1_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                                champion2_hp = champion2_hp - self.calculate_ai_damage(2, 2, 0)
                                                champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 2, 1))
                                                if champion2_hp < 0:
                                                    champion2_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                                champion3_hp = champion3_hp - self.calculate_ai_damage(3, 2, 0)
                                                champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 2, 1))
                                                if champion3_hp < 0:
                                                    champion3_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                                champion4_hp = champion4_hp - self.calculate_ai_damage(4, 2, 0)
                                                champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 2, 1))
                                                if champion4_hp < 0:
                                                    champion4_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                                champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 2, 0) * 0.5)
                                                champion5_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(5, 2, 1) * 0.5))
                                                if champion5_hp < 0:
                                                    champion5_hp = 0
                                        elif immune == "Evasive Manoeuvres":
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                elif CHAMPION_LIST[0] == MONK.title:
                                    bauble_damage = self.calculate_ai_damage(5, 2, 0)
                                    bauble_unavailable_check = 0
                                    if monk_bauble_damage_list1[1] == 0:
                                        monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list2[1] == 0:
                                            monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            if monk_bauble_damage_list3[1] == 0:
                                                monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                            else:
                                                bauble_unavailable_check = 1
                                    monk_damage_taken = 0
                                    if monk_bauble_damage_list1[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                    if monk_bauble_damage_list2[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                    if monk_bauble_damage_list3[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                    if bauble_unavailable_check == 1:
                                        monk_damage_taken = monk_damage_taken + bauble_damage
                                    champion5_hp = champion5_hp - math.ceil(monk_damage_taken)
                                    champion5_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                    if champion5_hp < 0:
                                        champion5_hp = 0
                                elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                    ai_hit_fencer_range = random.randint(1, 100)
                                    if ai_hit_fencer_range <= ai2_fencer_dodgechance:
                                        if AI_SIZE == "Tiny":
                                            champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 2, 0) * 0.5)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 2, 1) * 0.5)
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Small":
                                            champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 2, 0) * 0.6)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 2, 1) * 0.6)
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Medium":
                                            champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 2, 0) * 0.7)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 2, 1) * 0.7)
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Large":
                                            champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 2, 0) * 0.8)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 2, 1) * 0.8)
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Huge":
                                            champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 2, 0) * 0.9)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 2, 1) * 0.9)
                                            self.apply_taunt(2, MASTER_FENCER.title, 1)
                                    else:
                                        champion5_hp = champion5_hp - self.calculate_ai_damage(5, 2, 0)
                                        champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 2, 1))
                                        if champion5_hp < 0:
                                            champion5_hp = 0
                                elif CHAMPION_LIST[0] == POWER_CONDUIT.title:
                                    champion5_hp = champion5_hp - self.calculate_ai_damage(5, 2, 0)
                                    champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 2, 1))
                                    if champion5_hp < 0:
                                        champion5_hp = 0
                                    ai2_hp = ai2_hp - 750
                                    if ai2_hp < 0:
                                        ai2_hp = 0
                                elif CHAMPION_LIST[0] == ACADEMIC_MAGE.title:
                                    mage_damage_taken = math.ceil(self.calculate_ai_damage(5, 2, 0) - champion5_magical_barrier)
                                    if mage_damage_taken < 0:
                                        champion5_magical_barrier = mage_damage_taken * -1
                                    else:
                                        champion5_magical_barrier = 0
                                        champion5_hp = champion5_hp - mage_damage_taken
                                        champion5_lastRoundDamageTaken_list.append(mage_damage_taken)
                                        if champion5_hp < 0:
                                            champion5_hp = 0
                                else:
                                    champion5_hp = champion5_hp - self.calculate_ai_damage(5, 2, 0)
                                    champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 2, 1))
                                    if champion5_hp < 0:
                                        champion5_hp = 0
                                if champion5_bush_armour != 0:
                                    ai2_hp = ai2_hp - 200
                                    self.apply_thornsDot(2, 1)
                                if ai2_hp < 0:
                                    ai2_hp = 0
                if monster_var == 3:
                    if ai3_hp == 0:
                        continue
                    if ai3_thornsDot[1] != 0:
                        ai3_hp = ai3_hp - ai3_thornsDot[0] * ai3_thornsDot[1]
                        if ai3_hp < 0:
                            ai3_hp = 0
                            continue
                    if ai3_burnDot[1] != 0:
                        ai3_hp = ai3_hp - ai3_burnDot[0]
                        ai3_burnDot[1] = ai3_burnDot[1] - 1
                        if ai3_hp < 0:
                            ai3_hp = 0
                            continue
                    if ai3_serraSlashDot[1] != 0:
                        ai3_hp = ai3_hp - self.calculate_bleed_damage("Serrated", 3)
                        ai3_serraSlashDot[1] = ai3_serraSlashDot[1] - 1
                        if ai3_hp < 0:
                            ai3_hp = 0
                            continue
                    if ai3_eviscerDot[1] != 0:
                        ai3_hp = ai3_hp - self.calculate_bleed_damage("Eviscerated", 3)
                        ai3_eviscerDot[1] = ai3_eviscerDot[1] - 1
                        if ai3_hp < 0:
                            ai3_hp = 0
                            continue
                    if ai3_garroteDot[1] != 0:
                        ai3_hp = ai3_hp - self.calculate_bleed_damage("Garroted", 3)
                        ai3_garroteDot[1] = ai3_garroteDot[1] - 1
                        if ai3_hp < 0:
                            ai3_hp = 0
                            continue
                    if ai3_rottingDot[1] != 0:
                        ai3_hp = ai3_hp - ai3_rottingDot[0]
                        self.apply_toc(3)
                        ai3_rottingDot[1] = ai3_rottingDot[1] - 1
                        if ai3_hp < 0:
                            ai3_hp = 0
                            continue
                    if ai3_shimmerDot[1] != 0:
                        ai3_hp = ai3_hp - ai3_shimmerDot[0]
                        ai3_shimmerDot[1] = ai3_shimmerDot[1] - 1
                        if champion1_hp > 0:
                            self.check_champion_blessing(1, ai3_shimmerDot[0])
                        if champion2_hp > 0:
                            self.check_champion_blessing(2, ai3_shimmerDot[0])
                        if champion3_hp > 0:
                            self.check_champion_blessing(3, ai3_shimmerDot[0])
                        if champion4_hp > 0:
                            self.check_champion_blessing(4, ai3_shimmerDot[0])
                        if champion5_hp > 0:
                            self.check_champion_blessing(5, ai3_shimmerDot[0])
                        if ai3_hp < 0:
                            ai3_hp = 0
                            continue
                    if ai3_divineDot[1] != 0:
                        ai3_hp = ai3_hp - ai3_divineDot[0]
                        ai3_divineDot[1] = ai3_divineDot[1] - 1
                        if champion1_hp > 0:
                            self.check_champion_blessing(1, ai3_divineDot[0])
                        if champion2_hp > 0:
                            self.check_champion_blessing(2, ai3_divineDot[0])
                        if champion3_hp > 0:
                            self.check_champion_blessing(3, ai3_divineDot[0])
                        if champion4_hp > 0:
                            self.check_champion_blessing(4, ai3_divineDot[0])
                        if champion5_hp > 0:
                            self.check_champion_blessing(5, ai3_divineDot[0])
                        if ai3_hp < 0:
                            ai3_hp = 0
                            continue
                    if ai3_barbedArrDot[1] != 0:
                        ai3_hp = ai3_hp - ai3_barbedArrDot[0]
                        ai3_barbedArrDot[1] = ai3_barbedArrDot[1] - 1
                        if ai3_hp < 0:
                            ai3_hp = 0
                            continue
                    if ai3_damnation[1] != 0:
                        ai3_damnation[1] = ai3_damnation[1] - 1
                        if ai3_damnation[1] == 0:
                            ai3_hp = ai3_hp - ai3_damnation[0]
                            if ai3_hp < 0:
                                ai3_hp = 0
                    if ai3_hp == 0:
                        continue
                    if ai3_stun != 0:
                        continue
                    if ai3_taunt[1] != 0:
                        if ai3_taunt[0] in CHAMPION_LIST[0]:
                            if len(champion1_immunity) != 0:
                                immune_list = []
                                for immune in champion1_immunity:
                                    if immune == "Cocoon":
                                        champion1_hp = champion1_hp
                                    elif immune == "Block":
                                        if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                            champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 3, 0) * 0.5)
                                            champion1_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(1, 3, 1) * 0.5))
                                            if champion1_hp < 0:
                                                champion1_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                            champion2_hp = champion2_hp - self.calculate_ai_damage(2, 3, 0)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 3, 1))
                                            if champion2_hp < 0:
                                                champion2_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                            champion3_hp = champion3_hp - self.calculate_ai_damage(3, 3, 0)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 3, 1))
                                            if champion3_hp < 0:
                                                champion3_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                            champion4_hp = champion4_hp - self.calculate_ai_damage(4, 3, 0)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 3, 1))
                                            if champion4_hp < 0:
                                                champion4_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                            champion5_hp = champion5_hp - self.calculate_ai_damage(5, 3, 0)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 3, 1))
                                            if champion5_hp < 0:
                                                champion5_hp = 0
                                    elif immune == "Evasive Manoeuvres":
                                        self.apply_taunt(3, MASTER_FENCER.title, 1)
                            elif CHAMPION_LIST[0] == MONK.title:
                                bauble_damage = self.calculate_ai_damage(1, 3, 0)
                                bauble_unavailable_check = 0
                                if monk_bauble_damage_list1[1] == 0:
                                    monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                else:
                                    if monk_bauble_damage_list2[1] == 0:
                                        monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list3[1] == 0:
                                            monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            bauble_unavailable_check = 1
                                monk_damage_taken = 0
                                if monk_bauble_damage_list1[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                if monk_bauble_damage_list2[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                if monk_bauble_damage_list3[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                if bauble_unavailable_check == 1:
                                    monk_damage_taken = monk_damage_taken + bauble_damage
                                champion1_hp = champion1_hp - math.ceil(monk_damage_taken)
                                champion1_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                if champion1_hp < 0:
                                    champion1_hp = 0
                            elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                ai_hit_fencer_range = random.randint(1, 100)
                                if ai_hit_fencer_range <= ai3_fencer_dodgechance:
                                    if AI_SIZE == "Tiny":
                                        champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 3, 0) * 0.5)
                                        champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 3, 1) * 0.5)
                                        self.apply_taunt(3, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Small":
                                        champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 3, 0) * 0.6)
                                        champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 3, 1) * 0.6)
                                        self.apply_taunt(3, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Medium":
                                        champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 3, 0) * 0.7)
                                        champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 3, 1) * 0.7)
                                        self.apply_taunt(3, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Large":
                                        champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 3, 0) * 0.8)
                                        champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 3, 1) * 0.8)
                                        self.apply_taunt(3, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Huge":
                                        champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 3, 0) * 0.9)
                                        champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 3, 1) * 0.9)
                                        self.apply_taunt(3, MASTER_FENCER.title, 1)
                                else:
                                    champion1_hp = champion1_hp - self.calculate_ai_damage(1, 3, 0)
                                    champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 3, 1))
                                    if champion1_hp < 0:
                                        champion1_hp = 0
                            else:
                                champion1_hp = champion1_hp - self.calculate_ai_damage(1, 3, 0)
                                champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 3, 1))
                                if champion1_hp < 0:
                                    champion1_hp = 0
                            if champion1_bush_armour != 0:
                                ai3_hp = ai3_hp - 200
                                self.apply_thornsDot(1, 3)
                            if ai3_hp < 0:
                                ai3_hp = 0
                        elif ai3_taunt[0] in CHAMPION_LIST[1]:
                            if len(champion2_immunity) != 0:
                                immune_list = []
                                for immune in champion2_immunity:
                                    if immune == "Cocoon":
                                        champion2_hp = champion2_hp
                                    elif immune == "Block":
                                        if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                            champion1_hp = champion1_hp - self.calculate_ai_damage(1, 3, 0)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 3, 1))
                                            if champion1_hp < 0:
                                                champion1_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                            champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 3, 0) * 0.5)
                                            champion2_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(2, 3, 1) * 0.5))
                                            if champion2_hp < 0:
                                                champion2_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                            champion3_hp = champion3_hp - self.calculate_ai_damage(3, 3, 0)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 3, 1))
                                            if champion3_hp < 0:
                                                champion3_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                            champion4_hp = champion4_hp - self.calculate_ai_damage(4, 3, 0)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 3, 1))
                                            if champion4_hp < 0:
                                                champion4_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                            champion5_hp = champion5_hp - self.calculate_ai_damage(5, 3, 0)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 3, 1))
                                            if champion5_hp < 0:
                                                champion5_hp = 0
                                    elif immune == "Evasive Manoeuvres":
                                        self.apply_taunt(3, MASTER_FENCER.title, 1)
                            elif CHAMPION_LIST[0] == MONK.title:
                                bauble_damage = self.calculate_ai_damage(2, 3, 0)
                                bauble_unavailable_check = 0
                                if monk_bauble_damage_list1[1] == 0:
                                    monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                else:
                                    if monk_bauble_damage_list2[1] == 0:
                                        monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list3[1] == 0:
                                            monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            bauble_unavailable_check = 1
                                monk_damage_taken = 0
                                if monk_bauble_damage_list1[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                if monk_bauble_damage_list2[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                if monk_bauble_damage_list3[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                if bauble_unavailable_check == 1:
                                    monk_damage_taken = monk_damage_taken + bauble_damage
                                champion2_hp = champion2_hp - math.ceil(monk_damage_taken)
                                champion2_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                if champion2_hp < 0:
                                    champion2_hp = 0
                            elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                ai_hit_fencer_range = random.randint(1, 100)
                                if ai_hit_fencer_range <= ai3_fencer_dodgechance:
                                    if AI_SIZE == "Tiny":
                                        champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 3, 0) * 0.5)
                                        champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 3, 1) * 0.5)
                                        self.apply_taunt(3, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Small":
                                        champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 3, 0) * 0.6)
                                        champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 3, 1) * 0.6)
                                        self.apply_taunt(3, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Medium":
                                        champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 3, 0) * 0.7)
                                        champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 3, 1) * 0.7)
                                        self.apply_taunt(3, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Large":
                                        champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 3, 0) * 0.8)
                                        champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 3, 1) * 0.8)
                                        self.apply_taunt(3, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Huge":
                                        champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 3, 0) * 0.9)
                                        champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 3, 1) * 0.9)
                                        self.apply_taunt(3, MASTER_FENCER.title, 1)
                                else:
                                    champion2_hp = champion2_hp - self.calculate_ai_damage(2, 3, 0)
                                    champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 3, 1))
                                    if champion2_hp < 0:
                                        champion2_hp = 0
                            else:
                                champion2_hp = champion2_hp - self.calculate_ai_damage(2, 3, 0)
                                champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 3, 1))
                                if champion2_hp < 0:
                                    champion2_hp = 0
                            if champion2_bush_armour != 0:
                                ai3_hp = ai3_hp - 200
                                self.apply_thornsDot(1, 3)
                            if ai3_hp < 0:
                                ai3_hp = 0
                        elif ai3_taunt[0] in CHAMPION_LIST[2]:
                            if len(champion3_immunity) != 0:
                                immune_list = []
                                for immune in champion3_immunity:
                                    if immune == "Cocoon":
                                        champion3_hp = champion3_hp
                                    elif immune == "Block":
                                        if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                            champion1_hp = champion1_hp - self.calculate_ai_damage(1, 3, 0)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 3, 1))
                                            if champion1_hp < 0:
                                                champion1_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                            champion2_hp = champion2_hp - self.calculate_ai_damage(2, 3, 0)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 3, 1))
                                            if champion2_hp < 0:
                                                champion2_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                            champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 3, 0) * 0.5)
                                            champion3_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(3, 3, 1) * 0.5))
                                            if champion3_hp < 0:
                                                champion3_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                            champion4_hp = champion4_hp - self.calculate_ai_damage(4, 3, 0)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 3, 1))
                                            if champion4_hp < 0:
                                                champion4_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                            champion5_hp = champion5_hp - self.calculate_ai_damage(5, 3, 0)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 3, 1))
                                            if champion5_hp < 0:
                                                champion5_hp = 0
                                    elif immune == "Evasive Manoeuvres":
                                        self.apply_taunt(3, MASTER_FENCER.title, 1)
                            elif CHAMPION_LIST[0] == MONK.title:
                                bauble_damage = self.calculate_ai_damage(3, 3)
                                bauble_unavailable_check = 0
                                if monk_bauble_damage_list1[1] == 0:
                                    monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                else:
                                    if monk_bauble_damage_list2[1] == 0:
                                        monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list3[1] == 0:
                                            monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            bauble_unavailable_check = 1
                                monk_damage_taken = 0
                                if monk_bauble_damage_list1[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                if monk_bauble_damage_list2[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                if monk_bauble_damage_list3[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                if bauble_unavailable_check == 1:
                                    monk_damage_taken = monk_damage_taken + bauble_damage
                                champion3_hp = champion3_hp - math.ceil(monk_damage_taken)
                                champion3_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                if champion3_hp < 0:
                                    champion3_hp = 0
                            elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                ai_hit_fencer_range = random.randint(1, 100)
                                if ai_hit_fencer_range <= ai3_fencer_dodgechance:
                                    if AI_SIZE == "Tiny":
                                        champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 3, 0) * 0.5)
                                        champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 3, 1) * 0.5)
                                        self.apply_taunt(3, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Small":
                                        champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 3, 0) * 0.6)
                                        champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 3, 1) * 0.6)
                                        self.apply_taunt(3, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Medium":
                                        champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 3, 0) * 0.7)
                                        champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 3, 1) * 0.7)
                                        self.apply_taunt(3, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Large":
                                        champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 3, 0) * 0.8)
                                        champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 3, 1) * 0.8)
                                        self.apply_taunt(3, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Huge":
                                        champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 3, 0) * 0.9)
                                        champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 3, 1) * 0.9)
                                        self.apply_taunt(3, MASTER_FENCER.title, 1)
                                else:
                                    champion3_hp = champion3_hp - self.calculate_ai_damage(3, 3, 0)
                                    champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 3, 1))
                                    if champion3_hp < 0:
                                        champion3_hp = 0
                            else:
                                champion3_hp = champion3_hp - self.calculate_ai_damage(3, 3, 0)
                                champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 3, 1))
                                if champion3_hp < 0:
                                    champion3_hp = 0
                            if champion3_bush_armour != 0:
                                ai3_hp = ai3_hp - 200
                                self.apply_thornsDot(1, 3)
                            if ai3_hp < 0:
                                ai3_hp = 0
                        elif ai3_taunt[0] in CHAMPION_LIST[3]:
                            if len(champion4_immunity) != 0:
                                immune_list = []
                                for immune in champion4_immunity:
                                    if immune == "Cocoon":
                                        champion4_hp = champion4_hp
                                    elif immune == "Block":
                                        if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                            champion1_hp = champion1_hp - self.calculate_ai_damage(1, 3, 0)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 3, 1))
                                            if champion1_hp < 0:
                                                champion1_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                            champion2_hp = champion2_hp - self.calculate_ai_damage(2, 3, 0)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 3, 1))
                                            if champion2_hp < 0:
                                                champion2_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                            champion3_hp = champion3_hp - self.calculate_ai_damage(3, 3, 0)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 3, 1))
                                            if champion3_hp < 0:
                                                champion3_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                            champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 3, 0) * 0.5)
                                            champion4_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(4, 3, 1) * 0.5))
                                            if champion4_hp < 0:
                                                champion4_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                            champion5_hp = champion5_hp - self.calculate_ai_damage(5, 3, 0)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 3, 1))
                                            if champion5_hp < 0:
                                                champion5_hp = 0
                                    elif immune == "Evasive Manoeuvres":
                                        self.apply_taunt(3, MASTER_FENCER.title, 1)
                            elif CHAMPION_LIST[0] == MONK.title:
                                bauble_damage = self.calculate_ai_damage(4, 3, 0)
                                bauble_unavailable_check = 0
                                if monk_bauble_damage_list1[1] == 0:
                                    monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                else:
                                    if monk_bauble_damage_list2[1] == 0:
                                        monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list3[1] == 0:
                                            monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            bauble_unavailable_check = 1
                                monk_damage_taken = 0
                                if monk_bauble_damage_list1[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                if monk_bauble_damage_list2[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                if monk_bauble_damage_list3[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                if bauble_unavailable_check == 1:
                                    monk_damage_taken = monk_damage_taken + bauble_damage
                                champion4_hp = champion4_hp - math.ceil(monk_damage_taken)
                                champion4_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                if champion4_hp < 0:
                                    champion4_hp = 0
                            elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                ai_hit_fencer_range = random.randint(1, 100)
                                if ai_hit_fencer_range <= ai3_fencer_dodgechance:
                                    if AI_SIZE == "Tiny":
                                        champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 3, 0) * 0.5)
                                        champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 3, 1) * 0.5)
                                        self.apply_taunt(3, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Small":
                                        champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 3, 0) * 0.6)
                                        champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 3, 1) * 0.6)
                                        self.apply_taunt(3, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Medium":
                                        champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 3, 0) * 0.7)
                                        champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 3, 1) * 0.7)
                                        self.apply_taunt(3, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Large":
                                        champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 3, 0) * 0.8)
                                        champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 3, 1) * 0.8)
                                        self.apply_taunt(3, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Huge":
                                        champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 3, 0) * 0.9)
                                        champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 3, 1) * 0.9)
                                        self.apply_taunt(3, MASTER_FENCER.title, 1)
                                else:
                                    champion4_hp = champion4_hp - self.calculate_ai_damage(4, 3, 0)
                                    champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 3, 1))
                                    if champion4_hp < 0:
                                        champion4_hp = 0
                            else:
                                champion4_hp = champion4_hp - self.calculate_ai_damage(4, 3, 0)
                                champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 3, 1))
                                if champion4_hp < 0:
                                    champion4_hp = 0
                            if champion4_bush_armour != 0:
                                ai3_hp = ai3_hp - 200
                                self.apply_thornsDot(1, 3)
                            if ai3_hp < 0:
                                ai3_hp = 0
                        elif ai3_taunt[0] in CHAMPION_LIST[4]:
                            if len(champion5_immunity) != 0:
                                immune_list = []
                                for immune in champion5_immunity:
                                    if immune == "Cocoon":
                                        champion5_hp = champion5_hp
                                    elif immune == "Block":
                                        if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                            champion1_hp = champion1_hp - self.calculate_ai_damage(1, 3, 0)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 3, 1))
                                            if champion1_hp < 0:
                                                champion1_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                            champion2_hp = champion2_hp - self.calculate_ai_damage(2, 3, 0)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 3, 1))
                                            if champion2_hp < 0:
                                                champion2_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                            champion3_hp = champion3_hp - self.calculate_ai_damage(3, 3, 0)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 3, 1))
                                            if champion3_hp < 0:
                                                champion3_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                            champion4_hp = champion4_hp - self.calculate_ai_damage(4, 3, 0)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 3, 1))
                                            if champion4_hp < 0:
                                                champion4_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                            champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 3, 0) * 0.5)
                                            champion5_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(5, 3, 0) * 0.5))
                                            if champion5_hp < 0:
                                                champion5_hp = 0
                                    elif immune == "Evasive Manoeuvres":
                                        self.apply_taunt(3, MASTER_FENCER.title, 1)
                            elif CHAMPION_LIST[0] == MONK.title:
                                bauble_damage = self.calculate_ai_damage(5, 3, 0)
                                bauble_unavailable_check = 0
                                if monk_bauble_damage_list1[1] == 0:
                                    monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                else:
                                    if monk_bauble_damage_list2[1] == 0:
                                        monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list3[1] == 0:
                                            monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            bauble_unavailable_check = 1
                                monk_damage_taken = 0
                                if monk_bauble_damage_list1[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                if monk_bauble_damage_list2[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                if monk_bauble_damage_list3[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                if bauble_unavailable_check == 1:
                                    monk_damage_taken = monk_damage_taken + bauble_damage
                                champion5_hp = champion5_hp - math.ceil(monk_damage_taken)
                                champion5_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                if champion5_hp < 0:
                                    champion5_hp = 0
                            elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                ai_hit_fencer_range = random.randint(1, 100)
                                if ai_hit_fencer_range <= ai3_fencer_dodgechance:
                                    if AI_SIZE == "Tiny":
                                        champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 3, 0) * 0.5)
                                        champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 3, 1) * 0.5)
                                        self.apply_taunt(3, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Small":
                                        champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 3, 0) * 0.6)
                                        champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 3, 1) * 0.6)
                                        self.apply_taunt(3, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Medium":
                                        champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 3, 0) * 0.7)
                                        champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 3, 1) * 0.7)
                                        self.apply_taunt(3, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Large":
                                        champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 3, 0) * 0.8)
                                        champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 3, 1) * 0.8)
                                        self.apply_taunt(3, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Huge":
                                        champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 3, 0) * 0.9)
                                        champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 3, 1) * 0.9)
                                        self.apply_taunt(3, MASTER_FENCER.title, 1)
                                else:
                                    champion5_hp = champion5_hp - self.calculate_ai_damage(5, 3, 0)
                                    champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 3, 1))
                                    if champion5_hp < 0:
                                        champion5_hp = 0
                            else:
                                champion5_hp = champion5_hp - self.calculate_ai_damage(5, 3, 0)
                                champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 3, 1))
                                if champion5_hp < 0:
                                    champion5_hp = 0
                            if champion5_bush_armour != 0:
                                ai3_hp = ai3_hp - 200
                                self.apply_thornsDot(1, 3)
                            if ai3_hp < 0:
                                ai3_hp = 0
                    else:
                        if "Everyone" in ai3_attack_intention:
                            if champion1_hp != 0:
                                if len(champion1_immunity) != 0:
                                    immune_list = []
                                    for immune in champion1_immunity:
                                        if immune == "Cocoon":
                                            champion1_hp = champion1_hp
                                        elif immune == "Block":
                                            if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                                champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 3, 0) * 0.5)
                                                champion1_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(1, 3, 1) * 0.5))
                                                if champion1_hp < 0:
                                                    champion1_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                                champion2_hp = champion2_hp - self.calculate_ai_damage(2, 3, 0)
                                                champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 3, 1))
                                                if champion2_hp < 0:
                                                    champion2_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                                champion3_hp = champion3_hp - self.calculate_ai_damage(3, 3, 0)
                                                champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 3, 1))
                                                if champion3_hp < 0:
                                                    champion3_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                                champion4_hp = champion4_hp - self.calculate_ai_damage(4, 3, 0)
                                                champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 3, 1))
                                                if champion4_hp < 0:
                                                    champion4_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                                champion5_hp = champion5_hp - self.calculate_ai_damage(5, 3, 0)
                                                champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 3, 1))
                                                if champion5_hp < 0:
                                                    champion5_hp = 0
                                        elif immune == "Evasive Manoeuvres":
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                elif CHAMPION_LIST[0] == MONK.title:
                                    bauble_damage = self.calculate_ai_damage(1, 3, 0)
                                    bauble_unavailable_check = 0
                                    if monk_bauble_damage_list1[1] == 0:
                                        monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list2[1] == 0:
                                            monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            if monk_bauble_damage_list3[1] == 0:
                                                monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                            else:
                                                bauble_unavailable_check = 1
                                    monk_damage_taken = 0
                                    if monk_bauble_damage_list1[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                    if monk_bauble_damage_list2[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                    if monk_bauble_damage_list3[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                    if bauble_unavailable_check == 1:
                                        monk_damage_taken = monk_damage_taken + bauble_damage
                                    champion1_hp = champion1_hp - math.ceil(monk_damage_taken)
                                    champion1_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                    if champion1_hp < 0:
                                        champion1_hp = 0
                                elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                    ai_hit_fencer_range = random.randint(1, 100)
                                    if ai_hit_fencer_range <= ai3_fencer_dodgechance:
                                        if AI_SIZE == "Tiny":
                                            champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 3, 0) * 0.5)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 3, 1) * 0.5)
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Small":
                                            champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 3, 0) * 0.6)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 3, 1) * 0.6)
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Medium":
                                            champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 3, 0) * 0.7)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 3, 1) * 0.7)
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Large":
                                            champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 3, 0) * 0.8)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 3, 1) * 0.8)
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Huge":
                                            champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 3, 0) * 0.9)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 3, 1) * 0.9)
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                    else:
                                        champion1_hp = champion1_hp - self.calculate_ai_damage(1, 3, 0)
                                        champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 3, 1))
                                        if champion1_hp < 0:
                                            champion1_hp = 0
                                elif CHAMPION_LIST[0] == POWER_CONDUIT.title:
                                    champion1_hp = champion1_hp - self.calculate_ai_damage(1, 3, 0)
                                    champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 3, 1))
                                    if champion1_hp < 0:
                                        champion1_hp = 0
                                    ai3_hp = ai3_hp - 750
                                    if ai3_hp < 0:
                                        ai3_hp = 0
                                elif CHAMPION_LIST[0] == ACADEMIC_MAGE.title:
                                    mage_damage_taken = math.ceil(self.calculate_ai_damage(1, 3, 0) - champion1_magical_barrier)
                                    if mage_damage_taken < 0:
                                        champion1_magical_barrier = mage_damage_taken * -1
                                    else:
                                        champion1_magical_barrier = 0
                                        champion1_hp = champion1_hp - mage_damage_taken
                                        champion1_lastRoundDamageTaken_list.append(mage_damage_taken)
                                        if champion1_hp < 0:
                                            champion1_hp = 0
                                else:
                                    champion1_hp = champion1_hp - self.calculate_ai_damage(1, 3, 0)
                                    champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 3, 1))
                                    if champion1_hp < 0:
                                        champion1_hp = 0
                                if champion1_bush_armour != 0:
                                    ai3_hp = ai3_hp - 200
                                    self.apply_thornsDot(3, 1)
                                if ai3_hp < 0:
                                    ai3_hp = 0
                            if champion2_hp != 0:
                                if len(champion2_immunity) != 0:
                                    immune_list = []
                                    for immune in champion2_immunity:
                                        if immune == "Cocoon":
                                            champion2_hp = champion2_hp
                                        elif immune == "Block":
                                            if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                                champion1_hp = champion1_hp - self.calculate_ai_damage(1, 3, 0)
                                                champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 3, 1))
                                                if champion1_hp < 0:
                                                    champion1_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                                champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 3, 0) * 0.5)
                                                champion2_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(2, 3, 1) * 0.5))
                                                if champion2_hp < 0:
                                                    champion2_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                                champion3_hp = champion3_hp - self.calculate_ai_damage(3, 3, 0)
                                                champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 3, 1))
                                                if champion3_hp < 0:
                                                    champion3_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                                champion4_hp = champion4_hp - self.calculate_ai_damage(4, 3, 0)
                                                champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 3, 1))
                                                if champion4_hp < 0:
                                                    champion4_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                                champion5_hp = champion5_hp - self.calculate_ai_damage(5, 3, 0)
                                                champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 3, 1))
                                                if champion5_hp < 0:
                                                    champion5_hp = 0
                                        elif immune == "Evasive Manoeuvres":
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                elif CHAMPION_LIST[0] == MONK.title:
                                    bauble_damage = self.calculate_ai_damage(2, 3, 0)
                                    bauble_unavailable_check = 0
                                    if monk_bauble_damage_list1[1] == 0:
                                        monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list2[1] == 0:
                                            monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            if monk_bauble_damage_list3[1] == 0:
                                                monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                            else:
                                                bauble_unavailable_check = 1
                                    monk_damage_taken = 0
                                    if monk_bauble_damage_list1[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                    if monk_bauble_damage_list2[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                    if monk_bauble_damage_list3[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                    if bauble_unavailable_check == 1:
                                        monk_damage_taken = monk_damage_taken + bauble_damage
                                    champion2_hp = champion2_hp - math.ceil(monk_damage_taken)
                                    champion2_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                    if champion2_hp < 0:
                                        champion2_hp = 0
                                elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                    ai_hit_fencer_range = random.randint(1, 100)
                                    if ai_hit_fencer_range <= ai3_fencer_dodgechance:
                                        if AI_SIZE == "Tiny":
                                            champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 3, 0) * 0.5)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 3, 1) * 0.5)
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Small":
                                            champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 3, 0) * 0.6)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 3, 1) * 0.6)
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Medium":
                                            champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 3, 0) * 0.7)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 3, 1) * 0.7)
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Large":
                                            champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 3, 0) * 0.8)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 3, 1) * 0.8)
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Huge":
                                            champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 3, 0) * 0.9)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 3, 1) * 0.9)
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                    else:
                                        champion2_hp = champion2_hp - self.calculate_ai_damage(2, 3, 0)
                                        champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 3, 1))
                                        if champion2_hp < 0:
                                            champion2_hp = 0
                                elif CHAMPION_LIST[0] == POWER_CONDUIT.title:
                                    champion2_hp = champion2_hp - self.calculate_ai_damage(2, 3, 0)
                                    champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 3, 1))
                                    if champion2_hp < 0:
                                        champion2_hp = 0
                                    ai3_hp = ai3_hp - 750
                                    if ai3_hp < 0:
                                        ai3_hp = 0
                                elif CHAMPION_LIST[0] == ACADEMIC_MAGE.title:
                                    mage_damage_taken = math.ceil(self.calculate_ai_damage(2, 3, 0) - champion2_magical_barrier)
                                    if mage_damage_taken < 0:
                                        champion2_magical_barrier = mage_damage_taken * -1
                                    else:
                                        champion2_magical_barrier = 0
                                        champion2_hp = champion2_hp - mage_damage_taken
                                        champion2_lastRoundDamageTaken_list.append(mage_damage_taken)
                                        if champion2_hp < 0:
                                            champion2_hp = 0
                                else:
                                    champion2_hp = champion2_hp - self.calculate_ai_damage(2, 3, 0)
                                    champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 3, 1))
                                    if champion2_hp < 0:
                                        champion2_hp = 0
                                if champion2_bush_armour != 0:
                                    ai3_hp = ai3_hp - 200
                                    self.apply_thornsDot(3, 1)
                                if ai3_hp < 0:
                                    ai3_hp = 0
                            if champion3_hp != 0:
                                if len(champion3_immunity) != 0:
                                    immune_list = []
                                    for immune in champion3_immunity:
                                        if immune == "Cocoon":
                                            champion3_hp = champion3_hp
                                        elif immune == "Block":
                                            if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                                champion1_hp = champion1_hp - self.calculate_ai_damage(1, 3, 0)
                                                champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 3, 1))
                                                if champion1_hp < 0:
                                                    champion1_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                                champion2_hp = champion2_hp - self.calculate_ai_damage(2, 3, 0)
                                                champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 3, 1))
                                                if champion2_hp < 0:
                                                    champion2_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                                champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 3, 0) * 0.5)
                                                champion3_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(3, 3, 1) * 0.5))
                                                if champion3_hp < 0:
                                                    champion3_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                                champion4_hp = champion4_hp - self.calculate_ai_damage(4, 3, 0)
                                                champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 3, 1))
                                                if champion4_hp < 0:
                                                    champion4_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                                champion5_hp = champion5_hp - self.calculate_ai_damage(5, 3, 0)
                                                champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 3, 1))
                                                if champion5_hp < 0:
                                                    champion5_hp = 0
                                        elif immune == "Evasive Manoeuvres":
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                elif CHAMPION_LIST[0] == MONK.title:
                                    bauble_damage = self.calculate_ai_damage(3, 3, 0)
                                    bauble_unavailable_check = 0
                                    if monk_bauble_damage_list1[1] == 0:
                                        monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list2[1] == 0:
                                            monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            if monk_bauble_damage_list3[1] == 0:
                                                monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                            else:
                                                bauble_unavailable_check = 1
                                    monk_damage_taken = 0
                                    if monk_bauble_damage_list1[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                    if monk_bauble_damage_list2[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                    if monk_bauble_damage_list3[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                    if bauble_unavailable_check == 1:
                                        monk_damage_taken = monk_damage_taken + bauble_damage
                                    champion3_hp = champion3_hp - math.ceil(monk_damage_taken)
                                    champion3_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                    if champion3_hp < 0:
                                        champion3_hp = 0
                                elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                    ai_hit_fencer_range = random.randint(1, 100)
                                    if ai_hit_fencer_range <= ai3_fencer_dodgechance:
                                        if AI_SIZE == "Tiny":
                                            champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 3, 0) * 0.5)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 3, 1) * 0.5)
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Small":
                                            champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 3, 0) * 0.6)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 3, 1) * 0.6)
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Medium":
                                            champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 3, 0) * 0.7)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 3, 1) * 0.7)
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Large":
                                            champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 3, 0) * 0.8)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 3, 1) * 0.8)
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Huge":
                                            champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 3, 0) * 0.9)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 3, 1) * 0.9)
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                    else:
                                        champion3_hp = champion3_hp - self.calculate_ai_damage(3, 3, 0)
                                        champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 3, 1))
                                        if champion3_hp < 0:
                                            champion3_hp = 0
                                elif CHAMPION_LIST[0] == POWER_CONDUIT.title:
                                    champion3_hp = champion3_hp - self.calculate_ai_damage(3, 3, 0)
                                    champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 3, 1))
                                    if champion3_hp < 0:
                                        champion3_hp = 0
                                    ai3_hp = ai3_hp - 750
                                    if ai3_hp < 0:
                                        ai3_hp = 0
                                elif CHAMPION_LIST[0] == ACADEMIC_MAGE.title:
                                    mage_damage_taken = math.ceil(self.calculate_ai_damage(3, 3, 0) - champion3_magical_barrier)
                                    if mage_damage_taken < 0:
                                        champion3_magical_barrier = mage_damage_taken * -1
                                    else:
                                        champion3_magical_barrier = 0
                                        champion3_hp = champion3_hp - mage_damage_taken
                                        champion3_lastRoundDamageTaken_list.append(mage_damage_taken)
                                        if champion3_hp < 0:
                                            champion3_hp = 0
                                else:
                                    champion3_hp = champion3_hp - self.calculate_ai_damage(3, 3, 0)
                                    champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 3, 1))
                                    if champion3_hp < 0:
                                        champion3_hp = 0
                                if champion3_bush_armour != 0:
                                    ai3_hp = ai3_hp - 200
                                    self.apply_thornsDot(3, 1)
                                if ai3_hp < 0:
                                    ai3_hp = 0
                            if champion4_hp != 0:
                                if len(champion4_immunity) != 0:
                                    immune_list = []
                                    for immune in champion4_immunity:
                                        if immune == "Cocoon":
                                            champion4_hp = champion4_hp
                                        elif immune == "Block":
                                            if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                                champion1_hp = champion1_hp - self.calculate_ai_damage(1, 3, 0)
                                                champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 3, 1))
                                                if champion1_hp < 0:
                                                    champion1_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                                champion2_hp = champion2_hp - self.calculate_ai_damage(2, 3, 0)
                                                champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 3, 1))
                                                if champion2_hp < 0:
                                                    champion2_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                                champion3_hp = champion3_hp - self.calculate_ai_damage(3, 3, 0)
                                                champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 3, 1))
                                                if champion3_hp < 0:
                                                    champion3_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                                champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 3, 0) * 0.5)
                                                champion4_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(4, 3, 1) * 0.5))
                                                if champion4_hp < 0:
                                                    champion4_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                                champion5_hp = champion5_hp - self.calculate_ai_damage(5, 3, 0)
                                                champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 3, 1))
                                                if champion5_hp < 0:
                                                    champion5_hp = 0
                                        elif immune == "Evasive Manoeuvres":
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                elif CHAMPION_LIST[0] == MONK.title:
                                    bauble_damage = self.calculate_ai_damage(4, 3, 0)
                                    bauble_unavailable_check = 0
                                    if monk_bauble_damage_list1[1] == 0:
                                        monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list2[1] == 0:
                                            monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            if monk_bauble_damage_list3[1] == 0:
                                                monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                            else:
                                                bauble_unavailable_check = 1
                                    monk_damage_taken = 0
                                    if monk_bauble_damage_list1[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                    if monk_bauble_damage_list2[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                    if monk_bauble_damage_list3[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                    if bauble_unavailable_check == 1:
                                        monk_damage_taken = monk_damage_taken + bauble_damage
                                    champion4_hp = champion4_hp - math.ceil(monk_damage_taken)
                                    champion4_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                    if champion4_hp < 0:
                                        champion4_hp = 0
                                elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                    ai_hit_fencer_range = random.randint(1, 100)
                                    if ai_hit_fencer_range <= ai3_fencer_dodgechance:
                                        if AI_SIZE == "Tiny":
                                            champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 3, 0) * 0.5)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 3, 1) * 0.5)
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Small":
                                            champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 3, 0) * 0.6)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 3, 1) * 0.6)
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Medium":
                                            champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 3, 0) * 0.7)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 3, 1) * 0.7)
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Large":
                                            champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 3, 0) * 0.8)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 3, 1) * 0.8)
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Huge":
                                            champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 3, 0) * 0.9)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 3, 1) * 0.9)
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                    else:
                                        champion4_hp = champion4_hp - self.calculate_ai_damage(4, 3, 0)
                                        champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 3, 1))
                                        if champion4_hp < 0:
                                            champion4_hp = 0
                                elif CHAMPION_LIST[0] == POWER_CONDUIT.title:
                                    champion4_hp = champion4_hp - self.calculate_ai_damage(4, 3, 0)
                                    champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 3, 1))
                                    if champion4_hp < 0:
                                        champion4_hp = 0
                                    ai3_hp = ai3_hp - 750
                                    if ai3_hp < 0:
                                        ai3_hp = 0
                                elif CHAMPION_LIST[0] == ACADEMIC_MAGE.title:
                                    mage_damage_taken = math.ceil(self.calculate_ai_damage(4, 3, 0) - champion4_magical_barrier)
                                    if mage_damage_taken < 0:
                                        champion4_magical_barrier = mage_damage_taken * -1
                                    else:
                                        champion4_magical_barrier = 0
                                        champion4_hp = champion4_hp - mage_damage_taken
                                        champion4_lastRoundDamageTaken_list.append(mage_damage_taken)
                                        if champion4_hp < 0:
                                            champion4_hp = 0
                                else:
                                    champion4_hp = champion4_hp - self.calculate_ai_damage(4, 3, 0)
                                    champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 3, 1))
                                    if champion4_hp < 0:
                                        champion4_hp = 0
                                if champion4_bush_armour != 0:
                                    ai3_hp = ai3_hp - 200
                                    self.apply_thornsDot(3, 1)
                                if ai3_hp < 0:
                                    ai3_hp = 0
                            if champion5_hp != 0:
                                if len(champion5_immunity) != 0:
                                    immune_list = []
                                    for immune in champion5_immunity:
                                        if immune == "Cocoon":
                                            champion5_hp = champion5_hp
                                        elif immune == "Block":
                                            if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                                champion1_hp = champion1_hp - self.calculate_ai_damage(1, 3, 0)
                                                champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 3, 1))
                                                if champion1_hp < 0:
                                                    champion1_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                                champion2_hp = champion2_hp - self.calculate_ai_damage(2, 3, 0)
                                                champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 3, 1))
                                                if champion2_hp < 0:
                                                    champion2_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                                champion3_hp = champion3_hp - self.calculate_ai_damage(3, 3, 0)
                                                champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 3, 1))
                                                if champion3_hp < 0:
                                                    champion3_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                                champion4_hp = champion4_hp - self.calculate_ai_damage(4, 3, 0)
                                                champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 3, 1))
                                                if champion4_hp < 0:
                                                    champion4_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                                champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 3, 0) * 0.5)
                                                champion5_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(5, 3, 1) * 0.5))
                                                if champion5_hp < 0:
                                                    champion5_hp = 0
                                        elif immune == "Evasive Manoeuvres":
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                elif CHAMPION_LIST[0] == MONK.title:
                                    bauble_damage = self.calculate_ai_damage(5, 3, 0)
                                    bauble_unavailable_check = 0
                                    if monk_bauble_damage_list1[1] == 0:
                                        monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list2[1] == 0:
                                            monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            if monk_bauble_damage_list3[1] == 0:
                                                monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                            else:
                                                bauble_unavailable_check = 1
                                    monk_damage_taken = 0
                                    if monk_bauble_damage_list1[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                    if monk_bauble_damage_list2[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                    if monk_bauble_damage_list3[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                    if bauble_unavailable_check == 1:
                                        monk_damage_taken = monk_damage_taken + bauble_damage
                                    champion5_hp = champion5_hp - math.ceil(monk_damage_taken)
                                    champion5_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                    if champion5_hp < 0:
                                        champion5_hp = 0
                                elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                    ai_hit_fencer_range = random.randint(1, 100)
                                    if ai_hit_fencer_range <= ai3_fencer_dodgechance:
                                        if AI_SIZE == "Tiny":
                                            champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 3, 0) * 0.5)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 3, 1) * 0.5)
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Small":
                                            champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 3, 0) * 0.6)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 3, 1) * 0.6)
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Medium":
                                            champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 3, 0) * 0.7)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 3, 1) * 0.7)
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Large":
                                            champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 3, 0) * 0.8)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 3, 1) * 0.8)
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Huge":
                                            champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 3, 0) * 0.9)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 3, 1) * 0.9)
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                    else:
                                        champion5_hp = champion5_hp - self.calculate_ai_damage(5, 3, 0)
                                        champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 3, 1))
                                        if champion5_hp < 0:
                                            champion5_hp = 0
                                elif CHAMPION_LIST[0] == POWER_CONDUIT.title:
                                    champion5_hp = champion5_hp - self.calculate_ai_damage(5, 3, 0)
                                    champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 3, 1))
                                    if champion5_hp < 0:
                                        champion5_hp = 0
                                    ai3_hp = ai3_hp - 750
                                    if ai3_hp < 0:
                                        ai3_hp = 0
                                elif CHAMPION_LIST[0] == ACADEMIC_MAGE.title:
                                    mage_damage_taken = math.ceil(self.calculate_ai_damage(5, 3, 0) - champion5_magical_barrier)
                                    if mage_damage_taken < 0:
                                        champion5_magical_barrier = mage_damage_taken * -1
                                    else:
                                        champion5_magical_barrier = 0
                                        champion5_hp = champion5_hp - mage_damage_taken
                                        champion5_lastRoundDamageTaken_list.append(mage_damage_taken)
                                        if champion5_hp < 0:
                                            champion5_hp = 0
                                else:
                                    champion5_hp = champion5_hp - self.calculate_ai_damage(5, 3, 0)
                                    champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 3, 1))
                                    if champion5_hp < 0:
                                        champion5_hp = 0
                                if champion5_bush_armour != 0:
                                    ai3_hp = ai3_hp - 200
                                    self.apply_thornsDot(3, 1)
                                if ai3_hp < 0:
                                    ai3_hp = 0
                        else:
                            if CHAMPION_LIST[0] in ai3_attack_intention:
                                if len(champion1_immunity) != 0:
                                    immune_list = []
                                    for immune in champion1_immunity:
                                        if immune == "Cocoon":
                                            champion1_hp = champion1_hp
                                        elif immune == "Block":
                                            if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                                champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 3, 0) * 0.5)
                                                champion1_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(1, 3, 1) * 0.5))
                                                if champion1_hp < 0:
                                                    champion1_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                                champion2_hp = champion2_hp - self.calculate_ai_damage(2, 3, 0)
                                                champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 3, 1))
                                                if champion2_hp < 0:
                                                    champion2_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                                champion3_hp = champion3_hp - self.calculate_ai_damage(3, 3, 0)
                                                champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 3, 1))
                                                if champion3_hp < 0:
                                                    champion3_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                                champion4_hp = champion4_hp - self.calculate_ai_damage(4, 3, 0)
                                                champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 3, 1))
                                                if champion4_hp < 0:
                                                    champion4_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                                champion5_hp = champion5_hp - self.calculate_ai_damage(5, 3, 0)
                                                champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 3, 1))
                                                if champion5_hp < 0:
                                                    champion5_hp = 0
                                        elif immune == "Evasive Manoeuvres":
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                elif CHAMPION_LIST[0] == MONK.title:
                                    bauble_damage = self.calculate_ai_damage(1, 3, 0)
                                    bauble_unavailable_check = 0
                                    if monk_bauble_damage_list1[1] == 0:
                                        monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list2[1] == 0:
                                            monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            if monk_bauble_damage_list3[1] == 0:
                                                monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                            else:
                                                bauble_unavailable_check = 1
                                    monk_damage_taken = 0
                                    if monk_bauble_damage_list1[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                    if monk_bauble_damage_list2[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                    if monk_bauble_damage_list3[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                    if bauble_unavailable_check == 1:
                                        monk_damage_taken = monk_damage_taken + bauble_damage
                                    champion1_hp = champion1_hp - math.ceil(monk_damage_taken)
                                    champion1_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                    if champion1_hp < 0:
                                        champion1_hp = 0
                                elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                    ai_hit_fencer_range = random.randint(1, 100)
                                    if ai_hit_fencer_range <= ai3_fencer_dodgechance:
                                        if AI_SIZE == "Tiny":
                                            champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 3, 0) * 0.5)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 3, 1) * 0.5)
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Small":
                                            champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 3, 0) * 0.6)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 3, 1) * 0.6)
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Medium":
                                            champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 3, 0) * 0.7)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 3, 1) * 0.7)
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Large":
                                            champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 3, 0) * 0.8)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 3, 1) * 0.8)
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Huge":
                                            champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 3, 0) * 0.9)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 3, 1) * 0.9)
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                    else:
                                        champion1_hp = champion1_hp - self.calculate_ai_damage(1, 3, 0)
                                        champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 3, 1))
                                        if champion1_hp < 0:
                                            champion1_hp = 0
                                elif CHAMPION_LIST[0] == POWER_CONDUIT.title:
                                    champion1_hp = champion1_hp - self.calculate_ai_damage(1, 3, 0)
                                    champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 3, 1))
                                    if champion1_hp < 0:
                                        champion1_hp = 0
                                    ai3_hp = ai3_hp - 750
                                    if ai3_hp < 0:
                                        ai3_hp = 0
                                elif CHAMPION_LIST[0] == ACADEMIC_MAGE.title:
                                    mage_damage_taken = math.ceil(self.calculate_ai_damage(1, 3, 0) - champion1_magical_barrier)
                                    if mage_damage_taken < 0:
                                        champion1_magical_barrier = mage_damage_taken * -1
                                    else:
                                        champion1_magical_barrier = 0
                                        champion1_hp = champion1_hp - mage_damage_taken
                                        champion1_lastRoundDamageTaken_list.append(mage_damage_taken)
                                        if champion1_hp < 0:
                                            champion1_hp = 0
                                else:
                                    champion1_hp = champion1_hp - self.calculate_ai_damage(1, 3, 0)
                                    champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 3, 1))
                                    if champion1_hp < 0:
                                        champion1_hp = 0
                                if champion1_bush_armour != 0:
                                    ai3_hp = ai3_hp - 200
                                    self.apply_thornsDot(3, 1)
                                if ai3_hp < 0:
                                    ai3_hp = 0
                            if CHAMPION_LIST[1] in ai3_attack_intention:
                                if len(champion2_immunity) != 0:
                                    immune_list = []
                                    for immune in champion2_immunity:
                                        if immune == "Cocoon":
                                            champion2_hp = champion2_hp
                                        elif immune == "Block":
                                            if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                                champion1_hp = champion1_hp - self.calculate_ai_damage(1, 3, 0)
                                                champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 3, 1))
                                                if champion1_hp < 0:
                                                    champion1_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                                champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 3, 0) * 0.5)
                                                champion2_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(2, 3, 1) * 0.5))
                                                if champion2_hp < 0:
                                                    champion2_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                                champion3_hp = champion3_hp - self.calculate_ai_damage(3, 3, 0)
                                                champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 3, 1))
                                                if champion3_hp < 0:
                                                    champion3_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                                champion4_hp = champion4_hp - self.calculate_ai_damage(4, 3, 0)
                                                champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 3, 1))
                                                if champion4_hp < 0:
                                                    champion4_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                                champion5_hp = champion5_hp - self.calculate_ai_damage(5, 3, 0)
                                                champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 3, 1))
                                                if champion5_hp < 0:
                                                    champion5_hp = 0
                                        elif immune == "Evasive Manoeuvres":
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                elif CHAMPION_LIST[0] == MONK.title:
                                    bauble_damage = self.calculate_ai_damage(2, 3, 0)
                                    bauble_unavailable_check = 0
                                    if monk_bauble_damage_list1[1] == 0:
                                        monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list2[1] == 0:
                                            monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            if monk_bauble_damage_list3[1] == 0:
                                                monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                            else:
                                                bauble_unavailable_check = 1
                                    monk_damage_taken = 0
                                    if monk_bauble_damage_list1[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                    if monk_bauble_damage_list2[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                    if monk_bauble_damage_list3[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                    if bauble_unavailable_check == 1:
                                        monk_damage_taken = monk_damage_taken + bauble_damage
                                    champion2_hp = champion2_hp - math.ceil(monk_damage_taken)
                                    champion2_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                    if champion2_hp < 0:
                                        champion2_hp = 0
                                elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                    ai_hit_fencer_range = random.randint(1, 100)
                                    if ai_hit_fencer_range <= ai3_fencer_dodgechance:
                                        if AI_SIZE == "Tiny":
                                            champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 3, 0) * 0.5)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 3, 1) * 0.5)
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Small":
                                            champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 3, 0) * 0.6)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 3, 1) * 0.6)
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Medium":
                                            champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 3, 0) * 0.7)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 3, 1) * 0.7)
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Large":
                                            champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 3, 0) * 0.8)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 3, 1) * 0.8)
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Huge":
                                            champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 3, 0) * 0.9)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 3, 1) * 0.9)
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                    else:
                                        champion2_hp = champion2_hp - self.calculate_ai_damage(2, 3, 0)
                                        champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 3, 1))
                                        if champion2_hp < 0:
                                            champion2_hp = 0
                                elif CHAMPION_LIST[0] == POWER_CONDUIT.title:
                                    champion2_hp = champion2_hp - self.calculate_ai_damage(2, 3, 0)
                                    champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 3, 1))
                                    if champion2_hp < 0:
                                        champion2_hp = 0
                                    ai3_hp = ai3_hp - 750
                                    if ai3_hp < 0:
                                        ai3_hp = 0
                                elif CHAMPION_LIST[0] == ACADEMIC_MAGE.title:
                                    mage_damage_taken = math.ceil(self.calculate_ai_damage(2, 3, 0) - champion2_magical_barrier)
                                    if mage_damage_taken < 0:
                                        champion2_magical_barrier = mage_damage_taken * -1
                                    else:
                                        champion2_magical_barrier = 0
                                        champion2_hp = champion2_hp - mage_damage_taken
                                        champion2_lastRoundDamageTaken_list.append(mage_damage_taken)
                                        if champion2_hp < 0:
                                            champion2_hp = 0
                                else:
                                    champion2_hp = champion2_hp - self.calculate_ai_damage(2, 3, 0)
                                    champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 3, 1))
                                    if champion2_hp < 0:
                                        champion2_hp = 0
                                if champion2_bush_armour != 0:
                                    ai3_hp = ai3_hp - 200
                                    self.apply_thornsDot(3, 1)
                                if ai3_hp < 0:
                                    ai3_hp = 0
                            if CHAMPION_LIST[2] in ai3_attack_intention:
                                if len(champion3_immunity) != 0:
                                    immune_list = []
                                    for immune in champion3_immunity:
                                        if immune == "Cocoon":
                                            champion3_hp = champion3_hp
                                        elif immune == "Block":
                                            if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                                champion1_hp = champion1_hp - self.calculate_ai_damage(1, 3, 0)
                                                champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 3, 1))
                                                if champion1_hp < 0:
                                                    champion1_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                                champion2_hp = champion2_hp - self.calculate_ai_damage(2, 3, 0)
                                                champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 3, 1))
                                                if champion2_hp < 0:
                                                    champion2_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                                champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 3, 0) * 0.5)
                                                champion3_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(3, 3, 1) * 0.5))
                                                if champion3_hp < 0:
                                                    champion3_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                                champion4_hp = champion4_hp - self.calculate_ai_damage(4, 3, 0)
                                                champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 3, 1))
                                                if champion4_hp < 0:
                                                    champion4_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                                champion5_hp = champion5_hp - self.calculate_ai_damage(5, 3, 0)
                                                champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 3, 1))
                                                if champion5_hp < 0:
                                                    champion5_hp = 0
                                        elif immune == "Evasive Manoeuvres":
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                elif CHAMPION_LIST[0] == MONK.title:
                                    bauble_damage = self.calculate_ai_damage(3, 3, 0)
                                    bauble_unavailable_check = 0
                                    if monk_bauble_damage_list1[1] == 0:
                                        monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list2[1] == 0:
                                            monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            if monk_bauble_damage_list3[1] == 0:
                                                monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                            else:
                                                bauble_unavailable_check = 1
                                    monk_damage_taken = 0
                                    if monk_bauble_damage_list1[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                    if monk_bauble_damage_list2[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                    if monk_bauble_damage_list3[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                    if bauble_unavailable_check == 1:
                                        monk_damage_taken = monk_damage_taken + bauble_damage
                                    champion3_hp = champion3_hp - math.ceil(monk_damage_taken)
                                    champion3_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                    if champion3_hp < 0:
                                        champion3_hp = 0
                                elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                    ai_hit_fencer_range = random.randint(1, 100)
                                    if ai_hit_fencer_range <= ai3_fencer_dodgechance:
                                        if AI_SIZE == "Tiny":
                                            champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 3, 0) * 0.5)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 3, 1) * 0.5)
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Small":
                                            champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 3, 0) * 0.6)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 3, 1) * 0.6)
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Medium":
                                            champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 3, 0) * 0.7)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 3, 1) * 0.7)
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Large":
                                            champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 3, 0) * 0.8)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 3, 1) * 0.8)
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Huge":
                                            champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 3, 0) * 0.9)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 3, 1) * 0.9)
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                    else:
                                        champion3_hp = champion3_hp - self.calculate_ai_damage(3, 3, 0)
                                        champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 3, 1))
                                        if champion3_hp < 0:
                                            champion3_hp = 0
                                elif CHAMPION_LIST[0] == POWER_CONDUIT.title:
                                    champion3_hp = champion3_hp - self.calculate_ai_damage(3, 3, 0)
                                    champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 3, 1))
                                    if champion3_hp < 0:
                                        champion3_hp = 0
                                    ai3_hp = ai3_hp - 750
                                    if ai3_hp < 0:
                                        ai3_hp = 0
                                elif CHAMPION_LIST[0] == ACADEMIC_MAGE.title:
                                    mage_damage_taken = math.ceil(self.calculate_ai_damage(3, 3, 0) - champion3_magical_barrier)
                                    if mage_damage_taken < 0:
                                        champion3_magical_barrier = mage_damage_taken * -1
                                    else:
                                        champion3_magical_barrier = 0
                                        champion3_hp = champion3_hp - mage_damage_taken
                                        champion3_lastRoundDamageTaken_list.append(mage_damage_taken)
                                        if champion3_hp < 0:
                                            champion3_hp = 0
                                else:
                                    champion3_hp = champion3_hp - self.calculate_ai_damage(3, 3, 0)
                                    champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 3, 1))
                                    if champion3_hp < 0:
                                        champion3_hp = 0
                                if champion3_bush_armour != 0:
                                    ai3_hp = ai3_hp - 200
                                    self.apply_thornsDot(3, 1)
                                if ai3_hp < 0:
                                    ai3_hp = 0
                            if CHAMPION_LIST[3] in ai3_attack_intention:
                                if len(champion4_immunity) != 0:
                                    immune_list = []
                                    for immune in champion4_immunity:
                                        if immune == "Cocoon":
                                            champion4_hp = champion4_hp
                                        elif immune == "Block":
                                            if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                                champion1_hp = champion1_hp - self.calculate_ai_damage(1, 3, 0)
                                                champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 3, 1))
                                                if champion1_hp < 0:
                                                    champion1_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                                champion2_hp = champion2_hp - self.calculate_ai_damage(2, 3, 0)
                                                champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 3, 1))
                                                if champion2_hp < 0:
                                                    champion2_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                                champion3_hp = champion3_hp - self.calculate_ai_damage(3, 3, 0)
                                                champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 3, 1))
                                                if champion3_hp < 0:
                                                    champion3_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                                champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 3, 0) * 0.5)
                                                champion4_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(4, 3, 1) * 0.5))
                                                if champion4_hp < 0:
                                                    champion4_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                                champion5_hp = champion5_hp - self.calculate_ai_damage(5, 3, 0)
                                                champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 3, 1))
                                                if champion5_hp < 0:
                                                    champion5_hp = 0
                                        elif immune == "Evasive Manoeuvres":
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                elif CHAMPION_LIST[0] == MONK.title:
                                    bauble_damage = self.calculate_ai_damage(4, 3, 0)
                                    bauble_unavailable_check = 0
                                    if monk_bauble_damage_list1[1] == 0:
                                        monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list2[1] == 0:
                                            monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            if monk_bauble_damage_list3[1] == 0:
                                                monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                            else:
                                                bauble_unavailable_check = 1
                                    monk_damage_taken = 0
                                    if monk_bauble_damage_list1[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                    if monk_bauble_damage_list2[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                    if monk_bauble_damage_list3[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                    if bauble_unavailable_check == 1:
                                        monk_damage_taken = monk_damage_taken + bauble_damage
                                    champion4_hp = champion4_hp - math.ceil(monk_damage_taken)
                                    champion4_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                    if champion4_hp < 0:
                                        champion4_hp = 0
                                elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                    ai_hit_fencer_range = random.randint(1, 100)
                                    if ai_hit_fencer_range <= ai3_fencer_dodgechance:
                                        if AI_SIZE == "Tiny":
                                            champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 3, 0) * 0.5)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 3, 1) * 0.5)
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Small":
                                            champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 3, 0) * 0.6)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 3, 1) * 0.6)
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Medium":
                                            champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 3, 0) * 0.7)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 3, 1) * 0.7)
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Large":
                                            champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 3, 0) * 0.8)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 3, 1) * 0.8)
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Huge":
                                            champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 3, 0) * 0.9)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 3, 1) * 0.9)
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                    else:
                                        champion4_hp = champion4_hp - self.calculate_ai_damage(4, 3, 0)
                                        champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 3, 1))
                                        if champion4_hp < 0:
                                            champion4_hp = 0
                                elif CHAMPION_LIST[0] == POWER_CONDUIT.title:
                                    champion4_hp = champion4_hp - self.calculate_ai_damage(4, 3, 0)
                                    champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 3, 1))
                                    if champion4_hp < 0:
                                        champion4_hp = 0
                                    ai3_hp = ai3_hp - 750
                                    if ai3_hp < 0:
                                        ai3_hp = 0
                                elif CHAMPION_LIST[0] == ACADEMIC_MAGE.title:
                                    mage_damage_taken = math.ceil(self.calculate_ai_damage(4, 3, 0) - champion4_magical_barrier)
                                    if mage_damage_taken < 0:
                                        champion4_magical_barrier = mage_damage_taken * -1
                                    else:
                                        champion4_magical_barrier = 0
                                        champion4_hp = champion4_hp - mage_damage_taken
                                        champion4_lastRoundDamageTaken_list.append(mage_damage_taken)
                                        if champion4_hp < 0:
                                            champion4_hp = 0
                                else:
                                    champion4_hp = champion4_hp - self.calculate_ai_damage(4, 3, 0)
                                    champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 3, 1))
                                    if champion4_hp < 0:
                                        champion4_hp = 0
                                if champion4_bush_armour != 0:
                                    ai3_hp = ai3_hp - 200
                                    self.apply_thornsDot(3, 1)
                                if ai3_hp < 0:
                                    ai3_hp = 0
                            if CHAMPION_LIST[4] in ai3_attack_intention:
                                if len(champion5_immunity) != 0:
                                    immune_list = []
                                    for immune in champion5_immunity:
                                        if immune == "Cocoon":
                                            champion5_hp = champion5_hp
                                        elif immune == "Block":
                                            if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                                champion1_hp = champion1_hp - self.calculate_ai_damage(1, 3, 0)
                                                champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 3, 1))
                                                if champion1_hp < 0:
                                                    champion1_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                                champion2_hp = champion2_hp - self.calculate_ai_damage(2, 3, 0)
                                                champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 3, 1))
                                                if champion2_hp < 0:
                                                    champion2_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                                champion3_hp = champion3_hp - self.calculate_ai_damage(3, 3, 0)
                                                champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 3, 1))
                                                if champion3_hp < 0:
                                                    champion3_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                                champion4_hp = champion4_hp - self.calculate_ai_damage(4, 3, 0)
                                                champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 3, 1))
                                                if champion4_hp < 0:
                                                    champion4_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                                champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 3, 0) * 0.5)
                                                champion5_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(5, 3, 1) * 0.5))
                                                if champion5_hp < 0:
                                                    champion5_hp = 0
                                        elif immune == "Evasive Manoeuvres":
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                elif CHAMPION_LIST[0] == MONK.title:
                                    bauble_damage = self.calculate_ai_damage(5, 3, 0)
                                    bauble_unavailable_check = 0
                                    if monk_bauble_damage_list1[1] == 0:
                                        monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list2[1] == 0:
                                            monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            if monk_bauble_damage_list3[1] == 0:
                                                monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                            else:
                                                bauble_unavailable_check = 1
                                    monk_damage_taken = 0
                                    if monk_bauble_damage_list1[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                    if monk_bauble_damage_list2[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                    if monk_bauble_damage_list3[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                    if bauble_unavailable_check == 1:
                                        monk_damage_taken = monk_damage_taken + bauble_damage
                                    champion5_hp = champion5_hp - math.ceil(monk_damage_taken)
                                    champion5_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                    if champion5_hp < 0:
                                        champion5_hp = 0
                                elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                    ai_hit_fencer_range = random.randint(1, 100)
                                    if ai_hit_fencer_range <= ai3_fencer_dodgechance:
                                        if AI_SIZE == "Tiny":
                                            champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 3, 0) * 0.5)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 3, 1) * 0.5)
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Small":
                                            champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 3, 0) * 0.6)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 3, 1) * 0.6)
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Medium":
                                            champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 3, 0) * 0.7)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 3, 1) * 0.7)
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Large":
                                            champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 3, 0) * 0.8)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 3, 1) * 0.8)
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Huge":
                                            champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 3, 0) * 0.9)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 3, 1) * 0.9)
                                            self.apply_taunt(3, MASTER_FENCER.title, 1)
                                    else:
                                        champion5_hp = champion5_hp - self.calculate_ai_damage(5, 3, 0)
                                        champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 3, 1))
                                        if champion5_hp < 0:
                                            champion5_hp = 0
                                elif CHAMPION_LIST[0] == POWER_CONDUIT.title:
                                    champion5_hp = champion5_hp - self.calculate_ai_damage(5, 3, 0)
                                    champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 3, 1))
                                    if champion5_hp < 0:
                                        champion5_hp = 0
                                    ai3_hp = ai3_hp - 750
                                    if ai3_hp < 0:
                                        ai3_hp = 0
                                elif CHAMPION_LIST[0] == ACADEMIC_MAGE.title:
                                    mage_damage_taken = math.ceil(self.calculate_ai_damage(5, 3, 0) - champion5_magical_barrier)
                                    if mage_damage_taken < 0:
                                        champion5_magical_barrier = mage_damage_taken * -1
                                    else:
                                        champion5_magical_barrier = 0
                                        champion5_hp = champion5_hp - mage_damage_taken
                                        champion5_lastRoundDamageTaken_list.append(mage_damage_taken)
                                        if champion5_hp < 0:
                                            champion5_hp = 0
                                else:
                                    champion5_hp = champion5_hp - self.calculate_ai_damage(5, 3, 0)
                                    champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 3, 1))
                                    if champion5_hp < 0:
                                        champion5_hp = 0
                                if champion5_bush_armour != 0:
                                    ai3_hp = ai3_hp - 200
                                    self.apply_thornsDot(3, 1)
                                if ai3_hp < 0:
                                    ai3_hp = 0
                if monster_var == 4:
                    if ai4_hp == 0:
                        continue
                    if ai4_thornsDot[1] != 0:
                        ai4_hp = ai4_hp - ai4_thornsDot[0] * ai4_thornsDot[1]
                        if ai4_hp < 0:
                            ai4_hp = 0
                            continue
                    if ai4_burnDot[1] != 0:
                        ai4_hp = ai4_hp - ai4_burnDot[0]
                        ai4_burnDot[1] = ai4_burnDot[1] - 1
                        if ai4_hp < 0:
                            ai4_hp = 0
                            continue
                    if ai4_serraSlashDot[1] != 0:
                        ai4_hp = ai4_hp - self.calculate_bleed_damage("Serrated", 4)
                        ai4_serraSlashDot[1] = ai4_serraSlashDot[1] - 1
                        if ai4_hp < 0:
                            ai4_hp = 0
                            continue
                    if ai4_eviscerDot[1] != 0:
                        ai4_hp = ai4_hp - self.calculate_bleed_damage("Eviscerated", 4)
                        ai4_eviscerDot[1] = ai4_eviscerDot[1] - 1
                        if ai4_hp < 0:
                            ai4_hp = 0
                            continue
                    if ai4_garroteDot[1] != 0:
                        ai4_hp = ai4_hp - self.calculate_bleed_damage("Garroted", 4)
                        ai4_garroteDot[1] = ai4_garroteDot[1] - 1
                        if ai4_hp < 0:
                            ai4_hp = 0
                            continue
                    if ai4_rottingDot[1] != 0:
                        ai4_hp = ai4_hp - ai4_rottingDot[0]
                        self.apply_toc(4)
                        ai4_rottingDot[1] = ai4_rottingDot[1] - 1
                        if ai4_hp < 0:
                            ai4_hp = 0
                            continue
                    if ai4_shimmerDot[1] != 0:
                        ai4_hp = ai4_hp - ai4_shimmerDot[0]
                        ai4_shimmerDot[1] = ai4_shimmerDot[1] - 1
                        if champion1_hp > 0:
                            self.check_champion_blessing(1, ai4_shimmerDot[0])
                        if champion2_hp > 0:
                            self.check_champion_blessing(2, ai4_shimmerDot[0])
                        if champion3_hp > 0:
                            self.check_champion_blessing(3, ai4_shimmerDot[0])
                        if champion4_hp > 0:
                            self.check_champion_blessing(4, ai4_shimmerDot[0])
                        if champion5_hp > 0:
                            self.check_champion_blessing(5, ai4_shimmerDot[0])
                        if ai4_hp < 0:
                            ai4_hp = 0
                            continue
                    if ai4_divineDot[1] != 0:
                        ai4_hp = ai4_hp - ai4_divineDot[0]
                        ai4_divineDot[1] = ai4_divineDot[1] - 1
                        if champion1_hp > 0:
                            self.check_champion_blessing(1, ai4_divineDot[0])
                        if champion2_hp > 0:
                            self.check_champion_blessing(2, ai4_divineDot[0])
                        if champion3_hp > 0:
                            self.check_champion_blessing(3, ai4_divineDot[0])
                        if champion4_hp > 0:
                            self.check_champion_blessing(4, ai4_divineDot[0])
                        if champion5_hp > 0:
                            self.check_champion_blessing(5, ai4_divineDot[0])
                        if ai4_hp < 0:
                            ai4_hp = 0
                            continue
                    if ai4_barbedArrDot[1] != 0:
                        ai4_hp = ai4_hp - ai4_barbedArrDot[0]
                        ai4_barbedArrDot[1] = ai4_barbedArrDot[1] - 1
                        if ai4_hp < 0:
                            ai4_hp = 0
                            continue
                    if ai4_damnation[1] != 0:
                        ai4_damnation[1] = ai4_damnation[1] - 1
                        if ai4_damnation[1] == 0:
                            ai4_hp = ai4_hp - ai4_damnation[0]
                            if ai4_hp < 0:
                                ai4_hp = 0
                    if ai4_hp == 0:
                        continue
                    if ai4_stun != 0:
                        continue
                    if ai4_taunt[1] != 0:
                        if ai4_taunt[0] in CHAMPION_LIST[0]:
                            if len(champion1_immunity) != 0:
                                immune_list = []
                                for immune in champion1_immunity:
                                    if immune == "Cocoon":
                                        champion1_hp = champion1_hp
                                    elif immune == "Block":
                                        if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                            champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 4, 0) * 0.5)
                                            champion1_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(1, 4, 1) * 0.5))
                                            if champion1_hp < 0:
                                                champion1_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                            champion2_hp = champion2_hp - self.calculate_ai_damage(2, 4, 0)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 4, 1))
                                            if champion2_hp < 0:
                                                champion2_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                            champion3_hp = champion3_hp - self.calculate_ai_damage(3, 4, 0)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 4, 1))
                                            if champion3_hp < 0:
                                                champion3_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                            champion4_hp = champion4_hp - self.calculate_ai_damage(4, 4, 0)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 4, 1))
                                            if champion4_hp < 0:
                                                champion4_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                            champion5_hp = champion5_hp - self.calculate_ai_damage(5, 4, 0)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 4, 1))
                                            if champion5_hp < 0:
                                                champion5_hp = 0
                                    elif immune == "Evasive Manoeuvres":
                                        self.apply_taunt(4, MASTER_FENCER.title, 1)
                            elif CHAMPION_LIST[0] == MONK.title:
                                bauble_damage = self.calculate_ai_damage(1, 4, 0)
                                bauble_unavailable_check = 0
                                if monk_bauble_damage_list1[1] == 0:
                                    monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                else:
                                    if monk_bauble_damage_list2[1] == 0:
                                        monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list3[1] == 0:
                                            monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            bauble_unavailable_check = 1
                                monk_damage_taken = 0
                                if monk_bauble_damage_list1[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                if monk_bauble_damage_list2[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                if monk_bauble_damage_list3[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                if bauble_unavailable_check == 1:
                                    monk_damage_taken = monk_damage_taken + bauble_damage
                                champion1_hp = champion1_hp - math.ceil(monk_damage_taken)
                                champion1_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                if champion1_hp < 0:
                                    champion1_hp = 0
                            elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                ai_hit_fencer_range = random.randint(1, 100)
                                if ai_hit_fencer_range <= ai4_fencer_dodgechance:
                                    if AI_SIZE == "Tiny":
                                        champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 4, 0) * 0.5)
                                        champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 4, 1) * 0.5)
                                        self.apply_taunt(4, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Small":
                                        champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 4, 0) * 0.6)
                                        champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 4, 1) * 0.6)
                                        self.apply_taunt(4, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Medium":
                                        champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 4, 0) * 0.7)
                                        champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 4, 1) * 0.7)
                                        self.apply_taunt(4, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Large":
                                        champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 4, 0) * 0.8)
                                        champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 4, 1) * 0.8)
                                        self.apply_taunt(4, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Huge":
                                        champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 4, 0) * 0.9)
                                        champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 4, 1) * 0.9)
                                        self.apply_taunt(4, MASTER_FENCER.title, 1)
                                else:
                                    champion1_hp = champion1_hp - self.calculate_ai_damage(1, 4, 0)
                                    champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 4, 1))
                                    if champion1_hp < 0:
                                        champion1_hp = 0
                            else:
                                champion1_hp = champion1_hp - self.calculate_ai_damage(1, 4, 0)
                                champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 4, 1))
                                if champion1_hp < 0:
                                    champion1_hp = 0
                            if champion1_bush_armour != 0:
                                ai4_hp = ai4_hp - 200
                                self.apply_thornsDot(1, 4)
                            if ai4_hp < 0:
                                ai4_hp = 0
                        elif ai4_taunt[0] in CHAMPION_LIST[1]:
                            if len(champion2_immunity) != 0:
                                immune_list = []
                                for immune in champion2_immunity:
                                    if immune == "Cocoon":
                                        champion2_hp = champion2_hp
                                    elif immune == "Block":
                                        if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                            champion1_hp = champion1_hp - self.calculate_ai_damage(1, 4, 0)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 4, 1))
                                            if champion1_hp < 0:
                                                champion1_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                            champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 4, 0) * 0.5)
                                            champion2_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(2, 4, 1) * 0.5))
                                            if champion2_hp < 0:
                                                champion2_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                            champion3_hp = champion3_hp - self.calculate_ai_damage(3, 4, 0)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 4, 1))
                                            if champion3_hp < 0:
                                                champion3_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                            champion4_hp = champion4_hp - self.calculate_ai_damage(4, 4, 0)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 4, 1))
                                            if champion4_hp < 0:
                                                champion4_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                            champion5_hp = champion5_hp - self.calculate_ai_damage(5, 4, 0)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 4, 1))
                                            if champion5_hp < 0:
                                                champion5_hp = 0
                                    elif immune == "Evasive Manoeuvres":
                                        self.apply_taunt(4, MASTER_FENCER.title, 1)
                            elif CHAMPION_LIST[0] == MONK.title:
                                bauble_damage = self.calculate_ai_damage(2, 4, 0)
                                bauble_unavailable_check = 0
                                if monk_bauble_damage_list1[1] == 0:
                                    monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                else:
                                    if monk_bauble_damage_list2[1] == 0:
                                        monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list3[1] == 0:
                                            monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            bauble_unavailable_check = 1
                                monk_damage_taken = 0
                                if monk_bauble_damage_list1[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                if monk_bauble_damage_list2[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                if monk_bauble_damage_list3[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                if bauble_unavailable_check == 1:
                                    monk_damage_taken = monk_damage_taken + bauble_damage
                                champion2_hp = champion2_hp - math.ceil(monk_damage_taken)
                                champion2_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                if champion2_hp < 0:
                                    champion2_hp = 0
                            elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                ai_hit_fencer_range = random.randint(1, 100)
                                if ai_hit_fencer_range <= ai4_fencer_dodgechance:
                                    if AI_SIZE == "Tiny":
                                        champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 4, 0) * 0.5)
                                        champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 4, 1) * 0.5)
                                        self.apply_taunt(4, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Small":
                                        champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 4, 0) * 0.6)
                                        champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 4, 1) * 0.6)
                                        self.apply_taunt(4, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Medium":
                                        champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 4, 0) * 0.7)
                                        champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 4, 1) * 0.7)
                                        self.apply_taunt(4, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Large":
                                        champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 4, 0) * 0.8)
                                        champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 4, 1) * 0.8)
                                        self.apply_taunt(4, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Huge":
                                        champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 4, 0) * 0.9)
                                        champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 4, 1) * 0.9)
                                        self.apply_taunt(4, MASTER_FENCER.title, 1)
                                else:
                                    champion2_hp = champion2_hp - self.calculate_ai_damage(2, 4, 0)
                                    champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 4, 1))
                                    if champion2_hp < 0:
                                        champion2_hp = 0
                            else:
                                champion2_hp = champion2_hp - self.calculate_ai_damage(2, 4, 0)
                                champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 4, 1))
                                if champion2_hp < 0:
                                    champion2_hp = 0
                            if champion2_bush_armour != 0:
                                ai4_hp = ai4_hp - 200
                                self.apply_thornsDot(1, 4)
                            if ai4_hp < 0:
                                ai4_hp = 0
                        elif ai4_taunt[0] in CHAMPION_LIST[2]:
                            if len(champion3_immunity) != 0:
                                immune_list = []
                                for immune in champion3_immunity:
                                    if immune == "Cocoon":
                                        champion3_hp = champion3_hp
                                    elif immune == "Block":
                                        if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                            champion1_hp = champion1_hp - self.calculate_ai_damage(1, 4, 0)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 4, 1))
                                            if champion1_hp < 0:
                                                champion1_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                            champion2_hp = champion2_hp - self.calculate_ai_damage(2, 4, 0)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 4, 1))
                                            if champion2_hp < 0:
                                                champion2_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                            champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 4, 0) * 0.5)
                                            champion3_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(3, 4, 1) * 0.5))
                                            if champion3_hp < 0:
                                                champion3_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                            champion4_hp = champion4_hp - self.calculate_ai_damage(4, 4, 0)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 4, 1))
                                            if champion4_hp < 0:
                                                champion4_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                            champion5_hp = champion5_hp - self.calculate_ai_damage(5, 4, 0)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 4, 1))
                                            if champion5_hp < 0:
                                                champion5_hp = 0
                                    elif immune == "Evasive Manoeuvres":
                                        self.apply_taunt(4, MASTER_FENCER.title, 1)
                            elif CHAMPION_LIST[0] == MONK.title:
                                bauble_damage = self.calculate_ai_damage(3, 4)
                                bauble_unavailable_check = 0
                                if monk_bauble_damage_list1[1] == 0:
                                    monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                else:
                                    if monk_bauble_damage_list2[1] == 0:
                                        monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list3[1] == 0:
                                            monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            bauble_unavailable_check = 1
                                monk_damage_taken = 0
                                if monk_bauble_damage_list1[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                if monk_bauble_damage_list2[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                if monk_bauble_damage_list3[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                if bauble_unavailable_check == 1:
                                    monk_damage_taken = monk_damage_taken + bauble_damage
                                champion3_hp = champion3_hp - math.ceil(monk_damage_taken)
                                champion3_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                if champion3_hp < 0:
                                    champion3_hp = 0
                            elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                ai_hit_fencer_range = random.randint(1, 100)
                                if ai_hit_fencer_range <= ai4_fencer_dodgechance:
                                    if AI_SIZE == "Tiny":
                                        champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 4, 0) * 0.5)
                                        champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 4, 1) * 0.5)
                                        self.apply_taunt(4, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Small":
                                        champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 4, 0) * 0.6)
                                        champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 4, 1) * 0.6)
                                        self.apply_taunt(4, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Medium":
                                        champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 4, 0) * 0.7)
                                        champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 4, 1) * 0.7)
                                        self.apply_taunt(4, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Large":
                                        champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 4, 0) * 0.8)
                                        champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 4, 1) * 0.8)
                                        self.apply_taunt(4, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Huge":
                                        champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 4, 0) * 0.9)
                                        champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 4, 1) * 0.9)
                                        self.apply_taunt(4, MASTER_FENCER.title, 1)
                                else:
                                    champion3_hp = champion3_hp - self.calculate_ai_damage(3, 4, 0)
                                    champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 4, 1))
                                    if champion3_hp < 0:
                                        champion3_hp = 0
                            else:
                                champion3_hp = champion3_hp - self.calculate_ai_damage(3, 4, 0)
                                champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 4, 1))
                                if champion3_hp < 0:
                                    champion3_hp = 0
                            if champion3_bush_armour != 0:
                                ai4_hp = ai4_hp - 200
                                self.apply_thornsDot(1, 4)
                            if ai4_hp < 0:
                                ai4_hp = 0
                        elif ai4_taunt[0] in CHAMPION_LIST[3]:
                            if len(champion4_immunity) != 0:
                                immune_list = []
                                for immune in champion4_immunity:
                                    if immune == "Cocoon":
                                        champion4_hp = champion4_hp
                                    elif immune == "Block":
                                        if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                            champion1_hp = champion1_hp - self.calculate_ai_damage(1, 4, 0)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 4, 1))
                                            if champion1_hp < 0:
                                                champion1_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                            champion2_hp = champion2_hp - self.calculate_ai_damage(2, 4, 0)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 4, 1))
                                            if champion2_hp < 0:
                                                champion2_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                            champion3_hp = champion3_hp - self.calculate_ai_damage(3, 4, 0)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 4, 1))
                                            if champion3_hp < 0:
                                                champion3_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                            champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 4, 0) * 0.5)
                                            champion4_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(4, 4, 1) * 0.5))
                                            if champion4_hp < 0:
                                                champion4_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                            champion5_hp = champion5_hp - self.calculate_ai_damage(5, 4, 0)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 4, 1))
                                            if champion5_hp < 0:
                                                champion5_hp = 0
                                    elif immune == "Evasive Manoeuvres":
                                        self.apply_taunt(4, MASTER_FENCER.title, 1)
                            elif CHAMPION_LIST[0] == MONK.title:
                                bauble_damage = self.calculate_ai_damage(4, 4, 0)
                                bauble_unavailable_check = 0
                                if monk_bauble_damage_list1[1] == 0:
                                    monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                else:
                                    if monk_bauble_damage_list2[1] == 0:
                                        monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list3[1] == 0:
                                            monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            bauble_unavailable_check = 1
                                monk_damage_taken = 0
                                if monk_bauble_damage_list1[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                if monk_bauble_damage_list2[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                if monk_bauble_damage_list3[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                if bauble_unavailable_check == 1:
                                    monk_damage_taken = monk_damage_taken + bauble_damage
                                champion4_hp = champion4_hp - math.ceil(monk_damage_taken)
                                champion4_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                if champion4_hp < 0:
                                    champion4_hp = 0
                            elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                ai_hit_fencer_range = random.randint(1, 100)
                                if ai_hit_fencer_range <= ai4_fencer_dodgechance:
                                    if AI_SIZE == "Tiny":
                                        champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 4, 0) * 0.5)
                                        champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 4, 1) * 0.5)
                                        self.apply_taunt(4, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Small":
                                        champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 4, 0) * 0.6)
                                        champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 4, 1) * 0.6)
                                        self.apply_taunt(4, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Medium":
                                        champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 4, 0) * 0.7)
                                        champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 4, 1) * 0.7)
                                        self.apply_taunt(4, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Large":
                                        champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 4, 0) * 0.8)
                                        champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 4, 1) * 0.8)
                                        self.apply_taunt(4, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Huge":
                                        champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 4, 0) * 0.9)
                                        champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 4, 1) * 0.9)
                                        self.apply_taunt(4, MASTER_FENCER.title, 1)
                                else:
                                    champion4_hp = champion4_hp - self.calculate_ai_damage(4, 4, 0)
                                    champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 4, 1))
                                    if champion4_hp < 0:
                                        champion4_hp = 0
                            else:
                                champion4_hp = champion4_hp - self.calculate_ai_damage(4, 4, 0)
                                champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 4, 1))
                                if champion4_hp < 0:
                                    champion4_hp = 0
                            if champion4_bush_armour != 0:
                                ai4_hp = ai4_hp - 200
                                self.apply_thornsDot(1, 4)
                            if ai4_hp < 0:
                                ai4_hp = 0
                        elif ai4_taunt[0] in CHAMPION_LIST[4]:
                            if len(champion5_immunity) != 0:
                                immune_list = []
                                for immune in champion5_immunity:
                                    if immune == "Cocoon":
                                        champion5_hp = champion5_hp
                                    elif immune == "Block":
                                        if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                            champion1_hp = champion1_hp - self.calculate_ai_damage(1, 4, 0)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 4, 1))
                                            if champion1_hp < 0:
                                                champion1_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                            champion2_hp = champion2_hp - self.calculate_ai_damage(2, 4, 0)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 4, 1))
                                            if champion2_hp < 0:
                                                champion2_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                            champion3_hp = champion3_hp - self.calculate_ai_damage(3, 4, 0)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 4, 1))
                                            if champion3_hp < 0:
                                                champion3_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                            champion4_hp = champion4_hp - self.calculate_ai_damage(4, 4, 0)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 4, 1))
                                            if champion4_hp < 0:
                                                champion4_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                            champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 4, 0) * 0.5)
                                            champion5_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(5, 4, 0) * 0.5))
                                            if champion5_hp < 0:
                                                champion5_hp = 0
                                    elif immune == "Evasive Manoeuvres":
                                        self.apply_taunt(4, MASTER_FENCER.title, 1)
                            elif CHAMPION_LIST[0] == MONK.title:
                                bauble_damage = self.calculate_ai_damage(5, 4, 0)
                                bauble_unavailable_check = 0
                                if monk_bauble_damage_list1[1] == 0:
                                    monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                else:
                                    if monk_bauble_damage_list2[1] == 0:
                                        monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list3[1] == 0:
                                            monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            bauble_unavailable_check = 1
                                monk_damage_taken = 0
                                if monk_bauble_damage_list1[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                if monk_bauble_damage_list2[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                if monk_bauble_damage_list3[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                if bauble_unavailable_check == 1:
                                    monk_damage_taken = monk_damage_taken + bauble_damage
                                champion5_hp = champion5_hp - math.ceil(monk_damage_taken)
                                champion5_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                if champion5_hp < 0:
                                    champion5_hp = 0
                            elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                ai_hit_fencer_range = random.randint(1, 100)
                                if ai_hit_fencer_range <= ai4_fencer_dodgechance:
                                    if AI_SIZE == "Tiny":
                                        champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 4, 0) * 0.5)
                                        champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 4, 1) * 0.5)
                                        self.apply_taunt(4, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Small":
                                        champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 4, 0) * 0.6)
                                        champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 4, 1) * 0.6)
                                        self.apply_taunt(4, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Medium":
                                        champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 4, 0) * 0.7)
                                        champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 4, 1) * 0.7)
                                        self.apply_taunt(4, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Large":
                                        champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 4, 0) * 0.8)
                                        champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 4, 1) * 0.8)
                                        self.apply_taunt(4, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Huge":
                                        champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 4, 0) * 0.9)
                                        champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 4, 1) * 0.9)
                                        self.apply_taunt(4, MASTER_FENCER.title, 1)
                                else:
                                    champion5_hp = champion5_hp - self.calculate_ai_damage(5, 4, 0)
                                    champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 4, 1))
                                    if champion5_hp < 0:
                                        champion5_hp = 0
                            else:
                                champion5_hp = champion5_hp - self.calculate_ai_damage(5, 4, 0)
                                champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 4, 1))
                                if champion5_hp < 0:
                                    champion5_hp = 0
                            if champion5_bush_armour != 0:
                                ai4_hp = ai4_hp - 200
                                self.apply_thornsDot(1, 4)
                            if ai4_hp < 0:
                                ai4_hp = 0
                    else:
                        if "Everyone" in ai4_attack_intention:
                            if champion1_hp != 0:
                                if len(champion1_immunity) != 0:
                                    immune_list = []
                                    for immune in champion1_immunity:
                                        if immune == "Cocoon":
                                            champion1_hp = champion1_hp
                                        elif immune == "Block":
                                            if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                                champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 4, 0) * 0.5)
                                                champion1_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(1, 4, 1) * 0.5))
                                                if champion1_hp < 0:
                                                    champion1_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                                champion2_hp = champion2_hp - self.calculate_ai_damage(2, 4, 0)
                                                champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 4, 1))
                                                if champion2_hp < 0:
                                                    champion2_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                                champion3_hp = champion3_hp - self.calculate_ai_damage(3, 4, 0)
                                                champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 4, 1))
                                                if champion3_hp < 0:
                                                    champion3_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                                champion4_hp = champion4_hp - self.calculate_ai_damage(4, 4, 0)
                                                champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 4, 1))
                                                if champion4_hp < 0:
                                                    champion4_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                                champion5_hp = champion5_hp - self.calculate_ai_damage(5, 4, 0)
                                                champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 4, 1))
                                                if champion5_hp < 0:
                                                    champion5_hp = 0
                                        elif immune == "Evasive Manoeuvres":
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                elif CHAMPION_LIST[0] == MONK.title:
                                    bauble_damage = self.calculate_ai_damage(1, 4, 0)
                                    bauble_unavailable_check = 0
                                    if monk_bauble_damage_list1[1] == 0:
                                        monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list2[1] == 0:
                                            monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            if monk_bauble_damage_list3[1] == 0:
                                                monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                            else:
                                                bauble_unavailable_check = 1
                                    monk_damage_taken = 0
                                    if monk_bauble_damage_list1[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                    if monk_bauble_damage_list2[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                    if monk_bauble_damage_list3[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                    if bauble_unavailable_check == 1:
                                        monk_damage_taken = monk_damage_taken + bauble_damage
                                    champion1_hp = champion1_hp - math.ceil(monk_damage_taken)
                                    champion1_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                    if champion1_hp < 0:
                                        champion1_hp = 0
                                elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                    ai_hit_fencer_range = random.randint(1, 100)
                                    if ai_hit_fencer_range <= ai4_fencer_dodgechance:
                                        if AI_SIZE == "Tiny":
                                            champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 4, 0) * 0.5)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 4, 1) * 0.5)
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Small":
                                            champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 4, 0) * 0.6)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 4, 1) * 0.6)
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Medium":
                                            champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 4, 0) * 0.7)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 4, 1) * 0.7)
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Large":
                                            champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 4, 0) * 0.8)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 4, 1) * 0.8)
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Huge":
                                            champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 4, 0) * 0.9)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 4, 1) * 0.9)
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                    else:
                                        champion1_hp = champion1_hp - self.calculate_ai_damage(1, 4, 0)
                                        champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 4, 1))
                                        if champion1_hp < 0:
                                            champion1_hp = 0
                                elif CHAMPION_LIST[0] == POWER_CONDUIT.title:
                                    champion1_hp = champion1_hp - self.calculate_ai_damage(1, 4, 0)
                                    champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 4, 1))
                                    if champion1_hp < 0:
                                        champion1_hp = 0
                                    ai4_hp = ai4_hp - 750
                                    if ai4_hp < 0:
                                        ai4_hp = 0
                                elif CHAMPION_LIST[0] == ACADEMIC_MAGE.title:
                                    mage_damage_taken = math.ceil(self.calculate_ai_damage(1, 4, 0) - champion1_magical_barrier)
                                    if mage_damage_taken < 0:
                                        champion1_magical_barrier = mage_damage_taken * -1
                                    else:
                                        champion1_magical_barrier = 0
                                        champion1_hp = champion1_hp - mage_damage_taken
                                        champion1_lastRoundDamageTaken_list.append(mage_damage_taken)
                                        if champion1_hp < 0:
                                            champion1_hp = 0
                                else:
                                    champion1_hp = champion1_hp - self.calculate_ai_damage(1, 4, 0)
                                    champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 4, 1))
                                    if champion1_hp < 0:
                                        champion1_hp = 0
                                if champion1_bush_armour != 0:
                                    ai4_hp = ai4_hp - 200
                                    self.apply_thornsDot(4, 1)
                                if ai4_hp < 0:
                                    ai4_hp = 0
                            if champion2_hp != 0:
                                if len(champion2_immunity) != 0:
                                    immune_list = []
                                    for immune in champion2_immunity:
                                        if immune == "Cocoon":
                                            champion2_hp = champion2_hp
                                        elif immune == "Block":
                                            if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                                champion1_hp = champion1_hp - self.calculate_ai_damage(1, 4, 0)
                                                champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 4, 1))
                                                if champion1_hp < 0:
                                                    champion1_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                                champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 4, 0) * 0.5)
                                                champion2_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(2, 4, 1) * 0.5))
                                                if champion2_hp < 0:
                                                    champion2_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                                champion3_hp = champion3_hp - self.calculate_ai_damage(3, 4, 0)
                                                champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 4, 1))
                                                if champion3_hp < 0:
                                                    champion3_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                                champion4_hp = champion4_hp - self.calculate_ai_damage(4, 4, 0)
                                                champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 4, 1))
                                                if champion4_hp < 0:
                                                    champion4_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                                champion5_hp = champion5_hp - self.calculate_ai_damage(5, 4, 0)
                                                champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 4, 1))
                                                if champion5_hp < 0:
                                                    champion5_hp = 0
                                        elif immune == "Evasive Manoeuvres":
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                elif CHAMPION_LIST[0] == MONK.title:
                                    bauble_damage = self.calculate_ai_damage(2, 4, 0)
                                    bauble_unavailable_check = 0
                                    if monk_bauble_damage_list1[1] == 0:
                                        monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list2[1] == 0:
                                            monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            if monk_bauble_damage_list3[1] == 0:
                                                monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                            else:
                                                bauble_unavailable_check = 1
                                    monk_damage_taken = 0
                                    if monk_bauble_damage_list1[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                    if monk_bauble_damage_list2[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                    if monk_bauble_damage_list3[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                    if bauble_unavailable_check == 1:
                                        monk_damage_taken = monk_damage_taken + bauble_damage
                                    champion2_hp = champion2_hp - math.ceil(monk_damage_taken)
                                    champion2_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                    if champion2_hp < 0:
                                        champion2_hp = 0
                                elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                    ai_hit_fencer_range = random.randint(1, 100)
                                    if ai_hit_fencer_range <= ai4_fencer_dodgechance:
                                        if AI_SIZE == "Tiny":
                                            champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 4, 0) * 0.5)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 4, 1) * 0.5)
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Small":
                                            champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 4, 0) * 0.6)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 4, 1) * 0.6)
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Medium":
                                            champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 4, 0) * 0.7)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 4, 1) * 0.7)
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Large":
                                            champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 4, 0) * 0.8)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 4, 1) * 0.8)
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Huge":
                                            champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 4, 0) * 0.9)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 4, 1) * 0.9)
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                    else:
                                        champion2_hp = champion2_hp - self.calculate_ai_damage(2, 4, 0)
                                        champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 4, 1))
                                        if champion2_hp < 0:
                                            champion2_hp = 0
                                elif CHAMPION_LIST[0] == POWER_CONDUIT.title:
                                    champion2_hp = champion2_hp - self.calculate_ai_damage(2, 4, 0)
                                    champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 4, 1))
                                    if champion2_hp < 0:
                                        champion2_hp = 0
                                    ai4_hp = ai4_hp - 750
                                    if ai4_hp < 0:
                                        ai4_hp = 0
                                elif CHAMPION_LIST[0] == ACADEMIC_MAGE.title:
                                    mage_damage_taken = math.ceil(self.calculate_ai_damage(2, 4, 0) - champion2_magical_barrier)
                                    if mage_damage_taken < 0:
                                        champion2_magical_barrier = mage_damage_taken * -1
                                    else:
                                        champion2_magical_barrier = 0
                                        champion2_hp = champion2_hp - mage_damage_taken
                                        champion2_lastRoundDamageTaken_list.append(mage_damage_taken)
                                        if champion2_hp < 0:
                                            champion2_hp = 0
                                else:
                                    champion2_hp = champion2_hp - self.calculate_ai_damage(2, 4, 0)
                                    champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 4, 1))
                                    if champion2_hp < 0:
                                        champion2_hp = 0
                                if champion2_bush_armour != 0:
                                    ai4_hp = ai4_hp - 200
                                    self.apply_thornsDot(4, 1)
                                if ai4_hp < 0:
                                    ai4_hp = 0
                            if champion3_hp != 0:
                                if len(champion3_immunity) != 0:
                                    immune_list = []
                                    for immune in champion3_immunity:
                                        if immune == "Cocoon":
                                            champion3_hp = champion3_hp
                                        elif immune == "Block":
                                            if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                                champion1_hp = champion1_hp - self.calculate_ai_damage(1, 4, 0)
                                                champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 4, 1))
                                                if champion1_hp < 0:
                                                    champion1_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                                champion2_hp = champion2_hp - self.calculate_ai_damage(2, 4, 0)
                                                champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 4, 1))
                                                if champion2_hp < 0:
                                                    champion2_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                                champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 4, 0) * 0.5)
                                                champion3_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(3, 4, 1) * 0.5))
                                                if champion3_hp < 0:
                                                    champion3_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                                champion4_hp = champion4_hp - self.calculate_ai_damage(4, 4, 0)
                                                champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 4, 1))
                                                if champion4_hp < 0:
                                                    champion4_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                                champion5_hp = champion5_hp - self.calculate_ai_damage(5, 4, 0)
                                                champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 4, 1))
                                                if champion5_hp < 0:
                                                    champion5_hp = 0
                                        elif immune == "Evasive Manoeuvres":
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                elif CHAMPION_LIST[0] == MONK.title:
                                    bauble_damage = self.calculate_ai_damage(3, 4, 0)
                                    bauble_unavailable_check = 0
                                    if monk_bauble_damage_list1[1] == 0:
                                        monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list2[1] == 0:
                                            monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            if monk_bauble_damage_list3[1] == 0:
                                                monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                            else:
                                                bauble_unavailable_check = 1
                                    monk_damage_taken = 0
                                    if monk_bauble_damage_list1[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                    if monk_bauble_damage_list2[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                    if monk_bauble_damage_list3[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                    if bauble_unavailable_check == 1:
                                        monk_damage_taken = monk_damage_taken + bauble_damage
                                    champion3_hp = champion3_hp - math.ceil(monk_damage_taken)
                                    champion3_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                    if champion3_hp < 0:
                                        champion3_hp = 0
                                elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                    ai_hit_fencer_range = random.randint(1, 100)
                                    if ai_hit_fencer_range <= ai4_fencer_dodgechance:
                                        if AI_SIZE == "Tiny":
                                            champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 4, 0) * 0.5)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 4, 1) * 0.5)
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Small":
                                            champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 4, 0) * 0.6)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 4, 1) * 0.6)
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Medium":
                                            champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 4, 0) * 0.7)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 4, 1) * 0.7)
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Large":
                                            champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 4, 0) * 0.8)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 4, 1) * 0.8)
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Huge":
                                            champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 4, 0) * 0.9)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 4, 1) * 0.9)
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                    else:
                                        champion3_hp = champion3_hp - self.calculate_ai_damage(3, 4, 0)
                                        champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 4, 1))
                                        if champion3_hp < 0:
                                            champion3_hp = 0
                                elif CHAMPION_LIST[0] == POWER_CONDUIT.title:
                                    champion3_hp = champion3_hp - self.calculate_ai_damage(3, 4, 0)
                                    champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 4, 1))
                                    if champion3_hp < 0:
                                        champion3_hp = 0
                                    ai4_hp = ai4_hp - 750
                                    if ai4_hp < 0:
                                        ai4_hp = 0
                                elif CHAMPION_LIST[0] == ACADEMIC_MAGE.title:
                                    mage_damage_taken = math.ceil(self.calculate_ai_damage(3, 4, 0) - champion3_magical_barrier)
                                    if mage_damage_taken < 0:
                                        champion3_magical_barrier = mage_damage_taken * -1
                                    else:
                                        champion3_magical_barrier = 0
                                        champion3_hp = champion3_hp - mage_damage_taken
                                        champion3_lastRoundDamageTaken_list.append(mage_damage_taken)
                                        if champion3_hp < 0:
                                            champion3_hp = 0
                                else:
                                    champion3_hp = champion3_hp - self.calculate_ai_damage(3, 4, 0)
                                    champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 4, 1))
                                    if champion3_hp < 0:
                                        champion3_hp = 0
                                if champion3_bush_armour != 0:
                                    ai4_hp = ai4_hp - 200
                                    self.apply_thornsDot(4, 1)
                                if ai4_hp < 0:
                                    ai4_hp = 0
                            if champion4_hp != 0:
                                if len(champion4_immunity) != 0:
                                    immune_list = []
                                    for immune in champion4_immunity:
                                        if immune == "Cocoon":
                                            champion4_hp = champion4_hp
                                        elif immune == "Block":
                                            if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                                champion1_hp = champion1_hp - self.calculate_ai_damage(1, 4, 0)
                                                champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 4, 1))
                                                if champion1_hp < 0:
                                                    champion1_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                                champion2_hp = champion2_hp - self.calculate_ai_damage(2, 4, 0)
                                                champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 4, 1))
                                                if champion2_hp < 0:
                                                    champion2_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                                champion3_hp = champion3_hp - self.calculate_ai_damage(3, 4, 0)
                                                champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 4, 1))
                                                if champion3_hp < 0:
                                                    champion3_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                                champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 4, 0) * 0.5)
                                                champion4_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(4, 4, 1) * 0.5))
                                                if champion4_hp < 0:
                                                    champion4_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                                champion5_hp = champion5_hp - self.calculate_ai_damage(5, 4, 0)
                                                champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 4, 1))
                                                if champion5_hp < 0:
                                                    champion5_hp = 0
                                        elif immune == "Evasive Manoeuvres":
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                elif CHAMPION_LIST[0] == MONK.title:
                                    bauble_damage = self.calculate_ai_damage(4, 4, 0)
                                    bauble_unavailable_check = 0
                                    if monk_bauble_damage_list1[1] == 0:
                                        monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list2[1] == 0:
                                            monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            if monk_bauble_damage_list3[1] == 0:
                                                monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                            else:
                                                bauble_unavailable_check = 1
                                    monk_damage_taken = 0
                                    if monk_bauble_damage_list1[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                    if monk_bauble_damage_list2[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                    if monk_bauble_damage_list3[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                    if bauble_unavailable_check == 1:
                                        monk_damage_taken = monk_damage_taken + bauble_damage
                                    champion4_hp = champion4_hp - math.ceil(monk_damage_taken)
                                    champion4_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                    if champion4_hp < 0:
                                        champion4_hp = 0
                                elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                    ai_hit_fencer_range = random.randint(1, 100)
                                    if ai_hit_fencer_range <= ai4_fencer_dodgechance:
                                        if AI_SIZE == "Tiny":
                                            champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 4, 0) * 0.5)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 4, 1) * 0.5)
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Small":
                                            champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 4, 0) * 0.6)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 4, 1) * 0.6)
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Medium":
                                            champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 4, 0) * 0.7)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 4, 1) * 0.7)
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Large":
                                            champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 4, 0) * 0.8)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 4, 1) * 0.8)
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Huge":
                                            champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 4, 0) * 0.9)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 4, 1) * 0.9)
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                    else:
                                        champion4_hp = champion4_hp - self.calculate_ai_damage(4, 4, 0)
                                        champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 4, 1))
                                        if champion4_hp < 0:
                                            champion4_hp = 0
                                elif CHAMPION_LIST[0] == POWER_CONDUIT.title:
                                    champion4_hp = champion4_hp - self.calculate_ai_damage(4, 4, 0)
                                    champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 4, 1))
                                    if champion4_hp < 0:
                                        champion4_hp = 0
                                    ai4_hp = ai4_hp - 750
                                    if ai4_hp < 0:
                                        ai4_hp = 0
                                elif CHAMPION_LIST[0] == ACADEMIC_MAGE.title:
                                    mage_damage_taken = math.ceil(self.calculate_ai_damage(4, 4, 0) - champion4_magical_barrier)
                                    if mage_damage_taken < 0:
                                        champion4_magical_barrier = mage_damage_taken * -1
                                    else:
                                        champion4_magical_barrier = 0
                                        champion4_hp = champion4_hp - mage_damage_taken
                                        champion4_lastRoundDamageTaken_list.append(mage_damage_taken)
                                        if champion4_hp < 0:
                                            champion4_hp = 0
                                else:
                                    champion4_hp = champion4_hp - self.calculate_ai_damage(4, 4, 0)
                                    champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 4, 1))
                                    if champion4_hp < 0:
                                        champion4_hp = 0
                                if champion4_bush_armour != 0:
                                    ai4_hp = ai4_hp - 200
                                    self.apply_thornsDot(4, 1)
                                if ai4_hp < 0:
                                    ai4_hp = 0
                            if champion5_hp != 0:
                                if len(champion5_immunity) != 0:
                                    immune_list = []
                                    for immune in champion5_immunity:
                                        if immune == "Cocoon":
                                            champion5_hp = champion5_hp
                                        elif immune == "Block":
                                            if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                                champion1_hp = champion1_hp - self.calculate_ai_damage(1, 4, 0)
                                                champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 4, 1))
                                                if champion1_hp < 0:
                                                    champion1_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                                champion2_hp = champion2_hp - self.calculate_ai_damage(2, 4, 0)
                                                champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 4, 1))
                                                if champion2_hp < 0:
                                                    champion2_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                                champion3_hp = champion3_hp - self.calculate_ai_damage(3, 4, 0)
                                                champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 4, 1))
                                                if champion3_hp < 0:
                                                    champion3_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                                champion4_hp = champion4_hp - self.calculate_ai_damage(4, 4, 0)
                                                champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 4, 1))
                                                if champion4_hp < 0:
                                                    champion4_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                                champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 4, 0) * 0.5)
                                                champion5_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(5, 4, 1) * 0.5))
                                                if champion5_hp < 0:
                                                    champion5_hp = 0
                                        elif immune == "Evasive Manoeuvres":
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                elif CHAMPION_LIST[0] == MONK.title:
                                    bauble_damage = self.calculate_ai_damage(5, 4, 0)
                                    bauble_unavailable_check = 0
                                    if monk_bauble_damage_list1[1] == 0:
                                        monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list2[1] == 0:
                                            monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            if monk_bauble_damage_list3[1] == 0:
                                                monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                            else:
                                                bauble_unavailable_check = 1
                                    monk_damage_taken = 0
                                    if monk_bauble_damage_list1[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                    if monk_bauble_damage_list2[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                    if monk_bauble_damage_list3[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                    if bauble_unavailable_check == 1:
                                        monk_damage_taken = monk_damage_taken + bauble_damage
                                    champion5_hp = champion5_hp - math.ceil(monk_damage_taken)
                                    champion5_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                    if champion5_hp < 0:
                                        champion5_hp = 0
                                elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                    ai_hit_fencer_range = random.randint(1, 100)
                                    if ai_hit_fencer_range <= ai4_fencer_dodgechance:
                                        if AI_SIZE == "Tiny":
                                            champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 4, 0) * 0.5)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 4, 1) * 0.5)
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Small":
                                            champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 4, 0) * 0.6)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 4, 1) * 0.6)
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Medium":
                                            champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 4, 0) * 0.7)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 4, 1) * 0.7)
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Large":
                                            champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 4, 0) * 0.8)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 4, 1) * 0.8)
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Huge":
                                            champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 4, 0) * 0.9)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 4, 1) * 0.9)
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                    else:
                                        champion5_hp = champion5_hp - self.calculate_ai_damage(5, 4, 0)
                                        champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 4, 1))
                                        if champion5_hp < 0:
                                            champion5_hp = 0
                                elif CHAMPION_LIST[0] == POWER_CONDUIT.title:
                                    champion5_hp = champion5_hp - self.calculate_ai_damage(5, 4, 0)
                                    champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 4, 1))
                                    if champion5_hp < 0:
                                        champion5_hp = 0
                                    ai4_hp = ai4_hp - 750
                                    if ai4_hp < 0:
                                        ai4_hp = 0
                                elif CHAMPION_LIST[0] == ACADEMIC_MAGE.title:
                                    mage_damage_taken = math.ceil(self.calculate_ai_damage(5, 4, 0) - champion5_magical_barrier)
                                    if mage_damage_taken < 0:
                                        champion5_magical_barrier = mage_damage_taken * -1
                                    else:
                                        champion5_magical_barrier = 0
                                        champion5_hp = champion5_hp - mage_damage_taken
                                        champion5_lastRoundDamageTaken_list.append(mage_damage_taken)
                                        if champion5_hp < 0:
                                            champion5_hp = 0
                                else:
                                    champion5_hp = champion5_hp - self.calculate_ai_damage(5, 4, 0)
                                    champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 4, 1))
                                    if champion5_hp < 0:
                                        champion5_hp = 0
                                if champion5_bush_armour != 0:
                                    ai4_hp = ai4_hp - 200
                                    self.apply_thornsDot(4, 1)
                                if ai4_hp < 0:
                                    ai4_hp = 0
                        else:
                            if CHAMPION_LIST[0] in ai4_attack_intention:
                                if len(champion1_immunity) != 0:
                                    immune_list = []
                                    for immune in champion1_immunity:
                                        if immune == "Cocoon":
                                            champion1_hp = champion1_hp
                                        elif immune == "Block":
                                            if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                                champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 4, 0) * 0.5)
                                                champion1_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(1, 4, 1) * 0.5))
                                                if champion1_hp < 0:
                                                    champion1_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                                champion2_hp = champion2_hp - self.calculate_ai_damage(2, 4, 0)
                                                champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 4, 1))
                                                if champion2_hp < 0:
                                                    champion2_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                                champion3_hp = champion3_hp - self.calculate_ai_damage(3, 4, 0)
                                                champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 4, 1))
                                                if champion3_hp < 0:
                                                    champion3_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                                champion4_hp = champion4_hp - self.calculate_ai_damage(4, 4, 0)
                                                champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 4, 1))
                                                if champion4_hp < 0:
                                                    champion4_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                                champion5_hp = champion5_hp - self.calculate_ai_damage(5, 4, 0)
                                                champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 4, 1))
                                                if champion5_hp < 0:
                                                    champion5_hp = 0
                                        elif immune == "Evasive Manoeuvres":
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                elif CHAMPION_LIST[0] == MONK.title:
                                    bauble_damage = self.calculate_ai_damage(1, 4, 0)
                                    bauble_unavailable_check = 0
                                    if monk_bauble_damage_list1[1] == 0:
                                        monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list2[1] == 0:
                                            monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            if monk_bauble_damage_list3[1] == 0:
                                                monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                            else:
                                                bauble_unavailable_check = 1
                                    monk_damage_taken = 0
                                    if monk_bauble_damage_list1[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                    if monk_bauble_damage_list2[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                    if monk_bauble_damage_list3[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                    if bauble_unavailable_check == 1:
                                        monk_damage_taken = monk_damage_taken + bauble_damage
                                    champion1_hp = champion1_hp - math.ceil(monk_damage_taken)
                                    champion1_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                    if champion1_hp < 0:
                                        champion1_hp = 0
                                elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                    ai_hit_fencer_range = random.randint(1, 100)
                                    if ai_hit_fencer_range <= ai4_fencer_dodgechance:
                                        if AI_SIZE == "Tiny":
                                            champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 4, 0) * 0.5)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 4, 1) * 0.5)
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Small":
                                            champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 4, 0) * 0.6)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 4, 1) * 0.6)
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Medium":
                                            champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 4, 0) * 0.7)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 4, 1) * 0.7)
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Large":
                                            champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 4, 0) * 0.8)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 4, 1) * 0.8)
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Huge":
                                            champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 4, 0) * 0.9)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 4, 1) * 0.9)
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                    else:
                                        champion1_hp = champion1_hp - self.calculate_ai_damage(1, 4, 0)
                                        champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 4, 1))
                                        if champion1_hp < 0:
                                            champion1_hp = 0
                                elif CHAMPION_LIST[0] == POWER_CONDUIT.title:
                                    champion1_hp = champion1_hp - self.calculate_ai_damage(1, 4, 0)
                                    champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 4, 1))
                                    if champion1_hp < 0:
                                        champion1_hp = 0
                                    ai4_hp = ai4_hp - 750
                                    if ai4_hp < 0:
                                        ai4_hp = 0
                                elif CHAMPION_LIST[0] == ACADEMIC_MAGE.title:
                                    mage_damage_taken = math.ceil(self.calculate_ai_damage(1, 4, 0) - champion1_magical_barrier)
                                    if mage_damage_taken < 0:
                                        champion1_magical_barrier = mage_damage_taken * -1
                                    else:
                                        champion1_magical_barrier = 0
                                        champion1_hp = champion1_hp - mage_damage_taken
                                        champion1_lastRoundDamageTaken_list.append(mage_damage_taken)
                                        if champion1_hp < 0:
                                            champion1_hp = 0
                                else:
                                    champion1_hp = champion1_hp - self.calculate_ai_damage(1, 4, 0)
                                    champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 4, 1))
                                    if champion1_hp < 0:
                                        champion1_hp = 0
                                if champion1_bush_armour != 0:
                                    ai4_hp = ai4_hp - 200
                                    self.apply_thornsDot(4, 1)
                                if ai4_hp < 0:
                                    ai4_hp = 0
                            if CHAMPION_LIST[1] in ai4_attack_intention:
                                if len(champion2_immunity) != 0:
                                    immune_list = []
                                    for immune in champion2_immunity:
                                        if immune == "Cocoon":
                                            champion2_hp = champion2_hp
                                        elif immune == "Block":
                                            if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                                champion1_hp = champion1_hp - self.calculate_ai_damage(1, 4, 0)
                                                champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 4, 1))
                                                if champion1_hp < 0:
                                                    champion1_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                                champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 4, 0) * 0.5)
                                                champion2_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(2, 4, 1) * 0.5))
                                                if champion2_hp < 0:
                                                    champion2_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                                champion3_hp = champion3_hp - self.calculate_ai_damage(3, 4, 0)
                                                champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 4, 1))
                                                if champion3_hp < 0:
                                                    champion3_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                                champion4_hp = champion4_hp - self.calculate_ai_damage(4, 4, 0)
                                                champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 4, 1))
                                                if champion4_hp < 0:
                                                    champion4_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                                champion5_hp = champion5_hp - self.calculate_ai_damage(5, 4, 0)
                                                champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 4, 1))
                                                if champion5_hp < 0:
                                                    champion5_hp = 0
                                        elif immune == "Evasive Manoeuvres":
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                elif CHAMPION_LIST[0] == MONK.title:
                                    bauble_damage = self.calculate_ai_damage(2, 4, 0)
                                    bauble_unavailable_check = 0
                                    if monk_bauble_damage_list1[1] == 0:
                                        monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list2[1] == 0:
                                            monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            if monk_bauble_damage_list3[1] == 0:
                                                monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                            else:
                                                bauble_unavailable_check = 1
                                    monk_damage_taken = 0
                                    if monk_bauble_damage_list1[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                    if monk_bauble_damage_list2[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                    if monk_bauble_damage_list3[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                    if bauble_unavailable_check == 1:
                                        monk_damage_taken = monk_damage_taken + bauble_damage
                                    champion2_hp = champion2_hp - math.ceil(monk_damage_taken)
                                    champion2_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                    if champion2_hp < 0:
                                        champion2_hp = 0
                                elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                    ai_hit_fencer_range = random.randint(1, 100)
                                    if ai_hit_fencer_range <= ai4_fencer_dodgechance:
                                        if AI_SIZE == "Tiny":
                                            champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 4, 0) * 0.5)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 4, 1) * 0.5)
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Small":
                                            champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 4, 0) * 0.6)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 4, 1) * 0.6)
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Medium":
                                            champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 4, 0) * 0.7)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 4, 1) * 0.7)
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Large":
                                            champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 4, 0) * 0.8)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 4, 1) * 0.8)
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Huge":
                                            champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 4, 0) * 0.9)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 4, 1) * 0.9)
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                    else:
                                        champion2_hp = champion2_hp - self.calculate_ai_damage(2, 4, 0)
                                        champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 4, 1))
                                        if champion2_hp < 0:
                                            champion2_hp = 0
                                elif CHAMPION_LIST[0] == POWER_CONDUIT.title:
                                    champion2_hp = champion2_hp - self.calculate_ai_damage(2, 4, 0)
                                    champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 4, 1))
                                    if champion2_hp < 0:
                                        champion2_hp = 0
                                    ai4_hp = ai4_hp - 750
                                    if ai4_hp < 0:
                                        ai4_hp = 0
                                elif CHAMPION_LIST[0] == ACADEMIC_MAGE.title:
                                    mage_damage_taken = math.ceil(self.calculate_ai_damage(2, 4, 0) - champion2_magical_barrier)
                                    if mage_damage_taken < 0:
                                        champion2_magical_barrier = mage_damage_taken * -1
                                    else:
                                        champion2_magical_barrier = 0
                                        champion2_hp = champion2_hp - mage_damage_taken
                                        champion2_lastRoundDamageTaken_list.append(mage_damage_taken)
                                        if champion2_hp < 0:
                                            champion2_hp = 0
                                else:
                                    champion2_hp = champion2_hp - self.calculate_ai_damage(2, 4, 0)
                                    champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 4, 1))
                                    if champion2_hp < 0:
                                        champion2_hp = 0
                                if champion2_bush_armour != 0:
                                    ai4_hp = ai4_hp - 200
                                    self.apply_thornsDot(4, 1)
                                if ai4_hp < 0:
                                    ai4_hp = 0
                            if CHAMPION_LIST[2] in ai4_attack_intention:
                                if len(champion3_immunity) != 0:
                                    immune_list = []
                                    for immune in champion3_immunity:
                                        if immune == "Cocoon":
                                            champion3_hp = champion3_hp
                                        elif immune == "Block":
                                            if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                                champion1_hp = champion1_hp - self.calculate_ai_damage(1, 4, 0)
                                                champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 4, 1))
                                                if champion1_hp < 0:
                                                    champion1_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                                champion2_hp = champion2_hp - self.calculate_ai_damage(2, 4, 0)
                                                champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 4, 1))
                                                if champion2_hp < 0:
                                                    champion2_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                                champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 4, 0) * 0.5)
                                                champion3_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(3, 4, 1) * 0.5))
                                                if champion3_hp < 0:
                                                    champion3_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                                champion4_hp = champion4_hp - self.calculate_ai_damage(4, 4, 0)
                                                champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 4, 1))
                                                if champion4_hp < 0:
                                                    champion4_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                                champion5_hp = champion5_hp - self.calculate_ai_damage(5, 4, 0)
                                                champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 4, 1))
                                                if champion5_hp < 0:
                                                    champion5_hp = 0
                                        elif immune == "Evasive Manoeuvres":
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                elif CHAMPION_LIST[0] == MONK.title:
                                    bauble_damage = self.calculate_ai_damage(3, 4, 0)
                                    bauble_unavailable_check = 0
                                    if monk_bauble_damage_list1[1] == 0:
                                        monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list2[1] == 0:
                                            monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            if monk_bauble_damage_list3[1] == 0:
                                                monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                            else:
                                                bauble_unavailable_check = 1
                                    monk_damage_taken = 0
                                    if monk_bauble_damage_list1[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                    if monk_bauble_damage_list2[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                    if monk_bauble_damage_list3[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                    if bauble_unavailable_check == 1:
                                        monk_damage_taken = monk_damage_taken + bauble_damage
                                    champion3_hp = champion3_hp - math.ceil(monk_damage_taken)
                                    champion3_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                    if champion3_hp < 0:
                                        champion3_hp = 0
                                elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                    ai_hit_fencer_range = random.randint(1, 100)
                                    if ai_hit_fencer_range <= ai4_fencer_dodgechance:
                                        if AI_SIZE == "Tiny":
                                            champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 4, 0) * 0.5)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 4, 1) * 0.5)
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Small":
                                            champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 4, 0) * 0.6)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 4, 1) * 0.6)
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Medium":
                                            champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 4, 0) * 0.7)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 4, 1) * 0.7)
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Large":
                                            champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 4, 0) * 0.8)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 4, 1) * 0.8)
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Huge":
                                            champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 4, 0) * 0.9)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 4, 1) * 0.9)
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                    else:
                                        champion3_hp = champion3_hp - self.calculate_ai_damage(3, 4, 0)
                                        champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 4, 1))
                                        if champion3_hp < 0:
                                            champion3_hp = 0
                                elif CHAMPION_LIST[0] == POWER_CONDUIT.title:
                                    champion3_hp = champion3_hp - self.calculate_ai_damage(3, 4, 0)
                                    champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 4, 1))
                                    if champion3_hp < 0:
                                        champion3_hp = 0
                                    ai4_hp = ai4_hp - 750
                                    if ai4_hp < 0:
                                        ai4_hp = 0
                                elif CHAMPION_LIST[0] == ACADEMIC_MAGE.title:
                                    mage_damage_taken = math.ceil(self.calculate_ai_damage(3, 4, 0) - champion3_magical_barrier)
                                    if mage_damage_taken < 0:
                                        champion3_magical_barrier = mage_damage_taken * -1
                                    else:
                                        champion3_magical_barrier = 0
                                        champion3_hp = champion3_hp - mage_damage_taken
                                        champion3_lastRoundDamageTaken_list.append(mage_damage_taken)
                                        if champion3_hp < 0:
                                            champion3_hp = 0
                                else:
                                    champion3_hp = champion3_hp - self.calculate_ai_damage(3, 4, 0)
                                    champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 4, 1))
                                    if champion3_hp < 0:
                                        champion3_hp = 0
                                if champion3_bush_armour != 0:
                                    ai4_hp = ai4_hp - 200
                                    self.apply_thornsDot(4, 1)
                                if ai4_hp < 0:
                                    ai4_hp = 0
                            if CHAMPION_LIST[3] in ai4_attack_intention:
                                if len(champion4_immunity) != 0:
                                    immune_list = []
                                    for immune in champion4_immunity:
                                        if immune == "Cocoon":
                                            champion4_hp = champion4_hp
                                        elif immune == "Block":
                                            if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                                champion1_hp = champion1_hp - self.calculate_ai_damage(1, 4, 0)
                                                champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 4, 1))
                                                if champion1_hp < 0:
                                                    champion1_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                                champion2_hp = champion2_hp - self.calculate_ai_damage(2, 4, 0)
                                                champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 4, 1))
                                                if champion2_hp < 0:
                                                    champion2_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                                champion3_hp = champion3_hp - self.calculate_ai_damage(3, 4, 0)
                                                champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 4, 1))
                                                if champion3_hp < 0:
                                                    champion3_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                                champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 4, 0) * 0.5)
                                                champion4_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(4, 4, 1) * 0.5))
                                                if champion4_hp < 0:
                                                    champion4_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                                champion5_hp = champion5_hp - self.calculate_ai_damage(5, 4, 0)
                                                champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 4, 1))
                                                if champion5_hp < 0:
                                                    champion5_hp = 0
                                        elif immune == "Evasive Manoeuvres":
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                elif CHAMPION_LIST[0] == MONK.title:
                                    bauble_damage = self.calculate_ai_damage(4, 4, 0)
                                    bauble_unavailable_check = 0
                                    if monk_bauble_damage_list1[1] == 0:
                                        monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list2[1] == 0:
                                            monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            if monk_bauble_damage_list3[1] == 0:
                                                monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                            else:
                                                bauble_unavailable_check = 1
                                    monk_damage_taken = 0
                                    if monk_bauble_damage_list1[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                    if monk_bauble_damage_list2[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                    if monk_bauble_damage_list3[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                    if bauble_unavailable_check == 1:
                                        monk_damage_taken = monk_damage_taken + bauble_damage
                                    champion4_hp = champion4_hp - math.ceil(monk_damage_taken)
                                    champion4_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                    if champion4_hp < 0:
                                        champion4_hp = 0
                                elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                    ai_hit_fencer_range = random.randint(1, 100)
                                    if ai_hit_fencer_range <= ai4_fencer_dodgechance:
                                        if AI_SIZE == "Tiny":
                                            champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 4, 0) * 0.5)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 4, 1) * 0.5)
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Small":
                                            champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 4, 0) * 0.6)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 4, 1) * 0.6)
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Medium":
                                            champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 4, 0) * 0.7)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 4, 1) * 0.7)
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Large":
                                            champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 4, 0) * 0.8)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 4, 1) * 0.8)
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Huge":
                                            champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 4, 0) * 0.9)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 4, 1) * 0.9)
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                    else:
                                        champion4_hp = champion4_hp - self.calculate_ai_damage(4, 4, 0)
                                        champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 4, 1))
                                        if champion4_hp < 0:
                                            champion4_hp = 0
                                elif CHAMPION_LIST[0] == POWER_CONDUIT.title:
                                    champion4_hp = champion4_hp - self.calculate_ai_damage(4, 4, 0)
                                    champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 4, 1))
                                    if champion4_hp < 0:
                                        champion4_hp = 0
                                    ai4_hp = ai4_hp - 750
                                    if ai4_hp < 0:
                                        ai4_hp = 0
                                elif CHAMPION_LIST[0] == ACADEMIC_MAGE.title:
                                    mage_damage_taken = math.ceil(self.calculate_ai_damage(4, 4, 0) - champion4_magical_barrier)
                                    if mage_damage_taken < 0:
                                        champion4_magical_barrier = mage_damage_taken * -1
                                    else:
                                        champion4_magical_barrier = 0
                                        champion4_hp = champion4_hp - mage_damage_taken
                                        champion4_lastRoundDamageTaken_list.append(mage_damage_taken)
                                        if champion4_hp < 0:
                                            champion4_hp = 0
                                else:
                                    champion4_hp = champion4_hp - self.calculate_ai_damage(4, 4, 0)
                                    champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 4, 1))
                                    if champion4_hp < 0:
                                        champion4_hp = 0
                                if champion4_bush_armour != 0:
                                    ai4_hp = ai4_hp - 200
                                    self.apply_thornsDot(4, 1)
                                if ai4_hp < 0:
                                    ai4_hp = 0
                            if CHAMPION_LIST[4] in ai4_attack_intention:
                                if len(champion5_immunity) != 0:
                                    immune_list = []
                                    for immune in champion5_immunity:
                                        if immune == "Cocoon":
                                            champion5_hp = champion5_hp
                                        elif immune == "Block":
                                            if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                                champion1_hp = champion1_hp - self.calculate_ai_damage(1, 4, 0)
                                                champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 4, 1))
                                                if champion1_hp < 0:
                                                    champion1_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                                champion2_hp = champion2_hp - self.calculate_ai_damage(2, 4, 0)
                                                champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 4, 1))
                                                if champion2_hp < 0:
                                                    champion2_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                                champion3_hp = champion3_hp - self.calculate_ai_damage(3, 4, 0)
                                                champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 4, 1))
                                                if champion3_hp < 0:
                                                    champion3_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                                champion4_hp = champion4_hp - self.calculate_ai_damage(4, 4, 0)
                                                champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 4, 1))
                                                if champion4_hp < 0:
                                                    champion4_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                                champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 4, 0) * 0.5)
                                                champion5_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(5, 4, 1) * 0.5))
                                                if champion5_hp < 0:
                                                    champion5_hp = 0
                                        elif immune == "Evasive Manoeuvres":
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                elif CHAMPION_LIST[0] == MONK.title:
                                    bauble_damage = self.calculate_ai_damage(5, 4, 0)
                                    bauble_unavailable_check = 0
                                    if monk_bauble_damage_list1[1] == 0:
                                        monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list2[1] == 0:
                                            monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            if monk_bauble_damage_list3[1] == 0:
                                                monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                            else:
                                                bauble_unavailable_check = 1
                                    monk_damage_taken = 0
                                    if monk_bauble_damage_list1[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                    if monk_bauble_damage_list2[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                    if monk_bauble_damage_list3[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                    if bauble_unavailable_check == 1:
                                        monk_damage_taken = monk_damage_taken + bauble_damage
                                    champion5_hp = champion5_hp - math.ceil(monk_damage_taken)
                                    champion5_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                    if champion5_hp < 0:
                                        champion5_hp = 0
                                elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                    ai_hit_fencer_range = random.randint(1, 100)
                                    if ai_hit_fencer_range <= ai4_fencer_dodgechance:
                                        if AI_SIZE == "Tiny":
                                            champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 4, 0) * 0.5)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 4, 1) * 0.5)
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Small":
                                            champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 4, 0) * 0.6)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 4, 1) * 0.6)
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Medium":
                                            champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 4, 0) * 0.7)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 4, 1) * 0.7)
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Large":
                                            champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 4, 0) * 0.8)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 4, 1) * 0.8)
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Huge":
                                            champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 4, 0) * 0.9)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 4, 1) * 0.9)
                                            self.apply_taunt(4, MASTER_FENCER.title, 1)
                                    else:
                                        champion5_hp = champion5_hp - self.calculate_ai_damage(5, 4, 0)
                                        champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 4, 1))
                                        if champion5_hp < 0:
                                            champion5_hp = 0
                                elif CHAMPION_LIST[0] == POWER_CONDUIT.title:
                                    champion5_hp = champion5_hp - self.calculate_ai_damage(5, 4, 0)
                                    champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 4, 1))
                                    if champion5_hp < 0:
                                        champion5_hp = 0
                                    ai4_hp = ai4_hp - 750
                                    if ai4_hp < 0:
                                        ai4_hp = 0
                                elif CHAMPION_LIST[0] == ACADEMIC_MAGE.title:
                                    mage_damage_taken = math.ceil(self.calculate_ai_damage(5, 4, 0) - champion5_magical_barrier)
                                    if mage_damage_taken < 0:
                                        champion5_magical_barrier = mage_damage_taken * -1
                                    else:
                                        champion5_magical_barrier = 0
                                        champion5_hp = champion5_hp - mage_damage_taken
                                        champion5_lastRoundDamageTaken_list.append(mage_damage_taken)
                                        if champion5_hp < 0:
                                            champion5_hp = 0
                                else:
                                    champion5_hp = champion5_hp - self.calculate_ai_damage(5, 4, 0)
                                    champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 4, 1))
                                    if champion5_hp < 0:
                                        champion5_hp = 0
                                if champion5_bush_armour != 0:
                                    ai4_hp = ai4_hp - 200
                                    self.apply_thornsDot(4, 1)
                                if ai4_hp < 0:
                                    ai4_hp = 0
                if monster_var == 5:
                    if ai5_hp == 0:
                        continue
                    if ai5_thornsDot[1] != 0:
                        ai5_hp = ai5_hp - ai5_thornsDot[0] * ai5_thornsDot[1]
                        if ai5_hp < 0:
                            ai5_hp = 0
                            continue
                    if ai5_burnDot[1] != 0:
                        ai5_hp = ai5_hp - ai5_burnDot[0]
                        ai5_burnDot[1] = ai5_burnDot[1] - 1
                        if ai5_hp < 0:
                            ai5_hp = 0
                            continue
                    if ai5_serraSlashDot[1] != 0:
                        ai5_hp = ai5_hp - self.calculate_bleed_damage("Serrated", 5)
                        ai5_serraSlashDot[1] = ai5_serraSlashDot[1] - 1
                        if ai5_hp < 0:
                            ai5_hp = 0
                            continue
                    if ai5_eviscerDot[1] != 0:
                        ai5_hp = ai5_hp - self.calculate_bleed_damage("Eviscerated", 5)
                        ai5_eviscerDot[1] = ai5_eviscerDot[1] - 1
                        if ai5_hp < 0:
                            ai5_hp = 0
                            continue
                    if ai5_garroteDot[1] != 0:
                        ai5_hp = ai5_hp - self.calculate_bleed_damage("Garroted", 5)
                        ai5_garroteDot[1] = ai5_garroteDot[1] - 1
                        if ai5_hp < 0:
                            ai5_hp = 0
                            continue
                    if ai5_rottingDot[1] != 0:
                        ai5_hp = ai5_hp - ai5_rottingDot[0]
                        self.apply_toc(5)
                        ai5_rottingDot[1] = ai5_rottingDot[1] - 1
                        if ai5_hp < 0:
                            ai5_hp = 0
                            continue
                    if ai5_shimmerDot[1] != 0:
                        ai5_hp = ai5_hp - ai5_shimmerDot[0]
                        ai5_shimmerDot[1] = ai5_shimmerDot[1] - 1
                        if champion1_hp > 0:
                            self.check_champion_blessing(1, ai5_shimmerDot[0])
                        if champion2_hp > 0:
                            self.check_champion_blessing(2, ai5_shimmerDot[0])
                        if champion3_hp > 0:
                            self.check_champion_blessing(3, ai5_shimmerDot[0])
                        if champion4_hp > 0:
                            self.check_champion_blessing(4, ai5_shimmerDot[0])
                        if champion5_hp > 0:
                            self.check_champion_blessing(5, ai5_shimmerDot[0])
                        if ai5_hp < 0:
                            ai5_hp = 0
                            continue
                    if ai5_divineDot[1] != 0:
                        ai5_hp = ai5_hp - ai5_divineDot[0]
                        ai5_divineDot[1] = ai5_divineDot[1] - 1
                        if champion1_hp > 0:
                            self.check_champion_blessing(1, ai5_divineDot[0])
                        if champion2_hp > 0:
                            self.check_champion_blessing(2, ai5_divineDot[0])
                        if champion3_hp > 0:
                            self.check_champion_blessing(3, ai5_divineDot[0])
                        if champion4_hp > 0:
                            self.check_champion_blessing(4, ai5_divineDot[0])
                        if champion5_hp > 0:
                            self.check_champion_blessing(5, ai5_divineDot[0])
                        if ai5_hp < 0:
                            ai5_hp = 0
                            continue
                    if ai5_barbedArrDot[1] != 0:
                        ai5_hp = ai5_hp - ai5_barbedArrDot[0]
                        ai5_barbedArrDot[1] = ai5_barbedArrDot[1] - 1
                        if ai5_hp < 0:
                            ai5_hp = 0
                            continue
                    if ai5_damnation[1] != 0:
                        ai5_damnation[1] = ai5_damnation[1] - 1
                        if ai5_damnation[1] == 0:
                            ai5_hp = ai5_hp - ai5_damnation[0]
                            if ai5_hp < 0:
                                ai5_hp = 0
                    if ai5_hp == 0:
                        continue
                    if ai5_stun != 0:
                        continue
                    if ai5_taunt[1] != 0:
                        if ai5_taunt[0] in CHAMPION_LIST[0]:
                            if len(champion1_immunity) != 0:
                                immune_list = []
                                for immune in champion1_immunity:
                                    if immune == "Cocoon":
                                        champion1_hp = champion1_hp
                                    elif immune == "Block":
                                        if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                            champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 5, 0) * 0.5)
                                            champion1_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(1, 5, 1) * 0.5))
                                            if champion1_hp < 0:
                                                champion1_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                            champion2_hp = champion2_hp - self.calculate_ai_damage(2, 5, 0)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 5, 1))
                                            if champion2_hp < 0:
                                                champion2_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                            champion3_hp = champion3_hp - self.calculate_ai_damage(3, 5, 0)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 5, 1))
                                            if champion3_hp < 0:
                                                champion3_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                            champion4_hp = champion4_hp - self.calculate_ai_damage(4, 5, 0)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 5, 1))
                                            if champion4_hp < 0:
                                                champion4_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                            champion5_hp = champion5_hp - self.calculate_ai_damage(5, 5, 0)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 5, 1))
                                            if champion5_hp < 0:
                                                champion5_hp = 0
                                    elif immune == "Evasive Manoeuvres":
                                        self.apply_taunt(5, MASTER_FENCER.title, 1)
                            elif CHAMPION_LIST[0] == MONK.title:
                                bauble_damage = self.calculate_ai_damage(1, 5, 0)
                                bauble_unavailable_check = 0
                                if monk_bauble_damage_list1[1] == 0:
                                    monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                else:
                                    if monk_bauble_damage_list2[1] == 0:
                                        monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list3[1] == 0:
                                            monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            bauble_unavailable_check = 1
                                monk_damage_taken = 0
                                if monk_bauble_damage_list1[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                if monk_bauble_damage_list2[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                if monk_bauble_damage_list3[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                if bauble_unavailable_check == 1:
                                    monk_damage_taken = monk_damage_taken + bauble_damage
                                champion1_hp = champion1_hp - math.ceil(monk_damage_taken)
                                champion1_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                if champion1_hp < 0:
                                    champion1_hp = 0
                            elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                ai_hit_fencer_range = random.randint(1, 100)
                                if ai_hit_fencer_range <= ai5_fencer_dodgechance:
                                    if AI_SIZE == "Tiny":
                                        champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 5, 0) * 0.5)
                                        champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 5, 1) * 0.5)
                                        self.apply_taunt(5, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Small":
                                        champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 5, 0) * 0.6)
                                        champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 5, 1) * 0.6)
                                        self.apply_taunt(5, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Medium":
                                        champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 5, 0) * 0.7)
                                        champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 5, 1) * 0.7)
                                        self.apply_taunt(5, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Large":
                                        champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 5, 0) * 0.8)
                                        champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 5, 1) * 0.8)
                                        self.apply_taunt(5, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Huge":
                                        champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 5, 0) * 0.9)
                                        champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 5, 1) * 0.9)
                                        self.apply_taunt(5, MASTER_FENCER.title, 1)
                                else:
                                    champion1_hp = champion1_hp - self.calculate_ai_damage(1, 5, 0)
                                    champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 5, 1))
                                    if champion1_hp < 0:
                                        champion1_hp = 0
                            else:
                                champion1_hp = champion1_hp - self.calculate_ai_damage(1, 5, 0)
                                champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 5, 1))
                                if champion1_hp < 0:
                                    champion1_hp = 0
                            if champion1_bush_armour != 0:
                                ai5_hp = ai5_hp - 200
                                self.apply_thornsDot(1, 5)
                            if ai5_hp < 0:
                                ai5_hp = 0
                        elif ai5_taunt[0] in CHAMPION_LIST[1]:
                            if len(champion2_immunity) != 0:
                                immune_list = []
                                for immune in champion2_immunity:
                                    if immune == "Cocoon":
                                        champion2_hp = champion2_hp
                                    elif immune == "Block":
                                        if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                            champion1_hp = champion1_hp - self.calculate_ai_damage(1, 5, 0)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 5, 1))
                                            if champion1_hp < 0:
                                                champion1_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                            champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 5, 0) * 0.5)
                                            champion2_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(2, 5, 1) * 0.5))
                                            if champion2_hp < 0:
                                                champion2_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                            champion3_hp = champion3_hp - self.calculate_ai_damage(3, 5, 0)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 5, 1))
                                            if champion3_hp < 0:
                                                champion3_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                            champion4_hp = champion4_hp - self.calculate_ai_damage(4, 5, 0)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 5, 1))
                                            if champion4_hp < 0:
                                                champion4_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                            champion5_hp = champion5_hp - self.calculate_ai_damage(5, 5, 0)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 5, 1))
                                            if champion5_hp < 0:
                                                champion5_hp = 0
                                    elif immune == "Evasive Manoeuvres":
                                        self.apply_taunt(5, MASTER_FENCER.title, 1)
                            elif CHAMPION_LIST[0] == MONK.title:
                                bauble_damage = self.calculate_ai_damage(2, 5, 0)
                                bauble_unavailable_check = 0
                                if monk_bauble_damage_list1[1] == 0:
                                    monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                else:
                                    if monk_bauble_damage_list2[1] == 0:
                                        monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list3[1] == 0:
                                            monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            bauble_unavailable_check = 1
                                monk_damage_taken = 0
                                if monk_bauble_damage_list1[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                if monk_bauble_damage_list2[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                if monk_bauble_damage_list3[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                if bauble_unavailable_check == 1:
                                    monk_damage_taken = monk_damage_taken + bauble_damage
                                champion2_hp = champion2_hp - math.ceil(monk_damage_taken)
                                champion2_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                if champion2_hp < 0:
                                    champion2_hp = 0
                            elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                ai_hit_fencer_range = random.randint(1, 100)
                                if ai_hit_fencer_range <= ai5_fencer_dodgechance:
                                    if AI_SIZE == "Tiny":
                                        champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 5, 0) * 0.5)
                                        champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 5, 1) * 0.5)
                                        self.apply_taunt(5, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Small":
                                        champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 5, 0) * 0.6)
                                        champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 5, 1) * 0.6)
                                        self.apply_taunt(5, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Medium":
                                        champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 5, 0) * 0.7)
                                        champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 5, 1) * 0.7)
                                        self.apply_taunt(5, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Large":
                                        champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 5, 0) * 0.8)
                                        champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 5, 1) * 0.8)
                                        self.apply_taunt(5, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Huge":
                                        champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 5, 0) * 0.9)
                                        champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 5, 1) * 0.9)
                                        self.apply_taunt(5, MASTER_FENCER.title, 1)
                                else:
                                    champion2_hp = champion2_hp - self.calculate_ai_damage(2, 5, 0)
                                    champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 5, 1))
                                    if champion2_hp < 0:
                                        champion2_hp = 0
                            else:
                                champion2_hp = champion2_hp - self.calculate_ai_damage(2, 5, 0)
                                champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 5, 1))
                                if champion2_hp < 0:
                                    champion2_hp = 0
                            if champion2_bush_armour != 0:
                                ai5_hp = ai5_hp - 200
                                self.apply_thornsDot(1, 5)
                            if ai5_hp < 0:
                                ai5_hp = 0
                        elif ai5_taunt[0] in CHAMPION_LIST[2]:
                            if len(champion3_immunity) != 0:
                                immune_list = []
                                for immune in champion3_immunity:
                                    if immune == "Cocoon":
                                        champion3_hp = champion3_hp
                                    elif immune == "Block":
                                        if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                            champion1_hp = champion1_hp - self.calculate_ai_damage(1, 5, 0)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 5, 1))
                                            if champion1_hp < 0:
                                                champion1_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                            champion2_hp = champion2_hp - self.calculate_ai_damage(2, 5, 0)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 5, 1))
                                            if champion2_hp < 0:
                                                champion2_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                            champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 5, 0) * 0.5)
                                            champion3_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(3, 5, 1) * 0.5))
                                            if champion3_hp < 0:
                                                champion3_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                            champion4_hp = champion4_hp - self.calculate_ai_damage(4, 5, 0)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 5, 1))
                                            if champion4_hp < 0:
                                                champion4_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                            champion5_hp = champion5_hp - self.calculate_ai_damage(5, 5, 0)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 5, 1))
                                            if champion5_hp < 0:
                                                champion5_hp = 0
                                    elif immune == "Evasive Manoeuvres":
                                        self.apply_taunt(5, MASTER_FENCER.title, 1)
                            elif CHAMPION_LIST[0] == MONK.title:
                                bauble_damage = self.calculate_ai_damage(3, 5)
                                bauble_unavailable_check = 0
                                if monk_bauble_damage_list1[1] == 0:
                                    monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                else:
                                    if monk_bauble_damage_list2[1] == 0:
                                        monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list3[1] == 0:
                                            monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            bauble_unavailable_check = 1
                                monk_damage_taken = 0
                                if monk_bauble_damage_list1[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                if monk_bauble_damage_list2[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                if monk_bauble_damage_list3[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                if bauble_unavailable_check == 1:
                                    monk_damage_taken = monk_damage_taken + bauble_damage
                                champion3_hp = champion3_hp - math.ceil(monk_damage_taken)
                                champion3_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                if champion3_hp < 0:
                                    champion3_hp = 0
                            elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                ai_hit_fencer_range = random.randint(1, 100)
                                if ai_hit_fencer_range <= ai5_fencer_dodgechance:
                                    if AI_SIZE == "Tiny":
                                        champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 5, 0) * 0.5)
                                        champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 5, 1) * 0.5)
                                        self.apply_taunt(5, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Small":
                                        champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 5, 0) * 0.6)
                                        champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 5, 1) * 0.6)
                                        self.apply_taunt(5, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Medium":
                                        champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 5, 0) * 0.7)
                                        champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 5, 1) * 0.7)
                                        self.apply_taunt(5, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Large":
                                        champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 5, 0) * 0.8)
                                        champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 5, 1) * 0.8)
                                        self.apply_taunt(5, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Huge":
                                        champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 5, 0) * 0.9)
                                        champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 5, 1) * 0.9)
                                        self.apply_taunt(5, MASTER_FENCER.title, 1)
                                else:
                                    champion3_hp = champion3_hp - self.calculate_ai_damage(3, 5, 0)
                                    champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 5, 1))
                                    if champion3_hp < 0:
                                        champion3_hp = 0
                            else:
                                champion3_hp = champion3_hp - self.calculate_ai_damage(3, 5, 0)
                                champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 5, 1))
                                if champion3_hp < 0:
                                    champion3_hp = 0
                            if champion3_bush_armour != 0:
                                ai5_hp = ai5_hp - 200
                                self.apply_thornsDot(1, 5)
                            if ai5_hp < 0:
                                ai5_hp = 0
                        elif ai5_taunt[0] in CHAMPION_LIST[3]:
                            if len(champion4_immunity) != 0:
                                immune_list = []
                                for immune in champion4_immunity:
                                    if immune == "Cocoon":
                                        champion4_hp = champion4_hp
                                    elif immune == "Block":
                                        if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                            champion1_hp = champion1_hp - self.calculate_ai_damage(1, 5, 0)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 5, 1))
                                            if champion1_hp < 0:
                                                champion1_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                            champion2_hp = champion2_hp - self.calculate_ai_damage(2, 5, 0)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 5, 1))
                                            if champion2_hp < 0:
                                                champion2_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                            champion3_hp = champion3_hp - self.calculate_ai_damage(3, 5, 0)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 5, 1))
                                            if champion3_hp < 0:
                                                champion3_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                            champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 5, 0) * 0.5)
                                            champion4_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(4, 5, 1) * 0.5))
                                            if champion4_hp < 0:
                                                champion4_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                            champion5_hp = champion5_hp - self.calculate_ai_damage(5, 5, 0)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 5, 1))
                                            if champion5_hp < 0:
                                                champion5_hp = 0
                                    elif immune == "Evasive Manoeuvres":
                                        self.apply_taunt(5, MASTER_FENCER.title, 1)
                            elif CHAMPION_LIST[0] == MONK.title:
                                bauble_damage = self.calculate_ai_damage(4, 5, 0)
                                bauble_unavailable_check = 0
                                if monk_bauble_damage_list1[1] == 0:
                                    monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                else:
                                    if monk_bauble_damage_list2[1] == 0:
                                        monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list3[1] == 0:
                                            monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            bauble_unavailable_check = 1
                                monk_damage_taken = 0
                                if monk_bauble_damage_list1[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                if monk_bauble_damage_list2[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                if monk_bauble_damage_list3[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                if bauble_unavailable_check == 1:
                                    monk_damage_taken = monk_damage_taken + bauble_damage
                                champion4_hp = champion4_hp - math.ceil(monk_damage_taken)
                                champion4_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                if champion4_hp < 0:
                                    champion4_hp = 0
                            elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                ai_hit_fencer_range = random.randint(1, 100)
                                if ai_hit_fencer_range <= ai5_fencer_dodgechance:
                                    if AI_SIZE == "Tiny":
                                        champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 5, 0) * 0.5)
                                        champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 5, 1) * 0.5)
                                        self.apply_taunt(5, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Small":
                                        champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 5, 0) * 0.6)
                                        champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 5, 1) * 0.6)
                                        self.apply_taunt(5, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Medium":
                                        champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 5, 0) * 0.7)
                                        champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 5, 1) * 0.7)
                                        self.apply_taunt(5, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Large":
                                        champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 5, 0) * 0.8)
                                        champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 5, 1) * 0.8)
                                        self.apply_taunt(5, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Huge":
                                        champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 5, 0) * 0.9)
                                        champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 5, 1) * 0.9)
                                        self.apply_taunt(5, MASTER_FENCER.title, 1)
                                else:
                                    champion4_hp = champion4_hp - self.calculate_ai_damage(4, 5, 0)
                                    champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 5, 1))
                                    if champion4_hp < 0:
                                        champion4_hp = 0
                            else:
                                champion4_hp = champion4_hp - self.calculate_ai_damage(4, 5, 0)
                                champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 5, 1))
                                if champion4_hp < 0:
                                    champion4_hp = 0
                            if champion4_bush_armour != 0:
                                ai5_hp = ai5_hp - 200
                                self.apply_thornsDot(1, 5)
                            if ai5_hp < 0:
                                ai5_hp = 0
                        elif ai5_taunt[0] in CHAMPION_LIST[4]:
                            if len(champion5_immunity) != 0:
                                immune_list = []
                                for immune in champion5_immunity:
                                    if immune == "Cocoon":
                                        champion5_hp = champion5_hp
                                    elif immune == "Block":
                                        if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                            champion1_hp = champion1_hp - self.calculate_ai_damage(1, 5, 0)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 5, 1))
                                            if champion1_hp < 0:
                                                champion1_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                            champion2_hp = champion2_hp - self.calculate_ai_damage(2, 5, 0)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 5, 1))
                                            if champion2_hp < 0:
                                                champion2_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                            champion3_hp = champion3_hp - self.calculate_ai_damage(3, 5, 0)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 5, 1))
                                            if champion3_hp < 0:
                                                champion3_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                            champion4_hp = champion4_hp - self.calculate_ai_damage(4, 5, 0)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 5, 1))
                                            if champion4_hp < 0:
                                                champion4_hp = 0
                                        elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                            champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 5, 0) * 0.5)
                                            champion5_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(5, 5, 0) * 0.5))
                                            if champion5_hp < 0:
                                                champion5_hp = 0
                                    elif immune == "Evasive Manoeuvres":
                                        self.apply_taunt(5, MASTER_FENCER.title, 1)
                            elif CHAMPION_LIST[0] == MONK.title:
                                bauble_damage = self.calculate_ai_damage(5, 5, 0)
                                bauble_unavailable_check = 0
                                if monk_bauble_damage_list1[1] == 0:
                                    monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                else:
                                    if monk_bauble_damage_list2[1] == 0:
                                        monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list3[1] == 0:
                                            monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            bauble_unavailable_check = 1
                                monk_damage_taken = 0
                                if monk_bauble_damage_list1[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                if monk_bauble_damage_list2[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                if monk_bauble_damage_list3[1] != 0:
                                    monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                if bauble_unavailable_check == 1:
                                    monk_damage_taken = monk_damage_taken + bauble_damage
                                champion5_hp = champion5_hp - math.ceil(monk_damage_taken)
                                champion5_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                if champion5_hp < 0:
                                    champion5_hp = 0
                            elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                ai_hit_fencer_range = random.randint(1, 100)
                                if ai_hit_fencer_range <= ai5_fencer_dodgechance:
                                    if AI_SIZE == "Tiny":
                                        champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 5, 0) * 0.5)
                                        champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 5, 1) * 0.5)
                                        self.apply_taunt(5, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Small":
                                        champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 5, 0) * 0.6)
                                        champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 5, 1) * 0.6)
                                        self.apply_taunt(5, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Medium":
                                        champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 5, 0) * 0.7)
                                        champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 5, 1) * 0.7)
                                        self.apply_taunt(5, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Large":
                                        champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 5, 0) * 0.8)
                                        champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 5, 1) * 0.8)
                                        self.apply_taunt(5, MASTER_FENCER.title, 1)
                                    if AI_SIZE == "Huge":
                                        champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 5, 0) * 0.9)
                                        champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 5, 1) * 0.9)
                                        self.apply_taunt(5, MASTER_FENCER.title, 1)
                                else:
                                    champion5_hp = champion5_hp - self.calculate_ai_damage(5, 5, 0)
                                    champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 5, 1))
                                    if champion5_hp < 0:
                                        champion5_hp = 0
                            else:
                                champion5_hp = champion5_hp - self.calculate_ai_damage(5, 5, 0)
                                champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 5, 1))
                                if champion5_hp < 0:
                                    champion5_hp = 0
                            if champion5_bush_armour != 0:
                                ai5_hp = ai5_hp - 200
                                self.apply_thornsDot(1, 5)
                            if ai5_hp < 0:
                                ai5_hp = 0
                    else:
                        if "Everyone" in ai5_attack_intention:
                            if champion1_hp != 0:
                                if len(champion1_immunity) != 0:
                                    immune_list = []
                                    for immune in champion1_immunity:
                                        if immune == "Cocoon":
                                            champion1_hp = champion1_hp
                                        elif immune == "Block":
                                            if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                                champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 5, 0) * 0.5)
                                                champion1_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(1, 5, 1) * 0.5))
                                                if champion1_hp < 0:
                                                    champion1_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                                champion2_hp = champion2_hp - self.calculate_ai_damage(2, 5, 0)
                                                champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 5, 1))
                                                if champion2_hp < 0:
                                                    champion2_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                                champion3_hp = champion3_hp - self.calculate_ai_damage(3, 5, 0)
                                                champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 5, 1))
                                                if champion3_hp < 0:
                                                    champion3_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                                champion4_hp = champion4_hp - self.calculate_ai_damage(4, 5, 0)
                                                champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 5, 1))
                                                if champion4_hp < 0:
                                                    champion4_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                                champion5_hp = champion5_hp - self.calculate_ai_damage(5, 5, 0)
                                                champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 5, 1))
                                                if champion5_hp < 0:
                                                    champion5_hp = 0
                                        elif immune == "Evasive Manoeuvres":
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                elif CHAMPION_LIST[0] == MONK.title:
                                    bauble_damage = self.calculate_ai_damage(1, 5, 0)
                                    bauble_unavailable_check = 0
                                    if monk_bauble_damage_list1[1] == 0:
                                        monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list2[1] == 0:
                                            monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            if monk_bauble_damage_list3[1] == 0:
                                                monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                            else:
                                                bauble_unavailable_check = 1
                                    monk_damage_taken = 0
                                    if monk_bauble_damage_list1[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                    if monk_bauble_damage_list2[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                    if monk_bauble_damage_list3[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                    if bauble_unavailable_check == 1:
                                        monk_damage_taken = monk_damage_taken + bauble_damage
                                    champion1_hp = champion1_hp - math.ceil(monk_damage_taken)
                                    champion1_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                    if champion1_hp < 0:
                                        champion1_hp = 0
                                elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                    ai_hit_fencer_range = random.randint(1, 100)
                                    if ai_hit_fencer_range <= ai5_fencer_dodgechance:
                                        if AI_SIZE == "Tiny":
                                            champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 5, 0) * 0.5)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 5, 1) * 0.5)
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Small":
                                            champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 5, 0) * 0.6)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 5, 1) * 0.6)
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Medium":
                                            champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 5, 0) * 0.7)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 5, 1) * 0.7)
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Large":
                                            champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 5, 0) * 0.8)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 5, 1) * 0.8)
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Huge":
                                            champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 5, 0) * 0.9)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 5, 1) * 0.9)
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                    else:
                                        champion1_hp = champion1_hp - self.calculate_ai_damage(1, 5, 0)
                                        champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 5, 1))
                                        if champion1_hp < 0:
                                            champion1_hp = 0
                                elif CHAMPION_LIST[0] == POWER_CONDUIT.title:
                                    champion1_hp = champion1_hp - self.calculate_ai_damage(1, 5, 0)
                                    champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 5, 1))
                                    if champion1_hp < 0:
                                        champion1_hp = 0
                                    ai5_hp = ai5_hp - 750
                                    if ai5_hp < 0:
                                        ai5_hp = 0
                                elif CHAMPION_LIST[0] == ACADEMIC_MAGE.title:
                                    mage_damage_taken = math.ceil(self.calculate_ai_damage(1, 5, 0) - champion1_magical_barrier)
                                    if mage_damage_taken < 0:
                                        champion1_magical_barrier = mage_damage_taken * -1
                                    else:
                                        champion1_magical_barrier = 0
                                        champion1_hp = champion1_hp - mage_damage_taken
                                        champion1_lastRoundDamageTaken_list.append(mage_damage_taken)
                                        if champion1_hp < 0:
                                            champion1_hp = 0
                                else:
                                    champion1_hp = champion1_hp - self.calculate_ai_damage(1, 5, 0)
                                    champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 5, 1))
                                    if champion1_hp < 0:
                                        champion1_hp = 0
                                if champion1_bush_armour != 0:
                                    ai5_hp = ai5_hp - 200
                                    self.apply_thornsDot(5, 1)
                                if ai5_hp < 0:
                                    ai5_hp = 0
                            if champion2_hp != 0:
                                if len(champion2_immunity) != 0:
                                    immune_list = []
                                    for immune in champion2_immunity:
                                        if immune == "Cocoon":
                                            champion2_hp = champion2_hp
                                        elif immune == "Block":
                                            if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                                champion1_hp = champion1_hp - self.calculate_ai_damage(1, 5, 0)
                                                champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 5, 1))
                                                if champion1_hp < 0:
                                                    champion1_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                                champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 5, 0) * 0.5)
                                                champion2_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(2, 5, 1) * 0.5))
                                                if champion2_hp < 0:
                                                    champion2_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                                champion3_hp = champion3_hp - self.calculate_ai_damage(3, 5, 0)
                                                champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 5, 1))
                                                if champion3_hp < 0:
                                                    champion3_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                                champion4_hp = champion4_hp - self.calculate_ai_damage(4, 5, 0)
                                                champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 5, 1))
                                                if champion4_hp < 0:
                                                    champion4_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                                champion5_hp = champion5_hp - self.calculate_ai_damage(5, 5, 0)
                                                champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 5, 1))
                                                if champion5_hp < 0:
                                                    champion5_hp = 0
                                        elif immune == "Evasive Manoeuvres":
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                elif CHAMPION_LIST[0] == MONK.title:
                                    bauble_damage = self.calculate_ai_damage(2, 5, 0)
                                    bauble_unavailable_check = 0
                                    if monk_bauble_damage_list1[1] == 0:
                                        monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list2[1] == 0:
                                            monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            if monk_bauble_damage_list3[1] == 0:
                                                monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                            else:
                                                bauble_unavailable_check = 1
                                    monk_damage_taken = 0
                                    if monk_bauble_damage_list1[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                    if monk_bauble_damage_list2[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                    if monk_bauble_damage_list3[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                    if bauble_unavailable_check == 1:
                                        monk_damage_taken = monk_damage_taken + bauble_damage
                                    champion2_hp = champion2_hp - math.ceil(monk_damage_taken)
                                    champion2_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                    if champion2_hp < 0:
                                        champion2_hp = 0
                                elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                    ai_hit_fencer_range = random.randint(1, 100)
                                    if ai_hit_fencer_range <= ai5_fencer_dodgechance:
                                        if AI_SIZE == "Tiny":
                                            champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 5, 0) * 0.5)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 5, 1) * 0.5)
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Small":
                                            champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 5, 0) * 0.6)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 5, 1) * 0.6)
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Medium":
                                            champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 5, 0) * 0.7)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 5, 1) * 0.7)
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Large":
                                            champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 5, 0) * 0.8)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 5, 1) * 0.8)
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Huge":
                                            champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 5, 0) * 0.9)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 5, 1) * 0.9)
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                    else:
                                        champion2_hp = champion2_hp - self.calculate_ai_damage(2, 5, 0)
                                        champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 5, 1))
                                        if champion2_hp < 0:
                                            champion2_hp = 0
                                elif CHAMPION_LIST[0] == POWER_CONDUIT.title:
                                    champion2_hp = champion2_hp - self.calculate_ai_damage(2, 5, 0)
                                    champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 5, 1))
                                    if champion2_hp < 0:
                                        champion2_hp = 0
                                    ai5_hp = ai5_hp - 750
                                    if ai5_hp < 0:
                                        ai5_hp = 0
                                elif CHAMPION_LIST[0] == ACADEMIC_MAGE.title:
                                    mage_damage_taken = math.ceil(self.calculate_ai_damage(2, 5, 0) - champion2_magical_barrier)
                                    if mage_damage_taken < 0:
                                        champion2_magical_barrier = mage_damage_taken * -1
                                    else:
                                        champion2_magical_barrier = 0
                                        champion2_hp = champion2_hp - mage_damage_taken
                                        champion2_lastRoundDamageTaken_list.append(mage_damage_taken)
                                        if champion2_hp < 0:
                                            champion2_hp = 0
                                else:
                                    champion2_hp = champion2_hp - self.calculate_ai_damage(2, 5, 0)
                                    champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 5, 1))
                                    if champion2_hp < 0:
                                        champion2_hp = 0
                                if champion2_bush_armour != 0:
                                    ai5_hp = ai5_hp - 200
                                    self.apply_thornsDot(5, 1)
                                if ai5_hp < 0:
                                    ai5_hp = 0
                            if champion3_hp != 0:
                                if len(champion3_immunity) != 0:
                                    immune_list = []
                                    for immune in champion3_immunity:
                                        if immune == "Cocoon":
                                            champion3_hp = champion3_hp
                                        elif immune == "Block":
                                            if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                                champion1_hp = champion1_hp - self.calculate_ai_damage(1, 5, 0)
                                                champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 5, 1))
                                                if champion1_hp < 0:
                                                    champion1_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                                champion2_hp = champion2_hp - self.calculate_ai_damage(2, 5, 0)
                                                champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 5, 1))
                                                if champion2_hp < 0:
                                                    champion2_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                                champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 5, 0) * 0.5)
                                                champion3_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(3, 5, 1) * 0.5))
                                                if champion3_hp < 0:
                                                    champion3_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                                champion4_hp = champion4_hp - self.calculate_ai_damage(4, 5, 0)
                                                champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 5, 1))
                                                if champion4_hp < 0:
                                                    champion4_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                                champion5_hp = champion5_hp - self.calculate_ai_damage(5, 5, 0)
                                                champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 5, 1))
                                                if champion5_hp < 0:
                                                    champion5_hp = 0
                                        elif immune == "Evasive Manoeuvres":
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                elif CHAMPION_LIST[0] == MONK.title:
                                    bauble_damage = self.calculate_ai_damage(3, 5, 0)
                                    bauble_unavailable_check = 0
                                    if monk_bauble_damage_list1[1] == 0:
                                        monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list2[1] == 0:
                                            monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            if monk_bauble_damage_list3[1] == 0:
                                                monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                            else:
                                                bauble_unavailable_check = 1
                                    monk_damage_taken = 0
                                    if monk_bauble_damage_list1[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                    if monk_bauble_damage_list2[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                    if monk_bauble_damage_list3[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                    if bauble_unavailable_check == 1:
                                        monk_damage_taken = monk_damage_taken + bauble_damage
                                    champion3_hp = champion3_hp - math.ceil(monk_damage_taken)
                                    champion3_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                    if champion3_hp < 0:
                                        champion3_hp = 0
                                elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                    ai_hit_fencer_range = random.randint(1, 100)
                                    if ai_hit_fencer_range <= ai5_fencer_dodgechance:
                                        if AI_SIZE == "Tiny":
                                            champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 5, 0) * 0.5)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 5, 1) * 0.5)
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Small":
                                            champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 5, 0) * 0.6)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 5, 1) * 0.6)
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Medium":
                                            champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 5, 0) * 0.7)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 5, 1) * 0.7)
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Large":
                                            champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 5, 0) * 0.8)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 5, 1) * 0.8)
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Huge":
                                            champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 5, 0) * 0.9)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 5, 1) * 0.9)
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                    else:
                                        champion3_hp = champion3_hp - self.calculate_ai_damage(3, 5, 0)
                                        champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 5, 1))
                                        if champion3_hp < 0:
                                            champion3_hp = 0
                                elif CHAMPION_LIST[0] == POWER_CONDUIT.title:
                                    champion3_hp = champion3_hp - self.calculate_ai_damage(3, 5, 0)
                                    champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 5, 1))
                                    if champion3_hp < 0:
                                        champion3_hp = 0
                                    ai5_hp = ai5_hp - 750
                                    if ai5_hp < 0:
                                        ai5_hp = 0
                                elif CHAMPION_LIST[0] == ACADEMIC_MAGE.title:
                                    mage_damage_taken = math.ceil(self.calculate_ai_damage(3, 5, 0) - champion3_magical_barrier)
                                    if mage_damage_taken < 0:
                                        champion3_magical_barrier = mage_damage_taken * -1
                                    else:
                                        champion3_magical_barrier = 0
                                        champion3_hp = champion3_hp - mage_damage_taken
                                        champion3_lastRoundDamageTaken_list.append(mage_damage_taken)
                                        if champion3_hp < 0:
                                            champion3_hp = 0
                                else:
                                    champion3_hp = champion3_hp - self.calculate_ai_damage(3, 5, 0)
                                    champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 5, 1))
                                    if champion3_hp < 0:
                                        champion3_hp = 0
                                if champion3_bush_armour != 0:
                                    ai5_hp = ai5_hp - 200
                                    self.apply_thornsDot(5, 1)
                                if ai5_hp < 0:
                                    ai5_hp = 0
                            if champion4_hp != 0:
                                if len(champion4_immunity) != 0:
                                    immune_list = []
                                    for immune in champion4_immunity:
                                        if immune == "Cocoon":
                                            champion4_hp = champion4_hp
                                        elif immune == "Block":
                                            if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                                champion1_hp = champion1_hp - self.calculate_ai_damage(1, 5, 0)
                                                champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 5, 1))
                                                if champion1_hp < 0:
                                                    champion1_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                                champion2_hp = champion2_hp - self.calculate_ai_damage(2, 5, 0)
                                                champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 5, 1))
                                                if champion2_hp < 0:
                                                    champion2_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                                champion3_hp = champion3_hp - self.calculate_ai_damage(3, 5, 0)
                                                champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 5, 1))
                                                if champion3_hp < 0:
                                                    champion3_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                                champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 5, 0) * 0.5)
                                                champion4_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(4, 5, 1) * 0.5))
                                                if champion4_hp < 0:
                                                    champion4_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                                champion5_hp = champion5_hp - self.calculate_ai_damage(5, 5, 0)
                                                champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 5, 1))
                                                if champion5_hp < 0:
                                                    champion5_hp = 0
                                        elif immune == "Evasive Manoeuvres":
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                elif CHAMPION_LIST[0] == MONK.title:
                                    bauble_damage = self.calculate_ai_damage(4, 5, 0)
                                    bauble_unavailable_check = 0
                                    if monk_bauble_damage_list1[1] == 0:
                                        monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list2[1] == 0:
                                            monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            if monk_bauble_damage_list3[1] == 0:
                                                monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                            else:
                                                bauble_unavailable_check = 1
                                    monk_damage_taken = 0
                                    if monk_bauble_damage_list1[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                    if monk_bauble_damage_list2[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                    if monk_bauble_damage_list3[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                    if bauble_unavailable_check == 1:
                                        monk_damage_taken = monk_damage_taken + bauble_damage
                                    champion4_hp = champion4_hp - math.ceil(monk_damage_taken)
                                    champion4_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                    if champion4_hp < 0:
                                        champion4_hp = 0
                                elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                    ai_hit_fencer_range = random.randint(1, 100)
                                    if ai_hit_fencer_range <= ai5_fencer_dodgechance:
                                        if AI_SIZE == "Tiny":
                                            champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 5, 0) * 0.5)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 5, 1) * 0.5)
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Small":
                                            champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 5, 0) * 0.6)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 5, 1) * 0.6)
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Medium":
                                            champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 5, 0) * 0.7)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 5, 1) * 0.7)
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Large":
                                            champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 5, 0) * 0.8)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 5, 1) * 0.8)
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Huge":
                                            champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 5, 0) * 0.9)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 5, 1) * 0.9)
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                    else:
                                        champion4_hp = champion4_hp - self.calculate_ai_damage(4, 5, 0)
                                        champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 5, 1))
                                        if champion4_hp < 0:
                                            champion4_hp = 0
                                elif CHAMPION_LIST[0] == POWER_CONDUIT.title:
                                    champion4_hp = champion4_hp - self.calculate_ai_damage(4, 5, 0)
                                    champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 5, 1))
                                    if champion4_hp < 0:
                                        champion4_hp = 0
                                    ai5_hp = ai5_hp - 750
                                    if ai5_hp < 0:
                                        ai5_hp = 0
                                elif CHAMPION_LIST[0] == ACADEMIC_MAGE.title:
                                    mage_damage_taken = math.ceil(self.calculate_ai_damage(4, 5, 0) - champion4_magical_barrier)
                                    if mage_damage_taken < 0:
                                        champion4_magical_barrier = mage_damage_taken * -1
                                    else:
                                        champion4_magical_barrier = 0
                                        champion4_hp = champion4_hp - mage_damage_taken
                                        champion4_lastRoundDamageTaken_list.append(mage_damage_taken)
                                        if champion4_hp < 0:
                                            champion4_hp = 0
                                else:
                                    champion4_hp = champion4_hp - self.calculate_ai_damage(4, 5, 0)
                                    champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 5, 1))
                                    if champion4_hp < 0:
                                        champion4_hp = 0
                                if champion4_bush_armour != 0:
                                    ai5_hp = ai5_hp - 200
                                    self.apply_thornsDot(5, 1)
                                if ai5_hp < 0:
                                    ai5_hp = 0
                            if champion5_hp != 0:
                                if len(champion5_immunity) != 0:
                                    immune_list = []
                                    for immune in champion5_immunity:
                                        if immune == "Cocoon":
                                            champion5_hp = champion5_hp
                                        elif immune == "Block":
                                            if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                                champion1_hp = champion1_hp - self.calculate_ai_damage(1, 5, 0)
                                                champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 5, 1))
                                                if champion1_hp < 0:
                                                    champion1_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                                champion2_hp = champion2_hp - self.calculate_ai_damage(2, 5, 0)
                                                champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 5, 1))
                                                if champion2_hp < 0:
                                                    champion2_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                                champion3_hp = champion3_hp - self.calculate_ai_damage(3, 5, 0)
                                                champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 5, 1))
                                                if champion3_hp < 0:
                                                    champion3_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                                champion4_hp = champion4_hp - self.calculate_ai_damage(4, 5, 0)
                                                champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 5, 1))
                                                if champion4_hp < 0:
                                                    champion4_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                                champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 5, 0) * 0.5)
                                                champion5_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(5, 5, 1) * 0.5))
                                                if champion5_hp < 0:
                                                    champion5_hp = 0
                                        elif immune == "Evasive Manoeuvres":
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                elif CHAMPION_LIST[0] == MONK.title:
                                    bauble_damage = self.calculate_ai_damage(5, 5, 0)
                                    bauble_unavailable_check = 0
                                    if monk_bauble_damage_list1[1] == 0:
                                        monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list2[1] == 0:
                                            monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            if monk_bauble_damage_list3[1] == 0:
                                                monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                            else:
                                                bauble_unavailable_check = 1
                                    monk_damage_taken = 0
                                    if monk_bauble_damage_list1[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                    if monk_bauble_damage_list2[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                    if monk_bauble_damage_list3[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                    if bauble_unavailable_check == 1:
                                        monk_damage_taken = monk_damage_taken + bauble_damage
                                    champion5_hp = champion5_hp - math.ceil(monk_damage_taken)
                                    champion5_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                    if champion5_hp < 0:
                                        champion5_hp = 0
                                elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                    ai_hit_fencer_range = random.randint(1, 100)
                                    if ai_hit_fencer_range <= ai5_fencer_dodgechance:
                                        if AI_SIZE == "Tiny":
                                            champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 5, 0) * 0.5)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 5, 1) * 0.5)
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Small":
                                            champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 5, 0) * 0.6)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 5, 1) * 0.6)
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Medium":
                                            champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 5, 0) * 0.7)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 5, 1) * 0.7)
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Large":
                                            champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 5, 0) * 0.8)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 5, 1) * 0.8)
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Huge":
                                            champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 5, 0) * 0.9)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 5, 1) * 0.9)
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                    else:
                                        champion5_hp = champion5_hp - self.calculate_ai_damage(5, 5, 0)
                                        champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 5, 1))
                                        if champion5_hp < 0:
                                            champion5_hp = 0
                                elif CHAMPION_LIST[0] == POWER_CONDUIT.title:
                                    champion5_hp = champion5_hp - self.calculate_ai_damage(5, 5, 0)
                                    champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 5, 1))
                                    if champion5_hp < 0:
                                        champion5_hp = 0
                                    ai5_hp = ai5_hp - 750
                                    if ai5_hp < 0:
                                        ai5_hp = 0
                                elif CHAMPION_LIST[0] == ACADEMIC_MAGE.title:
                                    mage_damage_taken = math.ceil(self.calculate_ai_damage(5, 5, 0) - champion5_magical_barrier)
                                    if mage_damage_taken < 0:
                                        champion5_magical_barrier = mage_damage_taken * -1
                                    else:
                                        champion5_magical_barrier = 0
                                        champion5_hp = champion5_hp - mage_damage_taken
                                        champion5_lastRoundDamageTaken_list.append(mage_damage_taken)
                                        if champion5_hp < 0:
                                            champion5_hp = 0
                                else:
                                    champion5_hp = champion5_hp - self.calculate_ai_damage(5, 5, 0)
                                    champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 5, 1))
                                    if champion5_hp < 0:
                                        champion5_hp = 0
                                if champion5_bush_armour != 0:
                                    ai5_hp = ai5_hp - 200
                                    self.apply_thornsDot(5, 1)
                                if ai5_hp < 0:
                                    ai5_hp = 0
                        else:
                            if CHAMPION_LIST[0] in ai5_attack_intention:
                                if len(champion1_immunity) != 0:
                                    immune_list = []
                                    for immune in champion1_immunity:
                                        if immune == "Cocoon":
                                            champion1_hp = champion1_hp
                                        elif immune == "Block":
                                            if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                                champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 5, 0) * 0.5)
                                                champion1_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(1, 5, 1) * 0.5))
                                                if champion1_hp < 0:
                                                    champion1_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                                champion2_hp = champion2_hp - self.calculate_ai_damage(2, 5, 0)
                                                champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 5, 1))
                                                if champion2_hp < 0:
                                                    champion2_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                                champion3_hp = champion3_hp - self.calculate_ai_damage(3, 5, 0)
                                                champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 5, 1))
                                                if champion3_hp < 0:
                                                    champion3_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                                champion4_hp = champion4_hp - self.calculate_ai_damage(4, 5, 0)
                                                champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 5, 1))
                                                if champion4_hp < 0:
                                                    champion4_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                                champion5_hp = champion5_hp - self.calculate_ai_damage(5, 5, 0)
                                                champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 5, 1))
                                                if champion5_hp < 0:
                                                    champion5_hp = 0
                                        elif immune == "Evasive Manoeuvres":
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                elif CHAMPION_LIST[0] == MONK.title:
                                    bauble_damage = self.calculate_ai_damage(1, 5, 0)
                                    bauble_unavailable_check = 0
                                    if monk_bauble_damage_list1[1] == 0:
                                        monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list2[1] == 0:
                                            monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            if monk_bauble_damage_list3[1] == 0:
                                                monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                            else:
                                                bauble_unavailable_check = 1
                                    monk_damage_taken = 0
                                    if monk_bauble_damage_list1[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                    if monk_bauble_damage_list2[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                    if monk_bauble_damage_list3[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                    if bauble_unavailable_check == 1:
                                        monk_damage_taken = monk_damage_taken + bauble_damage
                                    champion1_hp = champion1_hp - math.ceil(monk_damage_taken)
                                    champion1_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                    if champion1_hp < 0:
                                        champion1_hp = 0
                                elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                    ai_hit_fencer_range = random.randint(1, 100)
                                    if ai_hit_fencer_range <= ai5_fencer_dodgechance:
                                        if AI_SIZE == "Tiny":
                                            champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 5, 0) * 0.5)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 5, 1) * 0.5)
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Small":
                                            champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 5, 0) * 0.6)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 5, 1) * 0.6)
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Medium":
                                            champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 5, 0) * 0.7)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 5, 1) * 0.7)
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Large":
                                            champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 5, 0) * 0.8)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 5, 1) * 0.8)
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Huge":
                                            champion1_hp = champion1_hp - math.ceil(self.calculate_ai_damage(1, 5, 0) * 0.9)
                                            champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 5, 1) * 0.9)
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                    else:
                                        champion1_hp = champion1_hp - self.calculate_ai_damage(1, 5, 0)
                                        champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 5, 1))
                                        if champion1_hp < 0:
                                            champion1_hp = 0
                                elif CHAMPION_LIST[0] == POWER_CONDUIT.title:
                                    champion1_hp = champion1_hp - self.calculate_ai_damage(1, 5, 0)
                                    champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 5, 1))
                                    if champion1_hp < 0:
                                        champion1_hp = 0
                                    ai5_hp = ai5_hp - 750
                                    if ai5_hp < 0:
                                        ai5_hp = 0
                                elif CHAMPION_LIST[0] == ACADEMIC_MAGE.title:
                                    mage_damage_taken = math.ceil(self.calculate_ai_damage(1, 5, 0) - champion1_magical_barrier)
                                    if mage_damage_taken < 0:
                                        champion1_magical_barrier = mage_damage_taken * -1
                                    else:
                                        champion1_magical_barrier = 0
                                        champion1_hp = champion1_hp - mage_damage_taken
                                        champion1_lastRoundDamageTaken_list.append(mage_damage_taken)
                                        if champion1_hp < 0:
                                            champion1_hp = 0
                                else:
                                    champion1_hp = champion1_hp - self.calculate_ai_damage(1, 5, 0)
                                    champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 5, 1))
                                    if champion1_hp < 0:
                                        champion1_hp = 0
                                if champion1_bush_armour != 0:
                                    ai5_hp = ai5_hp - 200
                                    self.apply_thornsDot(5, 1)
                                if ai5_hp < 0:
                                    ai5_hp = 0
                            if CHAMPION_LIST[1] in ai5_attack_intention:
                                if len(champion2_immunity) != 0:
                                    immune_list = []
                                    for immune in champion2_immunity:
                                        if immune == "Cocoon":
                                            champion2_hp = champion2_hp
                                        elif immune == "Block":
                                            if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                                champion1_hp = champion1_hp - self.calculate_ai_damage(1, 5, 0)
                                                champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 5, 1))
                                                if champion1_hp < 0:
                                                    champion1_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                                champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 5, 0) * 0.5)
                                                champion2_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(2, 5, 1) * 0.5))
                                                if champion2_hp < 0:
                                                    champion2_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                                champion3_hp = champion3_hp - self.calculate_ai_damage(3, 5, 0)
                                                champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 5, 1))
                                                if champion3_hp < 0:
                                                    champion3_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                                champion4_hp = champion4_hp - self.calculate_ai_damage(4, 5, 0)
                                                champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 5, 1))
                                                if champion4_hp < 0:
                                                    champion4_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                                champion5_hp = champion5_hp - self.calculate_ai_damage(5, 5, 0)
                                                champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 5, 1))
                                                if champion5_hp < 0:
                                                    champion5_hp = 0
                                        elif immune == "Evasive Manoeuvres":
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                elif CHAMPION_LIST[0] == MONK.title:
                                    bauble_damage = self.calculate_ai_damage(2, 5, 0)
                                    bauble_unavailable_check = 0
                                    if monk_bauble_damage_list1[1] == 0:
                                        monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list2[1] == 0:
                                            monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            if monk_bauble_damage_list3[1] == 0:
                                                monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                            else:
                                                bauble_unavailable_check = 1
                                    monk_damage_taken = 0
                                    if monk_bauble_damage_list1[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                    if monk_bauble_damage_list2[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                    if monk_bauble_damage_list3[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                    if bauble_unavailable_check == 1:
                                        monk_damage_taken = monk_damage_taken + bauble_damage
                                    champion2_hp = champion2_hp - math.ceil(monk_damage_taken)
                                    champion2_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                    if champion2_hp < 0:
                                        champion2_hp = 0
                                elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                    ai_hit_fencer_range = random.randint(1, 100)
                                    if ai_hit_fencer_range <= ai5_fencer_dodgechance:
                                        if AI_SIZE == "Tiny":
                                            champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 5, 0) * 0.5)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 5, 1) * 0.5)
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Small":
                                            champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 5, 0) * 0.6)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 5, 1) * 0.6)
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Medium":
                                            champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 5, 0) * 0.7)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 5, 1) * 0.7)
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Large":
                                            champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 5, 0) * 0.8)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 5, 1) * 0.8)
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Huge":
                                            champion2_hp = champion2_hp - math.ceil(self.calculate_ai_damage(2, 5, 0) * 0.9)
                                            champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 5, 1) * 0.9)
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                    else:
                                        champion2_hp = champion2_hp - self.calculate_ai_damage(2, 5, 0)
                                        champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 5, 1))
                                        if champion2_hp < 0:
                                            champion2_hp = 0
                                elif CHAMPION_LIST[0] == POWER_CONDUIT.title:
                                    champion2_hp = champion2_hp - self.calculate_ai_damage(2, 5, 0)
                                    champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 5, 1))
                                    if champion2_hp < 0:
                                        champion2_hp = 0
                                    ai5_hp = ai5_hp - 750
                                    if ai5_hp < 0:
                                        ai5_hp = 0
                                elif CHAMPION_LIST[0] == ACADEMIC_MAGE.title:
                                    mage_damage_taken = math.ceil(self.calculate_ai_damage(2, 5, 0) - champion2_magical_barrier)
                                    if mage_damage_taken < 0:
                                        champion2_magical_barrier = mage_damage_taken * -1
                                    else:
                                        champion2_magical_barrier = 0
                                        champion2_hp = champion2_hp - mage_damage_taken
                                        champion2_lastRoundDamageTaken_list.append(mage_damage_taken)
                                        if champion2_hp < 0:
                                            champion2_hp = 0
                                else:
                                    champion2_hp = champion2_hp - self.calculate_ai_damage(2, 5, 0)
                                    champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 5, 1))
                                    if champion2_hp < 0:
                                        champion2_hp = 0
                                if champion2_bush_armour != 0:
                                    ai5_hp = ai5_hp - 200
                                    self.apply_thornsDot(5, 1)
                                if ai5_hp < 0:
                                    ai5_hp = 0
                            if CHAMPION_LIST[2] in ai5_attack_intention:
                                if len(champion3_immunity) != 0:
                                    immune_list = []
                                    for immune in champion3_immunity:
                                        if immune == "Cocoon":
                                            champion3_hp = champion3_hp
                                        elif immune == "Block":
                                            if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                                champion1_hp = champion1_hp - self.calculate_ai_damage(1, 5, 0)
                                                champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 5, 1))
                                                if champion1_hp < 0:
                                                    champion1_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                                champion2_hp = champion2_hp - self.calculate_ai_damage(2, 5, 0)
                                                champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 5, 1))
                                                if champion2_hp < 0:
                                                    champion2_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                                champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 5, 0) * 0.5)
                                                champion3_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(3, 5, 1) * 0.5))
                                                if champion3_hp < 0:
                                                    champion3_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                                champion4_hp = champion4_hp - self.calculate_ai_damage(4, 5, 0)
                                                champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 5, 1))
                                                if champion4_hp < 0:
                                                    champion4_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                                champion5_hp = champion5_hp - self.calculate_ai_damage(5, 5, 0)
                                                champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 5, 1))
                                                if champion5_hp < 0:
                                                    champion5_hp = 0
                                        elif immune == "Evasive Manoeuvres":
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                elif CHAMPION_LIST[0] == MONK.title:
                                    bauble_damage = self.calculate_ai_damage(3, 5, 0)
                                    bauble_unavailable_check = 0
                                    if monk_bauble_damage_list1[1] == 0:
                                        monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list2[1] == 0:
                                            monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            if monk_bauble_damage_list3[1] == 0:
                                                monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                            else:
                                                bauble_unavailable_check = 1
                                    monk_damage_taken = 0
                                    if monk_bauble_damage_list1[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                    if monk_bauble_damage_list2[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                    if monk_bauble_damage_list3[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                    if bauble_unavailable_check == 1:
                                        monk_damage_taken = monk_damage_taken + bauble_damage
                                    champion3_hp = champion3_hp - math.ceil(monk_damage_taken)
                                    champion3_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                    if champion3_hp < 0:
                                        champion3_hp = 0
                                elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                    ai_hit_fencer_range = random.randint(1, 100)
                                    if ai_hit_fencer_range <= ai5_fencer_dodgechance:
                                        if AI_SIZE == "Tiny":
                                            champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 5, 0) * 0.5)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 5, 1) * 0.5)
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Small":
                                            champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 5, 0) * 0.6)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 5, 1) * 0.6)
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Medium":
                                            champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 5, 0) * 0.7)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 5, 1) * 0.7)
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Large":
                                            champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 5, 0) * 0.8)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 5, 1) * 0.8)
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Huge":
                                            champion3_hp = champion3_hp - math.ceil(self.calculate_ai_damage(3, 5, 0) * 0.9)
                                            champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 5, 1) * 0.9)
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                    else:
                                        champion3_hp = champion3_hp - self.calculate_ai_damage(3, 5, 0)
                                        champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 5, 1))
                                        if champion3_hp < 0:
                                            champion3_hp = 0
                                elif CHAMPION_LIST[0] == POWER_CONDUIT.title:
                                    champion3_hp = champion3_hp - self.calculate_ai_damage(3, 5, 0)
                                    champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 5, 1))
                                    if champion3_hp < 0:
                                        champion3_hp = 0
                                    ai5_hp = ai5_hp - 750
                                    if ai5_hp < 0:
                                        ai5_hp = 0
                                elif CHAMPION_LIST[0] == ACADEMIC_MAGE.title:
                                    mage_damage_taken = math.ceil(self.calculate_ai_damage(3, 5, 0) - champion3_magical_barrier)
                                    if mage_damage_taken < 0:
                                        champion3_magical_barrier = mage_damage_taken * -1
                                    else:
                                        champion3_magical_barrier = 0
                                        champion3_hp = champion3_hp - mage_damage_taken
                                        champion3_lastRoundDamageTaken_list.append(mage_damage_taken)
                                        if champion3_hp < 0:
                                            champion3_hp = 0
                                else:
                                    champion3_hp = champion3_hp - self.calculate_ai_damage(3, 5, 0)
                                    champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 5, 1))
                                    if champion3_hp < 0:
                                        champion3_hp = 0
                                if champion3_bush_armour != 0:
                                    ai5_hp = ai5_hp - 200
                                    self.apply_thornsDot(5, 1)
                                if ai5_hp < 0:
                                    ai5_hp = 0
                            if CHAMPION_LIST[3] in ai5_attack_intention:
                                if len(champion4_immunity) != 0:
                                    immune_list = []
                                    for immune in champion4_immunity:
                                        if immune == "Cocoon":
                                            champion4_hp = champion4_hp
                                        elif immune == "Block":
                                            if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                                champion1_hp = champion1_hp - self.calculate_ai_damage(1, 5, 0)
                                                champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 5, 1))
                                                if champion1_hp < 0:
                                                    champion1_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                                champion2_hp = champion2_hp - self.calculate_ai_damage(2, 5, 0)
                                                champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 5, 1))
                                                if champion2_hp < 0:
                                                    champion2_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                                champion3_hp = champion3_hp - self.calculate_ai_damage(3, 5, 0)
                                                champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 5, 1))
                                                if champion3_hp < 0:
                                                    champion3_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                                champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 5, 0) * 0.5)
                                                champion4_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(4, 5, 1) * 0.5))
                                                if champion4_hp < 0:
                                                    champion4_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                                champion5_hp = champion5_hp - self.calculate_ai_damage(5, 5, 0)
                                                champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 5, 1))
                                                if champion5_hp < 0:
                                                    champion5_hp = 0
                                        elif immune == "Evasive Manoeuvres":
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                elif CHAMPION_LIST[0] == MONK.title:
                                    bauble_damage = self.calculate_ai_damage(4, 5, 0)
                                    bauble_unavailable_check = 0
                                    if monk_bauble_damage_list1[1] == 0:
                                        monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list2[1] == 0:
                                            monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            if monk_bauble_damage_list3[1] == 0:
                                                monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                            else:
                                                bauble_unavailable_check = 1
                                    monk_damage_taken = 0
                                    if monk_bauble_damage_list1[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                    if monk_bauble_damage_list2[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                    if monk_bauble_damage_list3[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                    if bauble_unavailable_check == 1:
                                        monk_damage_taken = monk_damage_taken + bauble_damage
                                    champion4_hp = champion4_hp - math.ceil(monk_damage_taken)
                                    champion4_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                    if champion4_hp < 0:
                                        champion4_hp = 0
                                elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                    ai_hit_fencer_range = random.randint(1, 100)
                                    if ai_hit_fencer_range <= ai5_fencer_dodgechance:
                                        if AI_SIZE == "Tiny":
                                            champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 5, 0) * 0.5)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 5, 1) * 0.5)
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Small":
                                            champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 5, 0) * 0.6)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 5, 1) * 0.6)
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Medium":
                                            champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 5, 0) * 0.7)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 5, 1) * 0.7)
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Large":
                                            champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 5, 0) * 0.8)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 5, 1) * 0.8)
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Huge":
                                            champion4_hp = champion4_hp - math.ceil(self.calculate_ai_damage(4, 5, 0) * 0.9)
                                            champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 5, 1) * 0.9)
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                    else:
                                        champion4_hp = champion4_hp - self.calculate_ai_damage(4, 5, 0)
                                        champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 5, 1))
                                        if champion4_hp < 0:
                                            champion4_hp = 0
                                elif CHAMPION_LIST[0] == POWER_CONDUIT.title:
                                    champion4_hp = champion4_hp - self.calculate_ai_damage(4, 5, 0)
                                    champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 5, 1))
                                    if champion4_hp < 0:
                                        champion4_hp = 0
                                    ai5_hp = ai5_hp - 750
                                    if ai5_hp < 0:
                                        ai5_hp = 0
                                elif CHAMPION_LIST[0] == ACADEMIC_MAGE.title:
                                    mage_damage_taken = math.ceil(self.calculate_ai_damage(4, 5, 0) - champion4_magical_barrier)
                                    if mage_damage_taken < 0:
                                        champion4_magical_barrier = mage_damage_taken * -1
                                    else:
                                        champion4_magical_barrier = 0
                                        champion4_hp = champion4_hp - mage_damage_taken
                                        champion4_lastRoundDamageTaken_list.append(mage_damage_taken)
                                        if champion4_hp < 0:
                                            champion4_hp = 0
                                else:
                                    champion4_hp = champion4_hp - self.calculate_ai_damage(4, 5, 0)
                                    champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 5, 1))
                                    if champion4_hp < 0:
                                        champion4_hp = 0
                                if champion4_bush_armour != 0:
                                    ai5_hp = ai5_hp - 200
                                    self.apply_thornsDot(5, 1)
                                if ai5_hp < 0:
                                    ai5_hp = 0
                            if CHAMPION_LIST[4] in ai5_attack_intention:
                                if len(champion5_immunity) != 0:
                                    for immune in champion5_immunity:
                                        if immune == "Cocoon":
                                            champion5_hp = champion5_hp
                                        elif immune == "Block":
                                            if KINGS_GUARD.title in CHAMPION_LIST[0]:
                                                champion1_hp = champion1_hp - self.calculate_ai_damage(1, 5, 0)
                                                champion1_lastRoundDamageTaken_list.append(self.calculate_ai_damage(1, 5, 1))
                                                if champion1_hp < 0:
                                                    champion1_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[1]:
                                                champion2_hp = champion2_hp - self.calculate_ai_damage(2, 5, 0)
                                                champion2_lastRoundDamageTaken_list.append(self.calculate_ai_damage(2, 5, 1))
                                                if champion2_hp < 0:
                                                    champion2_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[2]:
                                                champion3_hp = champion3_hp - self.calculate_ai_damage(3, 5, 0)
                                                champion3_lastRoundDamageTaken_list.append(self.calculate_ai_damage(3, 5, 1))
                                                if champion3_hp < 0:
                                                    champion3_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[3]:
                                                champion4_hp = champion4_hp - self.calculate_ai_damage(4, 5, 0)
                                                champion4_lastRoundDamageTaken_list.append(self.calculate_ai_damage(4, 5, 1))
                                                if champion4_hp < 0:
                                                    champion4_hp = 0
                                            elif KINGS_GUARD.title in CHAMPION_LIST[4]:
                                                champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 5, 0) * 0.5)
                                                champion5_lastRoundDamageTaken_list.append(math.ceil(self.calculate_ai_damage(5, 5, 1) * 0.5))
                                                if champion5_hp < 0:
                                                    champion5_hp = 0
                                        elif immune == "Evasive Manoeuvres":
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                elif CHAMPION_LIST[0] == MONK.title:
                                    bauble_damage = self.calculate_ai_damage(5, 5, 0)
                                    bauble_unavailable_check = 0
                                    if monk_bauble_damage_list1[1] == 0:
                                        monk_bauble_damage_list1 = [math.ceil(bauble_damage / 3), 3]
                                    else:
                                        if monk_bauble_damage_list2[1] == 0:
                                            monk_bauble_damage_list2 = [math.ceil(bauble_damage / 3), 3]
                                        else:
                                            if monk_bauble_damage_list3[1] == 0:
                                                monk_bauble_damage_list3 = [math.ceil(bauble_damage / 3), 3]
                                            else:
                                                bauble_unavailable_check = 1
                                    monk_damage_taken = 0
                                    if monk_bauble_damage_list1[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list1[0]
                                    if monk_bauble_damage_list2[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list2[0]
                                    if monk_bauble_damage_list3[1] != 0:
                                        monk_damage_taken = monk_damage_taken + monk_bauble_damage_list3[0]
                                    if bauble_unavailable_check == 1:
                                        monk_damage_taken = monk_damage_taken + bauble_damage
                                    champion5_hp = champion5_hp - math.ceil(monk_damage_taken)
                                    champion5_lastRoundDamageTaken_list.append(math.ceil(monk_damage_taken))
                                    if champion5_hp < 0:
                                        champion5_hp = 0
                                elif CHAMPION_LIST[0] == MASTER_FENCER.title:
                                    ai_hit_fencer_range = random.randint(1, 100)
                                    if ai_hit_fencer_range <= ai5_fencer_dodgechance:
                                        if AI_SIZE == "Tiny":
                                            champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 5, 0) * 0.5)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 5, 1) * 0.5)
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Small":
                                            champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 5, 0) * 0.6)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 5, 1) * 0.6)
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Medium":
                                            champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 5, 0) * 0.7)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 5, 1) * 0.7)
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Large":
                                            champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 5, 0) * 0.8)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 5, 1) * 0.8)
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                        if AI_SIZE == "Huge":
                                            champion5_hp = champion5_hp - math.ceil(self.calculate_ai_damage(5, 5, 0) * 0.9)
                                            champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 5, 1) * 0.9)
                                            self.apply_taunt(5, MASTER_FENCER.title, 1)
                                    else:
                                        champion5_hp = champion5_hp - self.calculate_ai_damage(5, 5, 0)
                                        champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 5, 1))
                                        if champion5_hp < 0:
                                            champion5_hp = 0
                                elif CHAMPION_LIST[0] == POWER_CONDUIT.title:
                                    champion5_hp = champion5_hp - self.calculate_ai_damage(5, 5, 0)
                                    champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 5, 1))
                                    if champion5_hp < 0:
                                        champion5_hp = 0
                                    ai5_hp = ai5_hp - 750
                                    if ai5_hp < 0:
                                        ai5_hp = 0
                                elif CHAMPION_LIST[0] == ACADEMIC_MAGE.title:
                                    mage_damage_taken = math.ceil(self.calculate_ai_damage(5, 5, 0) - champion5_magical_barrier)
                                    if mage_damage_taken < 0:
                                        champion5_magical_barrier = mage_damage_taken * -1
                                    else:
                                        champion5_magical_barrier = 0
                                        champion5_hp = champion5_hp - mage_damage_taken
                                        champion5_lastRoundDamageTaken_list.append(mage_damage_taken)
                                        if champion5_hp < 0:
                                            champion5_hp = 0
                                else:
                                    champion5_hp = champion5_hp - self.calculate_ai_damage(5, 5, 0)
                                    champion5_lastRoundDamageTaken_list.append(self.calculate_ai_damage(5, 5, 1))
                                    if champion5_hp < 0:
                                        champion5_hp = 0
                                if champion5_bush_armour != 0:
                                    ai5_hp = ai5_hp - 200
                                    self.apply_thornsDot(5, 1)
                                if ai5_hp < 0:
                                    ai5_hp = 0
            if ai1_thornsDot == 0:
                if "Thorns" in ai1_statuses:
                    ai1_statuses.remove("Thorns")
            if ai2_thornsDot == 0:
                if "Thorns" in ai2_statuses:
                    ai2_statuses.remove("Thorns")
            if ai3_thornsDot == 0:
                if "Thorns" in ai3_statuses:
                    ai3_statuses.remove("Thorns")
            if ai4_thornsDot == 0:
                if "Thorns" in ai4_statuses:
                    ai4_statuses.remove("Thorns")
            if ai5_thornsDot == 0:
                if "Thorns" in ai5_statuses:
                    ai5_statuses.remove("Thorns")
            if ai1_burnDot[1] == 0:
                if "Burning" in ai1_statuses:
                    ai1_statuses.remove("Burning")
            if ai2_burnDot[1] == 0:
                if "Burning" in ai2_statuses:
                    ai2_statuses.remove("Burning")
            if ai3_burnDot[1] == 0:
                if "Burning" in ai3_statuses:
                    ai3_statuses.remove("Burning")
            if ai4_burnDot[1] == 0:
                if "Burning" in ai4_statuses:
                    ai4_statuses.remove("Burning")
            if ai5_burnDot[1] == 0:
                if "Burning" in ai5_statuses:
                    ai5_statuses.remove("Burning")
            if ai1_garroteDot[1] == 0:
                if "Garroted" in ai1_statuses:
                    ai1_statuses.remove("Garroted")
            if ai2_garroteDot[1] == 0:
                if "Garroted" in ai2_statuses:
                    ai2_statuses.remove("Garroted")
            if ai3_garroteDot[1] == 0:
                if "Garroted" in ai3_statuses:
                    ai3_statuses.remove("Garroted")
            if ai4_garroteDot[1] == 0:
                if "Garroted" in ai4_statuses:
                    ai4_statuses.remove("Garroted")
            if ai5_garroteDot[1] == 0:
                if "Garroted" in ai5_statuses:
                    ai5_statuses.remove("Garroted")
            if ai1_eviscerDot[1] == 0:
                if "Eviscerated" in ai1_statuses:
                    ai1_statuses.remove("Eviscerated")
            if ai2_eviscerDot[1] == 0:
                if "Eviscerated" in ai2_statuses:
                    ai2_statuses.remove("Eviscerated")
            if ai3_eviscerDot[1] == 0:
                if "Eviscerated" in ai3_statuses:
                    ai3_statuses.remove("Eviscerated")
            if ai4_eviscerDot[1] == 0:
                if "Eviscerated" in ai4_statuses:
                    ai4_statuses.remove("Eviscerated")
            if ai5_eviscerDot[1] == 0:
                if "Eviscerated" in ai5_statuses:
                    ai5_statuses.remove("Eviscerated")
            if ai1_serraSlashDot[1] == 0:
                if "Serrated" in ai1_statuses:
                    ai1_statuses.remove("Serrated")
            if ai2_serraSlashDot[1] == 0:
                if "Serrated" in ai2_statuses:
                    ai2_statuses.remove("Serrated")
            if ai3_serraSlashDot[1] == 0:
                if "Serrated" in ai3_statuses:
                    ai3_statuses.remove("Serrated")
            if ai4_serraSlashDot[1] == 0:
                if "Serrated" in ai4_statuses:
                    ai4_statuses.remove("Serrated")
            if ai5_serraSlashDot[1] == 0:
                if "Serrated" in ai5_statuses:
                    ai5_statuses.remove("Serrated")
            if ai1_rottingDot[1] == 0:
                if "Rotting" in ai1_statuses:
                    ai1_statuses.remove("Rotting")
            if ai2_rottingDot[1] == 0:
                if "Rotting" in ai2_statuses:
                    ai2_statuses.remove("Rotting")
            if ai3_rottingDot[1] == 0:
                if "Rotting" in ai3_statuses:
                    ai3_statuses.remove("Rotting")
            if ai4_rottingDot[1] == 0:
                if "Rotting" in ai4_statuses:
                    ai4_statuses.remove("Rotting")
            if ai5_rottingDot[1] == 0:
                if "Rotting" in ai5_statuses:
                    ai5_statuses.remove("Rotting")
            if ai1_shimmerDot[1] == 0:
                if "Sizzling Light" in ai1_statuses:
                    ai1_statuses.remove("Sizzling Light")
            if ai2_shimmerDot[1] == 0:
                if "Sizzling Light" in ai2_statuses:
                    ai2_statuses.remove("Sizzling Light")
            if ai3_shimmerDot[1] == 0:
                if "Sizzling Light" in ai3_statuses:
                    ai3_statuses.remove("Sizzling Light")
            if ai4_shimmerDot[1] == 0:
                if "Sizzling Light" in ai4_statuses:
                    ai4_statuses.remove("Sizzling Light")
            if ai5_shimmerDot[1] == 0:
                if "Sizzling Light" in ai5_statuses:
                    ai5_statuses.remove("Sizzling Light")
            if ai1_divineDot[1] == 0:
                if "Searing Light" in ai1_statuses:
                    ai1_statuses.remove("Searing Light")
            if ai2_divineDot[1] == 0:
                if "Searing Light" in ai2_statuses:
                    ai2_statuses.remove("Searing Light")
            if ai3_divineDot[1] == 0:
                if "Searing Light" in ai3_statuses:
                    ai3_statuses.remove("Searing Light")
            if ai4_divineDot[1] == 0:
                if "Searing Light" in ai4_statuses:
                    ai4_statuses.remove("Searing Light")
            if ai5_divineDot[1] == 0:
                if "Searing Light" in ai5_statuses:
                    ai5_statuses.remove("Searing Light")
            if ai1_barbedArrDot[1] == 0:
                if "Barbed" in ai1_statuses:
                    ai1_statuses.remove("Barbed")
            if ai2_barbedArrDot[1] == 0:
                if "Barbed" in ai2_statuses:
                    ai2_statuses.remove("Barbed")
            if ai3_barbedArrDot[1] == 0:
                if "Barbed" in ai3_statuses:
                    ai3_statuses.remove("Barbed")
            if ai4_barbedArrDot[1] == 0:
                if "Barbed" in ai4_statuses:
                    ai4_statuses.remove("Barbed")
            if ai5_barbedArrDot[1] == 0:
                if "Barbed" in ai5_statuses:
                    ai5_statuses.remove("Barbed")
            if ai1_damnation[1] == 0:
                if "Exploding" in ai1_statuses:
                    ai1_statuses.remove("Exploding")
            if ai2_damnation[1] == 0:
                if "Exploding" in ai2_statuses:
                    ai2_statuses.remove("Exploding")
            if ai3_damnation[1] == 0:
                if "Exploding" in ai3_statuses:
                    ai3_statuses.remove("Exploding")
            if ai4_damnation[1] == 0:
                if "Exploding" in ai4_statuses:
                    ai4_statuses.remove("Exploding")
            if ai5_damnation[1] == 0:
                if "Exploding" in ai5_statuses:
                    ai5_statuses.remove("Exploding")
            if ai1_brittle != 0:
                ai1_brittle = ai1_brittle - 1
                if ai1_brittle == 0:
                    ai1_statuses.remove("Brittle")
            if ai2_brittle != 0:
                ai2_brittle = ai2_brittle - 1
                if ai2_brittle == 0:
                    ai2_statuses.remove("Brittle")
            if ai3_brittle != 0:
                ai3_brittle = ai3_brittle - 1
                if ai3_brittle == 0:
                    ai3_statuses.remove("Brittle")
            if ai4_brittle != 0:
                ai4_brittle = ai4_brittle - 1
                if ai4_brittle == 0:
                    ai4_statuses.remove("Brittle")
            if ai5_brittle != 0:
                ai5_brittle = ai5_brittle - 1
                if ai5_brittle == 0:
                    ai5_statuses.remove("Brittle")
            if ai1_weakness != 0:
                ai1_weakness = ai1_weakness - 1
                if ai1_weakness == 0:
                    ai1_statuses.remove("Weakened")
            if ai2_weakness != 0:
                ai2_weakness = ai2_weakness - 1
                if ai2_weakness == 0:
                    ai2_statuses.remove("Weakened")
            if ai3_weakness != 0:
                ai3_weakness = ai3_weakness - 1
                if ai3_weakness == 0:
                    ai3_statuses.remove("Weakened")
            if ai4_weakness != 0:
                ai4_weakness = ai4_weakness - 1
                if ai4_weakness == 0:
                    ai4_statuses.remove("Weakened")
            if ai5_weakness != 0:
                ai5_weakness = ai5_weakness - 1
                if ai5_weakness == 0:
                    ai5_statuses.remove("Weakened")
            if ai1_stun != 0:
                ai1_stun = ai1_stun - 1
                if ai1_stun == 0:
                    ai1_statuses.remove("Stunned")
            if ai2_stun != 0:
                ai2_stun = ai2_stun - 1
                if ai2_stun == 0:
                    ai2_statuses.remove("Stunned")
            if ai3_stun != 0:
                ai3_stun = ai3_stun - 1
                if ai3_stun == 0:
                    ai3_statuses.remove("Stunned")
            if ai4_stun != 0:
                ai4_stun = ai4_stun - 1
                if ai4_stun == 0:
                    ai4_statuses.remove("Stunned")
            if ai5_stun != 0:
                ai5_stun = ai5_stun - 1
                if ai5_stun == 0:
                    ai5_statuses.remove("Stunned")
            if ai1_taunt[1] != 0:
                ai1_taunt[1] = ai1_taunt[1] - 1
                if ai1_taunt[1] == 0:
                    ai1_statuses.remove("Taunted")
            if ai2_taunt[1] != 0:
                ai2_taunt[1] = ai2_taunt[1] - 1
                if ai2_taunt[1] == 0:
                    ai2_statuses.remove("Taunted")
            if ai3_taunt[1] != 0:
                ai3_taunt[1] = ai3_taunt[1] - 1
                if ai3_taunt[1] == 0:
                    ai3_statuses.remove("Taunted")
            if ai4_taunt[1] != 0:
                ai4_taunt[1] = ai4_taunt[1] - 1
                if ai4_taunt[1] == 0:
                    ai4_statuses.remove("Taunted")
            if ai5_taunt[1] != 0:
                ai5_taunt[1] = ai5_taunt[1] - 1
                if ai5_taunt[1] == 0:
                    ai5_statuses.remove("Taunted")
            self.heal_overtime_tick()
            if monk_bauble_damage_list1[1] != 0:
                monk_bauble_damage_list1[1] = monk_bauble_damage_list1[1] - 1
            if monk_bauble_damage_list2[1] != 0:
                monk_bauble_damage_list2[1] = monk_bauble_damage_list2[1] - 1
            if monk_bauble_damage_list3[1] != 0:
                monk_bauble_damage_list3[1] = monk_bauble_damage_list3[1] - 1
            if MASTER_FENCER.title in CHAMPION_LIST:
                if ai1_fencer_dodgechance > 30:
                    ai1_fencer_dodgechance = 30
                if ai2_fencer_dodgechance > 30:
                    ai2_fencer_dodgechance = 30
                if ai3_fencer_dodgechance > 30:
                    ai3_fencer_dodgechance = 30
                if ai4_fencer_dodgechance > 30:
                    ai4_fencer_dodgechance = 30
                if ai5_fencer_dodgechance > 30:
                    ai5_fencer_dodgechance = 30
            current_turn = "MN"
            self.next_turn()
#Checks all the damage modifiers that the would influence the enemies damage
#Like ally buffs that reduce or increase damage taken
#And enemies debuffs that reduce their damage done
#Also calculates the damage redirected by the Kings-Guard passive, if active
#returns the result
    def calculate_ai_damage(self, champion_position, ai_position, lastround_calculation_check):
        global champion1_hp, champion2_hp, champion3_hp, champion4_hp, champion5_hp
        guardpassive_check = 0
        if ai_position == 1:
            ai1_damage_done = ai1_attack[1]
            if ai1_weakness != 0:
                ai1_damage_done = ai1_damage_done * 0.8
            if ai1_toc != 0:
                ai1_damage_done = ai1_damage_done * (1 - (0.01 * ai1_toc))
            if champion_position == 1:
                if CHAMPION_LIST[0] == KINGS_GUARD.title:
                    if champion1_hp < 0:
                        guardpassive_check = 1
                if champion1_fortification != 0:
                    ai1_damage_done = ai1_damage_done * 0.7
                if paladin_aura == 2:
                    ai1_damage_done = ai1_damage_done * 0.9
                if champion1_pure_rage != 0:
                    ai1_damage_done = ai1_damage_done * 1.3
                if "Enharden Nerves" in champion1_statuses:
                    ai1_damage_done = ai1_damage_done * 0.6
                if "Tight Tourniquet" in champion1_statuses:
                    ai1_damage_done = ai1_damage_done * 0.8
                if "Weak Tourniquet" in champion1_statuses:
                    ai1_damage_done = ai1_damage_done * 0.9
                if "Toughened Mud" in champion1_statuses:
                    ai1_damage_done = ai1_damage_done * 0.85
            if champion_position == 2:
                if CHAMPION_LIST[1] == KINGS_GUARD.title:
                    if champion2_hp < 0:
                        guardpassive_check = 1
                if champion2_fortification != 0:
                    ai1_damage_done = ai1_damage_done * 0.7
                if paladin_aura != 0:
                    ai1_damage_done = ai1_damage_done * 0.9
                if champion2_pure_rage != 0:
                    ai1_damage_done = ai1_damage_done * 1.3
                if "Enharden Nerves" in champion2_statuses:
                    ai1_damage_done = ai1_damage_done * 0.6
                if "Tight Tourniquet" in champion2_statuses:
                    ai1_damage_done = ai1_damage_done * 0.8
                if "Weak Tourniquet" in champion2_statuses:
                    ai1_damage_done = ai1_damage_done * 0.9
                if "Toughened Mud" in champion2_statuses:
                    ai1_damage_done = ai1_damage_done * 0.85
            if champion_position == 3:
                if CHAMPION_LIST[2] == KINGS_GUARD.title:
                    if champion3_hp < 0:
                        guardpassive_check = 1
                if champion3_fortification != 0:
                    ai1_damage_done = ai1_damage_done * 0.7
                if paladin_aura != 0:
                    ai1_damage_done = ai1_damage_done * 0.9
                if champion3_pure_rage != 0:
                    ai1_damage_done = ai1_damage_done * 1.3
                if "Enharden Nerves" in champion3_statuses:
                    ai1_damage_done = ai1_damage_done * 0.6
                if "Tight Tourniquet" in champion3_statuses:
                    ai1_damage_done = ai1_damage_done * 0.8
                if "Weak Tourniquet" in champion3_statuses:
                    ai1_damage_done = ai1_damage_done * 0.9
                if "Toughened Mud" in champion3_statuses:
                    ai1_damage_done = ai1_damage_done * 0.85
            if champion_position == 4:
                if CHAMPION_LIST[3] == KINGS_GUARD.title:
                    if champion4_hp < 0:
                        guardpassive_check = 1
                if champion4_fortification != 0:
                    ai1_damage_done = ai1_damage_done * 0.7
                if paladin_aura != 0:
                    ai1_damage_done = ai1_damage_done * 0.9
                if champion4_pure_rage != 0:
                    ai1_damage_done = ai1_damage_done * 1.3
                if "Enharden Nerves" in champion4_statuses:
                    ai1_damage_done = ai1_damage_done * 0.6
                if "Tight Tourniquet" in champion4_statuses:
                    ai1_damage_done = ai1_damage_done * 0.8
                if "Weak Tourniquet" in champion4_statuses:
                    ai1_damage_done = ai1_damage_done * 0.9
                if "Toughened Mud" in champion4_statuses:
                    ai1_damage_done = ai1_damage_done * 0.85
            if champion_position == 5:
                if CHAMPION_LIST[4] == KINGS_GUARD.title:
                    if champion5_hp < 0:
                        guardpassive_check = 1
                if champion5_fortification != 0:
                    ai1_damage_done = ai1_damage_done * 0.7
                if paladin_aura != 0:
                    ai1_damage_done = ai1_damage_done * 0.9
                if champion5_pure_rage != 0:
                    ai1_damage_done = ai1_damage_done * 1.3
                if "Enharden Nerves" in champion5_statuses:
                    ai1_damage_done = ai1_damage_done * 0.6
                if "Tight Tourniquet" in champion5_statuses:
                    ai1_damage_done = ai1_damage_done * 0.8
                if "Weak Tourniquet" in champion5_statuses:
                    ai1_damage_done = ai1_damage_done * 0.9
                if "Toughened Mud" in champion5_statuses:
                    ai1_damage_done = ai1_damage_done * 0.85
            if KINGS_GUARD.title in CHAMPION_LIST:
                if guardpassive_check == 0:
                    if lastround_calculation_check == 0:
                        if CHAMPION_LIST[0] == KINGS_GUARD.title:
                            champion1_hp = champion1_hp - math.ceil(ai1_damage_done * 0.15)
                            champion1_lastRoundDamageTaken_list.append(math.ceil(ai1_damage_done * 0.15))
                        if CHAMPION_LIST[1] == KINGS_GUARD.title:
                            champion2_hp = champion2_hp - math.ceil(ai1_damage_done * 0.15)
                            champion2_lastRoundDamageTaken_list.append(math.ceil(ai1_damage_done * 0.15))
                        if CHAMPION_LIST[2] == KINGS_GUARD.title:
                            champion3_hp = champion3_hp - math.ceil(ai1_damage_done * 0.15)
                            champion3_lastRoundDamageTaken_list.append(math.ceil(ai1_damage_done * 0.15))
                        if CHAMPION_LIST[3] == KINGS_GUARD.title:
                            champion4_hp = champion4_hp - math.ceil(ai1_damage_done * 0.15)
                            champion4_lastRoundDamageTaken_list.append(math.ceil(ai1_damage_done * 0.15))
                        if CHAMPION_LIST[4] == KINGS_GUARD.title:
                            champion5_hp = champion5_hp - math.ceil(ai1_damage_done * 0.15)
                            champion5_lastRoundDamageTaken_list.append(math.ceil(ai1_damage_done * 0.15))
                    ai1_damage_done = ai1_damage_done * 0.85
            return math.ceil(ai1_damage_done)
        if ai_position == 2:
            ai2_damage_done = ai2_attack[1]
            if ai2_weakness != 0:
                ai2_damage_done = ai2_damage_done * 0.8
            if ai2_toc != 0:
                ai2_damage_done = ai2_damage_done * (1 - (0.01 * ai2_toc))
            if champion_position == 1:
                if CHAMPION_LIST[0] == KINGS_GUARD.title:
                    if champion1_hp < 0:
                        guardpassive_check = 1
                if champion1_fortification != 0:
                    ai2_damage_done = ai2_damage_done * 0.7
                if paladin_aura == 2:
                    ai2_damage_done = ai2_damage_done * 0.9
                if champion2_pure_rage != 0:
                    ai2_damage_done = ai2_damage_done * 1.3
                if "Enharden Nerves" in champion1_statuses:
                    ai2_damage_done = ai2_damage_done * 0.6
                if "Tight Tourniquet" in champion1_statuses:
                    ai2_damage_done = ai2_damage_done * 0.8
                if "Weak Tourniquet" in champion1_statuses:
                    ai2_damage_done = ai2_damage_done * 0.9
                if "Toughened Mud" in champion1_statuses:
                    ai2_damage_done = ai2_damage_done * 0.85
            if champion_position == 2:
                if CHAMPION_LIST[1] == KINGS_GUARD.title:
                    if champion2_hp < 0:
                        guardpassive_check = 1
                if champion2_fortification != 0:
                    ai2_damage_done = ai2_damage_done * 0.7
                if paladin_aura != 0:
                    ai2_damage_done = ai2_damage_done * 0.9
                if champion2_pure_rage != 0:
                    ai2_damage_done = ai2_damage_done * 1.3
                if "Enharden Nerves" in champion2_statuses:
                    ai2_damage_done = ai2_damage_done * 0.6
                if "Tight Tourniquet" in champion2_statuses:
                    ai2_damage_done = ai2_damage_done * 0.8
                if "Weak Tourniquet" in champion2_statuses:
                    ai2_damage_done = ai2_damage_done * 0.9
                if "Toughened Mud" in champion2_statuses:
                    ai2_damage_done = ai2_damage_done * 0.85
            if champion_position == 3:
                if CHAMPION_LIST[2] == KINGS_GUARD.title:
                    if champion3_hp < 0:
                        guardpassive_check = 1
                if champion3_fortification != 0:
                    ai2_damage_done = ai2_damage_done * 0.7
                if paladin_aura != 0:
                    ai2_damage_done = ai2_damage_done * 0.9
                if champion3_pure_rage != 0:
                    ai2_damage_done = ai2_damage_done * 1.3
                if "Enharden Nerves" in champion3_statuses:
                    ai2_damage_done = ai2_damage_done * 0.6
                if "Tight Tourniquet" in champion3_statuses:
                    ai2_damage_done = ai2_damage_done * 0.8
                if "Weak Tourniquet" in champion3_statuses:
                    ai2_damage_done = ai2_damage_done * 0.9
                if "Toughened Mud" in champion3_statuses:
                    ai2_damage_done = ai2_damage_done * 0.85
            if champion_position == 4:
                if CHAMPION_LIST[3] == KINGS_GUARD.title:
                    if champion4_hp < 0:
                        guardpassive_check = 1
                if champion4_fortification != 0:
                    ai2_damage_done = ai2_damage_done * 0.7
                if paladin_aura != 0:
                    ai2_damage_done = ai2_damage_done * 0.9
                if champion4_pure_rage != 0:
                    ai2_damage_done = ai2_damage_done * 1.3
                if "Enharden Nerves" in champion4_statuses:
                    ai2_damage_done = ai2_damage_done * 0.6
                if "Tight Tourniquet" in champion4_statuses:
                    ai2_damage_done = ai2_damage_done * 0.8
                if "Weak Tourniquet" in champion4_statuses:
                    ai2_damage_done = ai2_damage_done * 0.9
                if "Toughened Mud" in champion4_statuses:
                    ai2_damage_done = ai2_damage_done * 0.85
            if champion_position == 5:
                if CHAMPION_LIST[4] == KINGS_GUARD.title:
                    if champion5_hp < 0:
                        guardpassive_check = 1
                if champion5_fortification != 0:
                    ai2_damage_done = ai2_damage_done * 0.7
                if paladin_aura != 0:
                    ai2_damage_done = ai2_damage_done * 0.9
                if champion5_pure_rage != 0:
                    ai2_damage_done = ai2_damage_done * 1.3
                if "Enharden Nerves" in champion5_statuses:
                    ai2_damage_done = ai2_damage_done * 0.6
                if "Tight Tourniquet" in champion5_statuses:
                    ai2_damage_done = ai2_damage_done * 0.8
                if "Weak Tourniquet" in champion5_statuses:
                    ai2_damage_done = ai2_damage_done * 0.9
                if "Toughened Mud" in champion5_statuses:
                    ai2_damage_done = ai2_damage_done * 0.85
            if KINGS_GUARD.title in CHAMPION_LIST:
                if guardpassive_check == 0:
                    if lastround_calculation_check == 0:
                        if CHAMPION_LIST[0] == KINGS_GUARD.title:
                            champion1_hp = champion1_hp - math.ceil(ai2_damage_done * 0.15)
                            champion1_lastRoundDamageTaken_list.append(math.ceil(ai2_damage_done * 0.15))
                        if CHAMPION_LIST[1] == KINGS_GUARD.title:
                            champion2_hp = champion2_hp - math.ceil(ai2_damage_done * 0.15)
                            champion2_lastRoundDamageTaken_list.append(math.ceil(ai2_damage_done * 0.15))
                        if CHAMPION_LIST[2] == KINGS_GUARD.title:
                            champion3_hp = champion3_hp - math.ceil(ai2_damage_done * 0.15)
                            champion3_lastRoundDamageTaken_list.append(math.ceil(ai2_damage_done * 0.15))
                        if CHAMPION_LIST[3] == KINGS_GUARD.title:
                            champion4_hp = champion4_hp - math.ceil(ai2_damage_done * 0.15)
                            champion4_lastRoundDamageTaken_list.append(math.ceil(ai2_damage_done * 0.15))
                        if CHAMPION_LIST[4] == KINGS_GUARD.title:
                            champion5_hp = champion5_hp - math.ceil(ai1_damage_done * 0.15)
                            champion5_lastRoundDamageTaken_list.append(math.ceil(ai2_damage_done * 0.15))
                        ai2_damage_done = ai2_damage_done * 0.85
            return math.ceil(ai2_damage_done)
        if ai_position == 3:
            ai3_damage_done = ai3_attack[1]
            if ai3_weakness != 0:
                ai3_damage_done = ai3_damage_done * 0.8
            if ai3_toc != 0:
                ai3_damage_done = ai3_damage_done * (1 - (0.01 * ai3_toc))
            if champion_position == 1:
                if CHAMPION_LIST[0] == KINGS_GUARD.title:
                    if champion1_hp < 0:
                        guardpassive_check = 1
                if champion1_fortification != 0:
                    ai3_damage_done = ai3_damage_done * 0.7
                if paladin_aura == 2:
                    ai3_damage_done = ai3_damage_done * 0.9
                if champion3_pure_rage != 0:
                    ai3_damage_done = ai3_damage_done * 1.3
                if "Enharden Nerves" in champion1_statuses:
                    ai3_damage_done = ai3_damage_done * 0.6
                if "Tight Tourniquet" in champion1_statuses:
                    ai3_damage_done = ai3_damage_done * 0.8
                if "Weak Tourniquet" in champion1_statuses:
                    ai3_damage_done = ai3_damage_done * 0.9
                if "Toughened Mud" in champion1_statuses:
                    ai3_damage_done = ai3_damage_done * 0.85
            if champion_position == 2:
                if CHAMPION_LIST[1] == KINGS_GUARD.title:
                    if champion2_hp < 0:
                        guardpassive_check = 1
                if champion2_fortification != 0:
                    ai3_damage_done = ai3_damage_done * 0.7
                if paladin_aura != 0:
                    ai3_damage_done = ai3_damage_done * 0.9
                if champion2_pure_rage != 0:
                    ai3_damage_done = ai3_damage_done * 1.3
                if "Enharden Nerves" in champion2_statuses:
                    ai3_damage_done = ai3_damage_done * 0.6
                if "Tight Tourniquet" in champion2_statuses:
                    ai3_damage_done = ai3_damage_done * 0.8
                if "Weak Tourniquet" in champion2_statuses:
                    ai3_damage_done = ai3_damage_done * 0.9
                if "Toughened Mud" in champion2_statuses:
                    ai3_damage_done = ai3_damage_done * 0.85
            if champion_position == 3:
                if CHAMPION_LIST[2] == KINGS_GUARD.title:
                    if champion3_hp < 0:
                        guardpassive_check = 1
                if champion3_fortification != 0:
                    ai3_damage_done = ai3_damage_done * 0.7
                if paladin_aura != 0:
                    ai3_damage_done = ai3_damage_done * 0.9
                if champion3_pure_rage != 0:
                    ai3_damage_done = ai3_damage_done * 1.3
                if "Enharden Nerves" in champion3_statuses:
                    ai3_damage_done = ai3_damage_done * 0.6
                if "Tight Tourniquet" in champion3_statuses:
                    ai3_damage_done = ai3_damage_done * 0.8
                if "Weak Tourniquet" in champion3_statuses:
                    ai3_damage_done = ai3_damage_done * 0.9
                if "Toughened Mud" in champion3_statuses:
                    ai3_damage_done = ai3_damage_done * 0.85
            if champion_position == 4:
                if CHAMPION_LIST[3] == KINGS_GUARD.title:
                    if champion4_hp < 0:
                        guardpassive_check = 1
                if champion4_fortification != 0:
                    ai3_damage_done = ai3_damage_done * 0.7
                if paladin_aura != 0:
                    ai3_damage_done = ai3_damage_done * 0.9
                if champion4_pure_rage != 0:
                    ai3_damage_done = ai3_damage_done * 1.3
                if "Enharden Nerves" in champion4_statuses:
                    ai3_damage_done = ai3_damage_done * 0.6
                if "Tight Tourniquet" in champion4_statuses:
                    ai3_damage_done = ai3_damage_done * 0.8
                if "Weak Tourniquet" in champion4_statuses:
                    ai3_damage_done = ai3_damage_done * 0.9
                if "Toughened Mud" in champion4_statuses:
                    ai3_damage_done = ai3_damage_done * 0.85
            if champion_position == 5:
                if CHAMPION_LIST[4] == KINGS_GUARD.title:
                    if champion5_hp < 0:
                        guardpassive_check = 1
                if champion5_fortification != 0:
                    ai3_damage_done = ai3_damage_done * 0.7
                if paladin_aura != 0:
                    ai3_damage_done = ai3_damage_done * 0.9
                if champion5_pure_rage != 0:
                    ai3_damage_done = ai3_damage_done * 1.3
                if "Enharden Nerves" in champion5_statuses:
                    ai3_damage_done = ai3_damage_done * 0.6
                if "Tight Tourniquet" in champion5_statuses:
                    ai3_damage_done = ai3_damage_done * 0.8
                if "Weak Tourniquet" in champion5_statuses:
                    ai3_damage_done = ai3_damage_done * 0.9
                if "Toughened Mud" in champion5_statuses:
                    ai3_damage_done = ai3_damage_done * 0.85
            if KINGS_GUARD.title in CHAMPION_LIST:
                if guardpassive_check == 0:
                    if lastround_calculation_check == 0:
                        if CHAMPION_LIST[0] == KINGS_GUARD.title:
                            champion1_hp = champion1_hp - math.ceil(ai3_damage_done * 0.15)
                            champion1_lastRoundDamageTaken_list.append(math.ceil(ai3_damage_done * 0.15))
                        if CHAMPION_LIST[1] == KINGS_GUARD.title:
                            champion2_hp = champion2_hp - math.ceil(ai3_damage_done * 0.15)
                            champion2_lastRoundDamageTaken_list.append(math.ceil(ai3_damage_done * 0.15))
                        if CHAMPION_LIST[2] == KINGS_GUARD.title:
                            champion3_hp = champion3_hp - math.ceil(ai3_damage_done * 0.15)
                            champion3_lastRoundDamageTaken_list.append(math.ceil(ai3_damage_done * 0.15))
                        if CHAMPION_LIST[3] == KINGS_GUARD.title:
                            champion4_hp = champion4_hp - math.ceil(ai3_damage_done * 0.15)
                            champion4_lastRoundDamageTaken_list.append(math.ceil(ai3_damage_done * 0.15))
                        if CHAMPION_LIST[4] == KINGS_GUARD.title:
                            champion5_hp = champion5_hp - math.ceil(ai3_damage_done * 0.15)
                            champion5_lastRoundDamageTaken_list.append(math.ceil(ai3_damage_done * 0.15))
                        ai3_damage_done = ai3_damage_done * 0.85
            return math.ceil(ai3_damage_done)
        if ai_position == 4:
            ai4_damage_done = ai4_attack[1]
            if ai4_weakness != 0:
                ai4_damage_done = ai4_damage_done * 0.8
            if ai4_toc != 0:
                ai4_damage_done = ai4_damage_done * (1 - (0.01 * ai4_toc))
            if champion_position == 1:
                if CHAMPION_LIST[0] == KINGS_GUARD.title:
                    if champion1_hp < 0:
                        guardpassive_check = 1
                if champion1_fortification != 0:
                    ai4_damage_done = ai4_damage_done * 0.7
                if paladin_aura == 2:
                    ai4_damage_done = ai4_damage_done * 0.9
                if champion4_pure_rage != 0:
                    ai4_damage_done = ai4_damage_done * 1.3
                if "Enharden Nerves" in champion1_statuses:
                    ai4_damage_done = ai4_damage_done * 0.6
                if "Tight Tourniquet" in champion1_statuses:
                    ai4_damage_done = ai4_damage_done * 0.8
                if "Weak Tourniquet" in champion1_statuses:
                    ai4_damage_done = ai4_damage_done * 0.9
                if "Toughened Mud" in champion1_statuses:
                    ai4_damage_done = ai4_damage_done * 0.85
            if champion_position == 2:
                if CHAMPION_LIST[1] == KINGS_GUARD.title:
                    if champion2_hp < 0:
                        guardpassive_check = 1
                if champion2_fortification != 0:
                    ai4_damage_done = ai4_damage_done * 0.7
                if paladin_aura != 0:
                    ai4_damage_done = ai4_damage_done * 0.9
                if champion2_pure_rage != 0:
                    ai4_damage_done = ai4_damage_done * 1.3
                if "Enharden Nerves" in champion2_statuses:
                    ai4_damage_done = ai4_damage_done * 0.6
                if "Tight Tourniquet" in champion2_statuses:
                    ai4_damage_done = ai4_damage_done * 0.8
                if "Weak Tourniquet" in champion2_statuses:
                    ai4_damage_done = ai4_damage_done * 0.9
                if "Toughened Mud" in champion2_statuses:
                    ai4_damage_done = ai4_damage_done * 0.85
            if champion_position == 3:
                if CHAMPION_LIST[2] == KINGS_GUARD.title:
                    if champion3_hp < 0:
                        guardpassive_check = 1
                if champion3_fortification != 0:
                    ai4_damage_done = ai4_damage_done * 0.7
                if paladin_aura != 0:
                    ai4_damage_done = ai4_damage_done * 0.9
                if champion3_pure_rage != 0:
                    ai4_damage_done = ai4_damage_done * 1.3
                if "Enharden Nerves" in champion3_statuses:
                    ai4_damage_done = ai4_damage_done * 0.6
                if "Tight Tourniquet" in champion3_statuses:
                    ai4_damage_done = ai4_damage_done * 0.8
                if "Weak Tourniquet" in champion3_statuses:
                    ai4_damage_done = ai4_damage_done * 0.9
                if "Toughened Mud" in champion3_statuses:
                    ai4_damage_done = ai4_damage_done * 0.85
            if champion_position == 4:
                if CHAMPION_LIST[3] == KINGS_GUARD.title:
                    if champion4_hp < 0:
                        guardpassive_check = 1
                if champion4_fortification != 0:
                    ai4_damage_done = ai4_damage_done * 0.7
                if paladin_aura != 0:
                    ai4_damage_done = ai4_damage_done * 0.9
                if champion4_pure_rage != 0:
                    ai4_damage_done = ai4_damage_done * 1.3
                if "Enharden Nerves" in champion4_statuses:
                    ai4_damage_done = ai4_damage_done * 0.6
                if "Tight Tourniquet" in champion4_statuses:
                    ai4_damage_done = ai4_damage_done * 0.8
                if "Weak Tourniquet" in champion4_statuses:
                    ai4_damage_done = ai4_damage_done * 0.9
                if "Toughened Mud" in champion4_statuses:
                    ai4_damage_done = ai4_damage_done * 0.85
            if champion_position == 5:
                if CHAMPION_LIST[4] == KINGS_GUARD.title:
                    if champion5_hp < 0:
                        guardpassive_check = 1
                if champion5_fortification != 0:
                    ai4_damage_done = ai4_damage_done * 0.7
                if paladin_aura != 0:
                    ai4_damage_done = ai4_damage_done * 0.9
                if champion5_pure_rage != 0:
                    ai4_damage_done = ai4_damage_done * 1.3
                if "Enharden Nerves" in champion5_statuses:
                    ai4_damage_done = ai4_damage_done * 0.6
                if "Tight Tourniquet" in champion5_statuses:
                    ai4_damage_done = ai4_damage_done * 0.8
                if "Weak Tourniquet" in champion5_statuses:
                    ai4_damage_done = ai4_damage_done * 0.9
                if "Toughened Mud" in champion5_statuses:
                    ai4_damage_done = ai4_damage_done * 0.85
            if KINGS_GUARD.title in CHAMPION_LIST:
                if guardpassive_check == 0:
                    if lastround_calculation_check == 0:
                        if CHAMPION_LIST[0] == KINGS_GUARD.title:
                            champion1_hp = champion1_hp - math.ceil(ai4_damage_done * 0.15)
                            champion1_lastRoundDamageTaken_list.append(math.ceil(ai4_damage_done * 0.15))
                        if CHAMPION_LIST[1] == KINGS_GUARD.title:
                            champion2_hp = champion2_hp - math.ceil(ai4_damage_done * 0.15)
                            champion2_lastRoundDamageTaken_list.append(math.ceil(ai4_damage_done * 0.15))
                        if CHAMPION_LIST[2] == KINGS_GUARD.title:
                            champion3_hp = champion3_hp - math.ceil(ai4_damage_done * 0.15)
                            champion3_lastRoundDamageTaken_list.append(math.ceil(ai4_damage_done * 0.15))
                        if CHAMPION_LIST[3] == KINGS_GUARD.title:
                            champion4_hp = champion4_hp - math.ceil(ai4_damage_done * 0.15)
                            champion4_lastRoundDamageTaken_list.append(math.ceil(ai4_damage_done * 0.15))
                        if CHAMPION_LIST[4] == KINGS_GUARD.title:
                            champion5_hp = champion5_hp - math.ceil(ai4_damage_done * 0.15)
                            champion5_lastRoundDamageTaken_list.append(math.ceil(ai4_damage_done * 0.15))
                        ai4_damage_done = ai4_damage_done * 0.85
            return math.ceil(ai4_damage_done)
        if ai_position == 5:
            ai5_damage_done = ai5_attack[1]
            if ai5_weakness != 0:
                ai5_damage_done = ai5_damage_done * 0.8
            if ai5_toc != 0:
                ai5_damage_done = ai5_damage_done * (1 - (0.01 * ai5_toc))
            if champion_position == 1:
                if CHAMPION_LIST[0] == KINGS_GUARD.title:
                    if champion1_hp < 0:
                        guardpassive_check = 1
                if champion1_fortification != 0:
                    ai5_damage_done = ai5_damage_done * 0.7
                if paladin_aura == 2:
                    ai5_damage_done = ai5_damage_done * 0.9
                if champion5_pure_rage != 0:
                    ai5_damage_done = ai5_damage_done * 1.3
                if "Enharden Nerves" in champion1_statuses:
                    ai5_damage_done = ai5_damage_done * 0.6
                if "Tight Tourniquet" in champion1_statuses:
                    ai5_damage_done = ai5_damage_done * 0.8
                if "Weak Tourniquet" in champion1_statuses:
                    ai5_damage_done = ai5_damage_done * 0.9
                if "Toughened Mud" in champion1_statuses:
                    ai5_damage_done = ai5_damage_done * 0.85
            if champion_position == 2:
                if CHAMPION_LIST[1] == KINGS_GUARD.title:
                    if champion2_hp < 0:
                        guardpassive_check = 1
                if champion2_fortification != 0:
                    ai5_damage_done = ai5_damage_done * 0.7
                if paladin_aura != 0:
                    ai5_damage_done = ai5_damage_done * 0.9
                if champion2_pure_rage != 0:
                    ai5_damage_done = ai5_damage_done * 1.3
                if "Enharden Nerves" in champion2_statuses:
                    ai5_damage_done = ai5_damage_done * 0.6
                if "Tight Tourniquet" in champion2_statuses:
                    ai5_damage_done = ai5_damage_done * 0.8
                if "Weak Tourniquet" in champion2_statuses:
                    ai5_damage_done = ai5_damage_done * 0.9
                if "Toughened Mud" in champion2_statuses:
                    ai5_damage_done = ai5_damage_done * 0.85
            if champion_position == 3:
                if CHAMPION_LIST[2] == KINGS_GUARD.title:
                    if champion3_hp < 0:
                        guardpassive_check = 1
                if champion3_fortification != 0:
                    ai5_damage_done = ai5_damage_done * 0.7
                if paladin_aura != 0:
                    ai5_damage_done = ai5_damage_done * 0.9
                if champion3_pure_rage != 0:
                    ai5_damage_done = ai5_damage_done * 1.3
                if "Enharden Nerves" in champion3_statuses:
                    ai5_damage_done = ai5_damage_done * 0.6
                if "Tight Tourniquet" in champion3_statuses:
                    ai5_damage_done = ai5_damage_done * 0.8
                if "Weak Tourniquet" in champion3_statuses:
                    ai5_damage_done = ai5_damage_done * 0.9
                if "Toughened Mud" in champion3_statuses:
                    ai5_damage_done = ai5_damage_done * 0.85
            if champion_position == 4:
                if CHAMPION_LIST[3] == KINGS_GUARD.title:
                    if champion4_hp < 0:
                        guardpassive_check = 1
                if champion4_fortification != 0:
                    ai5_damage_done = ai5_damage_done * 0.7
                if paladin_aura != 0:
                    ai5_damage_done = ai5_damage_done * 0.9
                if champion4_pure_rage != 0:
                    ai5_damage_done = ai5_damage_done * 1.3
                if "Enharden Nerves" in champion4_statuses:
                    ai5_damage_done = ai5_damage_done * 0.6
                if "Tight Tourniquet" in champion4_statuses:
                    ai5_damage_done = ai5_damage_done * 0.8
                if "Weak Tourniquet" in champion4_statuses:
                    ai5_damage_done = ai5_damage_done * 0.9
                if "Toughened Mud" in champion4_statuses:
                    ai5_damage_done = ai5_damage_done * 0.85
            if champion_position == 5:
                if CHAMPION_LIST[4] == KINGS_GUARD.title:
                    if champion5_hp < 0:
                        guardpassive_check = 1
                if champion5_fortification != 0:
                    ai5_damage_done = ai5_damage_done * 0.7
                if paladin_aura != 0:
                    ai5_damage_done = ai5_damage_done * 0.9
                if champion5_pure_rage != 0:
                    ai5_damage_done = ai5_damage_done * 1.3
                if "Enharden Nerves" in champion5_statuses:
                    ai5_damage_done = ai5_damage_done * 0.6
                if "Tight Tourniquet" in champion5_statuses:
                    ai5_damage_done = ai5_damage_done * 0.8
                if "Weak Tourniquet" in champion5_statuses:
                    ai5_damage_done = ai5_damage_done * 0.9
                if "Toughened Mud" in champion5_statuses:
                    ai5_damage_done = ai5_damage_done * 0.85
            if KINGS_GUARD.title in CHAMPION_LIST:
                if guardpassive_check == 0:
                    if lastround_calculation_check == 0:
                        if CHAMPION_LIST[0] == KINGS_GUARD.title:
                            champion1_hp = champion1_hp - math.ceil(ai5_damage_done * 0.15)
                            champion1_lastRoundDamageTaken_list.append(math.ceil(ai5_damage_done * 0.15))
                        if CHAMPION_LIST[1] == KINGS_GUARD.title:
                            champion2_hp = champion2_hp - math.ceil(ai5_damage_done * 0.15)
                            champion2_lastRoundDamageTaken_list.append(math.ceil(ai5_damage_done * 0.15))
                        if CHAMPION_LIST[2] == KINGS_GUARD.title:
                            champion3_hp = champion3_hp - math.ceil(ai5_damage_done * 0.15)
                            champion3_lastRoundDamageTaken_list.append(math.ceil(ai5_damage_done * 0.15))
                        if CHAMPION_LIST[3] == KINGS_GUARD.title:
                            champion4_hp = champion4_hp - math.ceil(ai5_damage_done * 0.15)
                            champion4_lastRoundDamageTaken_list.append(math.ceil(ai5_damage_done * 0.15))
                        if CHAMPION_LIST[4] == KINGS_GUARD.title:
                            champion5_hp = champion5_hp - math.ceil(ai5_damage_done * 0.15)
                            champion5_lastRoundDamageTaken_list.append(math.ceil(ai5_damage_done * 0.15))
                        ai5_damage_done = ai5_damage_done * 0.85
            return math.ceil(ai5_damage_done)
#Reduces all abilities remaining cooldowns and all active buffs duration by one 
    def champion_turn_ticker(self, champion_position):
        global leg_sweep_requirements, pressure_points_requirements, challenging_shout_requirements, trainwreck_requirements, \
            fortification_requirements, riposte_requirements, magic_reflection_requirements, evasive_manoeuvres_requirements, \
            reckless_flurry_requirements, eviscerate_requirements, exploit_weakness_requirements, scrap_bomb_requirements, \
            play_dead_requirements, survival_kit_requirements, uppercut_requirements, knock_out_requirements, \
            wide_swing_requirements, arcane_brilliance_requirements, vine_swipe_requirements, burst_n_bloom_requirements, \
            wound_fissure_requirements, blood_boil_requirements, enharden_nerves_requirements, righteous_blow_requirements, \
            crusade_requirements, damnation_requirements, power_shot_requirements, multi_shot_requirements, \
            ricochet_shot_requirements, energise_requirements, superconductor_requirements, ocean_tides_requirements, \
            alter_time_requirements, tight_tourniquet_requirements, secret_remedy_requirements, \
            champion1_immunity, champion2_immunity, champion3_immunity, champion4_immunity, champion5_immunity, \
            champion1_fullPotential, champion2_fullPotential, champion3_fullPotential, champion4_fullPotential, champion5_fullPotential, \
            champion1_muscleEnlarger, champion2_muscleEnlarger, champion3_muscleEnlarger, champion4_muscleEnlarger, champion5_muscleEnlarger, \
            champion1_nanobot, champion2_nanobot, champion3_nanobot, champion4_nanobot, champion5_nanobot, \
            champion1_blessing, champion2_blessing, champion3_blessing, champion4_blessing, champion5_blessing, \
            monk_bauble_damage_list1, monk_bauble_damage_list2, monk_bauble_damage_list3, \
            champion1_fortification, champion2_fortification, champion3_fortification, champion4_fortification, champion5_fortification, \
            champion1_pure_rage, champion2_pure_rage, champion3_pure_rage, champion4_pure_rage, champion5_pure_rage, \
            champion1_play_dead, champion2_play_dead, champion3_play_dead, champion4_play_dead, champion5_play_dead, \
            champion1_bush_armour, champion2_bush_armour, champion3_bush_armour, champion4_bush_armour, champion5_bush_armour, \
            champion1_enhardened_nerves, champion2_enhardened_nerves, champion3_enhardened_nerves, champion4_enhardened_nerves, champion5_enhardened_nerves
        if champion_position == 1:
            if CHAMPION_LIST[0] == "Monk":
                if leg_sweep_requirements[3] > 0:
                    leg_sweep_requirements[3] = leg_sweep_requirements[3] - 1
                if pressure_points_requirements[3] > 0:
                    pressure_points_requirements[3] = pressure_points_requirements[3] - 1
            if CHAMPION_LIST[0] == "Barbarian":
                if challenging_shout_requirements[3] > 0:
                    challenging_shout_requirements[3] = challenging_shout_requirements[3] - 1
            if CHAMPION_LIST[0] == "Kings-Guard":
                if trainwreck_requirements[3] > 0:
                    trainwreck_requirements[3] = trainwreck_requirements[3] - 1
                if fortification_requirements[3] > 0:
                    fortification_requirements[3] = fortification_requirements[3] - 1
            if CHAMPION_LIST[0] == "Fencer":
                if riposte_requirements[3] > 0:
                    riposte_requirements[3] = riposte_requirements[3] - 1
                if magic_reflection_requirements[3] > 0:
                    magic_reflection_requirements[3] = magic_reflection_requirements[3] - 1
                if evasive_manoeuvres_requirements[3] > 0:
                    evasive_manoeuvres_requirements[3] = evasive_manoeuvres_requirements[3] - 1
            if CHAMPION_LIST[0] == "Berserker":
                if reckless_flurry_requirements[3] > 0:
                    reckless_flurry_requirements[3] = reckless_flurry_requirements[3] - 1
            if CHAMPION_LIST[0] == "Rogue":
                if eviscerate_requirements[3] > 0:
                    eviscerate_requirements[3] = eviscerate_requirements[3] - 1
                if exploit_weakness_requirements[3] > 0:
                    exploit_weakness_requirements[3] = exploit_weakness_requirements[3] - 1
            if CHAMPION_LIST[0] == "Survivalist":
                if scrap_bomb_requirements[3] > 0:
                    scrap_bomb_requirements[3] = scrap_bomb_requirements[3] - 1
                if play_dead_requirements[3] > 0:
                    play_dead_requirements[3] = play_dead_requirements[3] - 1
                if survival_kit_requirements[3] > 0:
                    survival_kit_requirements[3] = survival_kit_requirements[3] - 1
            if CHAMPION_LIST[0] == "Brawlist":
                if uppercut_requirements[3] > 0:
                    uppercut_requirements[3] = uppercut_requirements[3] - 1
                if knock_out_requirements[3] > 0:
                    knock_out_requirements[3] = knock_out_requirements[3] - 1
                if wide_swing_requirements[3] > 0:
                    wide_swing_requirements[3] = wide_swing_requirements[3] - 1
            if CHAMPION_LIST[0] == "Academics Mage":
                if arcane_brilliance_requirements[3] > 0:
                    arcane_brilliance_requirements[3] = arcane_brilliance_requirements[3] - 1
            if CHAMPION_LIST[0] == "Druid":
                if vine_swipe_requirements[3] > 0:
                    vine_swipe_requirements[3] = vine_swipe_requirements[3] - 1
                if burst_n_bloom_requirements[3] > 0:
                    burst_n_bloom_requirements[3] = burst_n_bloom_requirements[3] - 1
            if CHAMPION_LIST[0] == "Warlock":
                if wound_fissure_requirements[3] > 0:
                    wound_fissure_requirements[3] = wound_fissure_requirements[3] - 1
            if CHAMPION_LIST[0] == "Bloodmancer":
                if blood_boil_requirements[3] > 0:
                    blood_boil_requirements[3] = blood_boil_requirements[3] - 1
                if enharden_nerves_requirements[3] > 0:
                    enharden_nerves_requirements[3] = enharden_nerves_requirements[3] - 1
            if CHAMPION_LIST[0] == "Paladin":
                if righteous_blow_requirements[3] > 0:
                    righteous_blow_requirements[3] = righteous_blow_requirements[3] - 1
                if crusade_requirements[3] > 0:
                    crusade_requirements[3] = crusade_requirements[3] - 1
                if damnation_requirements[3] > 0:
                    damnation_requirements[3] = damnation_requirements[3] - 1
            if CHAMPION_LIST[0] == "Ranger":
                if power_shot_requirements[3] > 0:
                    power_shot_requirements[3] = power_shot_requirements[3] - 1
                if multi_shot_requirements[3] > 0:
                    multi_shot_requirements[3] = multi_shot_requirements[3] - 1
                if ricochet_shot_requirements[3] > 0:
                    ricochet_shot_requirements[3] = ricochet_shot_requirements[3] - 1
            if CHAMPION_LIST[0] == "Magnetimancer":
                if energise_requirements[3] > 0:
                    energise_requirements[3] = energise_requirements[3] - 1
                if superconductor_requirements[3] > 0:
                    superconductor_requirements[3] = superconductor_requirements[3] - 1
            if CHAMPION_LIST[0] == "Earth Speaker":
                if ocean_tides_requirements[3] > 0:
                    ocean_tides_requirements[3] = ocean_tides_requirements[3] - 1
            if CHAMPION_LIST[0] == "Time Walker":
                if alter_time_requirements[3] > 0:
                    alter_time_requirements[3] = alter_time_requirements[3] - 1
            if CHAMPION_LIST[0] == "Field Medic":
                if tight_tourniquet_requirements[3] > 0:
                    tight_tourniquet_requirements[3] = tight_tourniquet_requirements[3] - 1
                if secret_remedy_requirements[3] > 0:
                    secret_remedy_requirements[3] = secret_remedy_requirements[3] - 1
            if "Immunity: Block" in champion1_statuses:
                champion1_statuses.remove("Immunity: Block")
            if "Immunity: Cocoon" in champion1_statuses:
                champion1_statuses.remove("Immunity: Cocoon")
            if "Immunity: Evasion" in champion1_statuses:
                champion1_statuses.remove("Immunity: Evasion")
            champion1_immunity = []
            if champion1_enhardened_nerves != 0:
                champion1_enhardened_nerves = 0
                champion1_statuses.remove("Enharden Nerves")
            if champion1_fullPotential != 0:
                champion1_fullPotential = champion1_fullPotential - 1
                if champion1_fullPotential == 0:
                    champion1_statuses.remove("Fullest Potential")
            if champion1_muscleEnlarger != 0:
                champion1_muscleEnlarger = champion1_muscleEnlarger - 1
                if champion1_muscleEnlarger == 0:
                    champion1_statuses.remove("Enlarged Muscles")
            if champion1_blessing != 0:
                champion1_blessing = champion1_blessing - 1
                if champion1_blessing == 0:
                    champion1_statuses.remove("Blessed")
            if champion1_fortification != 0:
                champion1_fortification = champion1_fortification - 1
                if champion1_fortification == 0:
                    champion1_statuses.remove("Fortified")
            if champion1_pure_rage != 0:
                champion1_pure_rage = champion1_pure_rage - 1
                if champion1_pure_rage == 0:
                    champion1_statuses.remove("Pure Rage")
            if champion1_play_dead != 0:
                champion1_play_dead = champion1_play_dead - 1
            if champion1_bush_armour != 0:
                champion1_bush_armour = champion1_bush_armour - 1
                if champion1_bush_armour == 0:
                    champion1_statuses.remove("Bush Armour")
        if champion_position == 2:
            if "Immunity: Block" in champion2_statuses:
                champion2_statuses.remove("Immunity: Block")
            if "Immunity: Cocoon" in champion2_statuses:
                champion2_statuses.remove("Immunity: Cocoon")
            if "Immunity: Evasion" in champion2_statuses:
                champion2_statuses.remove("Immunity: Evasion")
            champion2_immunity = []
            if champion2_fullPotential != 0:
                champion2_fullPotential = champion2_fullPotential - 1
                if champion2_fullPotential == 0:
                    champion2_statuses.remove("Fullest Potential")
            if champion2_muscleEnlarger != 0:
                champion2_muscleEnlarger = champion2_muscleEnlarger - 1
                if champion2_muscleEnlarger == 0:
                    champion2_statuses.remove("Enlarged Muscles")
            if champion2_blessing != 0:
                champion2_blessing = champion2_blessing - 1
                if champion2_blessing == 0:
                    champion2_statuses.remove("Blessed")
            if champion2_fortification != 0:
                champion2_fortification = champion2_fortification - 1
                if champion2_fortification == 0:
                    champion2_statuses.remove("Fortified")
            if champion2_pure_rage != 0:
                champion2_pure_rage = champion2_pure_rage - 1
                if champion2_pure_rage == 0:
                    champion2_statuses.remove("Pure Rage")
            if champion2_play_dead != 0:
                champion2_play_dead = champion2_play_dead - 1
            if champion2_bush_armour != 0:
                champion2_bush_armour = champion2_bush_armour - 1
                if champion2_bush_armour == 0:
                    champion2_statuses.remove("Bush Armour")
            if CHAMPION_LIST[1] == "Monk":
                if leg_sweep_requirements[3] > 0:
                    leg_sweep_requirements[3] = leg_sweep_requirements[3] - 1
                if pressure_points_requirements[3] > 0:
                    pressure_points_requirements[3] = pressure_points_requirements[3] - 1
            if CHAMPION_LIST[1] == "Barbarian":
                if challenging_shout_requirements[3] > 0:
                    challenging_shout_requirements[3] = challenging_shout_requirements[3] - 1
            if CHAMPION_LIST[1] == "Kings-Guard":
                if trainwreck_requirements[3] > 0:
                    trainwreck_requirements[3] = trainwreck_requirements[3] - 1
                if fortification_requirements[3] > 0:
                    fortification_requirements[3] = fortification_requirements[3] - 1
            if CHAMPION_LIST[1] == "Fencer":
                if riposte_requirements[3] > 0:
                    riposte_requirements[3] = riposte_requirements[3] - 1
                if magic_reflection_requirements[3] > 0:
                    magic_reflection_requirements[3] = magic_reflection_requirements[3] - 1
                if evasive_manoeuvres_requirements[3] > 0:
                    evasive_manoeuvres_requirements[3] = evasive_manoeuvres_requirements[3] - 1
            if CHAMPION_LIST[1] == "Berserker":
                if reckless_flurry_requirements[3] > 0:
                    reckless_flurry_requirements[3] = reckless_flurry_requirements[3] - 1
            if CHAMPION_LIST[1] == "Rogue":
                if eviscerate_requirements[3] > 0:
                    eviscerate_requirements[3] = eviscerate_requirements[3] - 1
                if exploit_weakness_requirements[3] > 0:
                    exploit_weakness_requirements[3] = exploit_weakness_requirements[3] - 1
            if CHAMPION_LIST[1] == "Survivalist":
                if scrap_bomb_requirements[3] > 0:
                    scrap_bomb_requirements[3] = scrap_bomb_requirements[3] - 1
                if play_dead_requirements[3] > 0:
                    play_dead_requirements[3] = play_dead_requirements[3] - 1
                if survival_kit_requirements[3] > 0:
                    survival_kit_requirements[3] = survival_kit_requirements[3] - 1
            if CHAMPION_LIST[1] == "Brawlist":
                if uppercut_requirements[3] > 0:
                    uppercut_requirements[3] = uppercut_requirements[3] - 1
                if knock_out_requirements[3] > 0:
                    knock_out_requirements[3] = knock_out_requirements[3] - 1
                if wide_swing_requirements[3] > 0:
                    wide_swing_requirements[3] = wide_swing_requirements[3] - 1
            if CHAMPION_LIST[1] == "Academics Mage":
                if arcane_brilliance_requirements[3] > 0:
                    arcane_brilliance_requirements[3] = arcane_brilliance_requirements[3] - 1
            if CHAMPION_LIST[1] == "Druid":
                if vine_swipe_requirements[3] > 0:
                    vine_swipe_requirements[3] = vine_swipe_requirements[3] - 1
                if burst_n_bloom_requirements[3] > 0:
                    burst_n_bloom_requirements[3] = burst_n_bloom_requirements[3] - 1
            if CHAMPION_LIST[1] == "Warlock":
                if wound_fissure_requirements[3] > 0:
                    wound_fissure_requirements[3] = wound_fissure_requirements[3] - 1
            if CHAMPION_LIST[1] == "Bloodmancer":
                if blood_boil_requirements[3] > 0:
                    blood_boil_requirements[3] = blood_boil_requirements[3] - 1
                if enharden_nerves_requirements[3] > 0:
                    enharden_nerves_requirements[3] = enharden_nerves_requirements[3] - 1
            if CHAMPION_LIST[1] == "Paladin":
                if righteous_blow_requirements[3] > 0:
                    righteous_blow_requirements[3] = righteous_blow_requirements[3] - 1
                if crusade_requirements[3] > 0:
                    crusade_requirements[3] = crusade_requirements[3] - 1
                if damnation_requirements[3] > 0:
                    damnation_requirements[3] = damnation_requirements[3] - 1
            if CHAMPION_LIST[1] == "Ranger":
                if power_shot_requirements[3] > 0:
                    power_shot_requirements[3] = power_shot_requirements[3] - 1
                if multi_shot_requirements[3] > 0:
                    multi_shot_requirements[3] = multi_shot_requirements[3] - 1
                if ricochet_shot_requirements[3] > 0:
                    ricochet_shot_requirements[3] = ricochet_shot_requirements[3] - 1
            if CHAMPION_LIST[1] == "Magnetimancer":
                if energise_requirements[3] > 0:
                    energise_requirements[3] = energise_requirements[3] - 1
                if superconductor_requirements[3] > 0:
                    superconductor_requirements[3] = superconductor_requirements[3] - 1
            if CHAMPION_LIST[1] == "Earth Speaker":
                if ocean_tides_requirements[3] > 0:
                    ocean_tides_requirements[3] = ocean_tides_requirements[3] - 1
            if CHAMPION_LIST[1] == "Time Walker":
                if alter_time_requirements[3] > 0:
                    alter_time_requirements[3] = alter_time_requirements[3] - 1
            if CHAMPION_LIST[1] == "Field Medic":
                if tight_tourniquet_requirements[3] > 0:
                    tight_tourniquet_requirements[3] = tight_tourniquet_requirements[3] - 1
                if secret_remedy_requirements[3] > 0:
                    secret_remedy_requirements[3] = secret_remedy_requirements[3] - 1
        if champion_position == 3:
            if "Immunity: Block" in champion3_statuses:
                champion3_statuses.remove("Immunity: Block")
            if "Immunity: Cocoon" in champion3_statuses:
                champion3_statuses.remove("Immunity: Cocoon")
            if "Immunity: Evasion" in champion3_statuses:
                champion3_statuses.remove("Immunity: Evasion")
            champion3_immunity = []
            if champion3_fullPotential != 0:
                champion3_fullPotential = champion3_fullPotential - 1
                if champion3_fullPotential == 0:
                    champion3_statuses.remove("Fullest Potential")
            if champion3_muscleEnlarger != 0:
                champion3_muscleEnlarger = champion3_muscleEnlarger - 1
                if champion3_muscleEnlarger == 0:
                    champion3_statuses.remove("Enlarged Muscles")
            if champion3_blessing != 0:
                champion3_blessing = champion3_blessing - 1
                if champion3_blessing == 0:
                    champion3_statuses.remove("Blessed")
            if champion3_fortification != 0:
                champion3_fortification = champion3_fortification - 1
                if champion3_fortification == 0:
                    champion3_statuses.remove("Fortified")
            if champion3_pure_rage != 0:
                champion3_pure_rage = champion3_pure_rage - 1
                if champion3_pure_rage == 0:
                    champion3_statuses.remove("Pure Rage")
            if champion3_play_dead != 0:
                champion3_play_dead = champion3_play_dead - 1
            if champion3_bush_armour != 0:
                champion3_bush_armour = champion3_bush_armour - 1
                if champion3_bush_armour == 0:
                    champion3_statuses.remove("Bush Armour")
            if CHAMPION_LIST[2] == "Monk":
                if leg_sweep_requirements[3] > 0:
                    leg_sweep_requirements[3] = leg_sweep_requirements[3] - 1
                if pressure_points_requirements[3] > 0:
                    pressure_points_requirements[3] = pressure_points_requirements[3] - 1
            if CHAMPION_LIST[2] == "Barbarian":
                if challenging_shout_requirements[3] > 0:
                    challenging_shout_requirements[3] = challenging_shout_requirements[3] - 1
            if CHAMPION_LIST[2] == "Kings-Guard":
                if trainwreck_requirements[3] > 0:
                    trainwreck_requirements[3] = trainwreck_requirements[3] - 1
                if fortification_requirements[3] > 0:
                    fortification_requirements[3] = fortification_requirements[3] - 1
            if CHAMPION_LIST[2] == "Fencer":
                if riposte_requirements[3] > 0:
                    riposte_requirements[3] = riposte_requirements[3] - 1
                if magic_reflection_requirements[3] > 0:
                    magic_reflection_requirements[3] = magic_reflection_requirements[3] - 1
                if evasive_manoeuvres_requirements[3] > 0:
                    evasive_manoeuvres_requirements[3] = evasive_manoeuvres_requirements[3] - 1
            if CHAMPION_LIST[2] == "Berserker":
                if reckless_flurry_requirements[3] > 0:
                    reckless_flurry_requirements[3] = reckless_flurry_requirements[3] - 1
            if CHAMPION_LIST[2] == "Rogue":
                if eviscerate_requirements[3] > 0:
                    eviscerate_requirements[3] = eviscerate_requirements[3] - 1
                if exploit_weakness_requirements[3] > 0:
                    exploit_weakness_requirements[3] = exploit_weakness_requirements[3] - 1
            if CHAMPION_LIST[2] == "Survivalist":
                if scrap_bomb_requirements[3] > 0:
                    scrap_bomb_requirements[3] = scrap_bomb_requirements[3] - 1
                if play_dead_requirements[3] > 0:
                    play_dead_requirements[3] = play_dead_requirements[3] - 1
                if survival_kit_requirements[3] > 0:
                    survival_kit_requirements[3] = survival_kit_requirements[3] - 1
            if CHAMPION_LIST[2] == "Brawlist":
                if uppercut_requirements[3] > 0:
                    uppercut_requirements[3] = uppercut_requirements[3] - 1
                if knock_out_requirements[3] > 0:
                    knock_out_requirements[3] = knock_out_requirements[3] - 1
                if wide_swing_requirements[3] > 0:
                    wide_swing_requirements[3] = wide_swing_requirements[3] - 1
            if CHAMPION_LIST[2] == "Academics Mage":
                if arcane_brilliance_requirements[3] > 0:
                    arcane_brilliance_requirements[3] = arcane_brilliance_requirements[3] - 1
            if CHAMPION_LIST[2] == "Druid":
                if vine_swipe_requirements[3] > 0:
                    vine_swipe_requirements[3] = vine_swipe_requirements[3] - 1
                if burst_n_bloom_requirements[3] > 0:
                    burst_n_bloom_requirements[3] = burst_n_bloom_requirements[3] - 1
            if CHAMPION_LIST[2] == "Warlock":
                if wound_fissure_requirements[3] > 0:
                    wound_fissure_requirements[3] = wound_fissure_requirements[3] - 1
            if CHAMPION_LIST[2] == "Bloodmancer":
                if blood_boil_requirements[3] > 0:
                    blood_boil_requirements[3] = blood_boil_requirements[3] - 1
                if enharden_nerves_requirements[3] > 0:
                    enharden_nerves_requirements[3] = enharden_nerves_requirements[3] - 1
            if CHAMPION_LIST[2] == "Paladin":
                if righteous_blow_requirements[3] > 0:
                    righteous_blow_requirements[3] = righteous_blow_requirements[3] - 1
                if crusade_requirements[3] > 0:
                    crusade_requirements[3] = crusade_requirements[3] - 1
                if damnation_requirements[3] > 0:
                    damnation_requirements[3] = damnation_requirements[3] - 1
            if CHAMPION_LIST[2] == "Ranger":
                if power_shot_requirements[3] > 0:
                    power_shot_requirements[3] = power_shot_requirements[3] - 1
                if multi_shot_requirements[3] > 0:
                    multi_shot_requirements[3] = multi_shot_requirements[3] - 1
                if ricochet_shot_requirements[3] > 0:
                    ricochet_shot_requirements[3] = ricochet_shot_requirements[3] - 1
            if CHAMPION_LIST[2] == "Magnetimancer":
                if energise_requirements[3] > 0:
                    energise_requirements[3] = energise_requirements[3] - 1
                if superconductor_requirements[3] > 0:
                    superconductor_requirements[3] = superconductor_requirements[3] - 1
            if CHAMPION_LIST[2] == "Earth Speaker":
                if ocean_tides_requirements[3] > 0:
                    ocean_tides_requirements[3] = ocean_tides_requirements[3] - 1
            if CHAMPION_LIST[2] == "Time Walker":
                if alter_time_requirements[3] > 0:
                    alter_time_requirements[3] = alter_time_requirements[3] - 1
            if CHAMPION_LIST[2] == "Field Medic":
                if tight_tourniquet_requirements[3] > 0:
                    tight_tourniquet_requirements[3] = tight_tourniquet_requirements[3] - 1
                if secret_remedy_requirements[3] > 0:
                    secret_remedy_requirements[3] = secret_remedy_requirements[3] - 1
        if champion_position == 4:
            if "Immunity: Block" in champion4_statuses:
                champion4_statuses.remove("Immunity: Block")
            if "Immunity: Cocoon" in champion4_statuses:
                champion4_statuses.remove("Immunity: Cocoon")
            if "Immunity: Evasion" in champion4_statuses:
                champion4_statuses.remove("Immunity: Evasion")
            champion4_immunity = []
            if champion4_fullPotential != 0:
                champion4_fullPotential = champion4_fullPotential - 1
                if champion4_fullPotential == 0:
                    champion4_statuses.remove("Fullest Potential")
            if champion4_muscleEnlarger != 0:
                champion4_muscleEnlarger = champion4_muscleEnlarger - 1
                if champion4_muscleEnlarger == 0:
                    champion4_statuses.remove("Enlarged Muscles")
            if champion4_blessing != 0:
                champion4_blessing = champion4_blessing - 1
                if champion4_blessing == 0:
                    champion4_statuses.remove("Blessed")
            if champion4_fortification != 0:
                champion4_fortification = champion4_fortification - 1
                if champion4_fortification == 0:
                    champion4_statuses.remove("Fortified")
            if champion4_pure_rage != 0:
                champion4_pure_rage = champion4_pure_rage - 1
                if champion4_pure_rage == 0:
                    champion4_statuses.remove("Pure Rage")
            if champion4_play_dead != 0:
                champion4_play_dead = champion4_play_dead - 1
            if champion4_bush_armour != 0:
                champion4_bush_armour = champion4_bush_armour - 1
                if champion4_bush_armour == 0:
                    champion4_statuses.remove("Bush Armour")
            if CHAMPION_LIST[3] == "Monk":
                if leg_sweep_requirements[3] > 0:
                    leg_sweep_requirements[3] = leg_sweep_requirements[3] - 1
                if pressure_points_requirements[3] > 0:
                    pressure_points_requirements[3] = pressure_points_requirements[3] - 1
            if CHAMPION_LIST[3] == "Barbarian":
                if challenging_shout_requirements[3] > 0:
                    challenging_shout_requirements[3] = challenging_shout_requirements[3] - 1
            if CHAMPION_LIST[3] == "Kings-Guard":
                if trainwreck_requirements[3] > 0:
                    trainwreck_requirements[3] = trainwreck_requirements[3] - 1
                if fortification_requirements[3] > 0:
                    fortification_requirements[3] = fortification_requirements[3] - 1
            if CHAMPION_LIST[3] == "Fencer":
                if riposte_requirements[3] > 0:
                    riposte_requirements[3] = riposte_requirements[3] - 1
                if magic_reflection_requirements[3] > 0:
                    magic_reflection_requirements[3] = magic_reflection_requirements[3] - 1
                if evasive_manoeuvres_requirements[3] > 0:
                    evasive_manoeuvres_requirements[3] = evasive_manoeuvres_requirements[3] - 1
            if CHAMPION_LIST[3] == "Berserker":
                if reckless_flurry_requirements[3] > 0:
                    reckless_flurry_requirements[3] = reckless_flurry_requirements[3] - 1
            if CHAMPION_LIST[3] == "Rogue":
                if eviscerate_requirements[3] > 0:
                    eviscerate_requirements[3] = eviscerate_requirements[3] - 1
                if exploit_weakness_requirements[3] > 0:
                    exploit_weakness_requirements[3] = exploit_weakness_requirements[3] - 1
            if CHAMPION_LIST[3] == "Survivalist":
                if scrap_bomb_requirements[3] > 0:
                    scrap_bomb_requirements[3] = scrap_bomb_requirements[3] - 1
                if play_dead_requirements[3] > 0:
                    play_dead_requirements[3] = play_dead_requirements[3] - 1
                if survival_kit_requirements[3] > 0:
                    survival_kit_requirements[3] = survival_kit_requirements[3] - 1
            if CHAMPION_LIST[3] == "Brawlist":
                if uppercut_requirements[3] > 0:
                    uppercut_requirements[3] = uppercut_requirements[3] - 1
                if knock_out_requirements[3] > 0:
                    knock_out_requirements[3] = knock_out_requirements[3] - 1
                if wide_swing_requirements[3] > 0:
                    wide_swing_requirements[3] = wide_swing_requirements[3] - 1
            if CHAMPION_LIST[3] == "Academics Mage":
                if arcane_brilliance_requirements[3] > 0:
                    arcane_brilliance_requirements[3] = arcane_brilliance_requirements[3] - 1
            if CHAMPION_LIST[3] == "Druid":
                if vine_swipe_requirements[3] > 0:
                    vine_swipe_requirements[3] = vine_swipe_requirements[3] - 1
                if burst_n_bloom_requirements[3] > 0:
                    burst_n_bloom_requirements[3] = burst_n_bloom_requirements[3] - 1
            if CHAMPION_LIST[3] == "Warlock":
                if wound_fissure_requirements[3] > 0:
                    wound_fissure_requirements[3] = wound_fissure_requirements[3] - 1
            if CHAMPION_LIST[3] == "Bloodmancer":
                if blood_boil_requirements[3] > 0:
                    blood_boil_requirements[3] = blood_boil_requirements[3] - 1
                if enharden_nerves_requirements[3] > 0:
                    enharden_nerves_requirements[3] = enharden_nerves_requirements[3] - 1
            if CHAMPION_LIST[3] == "Paladin":
                if righteous_blow_requirements[3] > 0:
                    righteous_blow_requirements[3] = righteous_blow_requirements[3] - 1
                if crusade_requirements[3] > 0:
                    crusade_requirements[3] = crusade_requirements[3] - 1
                if damnation_requirements[3] > 0:
                    damnation_requirements[3] = damnation_requirements[3] - 1
            if CHAMPION_LIST[3] == "Ranger":
                if power_shot_requirements[3] > 0:
                    power_shot_requirements[3] = power_shot_requirements[3] - 1
                if multi_shot_requirements[3] > 0:
                    multi_shot_requirements[3] = multi_shot_requirements[3] - 1
                if ricochet_shot_requirements[3] > 0:
                    ricochet_shot_requirements[3] = ricochet_shot_requirements[3] - 1
            if CHAMPION_LIST[3] == "Magnetimancer":
                if energise_requirements[3] > 0:
                    energise_requirements[3] = energise_requirements[3] - 1
                if superconductor_requirements[3] > 0:
                    superconductor_requirements[3] = superconductor_requirements[3] - 1
            if CHAMPION_LIST[3] == "Earth Speaker":
                if ocean_tides_requirements[3] > 0:
                    ocean_tides_requirements[3] = ocean_tides_requirements[3] - 1
            if CHAMPION_LIST[3] == "Time Walker":
                if alter_time_requirements[3] > 0:
                    alter_time_requirements[3] = alter_time_requirements[3] - 1
            if CHAMPION_LIST[3] == "Field Medic":
                if tight_tourniquet_requirements[3] > 0:
                    tight_tourniquet_requirements[3] = tight_tourniquet_requirements[3] - 1
                if secret_remedy_requirements[3] > 0:
                    secret_remedy_requirements[3] = secret_remedy_requirements[3] - 1
        if champion_position == 5:
            if "Immunity: Block" in champion5_statuses:
                champion5_statuses.remove("Immunity: Block")
            if "Immunity: Cocoon" in champion5_statuses:
                champion5_statuses.remove("Immunity: Cocoon")
            if "Immunity: Evasion" in champion5_statuses:
                champion5_statuses.remove("Immunity: Evasion")
            champion5_immunity = []
            if champion5_fullPotential != 0:
                champion5_fullPotential = champion5_fullPotential - 1
                if champion5_fullPotential == 0:
                    champion5_statuses.remove("Fullest Potential")
            if champion5_muscleEnlarger != 0:
                champion5_muscleEnlarger = champion5_muscleEnlarger - 1
                if champion5_muscleEnlarger == 0:
                    champion5_statuses.remove("Enlarged Muscles")
            if champion5_blessing != 0:
                champion5_blessing = champion5_blessing - 1
                if champion5_blessing == 0:
                    champion5_statuses.remove("Blessed")
            if champion5_fortification != 0:
                champion5_fortification = champion5_fortification - 1
                if champion5_fortification == 0:
                    champion5_statuses.remove("Fortified")
            if champion5_pure_rage != 0:
                champion5_pure_rage = champion5_pure_rage - 1
                if champion5_pure_rage == 0:
                    champion5_statuses.remove("Pure Rage")
            if champion5_play_dead != 0:
                champion5_play_dead = champion5_play_dead - 1
            if champion5_bush_armour != 0:
                champion5_bush_armour = champion5_bush_armour - 1
                if champion5_bush_armour == 0:
                    champion5_statuses.remove("Bush Armour")
            if CHAMPION_LIST[4] == "Monk":
                if leg_sweep_requirements[3] > 0:
                    leg_sweep_requirements[3] = leg_sweep_requirements[3] - 1
                if pressure_points_requirements[3] > 0:
                    pressure_points_requirements[3] = pressure_points_requirements[3] - 1
            if CHAMPION_LIST[4] == "Barbarian":
                if challenging_shout_requirements[3] > 0:
                    challenging_shout_requirements[3] = challenging_shout_requirements[3] - 1
            if CHAMPION_LIST[4] == "Kings-Guard":
                if trainwreck_requirements[3] > 0:
                    trainwreck_requirements[3] = trainwreck_requirements[3] - 1
                if fortification_requirements[3] > 0:
                    fortification_requirements[3] = fortification_requirements[3] - 1
            if CHAMPION_LIST[4] == "Fencer":
                if riposte_requirements[3] > 0:
                    riposte_requirements[3] = riposte_requirements[3] - 1
                if magic_reflection_requirements[3] > 0:
                    magic_reflection_requirements[3] = magic_reflection_requirements[3] - 1
                if evasive_manoeuvres_requirements[3] > 0:
                    evasive_manoeuvres_requirements[3] = evasive_manoeuvres_requirements[3] - 1
            if CHAMPION_LIST[4] == "Berserker":
                if reckless_flurry_requirements[3] > 0:
                    reckless_flurry_requirements[3] = reckless_flurry_requirements[3] - 1
            if CHAMPION_LIST[4] == "Rogue":
                if eviscerate_requirements[3] > 0:
                    eviscerate_requirements[3] = eviscerate_requirements[3] - 1
                if exploit_weakness_requirements[3] > 0:
                    exploit_weakness_requirements[3] = exploit_weakness_requirements[3] - 1
            if CHAMPION_LIST[4] == "Survivalist":
                if scrap_bomb_requirements[3] > 0:
                    scrap_bomb_requirements[3] = scrap_bomb_requirements[3] - 1
                if play_dead_requirements[3] > 0:
                    play_dead_requirements[3] = play_dead_requirements[3] - 1
                if survival_kit_requirements[3] > 0:
                    survival_kit_requirements[3] = survival_kit_requirements[3] - 1
            if CHAMPION_LIST[4] == "Brawlist":
                if uppercut_requirements[3] > 0:
                    uppercut_requirements[3] = uppercut_requirements[3] - 1
                if knock_out_requirements[3] > 0:
                    knock_out_requirements[3] = knock_out_requirements[3] - 1
                if wide_swing_requirements[3] > 0:
                    wide_swing_requirements[3] = wide_swing_requirements[3] - 1
            if CHAMPION_LIST[4] == "Academics Mage":
                if arcane_brilliance_requirements[3] > 0:
                    arcane_brilliance_requirements[3] = arcane_brilliance_requirements[3] - 1
            if CHAMPION_LIST[4] == "Druid":
                if vine_swipe_requirements[3] > 0:
                    vine_swipe_requirements[3] = vine_swipe_requirements[3] - 1
                if burst_n_bloom_requirements[3] > 0:
                    burst_n_bloom_requirements[3] = burst_n_bloom_requirements[3] - 1
            if CHAMPION_LIST[4] == "Warlock":
                if wound_fissure_requirements[3] > 0:
                    wound_fissure_requirements[3] = wound_fissure_requirements[3] - 1
            if CHAMPION_LIST[4] == "Bloodmancer":
                if blood_boil_requirements[3] > 0:
                    blood_boil_requirements[3] = blood_boil_requirements[3] - 1
                if enharden_nerves_requirements[3] > 0:
                    enharden_nerves_requirements[3] = enharden_nerves_requirements[3] - 1
            if CHAMPION_LIST[4] == "Paladin":
                if righteous_blow_requirements[3] > 0:
                    righteous_blow_requirements[3] = righteous_blow_requirements[3] - 1
                if crusade_requirements[3] > 0:
                    crusade_requirements[3] = crusade_requirements[3] - 1
                if damnation_requirements[3] > 0:
                    damnation_requirements[3] = damnation_requirements[3] - 1
            if CHAMPION_LIST[4] == "Ranger":
                if power_shot_requirements[3] > 0:
                    power_shot_requirements[3] = power_shot_requirements[3] - 1
                if multi_shot_requirements[3] > 0:
                    multi_shot_requirements[3] = multi_shot_requirements[3] - 1
                if ricochet_shot_requirements[3] > 0:
                    ricochet_shot_requirements[3] = ricochet_shot_requirements[3] - 1
            if CHAMPION_LIST[4] == "Magnetimancer":
                if energise_requirements[3] > 0:
                    energise_requirements[3] = energise_requirements[3] - 1
                if superconductor_requirements[3] > 0:
                    superconductor_requirements[3] = superconductor_requirements[3] - 1
            if CHAMPION_LIST[4] == "Earth Speaker":
                if ocean_tides_requirements[3] > 0:
                    ocean_tides_requirements[3] = ocean_tides_requirements[3] - 1
            if CHAMPION_LIST[4] == "Time Walker":
                if alter_time_requirements[3] > 0:
                    alter_time_requirements[3] = alter_time_requirements[3] - 1
            if CHAMPION_LIST[4] == "Field Medic":
                if tight_tourniquet_requirements[3] > 0:
                    tight_tourniquet_requirements[3] = tight_tourniquet_requirements[3] - 1
                if secret_remedy_requirements[3] > 0:
                    secret_remedy_requirements[3] = secret_remedy_requirements[3] - 1
#Function that heals champions for each heal over time/buff they have and reduces their duration by one
    def heal_overtime_tick(self):
        global champion1_nanobot, champion2_nanobot, champion3_nanobot, champion4_nanobot, champion5_nanobot, \
            champion1_bandaged, champion2_bandaged, champion3_bandaged, champion4_bandaged,champion5_bandaged, \
            champion1_weaktourniquet, champion2_weaktourniquet, champion3_weaktourniquet, champion4_weaktourniquet, champion5_weaktourniquet, \
            champion1_tighttourniquet, champion2_tighttourniquet, champion3_tighttourniquet, champion4_tighttourniquet, champion5_tighttourniquet, \
            champion1_weakremedy, champion2_weakremedy, champion3_weakremedy, champion4_weakremedy, champion5_weakremedy, \
            champion1_strongremedy, champion2_strongremedy, champion3_strongremedy, champion4_strongremedy, champion5_strongremedy, \
            champion1_springwaters, champion2_springwaters, champion3_springwaters, champion4_springwaters, champion5_springwaters, \
            champion1_oceantide, champion2_oceantide, champion3_oceantide, champion4_oceantide, champion5_oceantide, \
            champion1_hp, champion2_hp, champion3_hp, champion4_hp, champion5_hp, nanobot_overclock, \
            champion1_statuses, champion2_statuses, champion3_statuses, champion4_statuses, champion5_statuses
        if "Nano-repair Bots" in champion1_statuses:
            if nanobot_overclock > 0:
                champion1_hp = champion1_hp + champion1_hp*0.2
            else:
                champion1_hp = champion1_hp + champion1_hp*0.1
            if champion1_hp > CHAMPION1_HP:
                champion1_hp = CHAMPION1_HP
        if "Nano-repair Bots" in champion2_statuses:
            if nanobot_overclock > 0:
                champion2_hp = champion2_hp + champion2_hp*0.2
            else:
                champion2_hp = champion2_hp + champion2_hp*0.1
            if champion2_hp > CHAMPION2_HP:
                champion2_hp = CHAMPION2_HP
        if "Nano-repair Bots" in champion3_statuses:
            if nanobot_overclock > 0:
                champion3_hp = champion3_hp + champion3_hp*0.2
            else:
                champion3_hp = champion3_hp + champion3_hp*0.1
            if champion3_hp > CHAMPION3_HP:
                champion3_hp = CHAMPION3_HP
        if "Nano-repair Bots" in champion4_statuses:
            if nanobot_overclock > 0:
                champion4_hp = champion4_hp + champion3_hp*0.2
            else:
                champion4_hp = champion4_hp + champion4_hp*0.1
            if champion4_hp > CHAMPION4_HP:
                champion4_hp = CHAMPION4_HP
        if "Nano-repair Bots" in champion5_statuses:
            if nanobot_overclock > 0:
                champion5_hp = champion5_hp + champion5_hp*0.2
            else:
                champion5_hp = champion5_hp + champion5_hp*0.1
            if champion5_hp > CHAMPION5_HP:
                champion5_hp = CHAMPION5_HP
        if nanobot_overclock > 0:
            nanobot_overclock = nanobot_overclock - 1
        if champion1_bandaged[1] != 0:
            champion1_bandaged[1] = champion1_bandaged[1] - 1
            champion1_hp = champion1_hp + champion1_bandaged[0]
            if champion1_hp > CHAMPION1_HP:
                champion1_hp = CHAMPION1_HP
            if champion1_bandaged[1] == 0:
                champion1_statuses.remove("Bandaged")
        if champion2_bandaged[1] != 0:
            champion2_bandaged[1] = champion2_bandaged[1] - 1
            champion2_hp = champion2_hp + champion2_bandaged[0]
            if champion2_hp > CHAMPION2_HP:
                champion2_hp = CHAMPION2_HP
            if champion2_bandaged[1] == 0:
                champion2_statuses.remove("Bandaged")
        if champion3_bandaged[1] != 0:
            champion3_bandaged[1] = champion3_bandaged[1] - 1
            champion3_hp = champion3_hp + champion3_bandaged[0]
            if champion3_hp > CHAMPION3_HP:
                champion3_hp = CHAMPION3_HP
            if champion3_bandaged[1] == 0:
                champion3_statuses.remove("Bandaged")
        if champion4_bandaged[1] != 0:
            champion4_bandaged[1] = champion4_bandaged[1] - 1
            champion4_hp = champion4_hp + champion4_bandaged[0]
            if champion4_hp > CHAMPION4_HP:
                champion4_hp = CHAMPION4_HP
            if champion4_bandaged[1] == 0:
                champion4_statuses.remove("Bandaged")
        if champion5_bandaged[1] != 0:
            champion5_bandaged[1] = champion5_bandaged[1] - 1
            champion5_hp = champion5_hp + champion5_bandaged[0]
            if champion5_hp > CHAMPION5_HP:
                champion5_hp = CHAMPION5_HP
            if champion5_bandaged[1] == 0:
                champion5_statuses.remove("Bandaged")
        if champion1_weaktourniquet != 0:
            champion1_weaktourniquet = champion1_weaktourniquet - 1
            if champion1_weaktourniquet == 0:
                champion1_statuses.remove("Weak Tourniquet")
            champion1_hp = champion1_hp + 150
            if champion1_hp > CHAMPION1_HP:
                champion1_hp = CHAMPION1_HP
        if champion2_weaktourniquet != 0:
            champion2_weaktourniquet = champion2_weaktourniquet - 1
            if champion2_weaktourniquet == 0:
                champion2_statuses.remove("Weak Tourniquet")
            champion2_hp = champion2_hp + 150
            if champion2_hp > CHAMPION2_HP:
                champion2_hp = CHAMPION2_HP
        if champion3_weaktourniquet != 0:
            champion3_weaktourniquet = champion3_weaktourniquet - 1
            if champion3_weaktourniquet == 0:
                champion3_statuses.remove("Weak Tourniquet")
            champion3_hp = champion3_hp + 150
            if champion3_hp > CHAMPION3_HP:
                champion3_hp = CHAMPION3_HP
        if champion4_weaktourniquet != 0:
            champion4_weaktourniquet = champion4_weaktourniquet - 1
            if champion4_weaktourniquet == 0:
                champion4_statuses.remove("Weak Tourniquet")
            champion4_hp = champion4_hp + 150
            if champion4_hp > CHAMPION4_HP:
                champion4_hp = CHAMPION4_HP
        if champion5_weaktourniquet != 0:
            champion5_weaktourniquet = champion5_weaktourniquet - 1
            if champion5_weaktourniquet == 0:
                champion5_statuses.remove("Weak Tourniquet")
            champion5_hp = champion5_hp + 150
            if champion5_hp > CHAMPION5_HP:
                champion5_hp = CHAMPION5_HP
        if champion1_tighttourniquet != 0:
            champion1_tighttourniquet = champion1_tighttourniquet - 1
            if champion1_tighttourniquet == 0:
                champion1_statuses.remove("Tight Tourniquet")
                self.apply_weak_tourniquet(1, 2)
                champion1_hp = champion1_hp + 150
                if champion1_hp > CHAMPION1_HP:
                    champion1_hp = CHAMPION1_HP
        if champion2_tighttourniquet != 0:
            champion2_tighttourniquet = champion2_tighttourniquet - 1
            if champion2_tighttourniquet == 0:
                champion2_statuses.remove("Tight Tourniquet")
                self.apply_weak_tourniquet(2, 2)
                champion2_hp = champion2_hp + 150
                if champion2_hp > CHAMPION2_HP:
                    champion2_hp = CHAMPION2_HP
        if champion3_tighttourniquet != 0:
            champion3_tighttourniquet = champion3_tighttourniquet - 1
            if champion3_tighttourniquet == 0:
                champion3_statuses.remove("Tight Tourniquet")
                self.apply_weak_tourniquet(3, 2)
                champion3_hp = champion3_hp + 150
                if champion3_hp > CHAMPION3_HP:
                    champion3_hp = CHAMPION3_HP
        if champion4_tighttourniquet != 0:
            champion4_tighttourniquet = champion4_tighttourniquet - 1
            if champion4_tighttourniquet == 0:
                champion4_statuses.remove("Tight Tourniquet")
                self.apply_weak_tourniquet(4, 2)
                champion4_hp = champion4_hp + 150
                if champion4_hp > CHAMPION4_HP:
                    champion4_hp = CHAMPION4_HP
        if champion5_tighttourniquet != 0:
            champion5_tighttourniquet = champion5_tighttourniquet - 1
            if champion5_tighttourniquet == 0:
                champion5_statuses.remove("Tight Tourniquet")
                self.apply_weak_tourniquet(5, 2)
                champion5_hp = champion5_hp + 150
                if champion5_hp > CHAMPION5_HP:
                    champion5_hp = CHAMPION5_HP
        if champion1_weakremedy != 0:
            champion1_weakremedy = champion1_weakremedy - 1
            if champion1_weakremedy == 0:
                champion1_statuses.remove("Weak Remedy")
            champion1_hp = champion1_hp + 150
            if champion1_hp > CHAMPION1_HP:
                champion1_hp = CHAMPION1_HP
        if champion2_weakremedy != 0:
            champion2_weakremedy = champion2_weakremedy - 1
            if champion2_weakremedy == 0:
                champion2_statuses.remove("Weak Remedy")
            champion2_hp = champion2_hp + 150
            if champion2_hp > CHAMPION2_HP:
                champion2_hp = CHAMPION2_HP
        if champion3_weakremedy != 0:
            champion3_weakremedy = champion3_weakremedy - 1
            if champion3_weakremedy == 0:
                champion3_statuses.remove("Weak Remedy")
            champion3_hp = champion3_hp + 150
            if champion3_hp > CHAMPION3_HP:
                champion3_hp = CHAMPION3_HP
        if champion4_weakremedy != 0:
            champion4_weakremedy = champion4_weakremedy - 1
            if champion4_weakremedy == 0:
                champion4_statuses.remove("Weak Remedy")
            champion4_hp = champion4_hp + 150
            if champion4_hp > CHAMPION4_HP:
                champion4_hp = CHAMPION4_HP
        if champion5_weakremedy != 0:
            champion5_weakremedy = champion5_weakremedy - 1
            if champion5_weakremedy == 0:
                champion5_statuses.remove("Weak Remedy")
            champion5_hp = champion5_hp + 150
            if champion5_hp > CHAMPION5_HP:
                champion5_hp = CHAMPION5_HP
        if champion1_strongremedy != 0:
            champion1_strongremedy = champion1_strongremedy - 1
            if champion1_strongremedy == 0:
                champion1_statuses.remove("Strong Remedy")
                self.apply_weak_remedy(1, 2)
                champion1_hp = champion1_hp + 150
                if champion1_hp > CHAMPION1_HP:
                    champion1_hp = CHAMPION1_HP
        if champion2_strongremedy != 0:
            champion2_strongremedy = champion2_strongremedy - 1
            if champion2_strongremedy == 0:
                champion2_statuses.remove("Strong Remedy")
                self.apply_weak_remedy(2, 2)
                champion2_hp = champion2_hp + 150
                if champion2_hp > CHAMPION2_HP:
                    champion2_hp = CHAMPION2_HP
        if champion3_strongremedy != 0:
            champion3_strongremedy = champion3_strongremedy - 1
            if champion3_strongremedy == 0:
                champion3_statuses.remove("Strong Remedy")
                self.apply_weak_remedy(3, 2)
                champion3_hp = champion3_hp + 150
                if champion3_hp > CHAMPION3_HP:
                    champion3_hp = CHAMPION3_HP
        if champion4_strongremedy != 0:
            champion4_strongremedy = champion4_strongremedy - 1
            if champion4_strongremedy == 0:
                champion4_statuses.remove("Strong Remedy")
                self.apply_weak_remedy(4, 2)
                champion4_hp = champion4_hp + 150
                if champion4_hp > CHAMPION4_HP:
                    champion4_hp = CHAMPION4_HP
        if champion5_strongremedy != 0:
            champion5_strongremedy = champion5_strongremedy - 1
            if champion5_strongremedy == 0:
                champion5_statuses.remove("Strong Remedy")
                self.apply_weak_remedy(5, 2)
                champion5_hp = champion5_hp + 150
                if champion5_hp > CHAMPION5_HP:
                    champion5_hp = CHAMPION5_HP
        if champion1_springwaters[1] != 0:
            champion1_springwaters[1] = champion1_springwaters[1] - 1
            champion1_hp = champion1_hp + champion1_springwaters[0]
            if champion1_hp > CHAMPION1_HP:
                champion1_hp = CHAMPION1_HP
            if champion1_springwaters[1] == 0:
                champion1_statuses.remove("Flowing Waters")
                if champion1_oceantide[1] == 0:
                    if "Toughened Mud" in champion1_statuses:
                        champion1_statuses.remove("Toughened Mud")
        if champion2_springwaters[1] != 0:
            champion2_springwaters[1] = champion2_springwaters[1] - 1
            champion2_hp = champion2_hp + champion2_springwaters[0]
            if champion2_hp > CHAMPION2_HP:
                champion2_hp = CHAMPION2_HP
            if champion2_springwaters[1] == 0:
                champion2_statuses.remove("Flowing Waters")
                if champion2_oceantide[1] == 0:
                    if "Toughened Mud" in champion2_statuses:
                        champion2_statuses.remove("Toughened Mud")
        if champion3_springwaters[1] != 0:
            champion3_springwaters[1] = champion3_springwaters[1] - 1
            champion3_hp = champion3_hp + champion3_springwaters[0]
            if champion3_hp > CHAMPION3_HP:
                champion3_hp = CHAMPION3_HP
            if champion3_springwaters[1] == 0:
                champion3_statuses.remove("Flowing Waters")
                if champion3_oceantide[1] == 0:
                    if "Toughened Mud" in champion3_statuses:
                        champion3_statuses.remove("Toughened Mud")
        if champion4_springwaters[1] != 0:
            champion4_springwaters[1] = champion4_springwaters[1] - 1
            champion4_hp = champion4_hp + champion4_springwaters[0]
            if champion4_hp > CHAMPION4_HP:
                champion4_hp = CHAMPION4_HP
            if champion4_springwaters[1] == 0:
                champion4_statuses.remove("Flowing Waters")
                if champion4_oceantide[1] == 0:
                    if "Toughened Mud" in champion4_statuses:
                        champion4_statuses.remove("Toughened Mud")
        if champion5_springwaters[1] != 0:
            champion5_springwaters[1] = champion5_springwaters[1] - 1
            champion5_hp = champion5_hp + champion5_springwaters[0]
            if champion5_hp > CHAMPION5_HP:
                champion5_hp = CHAMPION5_HP
            if champion5_springwaters[1] == 0:
                champion5_statuses.remove("Flowing Waters")
                if champion5_oceantide[1] == 0:
                    if "Toughened Mud" in champion5_statuses:
                        champion5_statuses.remove("Toughened Mud")
        if champion1_oceantide[1] != 0:
            champion1_oceantide[1] = champion1_oceantide[1] - 1
            champion1_hp = champion1_hp + champion1_oceantide[0]
            if champion1_hp > CHAMPION1_HP:
                champion1_hp = CHAMPION1_HP
            if champion1_oceantide[1] == 0:
                champion1_statuses.remove("Crashing Waters")
                if champion1_springwaters[1] == 0:
                    if "Toughened Mud" in champion1_statuses:
                        champion1_statuses.remove("Toughened Mud")
        if champion2_oceantide[1] != 0:
            champion2_oceantide[1] = champion2_oceantide[1] - 1
            champion2_hp = champion2_hp + champion2_oceantide[0]
            if champion2_hp > CHAMPION2_HP:
                champion2_hp = CHAMPION2_HP
            if champion2_oceantide[1] == 0:
                champion2_statuses.remove("Crashing Waters")
                if champion2_springwaters[1] == 0:
                    if "Toughened Mud" in champion2_statuses:
                        champion2_statuses.remove("Toughened Mud")
        if champion3_oceantide[1] != 0:
            champion3_oceantide[1] = champion3_oceantide[1] - 1
            champion3_hp = champion3_hp + champion3_oceantide[0]
            if champion3_hp > CHAMPION3_HP:
                champion3_hp = CHAMPION3_HP
            if champion3_oceantide[1] == 0:
                champion3_statuses.remove("Crashing Waters")
                if champion3_springwaters[1] == 0:
                    if "Toughened Mud" in champion3_statuses:
                        champion3_statuses.remove("Toughened Mud")
        if champion4_oceantide[1] != 0:
            champion4_oceantide[1] = champion4_oceantide[1] - 1
            champion4_hp = champion4_hp + champion4_oceantide[0]
            if champion4_hp > CHAMPION4_HP:
                champion4_hp = CHAMPION4_HP
            if champion4_oceantide[1] == 0:
                champion4_statuses.remove("Crashing Waters")
                if champion4_springwaters[1] == 0:
                    if "Toughened Mud" in champion4_statuses:
                        champion4_statuses.remove("Toughened Mud")
        if champion5_oceantide[1] != 0:
            champion5_oceantide[1] = champion5_oceantide[1] - 1
            champion5_hp = champion5_hp + champion5_oceantide[0]
            if champion5_hp > CHAMPION5_HP:
                champion5_hp = CHAMPION5_HP
            if champion5_oceantide[1] == 0:
                champion5_statuses.remove("Crashing Waters")
                if champion5_springwaters[1] == 0:
                    if "Toughened Mud" in champion5_statuses:
                        champion5_statuses.remove("Toughened Mud")
#Pop-up window that shows at the end of the game.
    def begin_endgame(self):
            global dungeon_floor_frame
            dungeon_floor_frame.destroy()
            self.EndGameSaving()
#Calculates how many emblems the user has received and adds it to their total if they're eligible (playing on the same difficulty as their rank)
#Also tells them whether or not they have ranked up due to the new emblems added to their total
    def EndGameSaving(self):
        global endgame_window
        endgame_window = tk.Tk()
        total_rooms = (floor_level * 3) + room_level
        whole_collected_emblems = floor_level
        fraction_collected_emblems = 0
        if room_level == 2:
            fraction_collected_emblems = 0.33
        elif room_level == 3:
            fraction_collected_emblems = 0.67
        total_collected_emblems = whole_collected_emblems + fraction_collected_emblems
        old_total_emblems = ParentClass.get_account_data(self, "emblems")
        dungeon_settings = ParentClass.get_dungeon_difficulty_data(self, "difficulty")
        new_total_emblems = old_total_emblems
        if ".33" in str(old_total_emblems):
            if fraction_collected_emblems == 0.33:
                new_total_emblems = new_total_emblems - 0.33
                new_total_emblems = new_total_emblems + 0.67
            elif fraction_collected_emblems == 0.67:
                new_total_emblems = new_total_emblems - 0.67
                new_total_emblems = new_total_emblems + 1
        elif ".67" in str(old_total_emblems):
            if fraction_collected_emblems == 0.33:
                new_total_emblems = new_total_emblems - 0.67
                new_total_emblems = new_total_emblems + 1
            elif fraction_collected_emblems == 0.67:
                new_total_emblems = new_total_emblems - 0.67
                new_total_emblems = new_total_emblems + 1.33
        invis_label1 = tk.Label(endgame_window)
        invis_label2 = tk.Label(endgame_window)
        title_label = tk.Label(endgame_window, text="You're exploration ends here", font=self.small_title_font)
        final_progress_label = tk.Label(endgame_window, text="But you've made it past {} Floors and {} Rooms, thats {} Rooms total!".format(floor_level, room_level, total_rooms))
        player_rank = ParentClass.get_account_data(self, "rank")
        if player_rank != dungeon_settings:
            emblems_update_label = tk.Label(endgame_window,
                                            text="Because you explored a lower level dungeon, you don't receive rewards towards your next Guild rank\nYou only receive dungeoneer emblems from your current guilds dungeon expedition")
        else:
            emblems_update_label = tk.Label(endgame_window,
                                                text="You've received {} dungeoneer emblems\nYou now have a total of {} emblems".format(total_collected_emblems, new_total_emblems))
            rank_change_check = 0
            if old_total_emblems < 20:
                if new_total_emblems >= 20:
                    rank_change_check = 1
                    rank_change_label = tk.Label(endgame_window, text="Congratulations! You've collected enough emblems to rank you up into the Silver Guild!\nYou've now got access to Silver Guild expeditions")
                else:
                    rank_change_label = tk.Label(endgame_window, text="")
            elif old_total_emblems < 40:
                if new_total_emblems >= 40:
                    rank_change_check = 1
                    rank_change_label = tk.Label(endgame_window, text="Congratulations! You've collected enough emblems to rank you up into the Gold Guild!\nYou've now got access to Gold Guild expeditions")
                else:
                    rank_change_label = tk.Label(endgame_window, text="")
            elif old_total_emblems < 60:
                if new_total_emblems >= 60:
                    rank_change_check = 1
                    rank_change_label = tk.Label(endgame_window, text="Congratulations! You've collected enough emblems to rank you up into the Steel Guild!\nYou've now got access to Steel Guild expeditions")
                else:
                    rank_change_label = tk.Label(endgame_window, text="")
            elif old_total_emblems < 80:
                if new_total_emblems >= 80:
                    rank_change_check = 1
                    rank_change_label = tk.Label(endgame_window, text="Congratulations! You've collected enough emblems to rank you up into the Diamond Guild!\nYou've now got access to Diamond Guild expeditions")
                else:
                    rank_change_label = tk.Label(endgame_window, text="")
            elif old_total_emblems < 100:
                if new_total_emblems >= 100:
                    rank_change_check = 1
                    rank_change_label = tk.Label(endgame_window, text="Congratulations! You've collected enough emblems to rank you up into the Ruby Guild!\nYou've now got access to Ruby Guild expeditions")
                else:
                    rank_change_label = tk.Label(endgame_window, text="")
            elif old_total_emblems < 120:
                if new_total_emblems >= 120:
                    rank_change_check = 1
                    rank_change_label = tk.Label(endgame_window, text="Congratulations! You've collected enough emblems to rank you up into the Obsidian Guild!\nYou've now got access to Obsidian Guild expeditions")
                else:
                    rank_change_label = tk.Label(endgame_window, text="")
            self.update_account_emblems(new_total_emblems, rank_change_check)
            rank_change_label.grid(row=5, column=3)
        endGame_to_mainMenu_button = tk.Button(endgame_window, text="Back to the Dungeon Entrance", command=lambda: self.endgame_to_dungeon_beginning(endgame_window))
        title_label.grid(row=1, column=3)
        final_progress_label.grid(row=2, column=3)
        invis_label1.grid(row=3, column=2, pady=10)
        emblems_update_label.grid(row=4, column=3)
        invis_label2.grid(row=6, column=3, pady=10)
        endGame_to_mainMenu_button.grid(row=7, column=3)
#Destroys the endgame window and brings the user back to the beginning screen at the start of GrameFrame
    def endgame_to_dungeon_beginning(self, endgame_window):
        endgame_window.destroy()
        self.begin_dungeon_run()
#Replaces the old emblem total with new total in the database and also changes their rank if they're surpassed a threshhold
    def update_account_emblems(self, new_emblem_total, rank_change_check):
        i = -1
        file = open("C:/Users/{}/Documents/L2_ASSIGNMENT_RPG/Game_Data (DO NOT EDIT)/account_data_users.txt".format(COMPUTER_USERNAME),
                    "r")
        file_allLines = file.readlines()
        user = ParentClass.get_account_data(self, "encoded_username")
        champion_list = ParentClass.get_account_data(self, "champion_list")
        if rank_change_check == 1:
            if new_emblem_total >= 40:
                if new_emblem_total >= 60:
                    if new_emblem_total >= 80:
                        if new_emblem_total >= 100:
                            if new_emblem_total >= 120:
                                rank = "Obsidian"
                            else:
                                rank = "Ruby"
                        else:
                            rank = "Diamond"
                    else:
                        rank = "Steel"
                else:
                    rank = "Gold"
            else:
                rank = "Silver"
        else:
            rank = ParentClass.get_account_data(self, "rank")
        user = str(user)
        for line in file_allLines:
            i += 1
            if user in line:
                new_line = "{}, {}, {}, {}\n".format(user, champion_list, new_emblem_total, rank)
                file_allLines[i] = new_line
                file_write = open(
                    "C:/Users/{}/Documents/L2_ASSIGNMENT_RPG/Game_Data (DO NOT EDIT)/account_data_users.txt".format(COMPUTER_USERNAME),
                    "w")
                file_write.writelines(file_allLines)
                file.close()
                file_write.close()
# 
class CreditPage(tk.Frame):
    def __init__(self, parent, controller):
        tk.Frame.__init__(self, parent)
        self.controller = controller
        label = tk.Label(self, text="Credits", font=controller.small_title_font)
        label.grid(row=0, sticky="nsew", pady=10)
        button = tk.Button(self, text="Return to Menu",
                           command=lambda: controller.show_frame("MainMenu"))
        button.grid()
# 
class How2PlayPage(tk.Frame):
    def __init__(self, parent, controller):
        global tutorial_frame
        tk.Frame.__init__(self, parent)
        self.controller = controller
        tutorial_frame = tk.Frame(self)
        tutorial_frame.grid(row=0, column=0)
        self.title_font = tkfont.Font(family='Times New Roman Baltic', size=120, weight="bold")
        self.small_title_font = tkfont.Font(family='Times New Roman Baltic', size=80, weight="bold")
        self.medium_text_font_bold = tkfont.Font(family='Times New ROman Baltic', size=50, weight="bold")
        self.menu_button_font = tkfont.Font(family='Helvetica', size=18, weight="bold")
        self.opening_tutorial_menu()
    def opening_tutorial_menu(self):
        for widget in tutorial_frame.winfo_children():
            widget.destroy()
        title_label = tk.Label(tutorial_frame, text="How To Play", font=self.small_title_font)
        choosing_team_tutorial_button = tk.Button(tutorial_frame, text=":Choosing your team:", font=self.menu_button_font, width=20, command=self.choosing_team_tutorial_page1)
        entering_dungeon_tutorial_button = tk.Button(tutorial_frame, text=":Entering the Dungeon:", font=self.menu_button_font, width=20, command=self.entering_the_dungeon_tutorial_menu)
        other_features_tutorial_button = tk.Button(tutorial_frame, text=":Leaderboard:", font=self.menu_button_font, width=16)
        invis_label = tk.Label(tutorial_frame)
        invis_label.grid(row=1,column=0, padx=160)
        title_label.grid(row=1, column=1, sticky="nsew", pady=10)
        choosing_team_tutorial_button.grid(row=2, column=1, pady=10)
        entering_dungeon_tutorial_button.grid(row=3, column=1, pady=10)
        other_features_tutorial_button.grid(row=4, column=1, pady=10)
        button = tk.Button(tutorial_frame, text="Return to Menu",
                           command=lambda: ParentClass.show_frame(app, "MainMenu"))
        button.grid(row=5, column=1)
    def choosing_team_tutorial_page1(self):
        for widget in tutorial_frame.winfo_children():
            widget.destroy()
        title_label = tk.Label(tutorial_frame, text="Choosing your team", font=self.small_title_font)
        slide_progress = tk.Label(tutorial_frame, text="1/10", font=self.medium_text_font_bold)
        choosing_team_tutorial_text_label = tk.Label(tutorial_frame, text="Before you can enter the Dungeon, you must select five champions"
                                                                          " to accompany you into the depths\n"
                                                                          "To begin assembling your team, select 'Champion Camp' in the Main Menu")
        img1 = Image.open("C:/Users/{}/Documents/L2_ASSIGNMENT_RPG/Game_Images/ChoosingTeam/choosingTeam_tutorial_picture1.png".format(COMPUTER_USERNAME))
        img1.thumbnail((450, 250))
        img1 = ImageTk.PhotoImage(img1)
        image_label = tk.Label(tutorial_frame, image=img1)
        image_label.image = img1
        image_label.grid(row=4, column=1)
        next_button = tk.Button(tutorial_frame, text="Next Slide", font=self.menu_button_font, command=self.choosing_team_tutorial_page2)
        exit_button = tk.Button(tutorial_frame, text="Exit", font=self.menu_button_font, command=self.opening_tutorial_menu)
        invis_label = tk.Label(tutorial_frame)
        invis_label.grid(row=1,column=0, padx=48)
        title_label.grid(row=1, column=1, sticky="nsew", pady=10)
        slide_progress.grid(row=2, column=1, pady=10)
        choosing_team_tutorial_text_label.grid(row=3, column=1, pady=10)
        next_button.grid(row=5, column=1, pady=10)
        exit_button.grid(row=6, column=1)
    def choosing_team_tutorial_page2(self):
        for widget in tutorial_frame.winfo_children():
            widget.destroy()
        title_label = tk.Label(tutorial_frame, text="Choosing your team", font=self.small_title_font)
        slide_progress = tk.Label(tutorial_frame, text="2/10", font=self.medium_text_font_bold)
        choosing_team_tutorial_text_label = tk.Label(tutorial_frame, text="You have a total of three team slots\n "
                                                                          "This lets you keep your favourite combinations while being able to try something new!\n"
                                                                          "Press any of the 'Create' buttons to begin team assembly")
        img2 = Image.open("C:/Users/{}/Documents/L2_ASSIGNMENT_RPG/Game_Images/ChoosingTeam/choosingTeam_tutorial_picture2.png".format(COMPUTER_USERNAME))
        img2.thumbnail((550, 250))
        img2 = ImageTk.PhotoImage(img2)
        image_label = tk.Label(tutorial_frame, image=img2)
        image_label.image = img2
        image_label.grid(row=4, column=1)
        next_button = tk.Button(tutorial_frame, text="Next Slide", font=self.menu_button_font, command=self.choosing_team_tutorial_page3)
        next_button.grid(row=5, column=1, pady=10)
        exit_button = tk.Button(tutorial_frame, text="Exit", font=self.menu_button_font, command=self.opening_tutorial_menu)
        invis_label = tk.Label(tutorial_frame)
        invis_label.grid(row=1, column=0, padx=48)
        title_label.grid(row=1, column=1, sticky="nsew", pady=10)
        slide_progress.grid(row=2, column=1, pady=10)
        choosing_team_tutorial_text_label.grid(row=3, column=1, pady=10)
        exit_button.grid(row=7, column=1)
    def choosing_team_tutorial_page3(self):
        for widget in tutorial_frame.winfo_children():
            widget.destroy()
        title_label = tk.Label(tutorial_frame, text="Choosing your team", font=self.small_title_font)
        slide_progress = tk.Label(tutorial_frame, text="3/10", font=self.medium_text_font_bold)
        choosing_team_tutorial_text_label = tk.Label(tutorial_frame, text="There are three specializations of champions\n"
                                                                          "Though each champion is solely unique in its own way, they all fall into one of the three specializations or 'specs'\n"
                                                                          "Each specialization plays an important role inside the dungeon, and utilizing each one will get you further in your run\n"
                                                                          "To view each specializations champion selection range, click on the specialization name button up on the top of your page\n"
                                                                          "View Page 4-5-6 of this tutorial to see what each specialization does")
        img3 = Image.open("C:/Users/{}/Documents/L2_ASSIGNMENT_RPG/Game_Images/ChoosingTeam/choosingTeam_tutorial_picture3.png".format(COMPUTER_USERNAME))
        img3.thumbnail((800, 800))
        img3 = ImageTk.PhotoImage(img3)
        image_label = tk.Label(tutorial_frame, image=img3)
        image_label.image = img3
        image_label.grid(row=4, column=1)
        next_button = tk.Button(tutorial_frame, text="Next Slide", font=self.menu_button_font, command=self.choosing_team_tutorial_page4)
        exit_button = tk.Button(tutorial_frame, text="Exit", font=self.menu_button_font, command=self.opening_tutorial_menu)
        invis_label = tk.Label(tutorial_frame)
        invis_label.grid(row=1,column=0, padx=48)
        title_label.grid(row=1, column=1, sticky="nsew", pady=10)
        slide_progress.grid(row=2, column=1, pady=10)
        choosing_team_tutorial_text_label.grid(row=3, column=1, pady=10)
        next_button.grid(row=5, column=1, pady=10)
        exit_button.grid(row=6, column=1)
    def choosing_team_tutorial_page4(self):
        for widget in tutorial_frame.winfo_children():
            widget.destroy()
        title_label = tk.Label(tutorial_frame, text="Choosing your team", font=self.small_title_font)
        slide_progress = tk.Label(tutorial_frame, text="4/10", font=self.medium_text_font_bold)
        choosing_team_tutorial_tank_label = tk.Label(tutorial_frame, text="Tanks", font=self.medium_text_font_bold)
        choosing_team_tutorial_text_label = tk.Label(tutorial_frame, text="The Tank specialization maximizes its teams survival by reducing the enemies damage done,\n"
                                                                          "by taunting enemies to force them to attack the tank instead of their teammates,\n"
                                                                          "and by blocking enemies attacks and protecting allies")
        next_button = tk.Button(tutorial_frame, text="Next Slide", font=self.menu_button_font, command=self.choosing_team_tutorial_page5)
        exit_button = tk.Button(tutorial_frame, text="Exit", font=self.menu_button_font, command=self.opening_tutorial_menu)
        invis_label = tk.Label(tutorial_frame)
        invis_label.grid(row=1,column=0, padx=48)
        title_label.grid(row=1, column=1, sticky="nsew", pady=10)
        slide_progress.grid(row=2, column=1, pady=10)
        choosing_team_tutorial_tank_label.grid(row=3, column=1, pady=10)
        choosing_team_tutorial_text_label.grid(row=4, column=1, pady=10)
        next_button.grid(row=6, column=1, pady=10)
        exit_button.grid(row=7, column=1)
    def choosing_team_tutorial_page5(self):
        for widget in tutorial_frame.winfo_children():
            widget.destroy()
        title_label = tk.Label(tutorial_frame, text="Choosing your team", font=self.small_title_font)
        slide_progress = tk.Label(tutorial_frame, text="5/10", font=self.medium_text_font_bold)
        choosing_team_tutorial_dps_catagory1_label = tk.Label(tutorial_frame, text="Damage Dealers", font=self.medium_text_font_bold)
        choosing_team_tutorial_text_label = tk.Label(tutorial_frame, text="The Damage Dealer specialization or 'DPS' maximizes its damage done to the monsters you'll encounter in the dungeon,\n"
                                                                          "they can also cause nasty effects that hinder and damage enemies over multiple turns,\n"
                                                                          "some DPS can also help other teammates by powering them to make them deal more damage")
        next_button = tk.Button(tutorial_frame, text="Next Slide", font=self.menu_button_font, command=self.choosing_team_tutorial_page6)
        exit_button = tk.Button(tutorial_frame, text="Exit", font=self.menu_button_font, command=self.opening_tutorial_menu)
        invis_label = tk.Label(tutorial_frame)
        invis_label.grid(row=1,column=0, padx=48)
        title_label.grid(row=1, column=1, sticky="nsew", pady=10)
        slide_progress.grid(row=2, column=1, pady=10)
        choosing_team_tutorial_dps_catagory1_label.grid(row=3, column=1, pady=10)
        choosing_team_tutorial_text_label.grid(row=4, column=1, pady=10)
        next_button.grid(row=6, column=1, pady=10)
        exit_button.grid(row=7, column=1)
    def choosing_team_tutorial_page6(self):
        for widget in tutorial_frame.winfo_children():
            widget.destroy()
        title_label = tk.Label(tutorial_frame, text="Choosing your team", font=self.small_title_font)
        slide_progress = tk.Label(tutorial_frame, text="6/10", font=self.medium_text_font_bold)
        choosing_team_tutorial_healer_label = tk.Label(tutorial_frame, text="Healers", font=self.medium_text_font_bold)
        choosing_team_tutorial_text_label = tk.Label(tutorial_frame, text="The Healer specialization maximizes its support capabilities to other teammates,\n"
                                                                          "Healers can heal back damage inflicted on teammates by monsters,\n"
                                                                          "Healers can also support their team by providing power boosts or protection from attacks")
        next_button = tk.Button(tutorial_frame, text="Next Slide", font=self.menu_button_font, command=self.choosing_team_tutorial_page7)
        exit_button = tk.Button(tutorial_frame, text="Exit", font=self.menu_button_font, command=self.opening_tutorial_menu)
        invis_label = tk.Label(tutorial_frame)
        invis_label.grid(row=1,column=0, padx=48)
        title_label.grid(row=1, column=1, sticky="nsew", pady=10)
        slide_progress.grid(row=2, column=1, pady=10)
        choosing_team_tutorial_healer_label.grid(row=3, column=1, pady=10)
        choosing_team_tutorial_text_label.grid(row=4, column=1, pady=10)
        next_button.grid(row=6, column=1, pady=10)
        exit_button.grid(row=7, column=1)
    def choosing_team_tutorial_page7(self):
        for widget in tutorial_frame.winfo_children():
            widget.destroy()
        title_label = tk.Label(tutorial_frame, text="Choosing your team", font=self.small_title_font)
        slide_progress = tk.Label(tutorial_frame, text="7/10", font=self.medium_text_font_bold)
        choosing_team_tutorial_text_label = tk.Label(tutorial_frame, text="To add a champion to your team, press the 'Add to team' button and they'll be added to the team bar on the bottom of the screen\n"
                                                                          "You may select any combination of champions by you many only have one of the same champion\n"                                                         
                                                                          "Its important to put together a team that can cover a wide array of scenarios so you can handle each challenge without being at a disadvantage")
        img4 = Image.open("C:/Users/{}/Documents/L2_ASSIGNMENT_RPG/Game_Images/ChoosingTeam/choosingTeam_tutorial_picture4.png".format(COMPUTER_USERNAME))
        img4.thumbnail((450, 450))
        img4 = ImageTk.PhotoImage(img4)
        image_label = tk.Label(tutorial_frame, image=img4)
        image_label.image = img4
        image_label.grid(row=4, column=1)
        next_button = tk.Button(tutorial_frame, text="Next Slide", font=self.menu_button_font, command=self.choosing_team_tutorial_page8)
        exit_button = tk.Button(tutorial_frame, text="Exit", font=self.menu_button_font, command=self.opening_tutorial_menu)
        invis_label = tk.Label(tutorial_frame)
        invis_label.grid(row=1,column=0, padx=48)
        title_label.grid(row=1, column=1, sticky="nsew", pady=10)
        slide_progress.grid(row=2, column=1, pady=10)
        choosing_team_tutorial_text_label.grid(row=3, column=1, pady=10)
        next_button.grid(row=5, column=1, pady=10)
        exit_button.grid(row=6, column=1)
    def choosing_team_tutorial_page8(self):
        for widget in tutorial_frame.winfo_children():
            widget.destroy()
        title_label = tk.Label(tutorial_frame, text="Choosing your team", font=self.small_title_font)
        slide_progress = tk.Label(tutorial_frame, text="8/10", font=self.medium_text_font_bold)
        choosing_team_tutorial_text_label = tk.Label(tutorial_frame, text="If you have all five team slots full and want to change a champion, don't fret!\n"
                                                                          "Just add the champion you want like normal and you'll be able to swap around champions in your party")
        img5 = Image.open("C:/Users/{}/Documents/L2_ASSIGNMENT_RPG/Game_Images/ChoosingTeam/choosingTeam_tutorial_picture5.png".format(COMPUTER_USERNAME))
        img5.thumbnail((400, 400))
        img5 = ImageTk.PhotoImage(img5)
        image_label1 = tk.Label(tutorial_frame, image=img5)
        image_label1.image = img5
        image_label1.grid(row=4, column=1, sticky="w")
        img6 = Image.open("C:/Users/{}/Documents/L2_ASSIGNMENT_RPG/Game_Images/ChoosingTeam/choosingTeam_tutorial_picture6.png".format(COMPUTER_USERNAME))
        img6.thumbnail((400, 400))
        img6 = ImageTk.PhotoImage(img6)
        image_label2 = tk.Label(tutorial_frame, image=img6)
        image_label2.image = img6
        image_label2.grid(row=4, column=1, sticky="e")
        next_button = tk.Button(tutorial_frame, text="Next Slide", font=self.menu_button_font, command=self.choosing_team_tutorial_page9)
        exit_button = tk.Button(tutorial_frame, text="Exit", font=self.menu_button_font, command=self.opening_tutorial_menu)
        invis_label = tk.Label(tutorial_frame)
        invis_label.grid(row=1,column=0, padx=48)
        title_label.grid(row=1, column=1, sticky="nsew", pady=10)
        slide_progress.grid(row=2, column=1, pady=10)
        choosing_team_tutorial_text_label.grid(row=3, column=1, pady=10)
        next_button.grid(row=5, column=1, pady=10)
        exit_button.grid(row=6, column=1)
    def choosing_team_tutorial_page9(self):
        for widget in tutorial_frame.winfo_children():
            widget.destroy()
        title_label = tk.Label(tutorial_frame, text="Choosing your team", font=self.small_title_font)
        slide_progress = tk.Label(tutorial_frame, text="9/10", font=self.medium_text_font_bold)
        choosing_team_tutorial_text_label = tk.Label(tutorial_frame, text="Once you have chosen all five of your preferred champions, make sure to press the 'Confirm Changes' button to save that team to the slot")
        img7 = Image.open("C:/Users/{}/Documents/L2_ASSIGNMENT_RPG/Game_Images/ChoosingTeam/choosingTeam_tutorial_picture7.png".format(COMPUTER_USERNAME))
        img7.thumbnail((450, 450))
        img7 = ImageTk.PhotoImage(img7)
        image_label = tk.Label(tutorial_frame, image=img7)
        image_label.image = img7
        image_label.grid(row=4, column=1)
        next_button = tk.Button(tutorial_frame, text="Next Slide", font=self.menu_button_font, command=self.choosing_team_tutorial_page10)
        exit_button = tk.Button(tutorial_frame, text="Exit", font=self.menu_button_font, command=self.opening_tutorial_menu)
        invis_label = tk.Label(tutorial_frame)
        invis_label.grid(row=1,column=0, padx=48)
        title_label.grid(row=1, column=1, sticky="nsew", pady=10)
        slide_progress.grid(row=2, column=1, pady=10)
        choosing_team_tutorial_text_label.grid(row=3, column=1, pady=10)
        next_button.grid(row=5, column=1, pady=10)
        exit_button.grid(row=6, column=1)
    def choosing_team_tutorial_page10(self):
        for widget in tutorial_frame.winfo_children():
            widget.destroy()
        title_label = tk.Label(tutorial_frame, text="Choosing your team", font=self.small_title_font)
        slide_progress = tk.Label(tutorial_frame, text="10/10", font=self.medium_text_font_bold)
        choosing_team_tutorial_text_label = tk.Label(tutorial_frame, text="That's it!\n"
                                                                          "You now know how to create Champion Teams and what each specialization does\n"
                                                                          "If you need to, read the other sections of the 'How to Play' page to learn more on how to play!")
        exit_button = tk.Button(tutorial_frame, text="Exit", font=self.menu_button_font, command=self.opening_tutorial_menu)
        invis_label = tk.Label(tutorial_frame)
        invis_label.grid(row=1,column=0, padx=48)
        title_label.grid(row=1, column=1, sticky="nsew", pady=10)
        slide_progress.grid(row=2, column=1, pady=10)
        choosing_team_tutorial_text_label.grid(row=3, column=1, pady=10)
        exit_button.grid(row=5, column=1)
    def entering_the_dungeon_tutorial_menu(self):
        for widget in tutorial_frame.winfo_children():
            widget.destroy()
        title_label = tk.Label(tutorial_frame, text="Entering the Dungeon", font=self.small_title_font)
        dungeon_settings_tutorial_button = tk.Button(tutorial_frame, text=":Dungeon Settings:", font=self.menu_button_font, width=20, command=self.dungeon_settings_tutorial_page1)
        entering_combat_tutorial_button = tk.Button(tutorial_frame, text=":Entering Combat:", font=self.menu_button_font, width=20, command=self.entering_combat_tutorial_menu)
        invis_label = tk.Label(tutorial_frame)
        invis_label.grid(row=1,column=0, padx=40)
        title_label.grid(row=1, column=1, sticky="nsew", pady=10)
        dungeon_settings_tutorial_button.grid(row=2, column=1, pady=10)
        entering_combat_tutorial_button.grid(row=3, column=1, pady=10)
        button = tk.Button(tutorial_frame, text="Back",
                           command=self.opening_tutorial_menu)
        button.grid(row=5, column=1)
    def dungeon_settings_tutorial_page1(self):
        for widget in tutorial_frame.winfo_children():
            widget.destroy()
        title_label = tk.Label(tutorial_frame, text="Dungeon Settings", font=self.small_title_font)
        slide_progress = tk.Label(tutorial_frame, text="1/5", font=self.medium_text_font_bold)
        choosing_team_tutorial_text_label = tk.Label(tutorial_frame, text="The Dungeon itself is perilous, but you can personally tune how you interact with the dungeon\n"
                                                                          "Navigate to the 'Dungeon Management' options as shown in the pictures to begin going through the game setting")
        img1 = Image.open("C:/Users/{}/Documents/L2_ASSIGNMENT_RPG/Game_Images/DungeonSettings/dungeonSettings_tutorial_picture1.png".format(COMPUTER_USERNAME))
        img1.thumbnail((400, 400))
        img1 = ImageTk.PhotoImage(img1)
        image_label1 = tk.Label(tutorial_frame, image=img1)
        image_label1.image = img1
        image_label1.grid(row=4, column=1, sticky="w")
        img2 = Image.open("C:/Users/{}/Documents/L2_ASSIGNMENT_RPG/Game_Images/DungeonSettings/dungeonSettings_tutorial_picture2.png".format(COMPUTER_USERNAME))
        img2.thumbnail((400, 400))
        img2 = ImageTk.PhotoImage(img2)
        image_label2 = tk.Label(tutorial_frame, image=img2)
        image_label2.image = img2
        image_label2.grid(row=4, column=1, sticky="e")
        next_button = tk.Button(tutorial_frame, text="Next Slide", font=self.menu_button_font, command=self.dungeon_settings_tutorial_page2)
        exit_button = tk.Button(tutorial_frame, text="Exit", font=self.menu_button_font, command=self.entering_the_dungeon_tutorial_menu)
        invis_label = tk.Label(tutorial_frame)
        invis_label.grid(row=1,column=0, padx=80)
        title_label.grid(row=1, column=1, sticky="nsew", pady=10)
        slide_progress.grid(row=2, column=1, pady=10)
        choosing_team_tutorial_text_label.grid(row=3, column=1, pady=10)
        next_button.grid(row=5, column=1, pady=10)
        exit_button.grid(row=6, column=1)
    def dungeon_settings_tutorial_page2(self):
        for widget in tutorial_frame.winfo_children():
            widget.destroy()
        title_label = tk.Label(tutorial_frame, text="Dungeon Settings", font=self.small_title_font)
        slide_progress = tk.Label(tutorial_frame, text="2/5", font=self.medium_text_font_bold)
        choosing_team_tutorial_text_label = tk.Label(tutorial_frame, text="The monsters inside the Dungeon become tougher the further you delve.\n"
                                                                          "Each difficult allows you to change the rate at which the monsters DAMAGE/HEALTH scale at per FLOOR/ROOM respectively\n"
                                                                          "Under each difficulty setting is the scaling modifier that takes affect")
        img1 = Image.open("C:/Users/{}/Documents/L2_ASSIGNMENT_RPG/Game_Images/DungeonSettings/dungeonSettings_tutorial_picture3.png".format(COMPUTER_USERNAME))
        img1.thumbnail((400, 400))
        img1 = ImageTk.PhotoImage(img1)
        image_label1 = tk.Label(tutorial_frame, image=img1)
        image_label1.image = img1
        image_label1.grid(row=4, column=1)
        next_button = tk.Button(tutorial_frame, text="Next Slide", font=self.menu_button_font, command=self.dungeon_settings_tutorial_page3)
        exit_button = tk.Button(tutorial_frame, text="Exit", font=self.menu_button_font, command=self.entering_the_dungeon_tutorial_menu)
        invis_label = tk.Label(tutorial_frame)
        invis_label.grid(row=1,column=0, padx=80)
        title_label.grid(row=1, column=1, sticky="nsew", pady=10)
        slide_progress.grid(row=2, column=1, pady=10)
        choosing_team_tutorial_text_label.grid(row=3, column=1, pady=10)
        next_button.grid(row=5, column=1, pady=10)
        exit_button.grid(row=6, column=1)
    def dungeon_settings_tutorial_page3(self):
        for widget in tutorial_frame.winfo_children():
            widget.destroy()
        title_label = tk.Label(tutorial_frame, text="Dungeon Settings", font=self.small_title_font)
        slide_progress = tk.Label(tutorial_frame, text="3/5", font=self.medium_text_font_bold)
        choosing_team_tutorial_text_label = tk.Label(tutorial_frame, text="To select a difficulty, just click on the button with the name of the difficulty you wish to play")
        img1 = Image.open("C:/Users/{}/Documents/L2_ASSIGNMENT_RPG/Game_Images/DungeonSettings/dungeonSettings_tutorial_picture4.png".format(COMPUTER_USERNAME))
        img1.thumbnail((400, 400))
        img1 = ImageTk.PhotoImage(img1)
        image_label1 = tk.Label(tutorial_frame, image=img1)
        image_label1.image = img1
        image_label1.grid(row=4, column=1)
        next_button = tk.Button(tutorial_frame, text="Next Slide", font=self.menu_button_font, command=self.dungeon_settings_tutorial_page4)
        exit_button = tk.Button(tutorial_frame, text="Exit", font=self.menu_button_font, command=self.entering_the_dungeon_tutorial_menu)
        invis_label = tk.Label(tutorial_frame)
        invis_label.grid(row=1,column=0, padx=80)
        title_label.grid(row=1, column=1, sticky="nsew", pady=10)
        slide_progress.grid(row=2, column=1, pady=10)
        choosing_team_tutorial_text_label.grid(row=3, column=1, pady=10)
        next_button.grid(row=5, column=1, pady=10)
        exit_button.grid(row=6, column=1)
    def dungeon_settings_tutorial_page4(self):
        for widget in tutorial_frame.winfo_children():
            widget.destroy()
        title_label = tk.Label(tutorial_frame, text="Dungeon Settings", font=self.small_title_font)
        slide_progress = tk.Label(tutorial_frame, text="4/5", font=self.medium_text_font_bold)
        choosing_team_tutorial_text_label = tk.Label(tutorial_frame, text="When in combat, lookout at the top of the screen to see what the current modifications the monsters have!\n"
                                                                          "Remember, every floor the attack modifier will increase, and every room the health modifier will increase.\n"
                                                                          "The in-game showcase also trackers the permanent health modifier, to understand the Permanent health modifier please view the Dungeon")
        img1 = Image.open("C:/Users/{}/Documents/L2_ASSIGNMENT_RPG/Game_Images/DungeonSettings/dungeonSettings_tutorial_picture5.png".format(COMPUTER_USERNAME))
        img1.thumbnail((400, 400))
        img1 = ImageTk.PhotoImage(img1)
        image_label1 = tk.Label(tutorial_frame, image=img1)
        image_label1.image = img1
        image_label1.grid(row=4, column=1, sticky="w")
        img2 = Image.open("C:/Users/{}/Documents/L2_ASSIGNMENT_RPG/Game_Images/DungeonSettings/dungeonSettings_tutorial_picture6.png".format(COMPUTER_USERNAME))
        img2.thumbnail((400, 400))
        img2 = ImageTk.PhotoImage(img2)
        image_label2 = tk.Label(tutorial_frame, image=img2)
        image_label2.image = img2
        image_label2.grid(row=4, column=1, sticky="e")
        next_button = tk.Button(tutorial_frame, text="Next Slide", font=self.menu_button_font, command=self.dungeon_settings_tutorial_page2)
        exit_button = tk.Button(tutorial_frame, text="Exit", font=self.menu_button_font, command=self.entering_the_dungeon_tutorial_menu)
        invis_label = tk.Label(tutorial_frame)
        invis_label.grid(row=1,column=0, padx=80)
        title_label.grid(row=1, column=1, sticky="nsew", pady=10)
        slide_progress.grid(row=2, column=1, pady=10)
        choosing_team_tutorial_text_label.grid(row=3, column=1, pady=10)
        next_button.grid(row=5, column=1, pady=10)
        exit_button.grid(row=6, column=1)
    def entering_combat_tutorial_menu(self):
        for widget in tutorial_frame.winfo_children():
            widget.destroy()
        title_label = tk.Label(tutorial_frame, text="Entering Combat", font=self.small_title_font)
        combat_user_interface_tutorial_button = tk.Button(tutorial_frame, text=":Combat User Interface:", font=self.menu_button_font, width=20, command=self.combat_user_interface_tutorial_page1)
        champion_ability_tutorial_button = tk.Button(tutorial_frame, text=":Champion Ability Requirements:", font=self.menu_button_font, width=20, command=self.champion_ability_requirements_tutorial_page1)
        special_effects_tutorial_button = tk.Button(tutorial_frame, text=":Special Combat Effects:", font=self.menu_button_font, width=16, command=self.special_effects_tutorial_page1)
        invis_label = tk.Label(tutorial_frame)
        invis_label.grid(row=1,column=0, padx=160)
        title_label.grid(row=1, column=1, sticky="nsew", pady=10)
        combat_user_interface_tutorial_button.grid(row=2, column=1, pady=10)
        champion_ability_tutorial_button.grid(row=3, column=1, pady=10)
        special_effects_tutorial_button.grid(row=4, column=1, pady=10)
        button = tk.Button(tutorial_frame, text="Back",
                           command= self.entering_the_dungeon_tutorial_menu)
        button.grid(row=5, column=1)
    def combat_user_interface_tutorial_page1(self):
        for widget in tutorial_frame.winfo_children():
            widget.destroy()
        title_label = tk.Label(tutorial_frame, text="Dungeon Settings", font=self.small_title_font)
        slide_progress = tk.Label(tutorial_frame, text="1/4", font=self.medium_text_font_bold)
        choosing_team_tutorial_text_label = tk.Label(tutorial_frame, text="Once you have chosen all five of your preferred champions, make sure to press the 'Confirm Changes' button to save that team to the slot")
        img7 = Image.open("C:/Users/{}/Documents/L2_ASSIGNMENT_RPG/Game_Images/choosingTeam_tutorial_picture7.png".format(COMPUTER_USERNAME))
        img7.thumbnail((450, 450))
        img7 = ImageTk.PhotoImage(img7)
        image_label = tk.Label(tutorial_frame, image=img7)
        image_label.image = img7
        image_label.grid(row=4, column=1)
        next_button = tk.Button(tutorial_frame, text="Next Slide", font=self.menu_button_font, command=self.choosing_team_tutorial_page10)
        exit_button = tk.Button(tutorial_frame, text="Exit", font=self.menu_button_font, command=self.entering_the_dungeon_tutorial_menu)
        invis_label = tk.Label(tutorial_frame)
        invis_label.grid(row=1,column=0, padx=48)
        title_label.grid(row=1, column=1, sticky="nsew", pady=10)
        slide_progress.grid(row=2, column=1, pady=10)
        choosing_team_tutorial_text_label.grid(row=3, column=1, pady=10)
        next_button.grid(row=5, column=1, pady=10)
        exit_button.grid(row=6, column=1)
    def champion_ability_requirements_tutorial_page1(self):
        for widget in tutorial_frame.winfo_children():
            widget.destroy()
        title_label = tk.Label(tutorial_frame, text="Dungeon Settings", font=self.small_title_font)
        slide_progress = tk.Label(tutorial_frame, text="1/4", font=self.medium_text_font_bold)
        choosing_team_tutorial_text_label = tk.Label(tutorial_frame, text="Once you have chosen all five of your preferred champions, make sure to press the 'Confirm Changes' button to save that team to the slot")
        img7 = Image.open("C:/Users/{}/Documents/L2_ASSIGNMENT_RPG/Game_Images/choosingTeam_tutorial_picture7.png".format(COMPUTER_USERNAME))
        img7.thumbnail((450, 450))
        img7 = ImageTk.PhotoImage(img7)
        image_label = tk.Label(tutorial_frame, image=img7)
        image_label.image = img7
        image_label.grid(row=4, column=1)
        next_button = tk.Button(tutorial_frame, text="Next Slide", font=self.menu_button_font, command=self.choosing_team_tutorial_page10)
        exit_button = tk.Button(tutorial_frame, text="Exit", font=self.menu_button_font, command=self.entering_the_dungeon_tutorial_menu)
        invis_label = tk.Label(tutorial_frame)
        invis_label.grid(row=1,column=0, padx=48)
        title_label.grid(row=1, column=1, sticky="nsew", pady=10)
        slide_progress.grid(row=2, column=1, pady=10)
        choosing_team_tutorial_text_label.grid(row=3, column=1, pady=10)
        next_button.grid(row=5, column=1, pady=10)
        exit_button.grid(row=6, column=1)
    def special_effects_tutorial_page1(self):
        for widget in tutorial_frame.winfo_children():
            widget.destroy()
        title_label = tk.Label(tutorial_frame, text="Dungeon Settings", font=self.small_title_font)
        slide_progress = tk.Label(tutorial_frame, text="1/4", font=self.medium_text_font_bold)
        choosing_team_tutorial_text_label = tk.Label(tutorial_frame, text="Once you have chosen all five of your preferred champions, make sure to press the 'Confirm Changes' button to save that team to the slot")
        img7 = Image.open("C:/Users/{}/Documents/L2_ASSIGNMENT_RPG/Game_Images/choosingTeam_tutorial_picture7.png".format(COMPUTER_USERNAME))
        img7.thumbnail((450, 450))
        img7 = ImageTk.PhotoImage(img7)
        image_label = tk.Label(tutorial_frame, image=img7)
        image_label.image = img7
        image_label.grid(row=4, column=1)
        next_button = tk.Button(tutorial_frame, text="Next Slide", font=self.menu_button_font, command=self.choosing_team_tutorial_page10)
        exit_button = tk.Button(tutorial_frame, text="Exit", font=self.menu_button_font, command=self.entering_the_dungeon_tutorial_menu)
        invis_label = tk.Label(tutorial_frame)
        invis_label.grid(row=1,column=0, padx=48)
        title_label.grid(row=1, column=1, sticky="nsew", pady=10)
        slide_progress.grid(row=2, column=1, pady=10)
        choosing_team_tutorial_text_label.grid(row=3, column=1, pady=10)
        next_button.grid(row=5, column=1, pady=10)
        exit_button.grid(row=6, column=1)
    def leaderboard_tutorial_page1(self):
        for widget in tutorial_frame.winfo_children():
            widget.destroy()
        title_label = tk.Label(tutorial_frame, text="Leaderboard", font=self.small_title_font)
        slide_progress = tk.Label(tutorial_frame, text="1/4", font=self.medium_text_font_bold)
        choosing_team_tutorial_text_label = tk.Label(tutorial_frame, text="")
        img1 = Image.open("C:/Users/{}/Documents/L2_ASSIGNMENT_RPG/Game_Images/leaderboard_tutorial_picture1.png".format(COMPUTER_USERNAME))
        img1.thumbnail((550, 250))
        img1 = ImageTk.PhotoImage(img1)
        image_label = tk.Label(tutorial_frame, image=img1)
        image_label.image = img1
        image_label.grid(row=4, column=1)
        next_button = tk.Button(tutorial_frame, text="Next Slide", font=self.menu_button_font, command=self.choosing_team_tutorial_page3)
        next_button.grid(row=5, column=1, pady=10)
        exit_button = tk.Button(tutorial_frame, text="Exit", font=self.menu_button_font, command=self.opening_tutorial_menu)
        invis_label = tk.Label(tutorial_frame)
        invis_label.grid(row=1, column=0, padx=48)
        title_label.grid(row=1, column=1, sticky="nsew", pady=10)
        slide_progress.grid(row=2, column=1, pady=10)
        choosing_team_tutorial_text_label.grid(row=3, column=1, pady=10)
        exit_button.grid(row=7, column=1)

if __name__ == "__main__":
    app = ParentClass()
    app.mainloop()